### YamlMime:ManagedReference
items:
- uid: System.IO.Log.FileRecordSequence
  id: FileRecordSequence
  children:
  - System.IO.Log.FileRecordSequence.#ctor(System.String)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  - System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.BaseSequenceNumber
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.CreateReservationCollection
  - System.IO.Log.FileRecordSequence.Dispose
  - System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.Flush
  - System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.LastSequenceNumber
  - System.IO.Log.FileRecordSequence.MaximumRecordLength
  - System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.FileRecordSequence.ReadRestartAreas
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReservedBytes
  - System.IO.Log.FileRecordSequence.RestartSequenceNumber
  - System.IO.Log.FileRecordSequence.RetryAppend
  - System.IO.Log.FileRecordSequence.TailPinned
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: FileRecordSequence
  nameWithType: FileRecordSequence
  fullName: System.IO.Log.FileRecordSequence
  type: Class
  summary: "実装して、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>ファイル上にします。 このクラスは継承できません。"
  remarks: "FileRecordSequence は、ファイル システム内の単一のログ ファイルに基づくレコード シーケンスです。 <xref:System.IO.Log.IRecordSequence>単純なファイル ベース ログ上で、インターフェイス</xref:System.IO.Log.IRecordSequence>の簡単な実装       ファイル ベース ログを操作するためで、アプリケーションを実行するアカウントは、FileRecordSequence は構築時にファイル システムのセキュリティで使用される、十分な特権が必要です。 さらに、構築時に FullTrust への要求が行われます。 アクセス許可の検証結果は、Windows のセキュリティ モデルに合わせてその後キャッシュされます。 誤って開示しない、未認証のユーザーに、レコード シーケンスの内容を確認する必要があります。"
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/t-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/t-system.io.log.filereco_1.cs)]"
  syntax:
    content: 'public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>指定したファイルを持つクラス。"
  remarks: "このコンス トラクターは、ファイルへの読み取り/書き込みアクセスを作成し、共有の読み取りアクセス権でファイルを開きます。 つまり、同じまたは別のプロセスによって書き込み用にファイルを開く要求は、これまでが失敗した<xref:System.IO.Log.FileRecordSequence>のインスタンスは破棄されましたが、読み取り試行は成功します</xref:System.IO.Log.FileRecordSequence>。 場合`path`が見つからない、サイズが 0 バイトの新しいファイルを作成します。"
  example:
  - "The following example creates a record sequence, appends record to it, reads the records, and finally diposes the sequence.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/m-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/m-system.io.log.filereco_1.cs)]"
  syntax:
    content: public FileRecordSequence (string path);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスこの<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>インスタンスがカプセル化します。"
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "によって指定されたファイル<code> path </code>が無効です。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "によって指定されたファイル<code> path </code>が見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定されたログ ストアへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileAccess)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>クラスは、指定したファイルとアクセス モードを使用します。"
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスこの<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>インスタンスがカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "有効な<xref href=&quot;System.IO.FileAccess&quot;></xref>アクセス ユーザーの種類を制御する値がログ ファイルにあります。"
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "によって指定されたファイル<code> path </code>が無効です。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "によって指定されたファイル<code> path </code>が見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定されたログ ストアへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  id: '#ctor(System.String,System.IO.FileAccess,System.Int32)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>指定されたファイル、アクセス モード、およびファイルのサイズを持つクラス。"
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access, int size);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスこの<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>インスタンスがカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "有効な<xref href=&quot;System.IO.FileAccess&quot;></xref>アクセス ユーザーの種類を制御する値がログ ファイルにあります。"
    - id: size
      type: System.Int32
      description: "開くログ ファイルのサイズ。"
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つまたは複数のパラメーターが有効な範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "によって指定されたファイル<code> path </code>が無効です。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "によって指定されたファイル<code> path </code>が見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定されたログ ストアへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログの基本シーケンス番号を前方移動します。 このメソッドは継承できません。"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "レコード シーケンスの新しい基本シーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>正しくありません。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "シーケンスの変更中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを書き込みます、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-cs[FileRecordSequence#0](~/add/codesnippet/csharp/10554b85-231e-4dbf-ad02-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを書き込みます、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  example:
  - "The following example shows how you can create a record sequence with this method.  \n  \n [!code-vb[IRecordSequence#3](~/add/codesnippet/visualbasic/5cdfd57c-5dff-4f9a-a7e0-_1.vb)]\n [!code-cs[IRecordSequence#3](~/add/codesnippet/csharp/5cdfd57c-5dff-4f9a-a7e0-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを書き込みます、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>、以前のシーケンスに予約された領域を使用します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されていません."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを書き込みます、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>、以前のシーケンスに予約された領域を使用します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されていません."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "現在の最初の有効なレコードのシーケンス番号を取得<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。"
  remarks: "有効なシーケンス番号より大きいまたは basesequencenumber と同じ値に等しいと<xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>。</xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>よりも小さい その他のすべてのシーケンス番号が無効です。       このプロパティの値を呼び出すことにより変更することができます、<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>または<xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A>メソッド</xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A></xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>。"
  example:
  - "The following example shows using BaseSequenceNumber in a loop:  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/p-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/p-system.io.log.filereco_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "有効なレコードに対応する下限のシーケンス番号、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。"
  overload: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期開始操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドは、追加操作が完了し、リソースを適切に解放できることを確認します</xref:System.IO.Log.FileRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期開始操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドは、追加操作が完了し、リソースを適切に解放できることを確認します</xref:System.IO.Log.FileRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の開始シーケンスで以前に予約された領域を使用して操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドは、追加操作が完了し、リソースを適切に解放できることを確認します</xref:System.IO.Log.FileRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の開始シーケンスで以前に予約された領域を使用して操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドは、追加操作が完了し、リソースを適切に解放できることを確認します</xref:System.IO.Log.FileRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "以前のシーケンスに予約された領域を使用して、非同期のフラッシュ操作を開始します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>を現在のメソッドによって返される、 <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>、フラッシュが完了し、リソースが適切に解放されるようにするメソッド</xref:System.IO.Log.FileRecordSequence.EndFlush%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期のフラッシュ中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndFlush%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndFlush%2A>。       このメソッドを呼び出すことにより、すべてのレコードを追加されていること、<xref:System.IO.Log.FileRecordSequence>は永続的に書き込まれます</xref:System.IO.Log.FileRecordSequence>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など非同期フラッシュ要求、中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.FileRecordSequence.EndFlush%2A>メソッドが呼び出されます</xref:System.IO.Log.FileRecordSequence.EndFlush%2A>。"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "書き込む必要のある最新レコードのシーケンス番号。 場合<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>が正しくない、すべてのレコードを書き込む必要があります。"
    - id: callback
      type: System.AsyncCallback
      description: "フラッシュが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期フラッシュ要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期のフラッシュ操作をまだ</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。       <code>sequenceNumber</code>このシーケンスに対して無効です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の予約を開始し、操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドは、追加操作が完了し、リソースを適切に解放できることを確認します</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す、この非同期操作を保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の予約を開始し、操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドは、追加操作が完了し、リソースを適切に解放できることを確認します</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す、この非同期操作を保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "以前のシーケンスに予約された領域を使用して、非同期の再開領域書き込み操作を開始します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>再開領域の書き込み操作を確保するためのメソッドが完了し、リソースを適切に解放できます</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期の再開領域の書き込み操作中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       操作が正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       場合、<xref:System.IO.Log.ReservationCollection>を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します</xref:System.IO.Log.ReservationCollection>。 メソッドが成功すると、消費され、最も小さな予約データを格納できること、および予約がコレクションから削除されます。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出されます</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>。"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "再開領域の書き込みが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期の再開領域の書き込み要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期の再開領域の書き込み操作、まだでした</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。       または、新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。       - または -<code>newBaseSeqNum</code>このシーケンスに対して無効です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "以前のシーケンスに予約された領域を使用して、非同期の再開領域書き込み操作を開始します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>再開領域の書き込み操作を確保するためのメソッドが完了し、リソースを適切に解放できます</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期の再開領域の書き込み操作中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       操作が正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       場合、<xref:System.IO.Log.ReservationCollection>を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します</xref:System.IO.Log.ReservationCollection>。 メソッドが成功すると、消費され、最も小さな予約データを格納できること、および予約がコレクションから削除されます。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出されます</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>。"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "再開領域の書き込みが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期の再開領域の書き込み要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期の再開領域の書き込み操作、まだでした</xref:System.IAsyncResult>。"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。       または、新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。       - または -<code>newBaseSeqNum</code>このシーケンスに対して無効です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新たに作成<xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>です。 このメソッドは継承できません。"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新しく作成された<xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>です。"
  overload: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "オブジェクトによって使用されているアンマネージ リソースを直ちに解放します。"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.FileRecordSequence.Dispose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加操作を非同期の終了。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndAppend が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.FileRecordSequence.BeginAppend%2A>メソッド</xref:System.IO.Log.FileRecordSequence.BeginAppend%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期のフラッシュ操作を終了します。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndFlush が呼び出されたときに、I/O 要求時にディスク障害など非同期フラッシュ要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.FileRecordSequence.BeginFlush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.BeginFlush%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "予約および追加操作を非同期の終了。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndReserveAndAppend が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A>メソッド</xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の再開領域の書き込み操作を終了します。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndWriteRestartArea が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A>メソッド</xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "書き込まれたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加したすべてのレコードが書き込まれていることを確認します。 このメソッドは継承できません。"
  remarks: "このメソッドを呼び出すことにより、すべてのレコードを追加されていること、<xref:System.IO.Log.FileRecordSequence>永続的に書き込まれます</xref:System.IO.Log.FileRecordSequence>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加したすべてのレコードが書き込まれていることを確認します。 このメソッドは継承できません。"
  remarks: "このメソッドにより、すべてのレコード シーケンス番号を呼び出すと、指定されたシーケンス番号は、永続的に書き込まれています。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "書き込む必要のある最新レコードのシーケンス番号。 この場合<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>が正しくない、すべてのレコードを書き込む必要があります。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>このシーケンスに対して無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "シーケンス番号を取得するが追加された最後のレコードより大きい。"
  remarks: "このプロパティには、大きくすることが保証されるシーケンス番号が含まれています。 最後のシーケンス番号よりも、レコードを追加します。 有効なシーケンス番号がより大きいか等しい<xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A>LastSequenceNumber よりも小さいです</xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A>。 その他のすべてのシーケンス番号が無効です。"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加された最後のレコードより大きい番号シーケンス番号します。"
  overload: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加または (バイト単位)、このシーケンスから読み取り可能な最大レコード サイズを取得します。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "追加または (バイト単位)、このシーケンスから読み取り可能な最大レコード サイズ。"
  overload: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "シーケンス内のレコードの列挙可能なコレクションを返します。 このメソッドは継承できません。"
  remarks: "このメソッドは、シーケンス内のレコードの列挙可能なコレクションを返します。 列挙されたレコードの順序の値によって異なります、`logRecordEnum`パラメーター。"
  example:
  - "The following example shows how you can use this method to read the records in a log sequence.  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/5d31b2a4-d7cf-41cf-80bb-_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/5d31b2a4-d7cf-41cf-80bb-_1.cs)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "読み込みを開始する最初のレコードのシーケンス番号。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "有効な<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>内からレコードを読み取る方法 (つまり、前方または後方) を指定する値、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "シーケンス内のレコードの列挙可能なコレクション。"
  overload: System.IO.Log.FileRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが書き込み専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコード シーケンスが破損しています。       または、レコードは、レコード シーケンスの互換性のないバージョンで書き込まれました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "列挙体が終了しました。       または、列挙が開始されていません。 呼び出し<xref:System.Collections.IEnumerator.MoveNext*>行う必要があります</xref:System.Collections.IEnumerator.MoveNext*>。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "シーケンス内の再開領域の列挙可能なコレクションを返します。 このメソッドは継承できません。"
  remarks: "再開領域が下限のシーケンス番号のシーケンス番号の最大値からは、反転シーケンス番号の順に列挙されます。 最後のシーケンス番号間のシーケンス番号を持つ再開領域のみと、基本シーケンス番号が列挙されます。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "シーケンス内の再開領域の列挙可能なコレクション。"
  overload: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが書き込み専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコード シーケンスが破損しています。       または、レコードは、レコード シーケンスの互換性のないバージョンで書き込まれました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "列挙体が終了しました。       または、列挙が開始されていません。 呼び出し<xref:System.Collections.IEnumerator.MoveNext*>行う必要があります</xref:System.Collections.IEnumerator.MoveNext*>。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動的に単一の予約を行い、シーケンスにレコードを追加します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>で予約を作成するコレクションを格納します。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されていません."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動的に単一の予約を行い、シーケンスにレコードを追加します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.FileRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.FileRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されていません."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "予約されているバイトの合計数を取得します。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "このレコード シーケンスで行われたすべての予約の合計サイズ。"
  overload: System.IO.Log.FileRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "直前に書き込まれた再開領域のシーケンス番号を取得します。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "再開領域を直前に書き込まれたのシーケンス番号。"
  overload: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得または設定を示す値かどうかを追加、ログがいっぱいの場合は、自動的に再試行します。"
  remarks: "このプロパティの値が場合`true`、および<xref:System.IO.Log.FileRecordSequence.Append%2A>、シーケンス内に十分な領域がないために、呼び出しが失敗し、レコード シーケンスが領域を解放して、追加の再試行を試みた</xref:System.IO.Log.FileRecordSequence.Append%2A>。"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合追加は自動的に再試行を行う場合、ログがいっぱいです。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.Log.FileRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "レコード シーケンスでは、末尾を前方移動する必要がありますが判断した場合に発生します。 このメソッドは継承できません。"
  remarks: "レコード シーケンスが領域を使い果たしたときに、このイベントを発生させることができます。 このイベントが発生したときに、シーケンス (つまり、基本シーケンス番号) の末尾は領域を解放する前方に移動します。"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に格納できます。 回復処理が必要なときに、再開領域の読み取りし、最後のチェックポイント操作からすべてのデータを取得します。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>。       バイト配列セグメント内のデータは、レコードとして追加するための単一のバイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に格納できます。 回復処理が必要なときに、再開領域の読み取りし、最後のチェックポイント操作からすべてのデータを取得します。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>。       バイト配列セグメント内のデータは、レコードとして追加するための単一のバイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に格納できます。 回復処理が必要なときに、再開領域の読み取りし、最後のチェックポイント操作からすべてのデータを取得します。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。       または、新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>このシーケンスに対して無効です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に格納できます。 回復処理が必要なときに、再開領域の読み取りし、最後のチェックポイント操作からすべてのデータを取得します。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。       または、新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>このシーケンスに対して無効です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に格納できます。 回復処理が必要なときに、再開領域の読み取りし、最後のチェックポイント操作からすべてのデータを取得します。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       予約を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します。 メソッドが成功すると、消費され、最も小さな予約データを持つことができること、および予約がコレクションから削除されます。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。       または、新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。       - または -<code>newBaseSeqNum</code>このシーケンスに対して無効です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に格納できます。 回復処理が必要なときに、再開領域の読み取りし、最後のチェックポイント操作からすべてのデータを取得します。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       予約を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します。 メソッドが成功すると、消費され、最も小さな予約データを持つことができること、および予約がコレクションから削除されます。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。       または、新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>このレコード シーケンスによって作成されませんでした。       - または -<code>newBaseSeqNum</code>このシーケンスに対して無効です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行することはできません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にメソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.FileRecordSequence.Dispose
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.Flush
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.FileRecordSequence.TailPinned
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.#ctor*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence
  nameWithType: FileRecordSequence.FileRecordSequence
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append
  nameWithType: FileRecordSequence.Append
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: FileRecordSequence.BeginAppend
- uid: System.IO.Log.FileRecordSequence.BeginFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: FileRecordSequence.BeginFlush
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: FileRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: FileRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: FileRecordSequence.CreateReservationCollection
- uid: System.IO.Log.FileRecordSequence.Dispose*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: FileRecordSequence.Dispose
- uid: System.IO.Log.FileRecordSequence.EndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: FileRecordSequence.EndAppend
- uid: System.IO.Log.FileRecordSequence.EndFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: FileRecordSequence.EndFlush
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: FileRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: FileRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.Flush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush
  nameWithType: FileRecordSequence.Flush
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: FileRecordSequence.ReadLogRecords
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: FileRecordSequence.ReadRestartAreas
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: FileRecordSequence.ReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.ReservedBytes*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: FileRecordSequence.WriteRestartArea
