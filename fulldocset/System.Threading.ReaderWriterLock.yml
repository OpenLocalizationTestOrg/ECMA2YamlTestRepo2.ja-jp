### YamlMime:ManagedReference
items:
- uid: System.Threading.ReaderWriterLock
  id: ReaderWriterLock
  children:
  - System.Threading.ReaderWriterLock.#ctor
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.Finalize
  - System.Threading.ReaderWriterLock.IsReaderLockHeld
  - System.Threading.ReaderWriterLock.IsWriterLockHeld
  - System.Threading.ReaderWriterLock.ReleaseLock
  - System.Threading.ReaderWriterLock.ReleaseReaderLock
  - System.Threading.ReaderWriterLock.ReleaseWriterLock
  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.WriterSeqNum
  langs:
  - csharp
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock
  fullName: System.Threading.ReaderWriterLock
  type: Class
  summary: "単一ライターと複数の読み取りをサポートするロックを定義します。"
  remarks: "> [!IMPORTANT]>、[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]が&2; つのリーダー ライター ロック<xref:System.Threading.ReaderWriterLockSlim>と ReaderWriterLock</xref:System.Threading.ReaderWriterLockSlim> 。 <xref:System.Threading.ReaderWriterLockSlim>すべての新しい開発をお勧めします。</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>ReaderWriterLock に似ていますが、再帰、アップグレード、およびロックの状態をダウン グレードの規則が簡素化されますがします。</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>多くの場合の潜在的なデッドロックを回避できます。</xref:System.Threading.ReaderWriterLockSlim> さらに、パフォーマンスの<xref:System.Threading.ReaderWriterLockSlim>は ReaderWriterLock よりも大幅に向上します</xref:System.Threading.ReaderWriterLockSlim>。       ReaderWriterLock がリソースへのアクセスを同期するために使用されます。 任意の時点で、いずれかの複数のスレッドの同時実行の読み取りアクセスまたは単一のスレッドの書き込みアクセスできます。 まれに、リソースが変更されている状況では、 `ReaderWriterLock` <xref:System.Threading.Monitor>.</xref:System.Threading.Monitor>など、単純な時間での&1; つロックよりスループットの向上を提供します。       `ReaderWriterLock`多くのアクセスは読み取り、書き込みは頻繁には、および短い期間の最適なは。 複数のリーダーの代替と単一ライターは、リーダーでもライターが長時間にわたってブロックできるようにします。      > [!NOTE] > 長期間には、他のスレッドがによってが阻害のロックのリーダーまたはライター ロックを保持します。 最適なパフォーマンスは、書き込みの時間を最小限に抑える、アプリケーションを再構築を検討してください。       ロックまたはライター ロックでは、両方ではなく、同時に、スレッドは、リーダーを保持できます。 ライター ロックを取得するために、リーダー ロックを解放するのではなく<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>。</xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A></xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>を使用することができます。       再帰的なロックの要求は、ロックのロック カウントを増やします。       リーダーとライターとは別にキューにあります。 スレッドがライター ロックを解放すると、その時点で、リーダーのキューで待機しているすべてのスレッドは、リーダー ロックが許可されます。ときにリーダー ロックをすべてがリリースされた、次のスレッドで待機している、ライター、ライター ロックが許可された場合、キューに表示され、します。 つまり、`ReaderWriterLock`リーダーのコレクションと&1; つのライターの代替です。       ライター キュー内のスレッドが待機中のアクティブ リーダー ロックが解放されるため、新しいリーダー ロックを要求するスレッドは、リーダーのキューに蓄積されます。 自身の要求が与えられていない場合でも、者既存リーダー ロック; への同時アクセスを共有する可能性があります。これにより、リーダーによって無期限進行を妨げているに対してライターを保護します。       ほとんどのメソッドでロックの獲得、`ReaderWriterLock`タイムアウト値をそのまま使用します。 アプリケーションでデッドロックを回避するのにには、タイムアウトを使用します。 たとえば、スレッドが&1; つのリソースにライター ロックを取得し、2 番目のリソースで、リーダー ロックを要求可能性があります。その間は、別のスレッドは、2 番目のリソースにライター ロックを取得し、最初のリーダー ロックを要求します。 タイムアウトを使用しない場合、スレッドのデッドロック。       メソッドが、 <xref:System.ApplicationException>。</xref:System.ApplicationException>スローすることによって、呼び出し元スレッドにコントロールを返します、タイムアウト期限が切れた場合、ロック要求が許可されていません スレッドは、この例外をキャッチし、[次へ] を実行するアクションを決定できます。       タイムアウトはミリ秒単位で表されます。 <xref:System.TimeSpan?displayProperty=fullName>使用される値ではタイムアウトを指定する、 <xref:System.TimeSpan>。</xref:System.TimeSpan>によって表される整数のミリ秒単位の合計数</xref:System.TimeSpan?displayProperty=fullName>を使用する場合 次の表は、ミリ秒単位で有効なタイムアウト値を示します。      |値 |説明 |  |-----------|-----------------|  |-1 |スレッドは、所要時間に関係なく、ロックが取得されるまで待機します。 整数のタイムアウトを指定する方法、<xref:System.Threading.Timeout.Infinite>定数を使用できます |。  |&0; |スレッドが、ロックの取得を待機しません</xref:System.Threading.Timeout.Infinite>。 かどうか、ロックをすぐに取得できない、メソッドが返されます |。  | >&0; |待機するミリ秒数です |。      -1 以外の負の値のタイムアウト値は許可されません。 -1 以外の負の整数を指定すると、0 のタイムアウト値が代わりに使用されます。 (つまり、メソッドを返します、待機せず、ロックをすぐに取得できない場合。)指定した場合、 <xref:System.TimeSpan>、負の値を-1 以外のミリ秒数を表す<xref:System.ArgumentOutOfRangeException>がスローされます</xref:System.ArgumentOutOfRangeException></xref:System.TimeSpan>。"
  example:
  - "The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref>クラスです。"
  remarks: ''
  example:
  - "The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]"
  syntax:
    content: public ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  id: AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "リーダーの取得を使用してロック、<xref:System.Int32>のタイムアウト値</xref:System.Int32>。"
  remarks: "別のスレッドがあるライター ロック場合、または少なくとも&1; つのスレッドがライター ロックを待機している場合、AcquireReaderLock がブロックされます。      > [!NOTE] >、現在のスレッドは、ライター ロックを既に持っている場合は、リーダー ロックは取得されません。 代わりに、ライター ロックのロック カウントがインクリメントされます。 これは、スレッドがライター ロックでブロックすることを防ぎます。 結果は、呼び出した場合と同じでは正確に<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>、および呼び出しを<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>はライター ロックを解放する場合に必要です</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A></xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。       `AcquireReaderLock`再帰的なリーダー ロック要求をサポートしています。 スレッドできます AcquireReaderLock を複数回呼び出し、毎回ロック カウントをインクリメントします。 呼び出す必要があります<xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>を呼び出すたびに&1; 回`AcquireReaderLock`</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>。 代わりに、呼び出すことができます<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>、すぐにゼロにロックの数を減らします</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>。       再帰的なロックの要求は必ずリーダー キューに要求元のスレッドをかけることがなく、すぐに許可されます。 注意、して再帰的なロックを使用して、長期にわたってライター ロック要求がブロックされないようにします。       有効なタイムアウト値<xref:System.Threading.ReaderWriterLock>。</xref:System.Threading.ReaderWriterLock>を参照してください。"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]"
  syntax:
    content: public void AcquireReaderLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "ミリ秒単位のタイムアウト。"
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>ロック要求を許可する前に期限が切れます。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  id: AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "リーダーの取得を使用してロック、<xref:System.TimeSpan>のタイムアウト値</xref:System.TimeSpan>。"
  remarks: "<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>少なくとも&1; つのスレッドがライター ロックを待機している場合または別のスレッドがライター ロックをブロックします。</xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>      > [!NOTE] >、現在のスレッドは、ライター ロックを既に持っている場合は、リーダー ロックは取得されません。 代わりに、ライター ロックのロック カウントがインクリメントされます。 これは、スレッドがライター ロックでブロックすることを防ぎます。 結果は、呼び出した場合と同じでは正確に<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>、および呼び出しを<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>はライター ロックを解放する場合に必要です</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A></xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。       `AcquireReaderLock`再帰的なリーダー ロック要求をサポートしています。 スレッドできます AcquireReaderLock を複数回呼び出し、毎回ロック カウントをインクリメントします。 呼び出す必要があります<xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>を呼び出すたびに&1; 回`AcquireReaderLock`</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>。 代わりに、呼び出すことができます<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>、すぐにゼロにロックの数を減らします</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>。       再帰的なロックの要求は必ずリーダー キューに要求元のスレッドをかけることがなく、すぐに許可されます。 注意、して再帰的なロックを使用して、長期にわたってライター ロック要求がブロックされないようにします。       有効なタイムアウト値<xref:System.Threading.ReaderWriterLock>。</xref:System.Threading.ReaderWriterLock>を参照してください。"
  syntax:
    content: public void AcquireReaderLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref>タイムアウト期間を指定します。"
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>ロック要求を許可する前に期限が切れます。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>-1 ミリ秒以外の負の値を指定します。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  id: AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "ライターの取得を使用してロック、<xref:System.Int32>のタイムアウト値</xref:System.Int32>。"
  remarks: "このメソッドは、別のスレッドがリーダー ロックまたは書き込みロックをブロックします。 方法の詳細については、複数の同時実行リーダー ロックをライター ロック代替は、<xref:System.Threading.ReaderWriterLock>クラス</xref:System.Threading.ReaderWriterLock>を参照してください。       既にリーダー ロックを保持しているスレッドが&2; つの方法のいずれかでライター ロックを取得できます: しているを呼び出す前に、リーダー ロックを解放するか、 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>を呼び出すことによって      > [!CAUTION] > スレッドが呼び出す場合`AcquireWriterLock`リーダー ロックがまだあるときに、リーダー ロックでブロック以外の場合は、スレッドはデッドロック状態無限のタイムアウトが指定されている場合。 このようなデッドロックを避けるためには、次のように使用します<xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>を現在のスレッドがリーダー ロックを既にかどうかを判断します。</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> 。       `AcquireWriterLock`再帰的なライター ロック要求をサポートしています。 スレッドを呼び出すことができます、 `AcquireWriterLock` 、複数回これロック カウントをインクリメントするたびにします。 呼び出す必要があります<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>を呼び出すたびに&1; 回`AcquireWriterLock`</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>。 代わりに、呼び出すことができます<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>、すぐにゼロにロックの数を減らします</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>。       再帰的なロックの要求は必ずライター キューに要求元のスレッドをかけることがなく、すぐに許可されます。       有効なタイムアウト値<xref:System.Threading.ReaderWriterLock>。</xref:System.Threading.ReaderWriterLock>を参照してください。"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]"
  syntax:
    content: public void AcquireWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "ミリ秒単位のタイムアウト。"
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>ロック要求を許可する前に期限が切れます。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  id: AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "ライターの取得を使用してロック、<xref:System.TimeSpan>のタイムアウト値</xref:System.TimeSpan>。"
  remarks: "このメソッドは、別のスレッドがリーダー ロックまたは書き込みロックをブロックします。 方法の詳細については、複数の同時実行リーダー ロックをライター ロック代替は、<xref:System.Threading.ReaderWriterLock>クラス</xref:System.Threading.ReaderWriterLock>を参照してください。       既にリーダー ロックを保持しているスレッドが&2; つの方法のいずれかでライター ロックを取得できます: を呼び出す前に、リーダー ロックを解放<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>、または<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>を呼び出すことによって</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>      > [!CAUTION] > スレッドが呼び出す場合`AcquireWriterLock`リーダー ロックがまだあるときに、リーダー ロックでブロック以外の場合は、スレッドはデッドロック状態無限のタイムアウトが指定されている場合。 このようなデッドロックを避けるためには、次のように使用します<xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>を現在のスレッドがリーダー ロックを既にかどうかを判断します。</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> 。       `AcquireWriterLock`再帰的なライター ロック要求をサポートしています。 スレッドを呼び出すことができます、 `AcquireWriterLock` 、複数回これロック カウントをインクリメントするたびにします。 呼び出す必要があります<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>を呼び出すたびに&1; 回`AcquireWriterLock`</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>。 代わりに、呼び出すことができます<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>、すぐにゼロにロックの数を減らします</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>。       再帰的なロックの要求は必ずライター キューに要求元のスレッドをかけることがなく、すぐに許可されます。       有効なタイムアウト値<xref:System.Threading.ReaderWriterLock>。</xref:System.Threading.ReaderWriterLock>を参照してください。"
  syntax:
    content: public void AcquireWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "<xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref>タイムアウト期間を指定します。"
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>ロック要求を許可する前に期限が切れます。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>-1 ミリ秒以外の負の値を指定します。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  id: AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "シーケンス番号を取得してから、任意のスレッドにライター ロックを付与されているかどうかを示します。"
  remarks: "使用することができます<xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>と`AnyWritersSince`アプリケーションのパフォーマンスを向上させるためにします</xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>。 たとえば、スレッドがリーダー ロックを保持しているときに取得した情報をキャッシュする可能性があります。 解放した後、ロックを取得した場合、スレッドを使用できる`AnyWritersSince`を決定するかどうか他のスレッドがリソース以外に、一時的に書き込まれたかどうか、キャッシュされた情報を使用できます。 この手法は、高価です。 ここでは、ロックで保護された情報を読み取る役立ちますたとえば、データベース クエリを実行しています。       呼び出し元は、シーケンス番号を使用するために、リーダー ロックまたは書き込みロック保持する必要があります。"
  example:
  - "The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]"
  syntax:
    content: public bool AnyWritersSince (int seqNum);
    parameters:
    - id: seqNum
      type: System.Int32
      description: "シーケンス番号。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ライター ロックは、シーケンス番号が取得された; してから、任意のスレッドに付与されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ReaderWriterLock.AnyWritersSince*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  id: DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "前に、のスレッドのロックの状態に復元<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>が呼び出されました</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>。"
  remarks: "DowngradeFromWriterLock は再帰的なロック数に関係なく、ライター ロックを解放し、リーダー ロックをライター ロックにアップグレードする前に、スレッドによって保持されたを復元します。 リーダー ロックのロック カウントが復元されます。      > [!NOTE]  >   `DowngradeFromWriterLock` <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>を呼び出すことによって取得</xref:System.Threading.LockCookie>を受け入れる 使用しないで、 `LockCookie` <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>によって返される       スレッドをブロックしませんライター ロックからダウン グレードするとき、ライター ロックが解放されるときに、すべてのリーダー ロック要求が与えられているために、他のスレッドがライター ロックを待機している場合でも。"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]"
  syntax:
    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>によって返される"
  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "スレッドには、ライター ロックはありません。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "アドレス<code> lockCookie </code> null ポインターです。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.Finalize
  id: Finalize
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "リソースが解放され、ガベージ コレクターがクリアするときに他のクリーンアップ操作が実行されることにより、 <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref>オブジェクト。"
  remarks: "ガベージ コレクターの呼び出しの最終処理時に現在<xref:System.Threading.ReaderWriterLock>オブジェクトが完了する準備ができています</xref:System.Threading.ReaderWriterLock>。"
  syntax:
    content: ~ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  id: IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のスレッドがリーダー ロックを保持しているかどうかを示す値を取得します。"
  remarks: ''
  example:
  - "The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]"
  syntax:
    content: public bool IsReaderLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>現在のスレッドがリーダー ロックを保持している場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  id: IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のスレッドがライター ロックを保持しているかどうかを示す値を取得します。"
  remarks: ''
  example:
  - "The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]"
  syntax:
    content: public bool IsWriterLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>現在のスレッドがライター ロックを保持している場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  id: ReleaseLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "スレッドがロックを取得した回数に関係なく、ロックを解放します。"
  remarks: "ReleaseLock は、リーダー ロックまたは再帰的なロック数に関係なく、ライター ロックを解放します。 ロック数など、ロックの状態を復元するには渡す<xref:System.Threading.LockCookie><xref:System.Threading.ReaderWriterLock.RestoreLock%2A>。</xref:System.Threading.ReaderWriterLock.RestoreLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie ReleaseLock ();
    parameters: []
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref>解放されたロックを表す値です。"
  overload: System.Threading.ReaderWriterLock.ReleaseLock*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  id: ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "ロック カウントをデクリメントします。"
  remarks: "ロック カウントを ReleaseReaderLock デクリメントします。 カウントが&0; になったときに、ロックが解放されます。      > [!NOTE] > スレッドにライター ロックがある場合は、呼び出す`ReleaseReaderLock` <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>を呼び出す場合と同じ効果 ロックがスレッドがない場合は、呼び出す`ReleaseReaderLock` <xref:System.ApplicationException>.</xref:System.ApplicationException>がスローされます"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]"
  syntax:
    content: public void ReleaseReaderLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "スレッドには、すべてのリーダーまたはライター ロックはありません。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  id: ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "ライター ロックのロックをカウントをデクリメントします。"
  remarks: "ライター ロック カウントを保持デクリメントします。 カウントには、ゼロに達すると、ライター ロックは解放されます。      > [!NOTE] > スレッドに、リーダー ロックまたはロックしない場合は、呼び出す`ReleaseWriterLock` <xref:System.ApplicationException>.</xref:System.ApplicationException>がスローされます"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]"
  syntax:
    content: public void ReleaseWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "スレッドには、ライター ロックはありません。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  id: RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "<xref:System.Threading.ReaderWriterLock.ReleaseLock*>。</xref:System.Threading.ReaderWriterLock.ReleaseLock*>を呼び出す前に、スレッドのロックの状態を復元します。"
  remarks: "によって復元状態`RestoreLock`再帰的なロック数が含まれています。       スレッドがブロックを別のスレッドがライター ロックを取得した後、または別のスレッドがリーダー ロックまたは書き込みロックが取得した後にライター ロックを復元しようとすると、リーダー ロックを復元しようとするとします。 `RestoreLock`タイムアウトを受け入れません。 可能なデッドロックを回避するように注意する必要があります。      > [!CAUTION] > 呼び出す前に`RestoreLock`、 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>への呼び出し以降取得したすべてのロックを解放することを確認してください たとえば、スレッドはデッドロック状態リーダー ロックを取得し、以前のライター ロックの復元を試みます。 使用して<xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>と<xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>をこのようなその他のロックを検出します</xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A></xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>。       <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>から返された</xref:System.Threading.LockCookie>を使用しないでください。"
  example:
  - "The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]"
  syntax:
    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>によって返される"
  overload: System.Threading.ReaderWriterLock.RestoreLock*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "アドレス<code> lockCookie </code> null ポインターです。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  id: UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "アップグレード、リーダー ロックをライター ロックを使用して、 <xref uid=&quot;langword_csharp_Int32&quot; name=&quot;Int32&quot; href=&quot;&quot;> </xref>のタイムアウト値。"
  remarks: "スレッドを呼び出すと`UpgradeToWriterLock`ロック カウントに関係なく、リーダー ロックが解放され、スレッドがライター ロックをキューの末尾に移動します。 したがって、他のスレッドがライター ロックが許可されるは、アップグレードを要求したスレッドの前に、リソースに書き込むことがあります。      > [!IMPORTANT] > 保持メソッドを呼び出したスレッドがリーダー ロックを再取得できるまでタイムアウト例外はスローされません。 ライター ロックを待機している他のスレッドがない場合は、この直ちに行われます。 ただし、別のスレッドがライター ロックをキューに配置される場合保持メソッドを呼び出したスレッドことはできません再取得リーダー ロック解放されるまで現在のすべての読み込みが、ロックが&1; つのスレッドを取得およびライター ロックを解放します。 これは、機能は、ライター ロックを要求したその他のスレッドを要求して、現在のスレッドに保持メソッドが呼び出された後に場合でも同様です。       ロックの状態を復元するには、呼び出す<xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>を使用して、<xref:System.Threading.LockCookie>によって返される`UpgradeToWriterLock`</xref:System.Threading.LockCookie></xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>。 これを使用しないでください`LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A></xref:System.Threading.ReaderWriterLock.RestoreLock%2A> 。       スレッドがリーダー ロックを持たない場合は使用しないで`UpgradeToWriterLock`です。 使用して<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>代わりにします</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。       有効なタイムアウト値<xref:System.Threading.ReaderWriterLock>。</xref:System.Threading.ReaderWriterLock>を参照してください。"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "ミリ秒単位のタイムアウト。"
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>ロック要求を許可する前に期限が切れます。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  id: UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "アップグレード、リーダー ロックをライター ロックを使用して、 <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref>のタイムアウト値。"
  remarks: "スレッドを呼び出すと`UpgradeToWriterLock`ロック カウントに関係なく、リーダー ロックが解放され、スレッドがライター ロックをキューの末尾に移動します。 したがって、他のスレッドがライター ロックが許可されるは、アップグレードを要求したスレッドの前に、リソースに書き込むことがあります。      > [!IMPORTANT] > を呼び出したスレッドまでタイムアウト例外はスローされません、<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>メソッドは、リーダー ロックを取得できます</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。 ライター ロックを待機している他のスレッドがない場合は、この直ちに行われます。 ただし、別のスレッドがライター ロックをキューに登録する場合、スレッドを呼び出した関数、<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>すべて現在リーダーが、ロックを解放し、1 つのスレッドが取得およびライター ロックを解放するまで、メソッドがリーダー ロックを再取得できません</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。 これは、true の場合でも、ライター ロックを要求したその他のスレッドを要求して、現在のスレッドが呼び出された後に、<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>メソッド</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。       ロックの状態を復元するには、呼び出す<xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>を使用して、<xref:System.Threading.LockCookie>によって返される`UpgradeToWriterLock`</xref:System.Threading.LockCookie></xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>。 これを使用しないでください`LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A></xref:System.Threading.ReaderWriterLock.RestoreLock%2A> 。       スレッドがリーダー ロックを持たない場合は使用しないで`UpgradeToWriterLock`です。 使用して<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>代わりにします</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。       有効なタイムアウト値<xref:System.Threading.ReaderWriterLock>。</xref:System.Threading.ReaderWriterLock>を参照してください。"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "<xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref>タイムアウト期間を指定します。"
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>ロック要求を許可する前に期限が切れます。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>-1 ミリ秒以外の負の値を指定します。"
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  id: WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のシーケンス番号を取得します。"
  remarks: "シーケンス番号は、スレッドがライター ロックを取得するたびに増加します。 シーケンス番号を保存してに渡す<xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>は後で、他のスレッドがライター ロックを当面の間に取得したかどうかを判断する場合</xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>。       使用することができます`WriterSeqNum`アプリケーションのパフォーマンスを向上させるためにします。 たとえば、スレッドがリーダー ロックを保持しているときに取得した情報をキャッシュする可能性があります。 スレッドを解放した後、ロックを取得した場合、呼び出すことで、他のスレッドがリソースに書き込まれたかどうかを決定できます`AnyWritersSince`以外の場合は、キャッシュされた情報を使用できます。 ロックで保護されている情報の読み取りが高価です。 この手法が有用です。たとえば、データベース クエリを実行しています。       呼び出し元は、シーケンス番号を使用するために、リーダー ロックまたは書き込みロック保持する必要があります。"
  example:
  - "The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]"
  syntax:
    content: public int WriterSeqNum { get; }
    return:
      type: System.Int32
      description: "現在のシーケンス番号。"
  overload: System.Threading.ReaderWriterLock.WriterSeqNum*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Threading.ReaderWriterLock.#ctor
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
- uid: System.Threading.LockCookie
  parent: System.Threading
  isExternal: false
  name: LockCookie
  nameWithType: LockCookie
  fullName: System.Threading.LockCookie
- uid: System.Threading.ReaderWriterLock.Finalize
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
- uid: System.Threading.ReaderWriterLock.#ctor*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock.ReaderWriterLock
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock
  nameWithType: ReaderWriterLock.AcquireReaderLock
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock
  nameWithType: ReaderWriterLock.AcquireWriterLock
- uid: System.Threading.ReaderWriterLock.AnyWritersSince*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince
  nameWithType: ReaderWriterLock.AnyWritersSince
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock
- uid: System.Threading.ReaderWriterLock.Finalize*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize
  nameWithType: ReaderWriterLock.Finalize
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock
  nameWithType: ReaderWriterLock.ReleaseLock
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock
  nameWithType: ReaderWriterLock.ReleaseReaderLock
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock
  nameWithType: ReaderWriterLock.ReleaseWriterLock
- uid: System.Threading.ReaderWriterLock.RestoreLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock
  nameWithType: ReaderWriterLock.RestoreLock
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock
  nameWithType: ReaderWriterLock.UpgradeToWriterLock
- uid: System.Threading.ReaderWriterLock.WriterSeqNum*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
