### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "タスクの実行、作業項目のポスト、非同期 I/O の処理、他のスレッドでは、代理で行う待機、およびタイマーの処理に使用できるスレッドのプールを提供します。"
  remarks: "多くのアプリケーションでは、長時間時間スリープ状態で、イベントの発生を待機しているスレッドを作成します。 他のスレッドは、スリープ状態の変更をポーリングまたは状態情報の更新を定期的にスリープ解除する場合にのみを入力します。 スレッド プールでは、システムによって管理されるワーカー スレッドのプールを使用してアプリケーションを提供することにより、スレッドをより効率的に使用することができます。 スレッド プールのスレッドを使用する操作の例については、次のとおりです: を作成するときに、<xref:System.Threading.Tasks.Task>または<xref:System.Threading.Tasks.Task%601>タスクがスレッド プールのスレッドで実行するスケジュールを既定では、非同期的にいくつかのタスクを実行するオブジェクト</xref:System.Threading.Tasks.Task%601></xref:System.Threading.Tasks.Task>。      -非同期タイマーは、スレッド プールを使用します。 スレッド プールのスレッドが<xref:System.Threading.Timer?displayProperty=fullName>、<xref:System.Timers.Timer?displayProperty=fullName>クラス</xref:System.Timers.Timer?displayProperty=fullName>からクラス、および raise のイベント</xref:System.Threading.Timer?displayProperty=fullName>からのコールバックを実行します。      -登録された待機ハンドルを使用する場合、システム スレッドは待機ハンドルの状態を監視します。 待機操作が完了すると、スレッド プールからワーカー スレッドは、対応するコールバック関数を実行します。      の呼び出すと、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>スレッド プールのスレッド上で実行するメソッドをキューにします</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 メソッドを渡すことによって、これを行う、<xref:System.Threading.WaitCallback>委任します</xref:System.Threading.WaitCallback>。   デリゲート シグネチャを持つ<CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder>場所`state`デリゲートによって使用されるデータを格納しているオブジェクトは、します。    実際のデータは、呼び出すことによって、デリゲートに渡すことが、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>メソッド</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>。      > [!NOTE] > マネージ スレッド プール内のスレッドがバック グラウンド スレッドです。 つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティは、 `true`</xref:System.Threading.Thread.IsBackground%2A> 。 これは、スレッド プールのスレッドによって、すべてのフォア グラウンド スレッドが終了した後に実行されるアプリケーションは保持しないことを意味します。      > [!IMPORTANT] > スレッド ローカル ストレージまたはでマークされたフィールドのデータは消去されません、スレッド プールには、スレッドが再利用、ときに、<xref:System.ThreadStaticAttribute>属性</xref:System.ThreadStaticAttribute>。 したがって、メソッドがスレッド ローカル ストレージを検査またはフィールドが付いている、<xref:System.ThreadStaticAttribute>属性、値が見つかる可能性があります残されるスレッド プールのスレッドの以前の使用</xref:System.ThreadStaticAttribute>。       また、スレッド プールに、待機操作に関連していない作業項目をキューできます。 作業項目をスレッド プール内のスレッドで処理することを要求するには、呼び出し、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 このメソッドは、メソッドまたはスレッド プールから選択したスレッドで呼び出されるデリゲートへの参照をパラメーターとして受け取ります。 キューに登録されましたが、作業項目をキャンセルする方法はありません。       タイマー キュー タイマーおよび登録された待機操作もスレッド プールを使用します。 これらのコールバック関数は、スレッド プールにキューに入っています。       プロセスごとに&1; つのスレッド プールがあります。 以降で、[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]プロセスのスレッド プールの既定のサイズは、仮想アドレス領域のサイズなど、いくつかの要因によって異なります。 プロセスを呼び出すことができます、<xref:System.Threading.ThreadPool.GetMaxThreads%2A>スレッドの数を決定するメソッド</xref:System.Threading.ThreadPool.GetMaxThreads%2A>。 使用しているスレッド プール内のスレッドの数を変更することができます、<xref:System.Threading.ThreadPool.SetMaxThreads%2A>メソッド</xref:System.Threading.ThreadPool.SetMaxThreads%2A>。 各スレッドは、既定のスタック サイズを使用し、既定の優先順位で実行します。      > [!NOTE] > を .NET Framework をホストするアンマネージ コードを使用して、スレッド プールのサイズを変更することができます、 `CorSetMaxThreads` mscoree.h ファイルで定義された関数。       スレッド プールを提供新しいワーカー スレッドまたは I/O 完了スレッド要求時に各カテゴリの最小値に達するまでします。 最低限に達すると、スレッド プールはそのカテゴリに追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。 以降で、 [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]、スレッド プールを作成し、タスクの単位時間あたりの完了数として定義されるスループットを最適化するためにワーカー スレッドを破棄します。 スレッドが少なすぎる可能性がありますいない、最適な使用使用可能なリソースは、スレッドが多すぎるはリソースの競合を増やすでしたがします。      > [!NOTE] > 需要が不足しているときに実際のスレッド プール スレッドの数を下回る場合、最小値。       使用することができます、<xref:System.Threading.ThreadPool.GetMinThreads%2A>これらの最小値を取得します</xref:System.Threading.ThreadPool.GetMinThreads%2A>。      > [!CAUTION] > を使用することができます、<xref:System.Threading.ThreadPool.SetMinThreads%2A>スレッドの最小数を増加させます</xref:System.Threading.ThreadPool.SetMinThreads%2A>。 ただし、不必要にこれらの値を増やすとパフォーマンスの問題が発生することができます。 タスクが多すぎますが、同時に開始する場合、は、低速であるし、すべての可能性があります。 ほとんどの場合、スレッド プールが優れてスレッドを割り当てるための独自のアルゴリズムでします。"
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "オペレーティング システム ハンドルのバインド、 <xref href=&quot;System.Threading.ThreadPool&quot;></xref>です。"
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "<xref:System.IntPtr>ハンドルを保持する</xref:System.IntPtr>。 ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、ハンドルがバインドされています。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "オペレーティング システム ハンドルのバインド、 <xref href=&quot;System.Threading.ThreadPool&quot;></xref>です。"
  remarks: "`osHandle` <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>抽象<xref:System.Runtime.InteropServices.SafeHandle>クラス</xref:System.Runtime.InteropServices.SafeHandle>から派生した、</xref:Microsoft.Win32.SafeHandles.SafeFileHandle>パラメーターでなければなりません"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "A<xref:System.Runtime.InteropServices.SafeHandle>オペレーティング システム ハンドルを保持する</xref:System.Runtime.InteropServices.SafeHandle>。 ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、ハンドルがバインドされています。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "によって返されるスレッド プールのスレッドの最大数の差を取得、<xref:System.Threading.ThreadPool.GetMaxThreads*>メソッド、および現在の数</xref:System.Threading.ThreadPool.GetMaxThreads*>。"
  remarks: "GetAvailableThreads 返されるときで指定された変数`workerThreads`を開始する追加のワーカー スレッドとで指定された変数の数を表す`completionPortThreads`を起動するその他の非同期 I/O スレッドの数が含まれています。       使用可能なスレッドがない場合は、追加のスレッド プールの要求までキューに置かれたスレッド プールのスレッドが使用可能になるです。"
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "使用可能なワーカー スレッドの数。"
    - id: completionPortThreads
      type: System.Int32
      description: "使用可能な非同期 I/O スレッドの数。"
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "同時にアクティブにできるスレッド プールに要求の数を取得します。 この数を超えるすべての要求は、スレッド プールのスレッドが使用可能になるまでキューに置かれます。"
  remarks: "GetMaxThreads 返されるときで指定された変数`workerThreads`スレッド プールで許可されるワーカー スレッドとで指定された変数の最大数を含む`completionPortThreads`スレッド プールで許可される非同期の I/O スレッドの最大数が含まれています。       使用することができます、<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>実際のスレッド プール内のスレッド数を特定の時点を調べます</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>。       使用することができます、<xref:System.Threading.ThreadPool.SetMaxThreads%2A>をスレッド プールでワーカー スレッドと非同期の I/O スレッドの最大数を設定します</xref:System.Threading.ThreadPool.SetMaxThreads%2A>。       システム メモリが許す限り多くのスレッド プールの要求とキューにできます。 スレッド プールのスレッドよりも多くの要求がある場合、追加の要求までキューに置かれたスレッド プールのスレッドが使用可能になります。"
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "スレッド プール内のワーカー スレッドの最大数。"
    - id: completionPortThreads
      type: System.Int32
      description: "スレッド プール内の非同期 I/O スレッドの最大数。"
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "スレッドの作成と破棄を管理するためのアルゴリズムに切り替える前に、新しい要求が行われる、スレッド プールがオンデマンドで作成するスレッドの最小数を取得します。"
  remarks: "スレッド プールを提供新しいワーカー スレッドまたは I/O 完了スレッド要求時に各カテゴリの最小値に達するまでします。 既定では、スレッドの最小数は、システム上のプロセッサの数を設定します。 最低限に達すると、スレッド プールはそのカテゴリに追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。 以降で、 [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]、スレッド プールを作成し、タスクの単位時間あたりの完了数として定義されるスループットを最適化するためにスレッドを破棄します。 スレッドが少なすぎる可能性がありますいない、最適な使用使用可能なリソースは、スレッドが多すぎるはリソースの競合を増やすでしたがします。      > [!NOTE] > 需要が不足しているときに実際のスレッド プール スレッドの数を下回る場合、最小値。"
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "このメソッドが戻るとき、スレッド プールがオンデマンドで作成されるワーカー スレッドの最小数を格納します。"
    - id: completionPortThreads
      type: System.Int32
      description: "このメソッドが戻るとき、スレッド プールがオンデマンドで作成するための非同期 I/O スレッドの最小数を格納します。"
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "メソッドの実行をキューに入れます。 メソッドは、スレッド プールのスレッドが利用可能になったらを実行します。"
  remarks: "クラス、メソッドが定義されている、または使用することができますのインスタンス フィールドでキューに置かれたメソッドで必要なデータを配置することができます、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>を必要なデータを格納するオブジェクトを受け入れるオーバー ロード</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>。      > [!NOTE] > Visual Basic の場合は省略できます、<xref:System.Threading.WaitCallback>コンス トラクター、および使用するだけで、 `AddressOf` <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>をコールバック メソッドを渡すときにオペレーター</xref:System.Threading.WaitCallback> Visual Basic では、適切なデリゲート コンス トラクターは、自動的に呼び出します。      ## バージョン情報で、.NET Framework version 2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A></xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>。 以前のバージョンでは、プリンシパルの情報は反映されません。"
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref>を実行するメソッドを表すです。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>メソッドが正常にキューに置かれた場合<xref:System.NotSupportedException>が、作業項目をキューにない場合にスローされます</xref:System.NotSupportedException>。"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "共通言語ランタイム (CLR) がホストされているし、ホストがこの操作をサポートしていません。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "メソッドの実行をキューに配置し、メソッドによって使用されるデータを格納しているオブジェクトを指定します。 メソッドは、スレッド プールのスレッドが利用可能になったらを実行します。"
  remarks: "コールバック メソッドには、複雑なデータが必要とする場合は、データを格納するクラスを定義することができます。      > [!NOTE] > Visual Basic の場合は省略できます、<xref:System.Threading.WaitCallback>コンス トラクター、および使用するだけで、 `AddressOf` QueueUserWorkItem をコールバック メソッドを渡すときにオペレーター</xref:System.Threading.WaitCallback> 。 Visual Basic では、適切なデリゲート コンス トラクターは、自動的に呼び出します。      ## バージョン情報で、.NET Framework version 2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A></xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>。 以前のバージョンでは、プリンシパルの情報は反映されません。"
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref>を実行するメソッドを表すです。"
    - id: state
      type: System.Object
      description: "メソッドによって使用されるデータを格納するオブジェクト。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>メソッドが正常にキューに置かれた場合<xref:System.NotSupportedException>が、作業項目をキューにない場合にスローされます</xref:System.NotSupportedException>。"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "共通言語ランタイム (CLR) がホストされているし、ホストがこの操作をサポートしていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、 <xref:System.Threading.WaitHandle>、(ミリ秒単位) をタイムアウトとして 32 ビット符号付き整数を指定します</xref:System.Threading.WaitHandle>。"
  remarks: "終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       RegisterWaitForSingleObject メソッドは、スレッド プールに指定されたデリゲートをキューします。 ワーカー スレッドは、次のいずれかが発生したときにデリゲートを実行します。-指定のオブジェクトがシグナル状態で。      -タイムアウト間隔が経過しました。       RegisterWaitForSingleObject メソッドは、指定されたオブジェクトの<xref:System.Threading.WaitHandle>。</xref:System.Threading.WaitHandle>の現在の状態をチェックします。 オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。      > [!IMPORTANT] > を使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。 代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore>1 の最大数を持つ</xref:System.Threading.Semaphore></xref:System.Threading.Mutex>。       待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。 したがって、RegisterWaitForSingleObject への複数の呼び出しでは、同じネイティブ オペレーティング システム ハンドルを使用する必要がある場合、は、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。 RegisterWaitForSingleObject に渡されたイベント オブジェクト待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためにパルスいない必要があることに注意してください。       、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。 たとえば、セマフォのカウントは&1; ずつ減少します。      ## .NET framework version 2.0 では、バージョン情報の開始、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>。 以前のバージョンでは、プリンシパルの情報は反映されません。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "デリゲートに渡されるオブジェクト。"
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "ミリ秒単位のタイムアウト。 場合、`millisecondsTimeOutInterval`パラメーターが 0 (ゼロ)、関数、オブジェクトの状態をテストを直ちに返されます。 場合`millisecondsTimeOutInterval`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>ネイティブ ハンドルをカプセル化します。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>パラメーターが-1 未満です。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、 <xref:System.Threading.WaitHandle>、ミリ秒単位のタイムアウトの 64 ビット符号付き整数を指定します</xref:System.Threading.WaitHandle>。"
  remarks: "終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       RegisterWaitForSingleObject メソッドは、スレッド プールに指定されたデリゲートをキューします。 ワーカー スレッドは、次のいずれかが発生したときにデリゲートを実行します。-指定のオブジェクトがシグナル状態で。      -タイムアウト間隔が経過しました。       RegisterWaitForSingleObject メソッドは、指定されたオブジェクトの<xref:System.Threading.WaitHandle>。</xref:System.Threading.WaitHandle>の現在の状態をチェックします。 オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。      > [!IMPORTANT] > を使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。 代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore>1 の最大数を持つ</xref:System.Threading.Semaphore></xref:System.Threading.Mutex>。       待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。 したがって、RegisterWaitForSingleObject への複数の呼び出しでは、同じネイティブ オペレーティング システム ハンドルを使用する必要がある場合、は、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。 RegisterWaitForSingleObject に渡されたイベント オブジェクト待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためにパルスいない必要があることに注意してください。       、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。 たとえば、セマフォのカウントは&1; ずつ減少します。      ## .NET framework version 2.0 では、バージョン情報の開始、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>。 以前のバージョンでは、プリンシパルの情報は反映されません。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "オブジェクトは、デリゲートに渡されます。"
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "ミリ秒単位のタイムアウト。 場合、`millisecondsTimeOutInterval`パラメーターが 0 (ゼロ)、関数、オブジェクトの状態をテストを直ちに返されます。 場合`millisecondsTimeOutInterval`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>ネイティブ ハンドルをカプセル化します。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>パラメーターが-1 未満です。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、<xref:System.Threading.WaitHandle>を指定して、<xref:System.TimeSpan>のタイムアウト値</xref:System.TimeSpan></xref:System.Threading.WaitHandle>。"
  remarks: "終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       RegisterWaitForSingleObject メソッドは、スレッド プールに指定されたデリゲートをキューします。 ワーカー スレッドは、次のいずれかが発生したときにデリゲートを実行します。-指定のオブジェクトがシグナル状態で。      -タイムアウト間隔が経過しました。       RegisterWaitForSingleObject メソッドは、指定されたオブジェクトの<xref:System.Threading.WaitHandle>。</xref:System.Threading.WaitHandle>の現在の状態をチェックします。 オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。      > [!IMPORTANT] > を使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。 代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore>1 の最大数を持つ</xref:System.Threading.Semaphore></xref:System.Threading.Mutex>。       待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。 したがって、RegisterWaitForSingleObject への複数の呼び出しでは、同じネイティブ オペレーティング システム ハンドルを使用する必要がある場合、は、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。 RegisterWaitForSingleObject に渡されたイベント オブジェクト待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためにパルスいない必要があることに注意してください。       、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。 たとえば、セマフォのカウントは&1; ずつ減少します。      ## .NET framework version 2.0 では、バージョン情報の開始、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>。 以前のバージョンでは、プリンシパルの情報は反映されません。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "オブジェクトは、デリゲートに渡されます。"
    - id: timeout
      type: System.TimeSpan
      description: "<xref:System.TimeSpan>。</xref:System.TimeSpan>で表されるタイムアウト 場合`timeout`0 (ゼロ) には、関数、オブジェクトの状態をテストを直ちに返されます。 場合`timeout`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>ネイティブ ハンドルをカプセル化します。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>パラメーターが-1 未満です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code>パラメーターがより大きい&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;です。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、 <xref:System.Threading.WaitHandle>、(ミリ秒単位) をタイムアウトとして 32 ビット符号なし整数を指定します</xref:System.Threading.WaitHandle>。"
  remarks: "終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>キューにスレッド プールに指定されたデリゲート メソッド</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>。 ワーカー スレッドは、次のいずれかが発生したときにデリゲートを実行します。-指定のオブジェクトがシグナル状態で。      -タイムアウト間隔が経過しました。       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドは、指定されたオブジェクトの<xref:System.Threading.WaitHandle>。</xref:System.Threading.WaitHandle>の現在の状態をチェックします。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。 待機操作は、スレッド プールのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。 場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。      > [!IMPORTANT] > を使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。 代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore>1 の最大数を持つ</xref:System.Threading.Semaphore></xref:System.Threading.Mutex>。       待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。       待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。 したがってで同じオペレーティング システムのネイティブ ハンドルを使用する場合は複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>。 渡されたイベント オブジェクトをパルスする必要がありますいないことに注意してください<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます前に、検出されないため、。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 。       、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。 変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。 たとえば、セマフォのカウントは&1; ずつ減少します。      ## .NET framework version 2.0 では、バージョン情報の開始、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>。 以前のバージョンでは、プリンシパルの情報は反映されません。"
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "オブジェクトは、デリゲートに渡されます。"
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "ミリ秒単位のタイムアウト。 場合、`millisecondsTimeOutInterval`パラメーターが 0 (ゼロ)、関数、オブジェクトの状態をテストを直ちに返されます。 場合`millisecondsTimeOutInterval`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>登録された待機操作をキャンセルするを使用できます。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>パラメーターが-1 未満です。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "同時にアクティブにできるスレッド プールに要求の数を設定します。 この数を超えるすべての要求は、スレッド プールのスレッドが使用可能になるまでキューに置かれます。"
  remarks: "ことはできませんワーカー スレッドまたは I/O 完了スレッドの最大数未満に設定、数、コンピューター上のプロセッサの数。 プロセッサの数が存在するには、値の取得、<xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>プロパティ</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>。 さらに、ワーカー スレッドまたは I/O 完了スレッド、対応する最小ワーカー スレッド数より小さい数にまたは I/O 完了スレッドの最大数を設定することはできません。 最小スレッド プールのサイズを調べるを呼び出して、<xref:System.Threading.ThreadPool.GetMinThreads%2A>メソッド</xref:System.Threading.ThreadPool.GetMinThreads%2A>。       共通言語ランタイムがホストされている場合など、インターネット インフォメーション サービス (IIS) または SQL Server によって、ホストを制限したり、スレッド プールのサイズを変更できないようにできます。       スレッド プール内のスレッドの最大数を変更する場合は、注意を使用します。 コードがメリットがあるときに、変更はコード ライブラリを使用するに悪影響を与える可能性があります。       スレッド プールのサイズが大きすぎる設定と、パフォーマンス問題が発生することができます。 スレッドが多すぎるを同時に実行する場合のタスクの切り替えは重要な要因をオーバーヘッドになります。"
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "スレッド プール内のワーカー スレッドの最大数。"
    - id: completionPortThreads
      type: System.Int32
      description: "スレッド プール内の非同期 I/O スレッドの最大数。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>変更が成功した場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "スレッドの作成と破棄を管理するためのアルゴリズムに切り替える前に、新しい要求が行われる、スレッド プールがオンデマンドで作成するスレッドの最小数を設定します。"
  remarks: "スレッド プールを提供新しいワーカー スレッドまたは I/O 完了スレッド要求時に各カテゴリの最小値に達するまでします。 最低限に達すると、スレッド プールはそのカテゴリに追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。 以降で、 [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]、スレッド プールを作成し、タスクの単位時間あたりの完了数として定義されるスループットを最適化するためにスレッドを破棄します。 スレッドが少なすぎる可能性がありますいない、最適な使用使用可能なリソースは、スレッドが多すぎるはリソースの競合を増やすでしたがします。       要求が不足しているときに、実際のスレッド プール スレッドの数は最小の値を下回ることができます。       負の数またはアクティブなスレッド プールのスレッドの最大数より大きい数値を指定する場合 (を使用して取得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)、SetMinThreads 返します`false`が最小値のいずれかが変更されていないとします</xref:System.Threading.ThreadPool.GetMaxThreads%2A>。      > [!CAUTION] > 既定では、スレッドの最小数は、システム上のプロセッサの数を設定します。 SetMinThreads メソッドを使用すると、最小の数値 ofthreads を大ききます。 ただし、不必要にこれらの値を増やすとパフォーマンスの問題が発生することができます。 タスクが多すぎますが、同時に開始する場合、は、低速であるし、すべての可能性があります。 ほとんどの場合、スレッド プールが優れてスレッドを割り当てるための独自のアルゴリズムでします。 プロセッサの数もパフォーマンスを低下させる可能性がより小さくする最低限の削減。"
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "スレッド プールがオンデマンドで作成されるワーカー スレッドの最小数。"
    - id: completionPortThreads
      type: System.Int32
      description: "スレッド プールがオンデマンドで作成するための非同期 I/O スレッドの最小数。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>変更が成功した場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "重複した I/O 操作の実行キューに入れます。"
  remarks: "ネイティブ Win32 を使用して情報には、I/O がオーバー ラップされたを参照してください、<xref:System.Threading.Overlapped>クラス、<xref:System.Threading.NativeOverlapped>構造体、および`OVERLAPPED`Win32 プラットフォーム SDK の構造</xref:System.Threading.NativeOverlapped></xref:System.Threading.Overlapped>。      > [!CAUTION] > を使用して、UnsafeQueueNativeOverlapped メソッドが誤って開きますセキュリティ ホールをします。 コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。 作業が UnsafeQueueNativeOverlapped を使用して、スレッド プール スレッドのキューにある場合、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。"
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "<xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref>キューに構造体。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>操作が正常に I/O 完了ポート; にキューに置かれた場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "指定したデリゲートをスレッド プール キューに配置が、コール スタックをワーカー スレッドに反映しません。"
  remarks: "異なり、 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>UnsafeQueueUserWorkItem、メソッドはコール スタックをワーカー スレッドを反映しません</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。      > [!CAUTION] > UnsafeQueueUserWorkItem の使用は、セキュリティ ホールを誤って開けません。 コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。 作業が UnsafeQueueUserWorkItem を使用して、スレッド プール スレッドのキューにある場合、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。"
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref>スレッド プール内のスレッドが作業項目をピックアップするときに呼び出されるデリゲートを表すです。"
    - id: state
      type: System.Object
      description: "スレッド プールから処理されるときに、デリゲートに渡されるオブジェクト。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>メソッドが成功した場合<xref:System.OutOfMemoryException>が、作業項目をキューにない場合にスローされます</xref:System.OutOfMemoryException>。"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "メモリ不足の状態が発生しました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "作業項目をキューにありませんでした。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、 <xref:System.Threading.WaitHandle>、ミリ秒単位のタイムアウトの 32 ビット符号付き整数を使用します</xref:System.Threading.WaitHandle>。 このメソッドはコール スタックをワーカー スレッドを反映していません。"
  remarks: "異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject、メソッドはコール スタックをワーカー スレッドを反映しません</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>。 これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。      > [!CAUTION] > UnsafeRegisterWaitForSingleObject の使用は、セキュリティ ホールを誤って開けません。 コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。 作業が UnsafeRegisterWaitForSingleObject を使用して、スレッド プール スレッドのキューにある場合、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。       使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。       終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "デリゲートに渡されるオブジェクト。"
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "ミリ秒単位のタイムアウト。 場合、`millisecondsTimeOutInterval`パラメーターが 0 (ゼロ)、関数、オブジェクトの状態をテストを直ちに返されます。 場合`millisecondsTimeOutInterval`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>登録された待機操作をキャンセルするために使用できるオブジェクト。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>パラメーターが-1 未満です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、 <xref:System.Threading.WaitHandle>、ミリ秒単位のタイムアウトの 64 ビット符号付き整数を指定します</xref:System.Threading.WaitHandle>。 このメソッドはコール スタックをワーカー スレッドを反映していません。"
  remarks: "異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject、メソッドはコール スタックをワーカー スレッドを反映しません</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>。 これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。      > [!CAUTION] > UnsafeRegisterWaitForSingleObject の使用は、セキュリティ ホールを誤って開けません。 コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。 作業が UnsafeRegisterWaitForSingleObject を使用して、スレッド プール スレッドのキューにある場合、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。       使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。       終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "デリゲートに渡されるオブジェクト。"
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "ミリ秒単位のタイムアウト。 場合、`millisecondsTimeOutInterval`パラメーターが 0 (ゼロ)、関数、オブジェクトの状態をテストを直ちに返されます。 場合`millisecondsTimeOutInterval`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>登録された待機操作をキャンセルするために使用できるオブジェクト。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>パラメーターが-1 未満です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、<xref:System.Threading.WaitHandle>を指定して、<xref:System.TimeSpan>のタイムアウト値</xref:System.TimeSpan></xref:System.Threading.WaitHandle>。 このメソッドはコール スタックをワーカー スレッドを反映していません。"
  remarks: "異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject、メソッドはコール スタックをワーカー スレッドを反映しません</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>。 これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。      > [!CAUTION] > UnsafeRegisterWaitForSingleObject の使用は、セキュリティ ホールを誤って開けません。 コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。 作業が UnsafeRegisterWaitForSingleObject を使用して、スレッド プール スレッドのキューにある場合、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。       使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。       終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "デリゲートに渡されるオブジェクト。"
    - id: timeout
      type: System.TimeSpan
      description: "<xref:System.TimeSpan>。</xref:System.TimeSpan>で表されるタイムアウト 場合`timeout`0 (ゼロ) には、関数、オブジェクトの状態をテストを直ちに返されます。 場合`timeout`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>登録された待機操作をキャンセルするために使用できるオブジェクト。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>パラメーターが-1 未満です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code>パラメーターがより大きい&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "待機するデリゲートを登録、 <xref:System.Threading.WaitHandle>、(ミリ秒単位) をタイムアウトとして 32 ビット符号なし整数を指定します</xref:System.Threading.WaitHandle>。 このメソッドはコール スタックをワーカー スレッドを反映していません。"
  remarks: "異なり、 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject、メソッドはコール スタックをワーカー スレッドを反映しません</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>。 これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。      > [!CAUTION] > UnsafeRegisterWaitForSingleObject の使用は、セキュリティ ホールを誤って開けません。 コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。 作業が UnsafeRegisterWaitForSingleObject を使用して、スレッド プール スレッドのキューにある場合、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。 悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。       使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします</xref:System.Threading.Mutex>。       終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>待機ハンドルへの参照を解放するメソッド</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName></xref:System.Threading.RegisteredWaitHandle>。 常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドを指定する場合でも`true`の`executeOnlyOnce`</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。 ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>を登録します</xref:System.Threading.WaitHandle>。 <xref:System.Threading.WaitHandle> <xref:System.Threading.Mutex>。</xref:System.Threading.Mutex>以外</xref:System.Threading.WaitHandle>を使用します。"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "ときに呼び出すデリゲート、`waitObject`パラメーターがシグナル状態にします。"
    - id: state
      type: System.Object
      description: "デリゲートに渡されるオブジェクト。"
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "ミリ秒単位のタイムアウト。 場合、`millisecondsTimeOutInterval`パラメーターが 0 (ゼロ)、関数、オブジェクトの状態をテストを直ちに返されます。 場合`millisecondsTimeOutInterval`-1 で、関数のタイムアウトしません。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スレッドが待機不要になったことを示すために、`waitObject`デリゲートが呼び出された後のパラメーター<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>を待機の登録が解除されるまでの待機操作が完了するたびに、タイマーがリセットされるかを示します。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>登録された待機操作をキャンセルするために使用できるオブジェクト。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
