### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkElement
  id: FrameworkElement
  children:
  - System.Windows.FrameworkElement.#ctor
  - System.Windows.FrameworkElement.ActualHeight
  - System.Windows.FrameworkElement.ActualHeightProperty
  - System.Windows.FrameworkElement.ActualWidth
  - System.Windows.FrameworkElement.ActualWidthProperty
  - System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkElement.ApplyTemplate
  - System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.BeginInit
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkElement.BindingGroup
  - System.Windows.FrameworkElement.BindingGroupProperty
  - System.Windows.FrameworkElement.BringIntoView
  - System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  - System.Windows.FrameworkElement.ContextMenu
  - System.Windows.FrameworkElement.ContextMenuClosing
  - System.Windows.FrameworkElement.ContextMenuClosingEvent
  - System.Windows.FrameworkElement.ContextMenuOpening
  - System.Windows.FrameworkElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkElement.ContextMenuProperty
  - System.Windows.FrameworkElement.Cursor
  - System.Windows.FrameworkElement.CursorProperty
  - System.Windows.FrameworkElement.DataContext
  - System.Windows.FrameworkElement.DataContextChanged
  - System.Windows.FrameworkElement.DataContextProperty
  - System.Windows.FrameworkElement.DefaultStyleKey
  - System.Windows.FrameworkElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkElement.EndInit
  - System.Windows.FrameworkElement.FindName(System.String)
  - System.Windows.FrameworkElement.FindResource(System.Object)
  - System.Windows.FrameworkElement.FlowDirection
  - System.Windows.FrameworkElement.FlowDirectionProperty
  - System.Windows.FrameworkElement.FocusVisualStyle
  - System.Windows.FrameworkElement.FocusVisualStyleProperty
  - System.Windows.FrameworkElement.ForceCursor
  - System.Windows.FrameworkElement.ForceCursorProperty
  - System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.FrameworkElement.GetTemplateChild(System.String)
  - System.Windows.FrameworkElement.GetUIParentCore
  - System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  - System.Windows.FrameworkElement.Height
  - System.Windows.FrameworkElement.HeightProperty
  - System.Windows.FrameworkElement.HorizontalAlignment
  - System.Windows.FrameworkElement.HorizontalAlignmentProperty
  - System.Windows.FrameworkElement.InheritanceBehavior
  - System.Windows.FrameworkElement.Initialized
  - System.Windows.FrameworkElement.InputScope
  - System.Windows.FrameworkElement.InputScopeProperty
  - System.Windows.FrameworkElement.IsInitialized
  - System.Windows.FrameworkElement.IsLoaded
  - System.Windows.FrameworkElement.Language
  - System.Windows.FrameworkElement.LanguageProperty
  - System.Windows.FrameworkElement.LayoutTransform
  - System.Windows.FrameworkElement.LayoutTransformProperty
  - System.Windows.FrameworkElement.Loaded
  - System.Windows.FrameworkElement.LoadedEvent
  - System.Windows.FrameworkElement.LogicalChildren
  - System.Windows.FrameworkElement.Margin
  - System.Windows.FrameworkElement.MarginProperty
  - System.Windows.FrameworkElement.MaxHeight
  - System.Windows.FrameworkElement.MaxHeightProperty
  - System.Windows.FrameworkElement.MaxWidth
  - System.Windows.FrameworkElement.MaxWidthProperty
  - System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  - System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.MinHeight
  - System.Windows.FrameworkElement.MinHeightProperty
  - System.Windows.FrameworkElement.MinWidth
  - System.Windows.FrameworkElement.MinWidthProperty
  - System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkElement.Name
  - System.Windows.FrameworkElement.NameProperty
  - System.Windows.FrameworkElement.OnApplyTemplate
  - System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.OverridesDefaultStyle
  - System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkElement.Parent
  - System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  - System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkElement.RequestBringIntoView
  - System.Windows.FrameworkElement.RequestBringIntoViewEvent
  - System.Windows.FrameworkElement.Resources
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  - System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkElement.ShouldSerializeResources
  - System.Windows.FrameworkElement.ShouldSerializeStyle
  - System.Windows.FrameworkElement.ShouldSerializeTriggers
  - System.Windows.FrameworkElement.SizeChanged
  - System.Windows.FrameworkElement.SizeChangedEvent
  - System.Windows.FrameworkElement.SourceUpdated
  - System.Windows.FrameworkElement.Style
  - System.Windows.FrameworkElement.StyleProperty
  - System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkElement.Tag
  - System.Windows.FrameworkElement.TagProperty
  - System.Windows.FrameworkElement.TargetUpdated
  - System.Windows.FrameworkElement.TemplatedParent
  - System.Windows.FrameworkElement.ToolTip
  - System.Windows.FrameworkElement.ToolTipClosing
  - System.Windows.FrameworkElement.ToolTipClosingEvent
  - System.Windows.FrameworkElement.ToolTipOpening
  - System.Windows.FrameworkElement.ToolTipOpeningEvent
  - System.Windows.FrameworkElement.ToolTipProperty
  - System.Windows.FrameworkElement.Triggers
  - System.Windows.FrameworkElement.TryFindResource(System.Object)
  - System.Windows.FrameworkElement.Unloaded
  - System.Windows.FrameworkElement.UnloadedEvent
  - System.Windows.FrameworkElement.UnregisterName(System.String)
  - System.Windows.FrameworkElement.UpdateDefaultStyle
  - System.Windows.FrameworkElement.UseLayoutRounding
  - System.Windows.FrameworkElement.UseLayoutRoundingProperty
  - System.Windows.FrameworkElement.VerticalAlignment
  - System.Windows.FrameworkElement.VerticalAlignmentProperty
  - System.Windows.FrameworkElement.VisualChildrenCount
  - System.Windows.FrameworkElement.Width
  - System.Windows.FrameworkElement.WidthProperty
  langs:
  - csharp
  name: FrameworkElement
  nameWithType: FrameworkElement
  fullName: System.Windows.FrameworkElement
  type: Class
  summary: "プロパティ、イベント、およびメソッドの WPF フレームワーク レベルのセットを提供[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]要素。 このクラスは、WPF コア レベルに基づいて構築された指定の WPF フレームワーク レベルの実装を表す[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]で定義されている<xref href=&quot;System.Windows.UIElement&quot;></xref>です。"
  remarks: "FrameworkElement が WPF フレームワーク レベルの要素のクラスと、WPF コア レベルのセット間の接続ポイント<xref:System.Windows.UIElement>プレゼンテーション サービス</xref:System.Windows.UIElement>。 これらの概念の詳細については、次を参照してください。 [WPF アーキテクチャ](~/add/includes/ajax-current-ext-md.md)です。       FrameworkElement 拡張<xref:System.Windows.UIElement>し、次の機能を追加します:-**レイアウト システム定義**: FrameworkElement 特定の WPF フレームワーク レベルの実装特定のメソッドを提供<xref:System.Windows.UIElement></xref:System.Windows.UIElement>仮想メンバーとして定義されている</xref:System.Windows.UIElement>。 特に、FrameworkElement では、特定の WPF コア レベル レイアウト上書きが封印し、代わりに派生クラスの WPF フレームワーク レベルの同等を代わりにオーバーライドする必要がありますを提供します。 FrameworkElement が封印<xref:System.Windows.UIElement.ArrangeCore%2A><xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。</xref:System.Windows.FrameworkElement.ArrangeOverride%2A>が、</xref:System.Windows.UIElement.ArrangeCore%2A>たとえば、 これらの変更は、派生クラスの WPF フレームワーク レベルでは完全レイアウト システム、FrameworkElement を表示できる場所にファクトを反映します。 WPF で構造体、一般的なは、特定のレベルのメンバーをコア[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]ベース レイアウト ソリューションの場所は、レイアウト システムの実際のエンジンが定義されていません。 詳細については、次を参照してください。[レイアウト](~/add/includes/ajax-current-ext-md.md)です。      -**論理ツリー:**全般的な[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]プログラミング モデルがされている要素のツリーとして表現されて多くの場合。 論理ツリーとして要素のツリーを表現するをサポートし、FrameworkElement レベルで実装がマークアップでそのツリーを定義するためのサポートに付属しています。 FrameworkElement が意図的に、コンテンツ モデルを一切定義しませんし、派生クラスには、その責任のままにする ただし注意してください。 詳細については、次を参照してください。 [wpf ツリー](~/add/includes/ajax-current-ext-md.md)です。      -**オブジェクトの有効期間イベント:**要素が初期化される場合を把握すると便利です (コンス トラクターが呼び出されます) または論理ツリーに要素が最初に読み込まれるときにします。 FrameworkElement では、分離コードが関係する操作子要素の追加などの要素の役立ちますフックを提供するオブジェクトの有効期間に関連するいくつかのイベントを定義します。 詳細については、次を参照してください。[オブジェクトの有効期間イベント](~/add/includes/ajax-current-ext-md.md)です。      -**データ バインディング、および動的リソース参照のサポート:**によってデータのバインドとリソースのプロパティ レベルのサポートは実装されて、<xref:System.Windows.DependencyProperty>クラスし、プロパティ システムはできるが、として格納されているメンバー値を解決するのには組み込まれた、 <xref:System.Windows.Expression>(データのバインドと動的なリソースの両方の基礎となるプログラミング構造) は、FrameworkElement によって実装されます</xref:System.Windows.Expression></xref:System.Windows.DependencyProperty>。 詳細については、次を参照してください。[データ バインディングの概要](~/add/includes/ajax-current-ext-md.md)と[XAML リソース](~/add/includes/ajax-current-ext-md.md)です。      -**スタイル:** FrameworkElement 定義、<xref:System.Windows.FrameworkElement.Style%2A>プロパティ</xref:System.Windows.FrameworkElement.Style%2A>。 ただし、FrameworkElement が、テンプレートのサポートを定義されていない、またはデコレーターをサポートしません。 これらの機能は<xref:System.Windows.Controls.Control>、 <xref:System.Windows.Controls.ContentControl>。</xref:System.Windows.Controls.ContentControl></xref:System.Windows.Controls.Control>などのコントロール クラス      -**アニメーション サポート:**一部アニメーション サポートは、WPF コア レベルで既に定義されてが FrameworkElement では、これを拡張を実装して<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>関連メンバーとします</xref:System.Windows.FrameworkElement.BeginStoryboard%2A>。       クラスの階層からわかるように多く[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]クラスは、直接または<xref:System.Windows.Controls.Panel>または<xref:System.Windows.Controls.Control>.</xref:System.Windows.Controls.Control></xref:System.Windows.Controls.Panel>などの中間の基本クラスのいずれかに、FrameworkElement から派生       FrameworkElement を基底クラスとして使用する場合は、まず既存の派生クラスを検査することができます。 FrameworkElement の基本的なシナリオの数は、サポートします、もいくつかの作成に使用する構成要素の意味で&quot;element&quot;ために必要な機能がない[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]で[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]です。 たとえば、FrameworkElement が、真のコンテンツ モデルを定義しません基底クラスとして FrameworkElement が作成できるプロパティを定義していない[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]子要素です。 具体的には、することができます<xref:System.Windows.Controls.Control>と<xref:System.Windows.Controls.ContentControl>。</xref:System.Windows.Controls.ContentControl></xref:System.Windows.Controls.Control>見る"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  - System.Windows.UIElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnCreateAutomationPeer
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  platform:
  - net462
- uid: System.Windows.FrameworkElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>クラスです。"
  syntax:
    content: public FrameworkElement ();
    parameters: []
  overload: System.Windows.FrameworkElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeight
  id: ActualHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の描画時の高さを取得します。"
  remarks: "このプロパティは、その他の高さの入力と、レイアウト システムに基づいて計算される値です。 値、実際のレンダリング パスに基づいて、レイアウト システム自体によって設定されているためとなる若干プロパティの設定された値の背後にあるなど<xref:System.Windows.FrameworkElement.Height%2A>入力の変更の基礎にある</xref:System.Windows.FrameworkElement.Height%2A>。       ActualHeight が計算された値であるためには、複数存在する可能性がありますまたは増分変更をさまざまな操作の結果としてシステムにより報告された、レイアウトのことに注意してください。 レイアウト システムには、子要素の親要素の制約用の領域の必要なメジャーが計算可能性があります。       このプロパティを設定することはできませんが[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、基にすることができます、<xref:System.Windows.Trigger>スタイルでは、その値にします</xref:System.Windows.Trigger>。      <a name=&quot;dependencyPropertyInfo_ActualHeight&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.ActualHeightProperty>"
  example:
  - "The following example displays various height properties.  \n  \n [!code-cs[HeightMinHeightMaxHeight#3](~/add/codesnippet/csharp/Height_MinHeight_MaxHeight_CSharp/Window1.xaml.cs#3)]\n [!code-vb[HeightMinHeightMaxHeight#3](~/add/codesnippet/visualbasic/Height_MinHeight_MaxHeight/Window1.xaml.vb#3)]"
  syntax:
    content: public double ActualHeight { get; }
    return:
      type: System.Double
      description: "値としての要素の高さ[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]です。 既定値は 0 (ゼロです)。"
  overload: System.Windows.FrameworkElement.ActualHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  id: ActualHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.ActualHeight*>依存関係プロパティ</xref:System.Windows.FrameworkElement.ActualHeight*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidth
  id: ActualWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の表示幅を取得します。"
  remarks: "このプロパティは、その他の幅の入力と、レイアウト システムに基づいて計算される値です。 値、実際のレンダリング パスに基づいて、レイアウト システム自体によって設定されているためとなる若干プロパティの設定された値の背後にあるなど<xref:System.Windows.FrameworkElement.Width%2A>入力の変更の基礎にある</xref:System.Windows.FrameworkElement.Width%2A>。       ActualWidth が計算された値であるためには、複数存在する可能性がありますまたは増分変更をさまざまな操作の結果としてシステムにより報告された、レイアウトのことに注意してください。 レイアウト システムには、子要素の親要素の制約用の領域の必要なメジャーが計算可能性があります。       このプロパティを設定することはできませんが[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、基にすることができます、<xref:System.Windows.Trigger>スタイルでは、その値にします</xref:System.Windows.Trigger>。      <a name=&quot;dependencyPropertyInfo_ActualWidth&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.ActualWidthProperty>"
  example:
  - "The following example displays various width properties.  \n  \n [!code-vb[WidthMinWidthMaxWidth#3](~/add/codesnippet/visualbasic/Width_MinWidth_MaxWidth/Window1.xaml.vb#3)]\n [!code-cs[WidthMinWidthMaxWidth#3](~/add/codesnippet/csharp/Width_MinWidth_MaxWidth_CSharp/Window1.xaml.cs#3)]"
  syntax:
    content: public double ActualWidth { get; }
    return:
      type: System.Double
      description: "値としての要素の幅[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]です。 既定値は 0 (ゼロです)。"
  overload: System.Windows.FrameworkElement.ActualWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  id: ActualWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.ActualWidth*>依存関係プロパティ</xref:System.Windows.FrameworkElement.ActualWidth*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の論理ツリーには、指定されたオブジェクトを追加します。"
  remarks: "要素の論理上の子要素を表すオブジェクトのコレクションの実装には、このメソッドを使用します。 プロパティの getter または setter、クラス処理を Changed イベント、コンス トラクター、またはコレクション型自体内では、子要素のコレクションのコレクションのメンテナンスを行う可能性があります。       使用可能な基本コントロール クラスのコンテンツ モデルの適切なものが、制御のシナリオの場合を除きは、コントロールの作成者がこのレベルで論理ツリーを操作するはお勧めできません。 レベルのサブクラス化を検討してください<xref:System.Windows.Controls.ContentControl>、 <xref:System.Windows.Controls.ItemsControl>、 <xref:System.Windows.Controls.HeaderedItemsControl></xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 。 これらのクラスを介して専用の論理ツリーの子要素の特定の強制使用したモデルのコンテンツを提供する[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]、その他の機能では通常望ましくのサポートに加えて、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]テンプレートを介してスタイルなどのコントロールです。 使用する方法の詳細についての<xref:System.Windows.FrameworkElement.LogicalChildren%2A>と AddLogicalChild を参照してください[wpf ツリー](~/add/includes/ajax-current-ext-md.md)</xref:System.Windows.FrameworkElement.LogicalChildren%2A> 。       別のプロセスによって、論理ツリーが反復処理されているときに呼び出された場合、AddLogicalChild は例外をスロー可能性があります。"
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The property value is cached, and then the new value is added to both the logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "追加する子要素です。"
  overload: System.Windows.FrameworkElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ApplyTemplate
  id: ApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "必要に応じての現在のテンプレートのビジュアル ツリーを構築し、この呼び出しによってビジュアル ツリーが再構築されたかどうかを示す値を返します。"
  remarks: "アプリケーションでは、要素のビジュアル ツリーが完了したことを保証するには、このメソッドを呼び出すことができます。 この保証のステップのコードは、ツリー内の子要素をチェックする場合は、必要があります。 アプリケーション内でのロジックを一般的な要素、ApplyTemplate を呼び出す必要はありません、テンプレートは適用されるため、適切な位置にある要素を有効期間内に自動的にします。       ApplyTemplate がすべてのメジャーと呼ばれる WPF フレームワーク レベルのレイアウト システムによって渡します。       <xref:System.Windows.FrameworkElement>派生クラスで使用できる、<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>通知を受ける場合はこのメソッドが明示的に呼び出された場合のまたはレイアウト システム クラス ハンドラー</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> 。</xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>テンプレートが完全に生成され、論理ツリーにアタッチされている後に呼び出されます。</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>"
  syntax:
    content: public bool ApplyTemplate ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ビジュアルがツリーに追加された場合返します<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>それ以外の場合。"
  overload: System.Windows.FrameworkElement.ApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  id: ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "実装<xref:System.Windows.UIElement.ArrangeCore*>(で仮想として定義されている<xref href=&quot;System.Windows.UIElement&quot;> </xref>) 実装をシールと</xref:System.Windows.UIElement.ArrangeCore*>。"
  remarks: "このメソッドはシールされています。 <xref:System.Windows.FrameworkElement>派生クラスが<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。</xref:System.Windows.FrameworkElement.ArrangeOverride%2A>をオーバーライドする必要があります</xref:System.Windows.FrameworkElement>、要素のレイアウトの配置パスを具体的には、カスタム要素内のロジックをオーバーライドするのには"
  syntax:
    content: protected override sealed void ArrangeCore (System.Windows.Rect finalRect);
    parameters:
    - id: finalRect
      type: System.Windows.Rect
      description: "この要素が要素自体とその子を配置に使用する親の末尾の領域。"
  overload: System.Windows.FrameworkElement.ArrangeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  id: ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、子要素を配置しのサイズを決定する<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>クラスを派生します。"
  syntax:
    content: protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);
    parameters:
    - id: finalSize
      type: System.Windows.Size
      description: "この要素が要素自体とその子を配置に使用する親の末尾の領域。"
    return:
      type: System.Windows.Size
      description: "使用される実際のサイズ。"
  overload: System.Windows.FrameworkElement.ArrangeOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の初期化プロセスを開始します。"
  remarks: "まだ公開または要素ツリーに要素を接続するための方法で調整する場合は、個々 の要素でこのメソッドを呼び出すことができます。 たとえば、独自に作成した新しい<xref:System.Windows.FrameworkElement>、まだ接続していないことを任意の論理ツリーですが</xref:System.Windows.FrameworkElement>。 または、内の子要素を要素がここでは、論理ツリーは、ウィンドウやアプリケーションのページに接続されていない可能性があります。"
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定したストーリー ボードに含まれているアクションのシーケンスを開始します。"
  remarks: "アニメーションの最も一般的なシナリオでは、このメソッドは使用しないでください。 通常、作成、<xref:System.Windows.Media.Animation.Storyboard>または<xref:System.Windows.Media.Animation.BeginStoryboard>マークアップにある要素を配置として、<xref:System.Windows.EventTrigger>要素のコンテンツ</xref:System.Windows.EventTrigger></xref:System.Windows.Media.Animation.BeginStoryboard></xref:System.Windows.Media.Animation.Storyboard>。 イベントによってトリガーされると、アニメーションが実行されます。 ほとんどのコントロール要素の<xref:System.Windows.Media.Animation.Storyboard>マークアップで公開されているプロパティでアドレス指定できます</xref:System.Windows.Media.Animation.Storyboard>。       署名を使用しない、 `isControllable`、パラメーター、そのパラメーターが指定されている場合または`false`、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。 そのため、アニメーションは、1 回の実行後に再開できません。 アニメーションを制御するもある必要があります、ストーリー ボード、 [X:name ディレクティブ](~/add/includes/ajax-current-ext-md.md)コード内で参照でアクセスできるか。"
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "開始するストーリー ボードです。"
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "プロパティが既にアニメーション化されている場合の動作を指定するオプションで指定したストーリー ボードに含まれているアクションのシーケンスを開始します。"
  remarks: "アニメーションの最も一般的なシナリオでは、このメソッドは使用しないでください。 通常、作成、<xref:System.Windows.Media.Animation.Storyboard>または<xref:System.Windows.Media.Animation.BeginStoryboard>マークアップにある要素を配置として、<xref:System.Windows.EventTrigger>要素のコンテンツ</xref:System.Windows.EventTrigger></xref:System.Windows.Media.Animation.BeginStoryboard></xref:System.Windows.Media.Animation.Storyboard>。 イベントによってトリガーされると、アニメーションが実行されます。 ほとんどのコントロール要素の<xref:System.Windows.Media.Animation.Storyboard>マークアップで公開されているプロパティでアドレス指定できます</xref:System.Windows.Media.Animation.Storyboard>。       署名を使用しない、 `isControllable`、パラメーター、そのパラメーターが指定されている場合または`false`、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。 そのため、アニメーションは、1 回の実行後に再開できません。 アニメーションを制御するもある必要があります、ストーリー ボード、 [X:name ディレクティブ](~/add/includes/ajax-current-ext-md.md)コード内で参照でアクセスできるか。       <xref:System.Windows.Media.Animation.BeginStoryboard>。</xref:System.Windows.Media.Animation.BeginStoryboard>の属性としてハンドオフ動作を指定することができます。      ## 使用して、作成 HandoffBehavior を適用する、 <xref:System.Windows.Media.Animation.Storyboard>、 <xref:System.Windows.Media.Animation.AnimationTimeline>、または<xref:System.Windows.Media.Animation.AnimationClock>を使用してプロパティを<xref:System.Windows.Media.Animation.HandoffBehavior><xref:System.Windows.Media.Animation.HandoffBehavior>、any<xref:System.Windows.Media.Animation.Clock>以前そのプロパティに関連付けられているオブジェクトがシステム リソースを消費引き続き; タイミング システムは、時計を自動的に削除されません</xref:System.Windows.Media.Animation.Clock></xref:System.Windows.Media.Animation.HandoffBehavior></xref:System.Windows.Media.Animation.HandoffBehavior></xref:System.Windows.Media.Animation.AnimationClock></xref:System.Windows.Media.Animation.AnimationTimeline></xref:System.Windows.Media.Animation.Storyboard>。       使用して多数の時計を適用するときに、パフォーマンスの問題を回避する<xref:System.Windows.Media.Animation.HandoffBehavior>、完了した後、アニメーションのプロパティから作成クロックを削除する必要があります</xref:System.Windows.Media.Animation.HandoffBehavior>。 時計を削除するいくつかの方法があります: - から削除するすべてのクロック プロパティを使用して、<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>または<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>アニメーション オブジェクトのメソッド</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29></xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>。 最初のパラメーターとしてアニメーション化されているプロパティを指定し、 `null`&2; つ目として。 これにより、すべてのアニメーション クロックが、プロパティから削除します。      -特定<xref:System.Windows.Media.Animation.AnimationClock>のクロックの一覧から、使用して<xref:System.Windows.Media.Animation.Clock.Controller%2A><xref:System.Windows.Media.Animation.AnimationClock><xref:System.Windows.Media.Animation.ClockController><xref:System.Windows.Media.Animation.ClockController.Remove%2A><xref:System.Windows.Media.Animation.ClockController>。</xref:System.Windows.Media.Animation.ClockController>のメソッド</xref:System.Windows.Media.Animation.ClockController.Remove%2A>を呼び出して、</xref:System.Windows.Media.Animation.ClockController>取得する</xref:System.Windows.Media.Animation.AnimationClock>プロパティ</xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.AnimationClock>を削除するには これは、通常、<xref:System.Windows.Media.Animation.Clock.Completed>クロックのイベント ハンドラー</xref:System.Windows.Media.Animation.Clock.Completed> 。 唯一のルート クロックできますで制御されることに注意してください、 <xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子クロックのプロパティを返します`null`</xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.ClockController>。 なお、 <xref:System.Windows.Media.Animation.Clock.Completed>、クロックの有効期間が forever の場合、イベントは発生しません</xref:System.Windows.Media.Animation.Clock.Completed>。  その場合は、ユーザー必要がある場合の判別<xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>を呼び出す       これは、主に有効期間が長いオブジェクトにおけるアニメーションの問題です。  オブジェクトがガベージ コレクションである場合は、そのクロックが切断されても、ガベージ コレクションします。       クロック オブジェクトに関する詳細については、次を参照してください。[アニメーションおよびタイミング システムの概要](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "開始するストーリー ボードです。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "ストーリー ボードで記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙体の値です。"
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "アニメーションの開始後のコントロールの状態を指定して、指定されたストーリー ボードに含まれているアクションのシーケンスを開始します。"
  remarks: "アニメーションの最も一般的なシナリオでは、このメソッドは使用しないでください。 通常、作成、<xref:System.Windows.Media.Animation.Storyboard>または<xref:System.Windows.Media.Animation.BeginStoryboard>マークアップにある要素を配置として、<xref:System.Windows.EventTrigger>要素のコンテンツ</xref:System.Windows.EventTrigger></xref:System.Windows.Media.Animation.BeginStoryboard></xref:System.Windows.Media.Animation.Storyboard>。 イベントによってトリガーされると、アニメーションが実行されます。 ほとんどのコントロール要素の<xref:System.Windows.Media.Animation.Storyboard>マークアップで公開されているプロパティでアドレス指定できます</xref:System.Windows.Media.Animation.Storyboard>。       署名を使用しない、 `isControllable`、パラメーター、そのパラメーターが指定されている場合または`false`、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。 そのため、アニメーションは、1 回の実行後に再開できません。 アニメーションを制御するもある必要があります、ストーリー ボード、 [X:name ディレクティブ](~/add/includes/ajax-current-ext-md.md)コード内で参照でアクセスできるか。       <xref:System.Windows.Media.Animation.BeginStoryboard>。</xref:System.Windows.Media.Animation.BeginStoryboard>の属性としてハンドオフ動作を指定することができます。      ## 使用して、作成 HandoffBehavior を適用する、 <xref:System.Windows.Media.Animation.Storyboard>、 <xref:System.Windows.Media.Animation.AnimationTimeline>、または<xref:System.Windows.Media.Animation.AnimationClock>を使用してプロパティを<xref:System.Windows.Media.Animation.HandoffBehavior><xref:System.Windows.Media.Animation.HandoffBehavior>、any<xref:System.Windows.Media.Animation.Clock>以前そのプロパティに関連付けられているオブジェクトがシステム リソースを消費引き続き; タイミング システムは、時計を自動的に削除されません</xref:System.Windows.Media.Animation.Clock></xref:System.Windows.Media.Animation.HandoffBehavior></xref:System.Windows.Media.Animation.HandoffBehavior></xref:System.Windows.Media.Animation.AnimationClock></xref:System.Windows.Media.Animation.AnimationTimeline></xref:System.Windows.Media.Animation.Storyboard>。       使用して多数の時計を適用するときに、パフォーマンスの問題を回避する<xref:System.Windows.Media.Animation.HandoffBehavior>、完了した後、アニメーションのプロパティから作成クロックを削除する必要があります</xref:System.Windows.Media.Animation.HandoffBehavior>。 時計を削除するいくつかの方法があります: - から削除するすべてのクロック プロパティを使用して、<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>または<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>アニメーション オブジェクトのメソッド</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29></xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>。 最初のパラメーターとしてアニメーション化されているプロパティを指定し、 `null`&2; つ目として。 これにより、すべてのアニメーション クロックが、プロパティから削除します。      -特定<xref:System.Windows.Media.Animation.AnimationClock>のクロックの一覧から、使用して<xref:System.Windows.Media.Animation.Clock.Controller%2A><xref:System.Windows.Media.Animation.AnimationClock><xref:System.Windows.Media.Animation.ClockController><xref:System.Windows.Media.Animation.ClockController.Remove%2A><xref:System.Windows.Media.Animation.ClockController>。</xref:System.Windows.Media.Animation.ClockController>のメソッド</xref:System.Windows.Media.Animation.ClockController.Remove%2A>を呼び出して、</xref:System.Windows.Media.Animation.ClockController>取得する</xref:System.Windows.Media.Animation.AnimationClock>プロパティ</xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.AnimationClock>を削除するには これは、通常、<xref:System.Windows.Media.Animation.Clock.Completed>クロックのイベント ハンドラー</xref:System.Windows.Media.Animation.Clock.Completed> 。 唯一のルート クロックできますで制御されることに注意してください、 <xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子クロックのプロパティを返します`null`</xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.ClockController>。 なお、 <xref:System.Windows.Media.Animation.Clock.Completed>、クロックの有効期間が forever の場合、イベントは発生しません</xref:System.Windows.Media.Animation.Clock.Completed>。  その場合は、ユーザー必要がある場合の判別<xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>を呼び出す       これは、主に有効期間が長いオブジェクトにおけるアニメーションの問題です。  オブジェクトがガベージ コレクションである場合は、そのクロックが切断されても、ガベージ コレクションします。       クロック オブジェクトに関する詳細については、次を参照してください。[アニメーションおよびタイミング システムの概要](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "開始するストーリー ボードです。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "ストーリー ボードで記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙体の値です。"
    - id: isControllable
      type: System.Boolean
      description: "アニメーションが制御可能かどうかを宣言 (一時停止できる) の開始後にします。"
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または設定、 <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref>要素に使用されます。"
  remarks: "A<xref:System.Windows.Data.BindingGroup>オブジェクトの複数のプロパティの値を検証するために使用できます</xref:System.Windows.Data.BindingGroup>。 たとえば、アプリケーションがアドレスを入力するように求めるし、その型のオブジェクトが設定されます`Address`、プロパティを持つ`Street`、 `City`、 `ZipCode`、および`Country`ユーザーが指定した値を持つ。 アプリケーションが&4; つを含むパネル<xref:System.Windows.Controls.TextBox>オブジェクトのプロパティのいずれかにバインドされているは、コントロール</xref:System.Windows.Controls.TextBox>。 使用することができます、<xref:System.Windows.Controls.ValidationRule>で、<xref:System.Windows.Data.BindingGroup>を検証する、`Address`オブジェクト</xref:System.Windows.Data.BindingGroup></xref:System.Windows.Controls.ValidationRule>。 たとえば、<xref:System.Windows.Controls.ValidationRule>郵便番号が有効、住所の国であることを確認できます</xref:System.Windows.Controls.ValidationRule>。       子要素を継承、<xref:System.Windows.Data.BindingGroup>だけで、他の継承可能なプロパティと同様に、親要素から</xref:System.Windows.Data.BindingGroup>。      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  |メタデータ プロパティに設定**true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.BindingGroupProperty>"
  example:
  - "The following examples are part of an application that checks whether the user has set the properties of two objects to equal values. The first example creates two <xref:System.Windows.Controls.TextBox> controls, each of which is bound to a different data source. The <xref:System.Windows.Controls.StackPanel> has a <xref:System.Windows.Data.BindingGroup> that contains a <xref:System.Windows.Controls.ValidationRule> that checks that the two strings are equal.  \n  \n [!code-xml[BindingGroupSnippets#BindingGroupComplete](~/add/codesnippet/xaml/BindingGroupSnippets/Window3.xaml#bindinggroupcomplete)]  \n  \n The following example shows the <xref:System.Windows.Controls.ValidationRule> that the previous example uses.  In the <xref:System.Windows.Controls.ValidationRule.Validate%2A> method override, the example gets each source object from the <xref:System.Windows.Data.BindingGroup> and checks whether the properties of the objects are equal.  \n  \n [!code-cs[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#bindinggroupnamevalidationrule)]\n [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#bindinggroupnamevalidationrule)]  \n  \n To invoke the <xref:System.Windows.Controls.ValidationRule>, call the <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> method.  The following example calls <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> when the click event of the button occurs.  \n  \n [!code-cs[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#updatesourcesclick)]\n [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#updatesourcesclick)]"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "<xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref>要素に使用されます。"
  overload: System.Windows.FrameworkElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.BindingGroup*>依存関係プロパティ</xref:System.Windows.FrameworkElement.BindingGroup*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "含まれているスクロール可能な領域内に、この要素を表示しようとしています。"
  remarks: "このメソッドを呼び出すことにより、<xref:System.Windows.FrameworkElement.RequestBringIntoView>の現在の要素から発生するイベントです</xref:System.Windows.FrameworkElement.RequestBringIntoView>。 このイベントで処理できるように、 <xref:System.Windows.Controls.ScrollViewer>、または派生されているかのようなクラス</xref:System.Windows.Controls.ScrollViewer> 想定される動作は、イベントがイベント データの処理済みとしてマーク、親要素によって処理され、イベントのソースに埋め込まれているロジックにより、ビューに組み込まこと、<xref:System.Windows.Controls.ScrollViewer>コントロール</xref:System.Windows.Controls.ScrollViewer>。 どちらも、<xref:System.Windows.FrameworkElement.RequestBringIntoView>イベントも BringIntoView メソッドについて、成功または失敗したもの以外のイベントは、通常の処理の成功とマーク情報を送信します</xref:System.Windows.FrameworkElement.RequestBringIntoView>。 失敗の原因としては、<xref:System.Windows.UIElement.Visibility%2A>ある<xref:System.Windows.Visibility>。</xref:System.Windows.Visibility>以外のいくつかの値</xref:System.Windows.UIElement.Visibility%2A>など、要素の設定を含めることができます。       指定されていない署名を使用する場合、 `targetRectangle`、全体の要素のサイズし (その<xref:System.Windows.UIElement.RenderSize%2A>) が表示される</xref:System.Windows.UIElement.RenderSize%2A>。       このメソッドを呼び出して、可能性のあるを呼び出す<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>要素を含む親スクロール可能な領域を</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>。 この要素がスクロール可能領域に含まれていない場合、<xref:System.Windows.FrameworkElement.RequestBringIntoView>も、イベントが発生しますが、なければ効果イベント リスナーが存在しないためです</xref:System.Windows.FrameworkElement.RequestBringIntoView>。"
  example:
  - "The following example implements a handler for an application navigation event that responds whenever the [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] being navigated to includes a fragment. The fragment is named in the [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)] following the hash sign (#), and the implemented behavior causes the element to scroll into view within the frame. BringIntoView and <xref:System.Windows.FrameworkElement.RequestBringIntoView> request that scrolling behavior in the example.  \n  \n [!code-vb[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/visualbasic/FragmentNavigationSampleVisualBasic/MainWindow.xaml.vb#febringintoview)]\n [!code-cs[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/csharp/FragmentNavigationSample/MainWindow.xaml.cs#febringintoview)]"
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  id: BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "含まれているスクロール可能な領域内に、この要素の指定された領域のサイズを表示しようとしています。"
  remarks: "このメソッドを呼び出すことにより、<xref:System.Windows.FrameworkElement.RequestBringIntoView>の現在の要素から発生するイベントです</xref:System.Windows.FrameworkElement.RequestBringIntoView>。 このイベントで処理できるように、 <xref:System.Windows.Controls.ScrollViewer>、または派生されているかのようなクラス</xref:System.Windows.Controls.ScrollViewer> 想定される動作は、イベントがイベント データの処理済みとしてマーク、親要素によって処理され、イベントのソースに埋め込まれているロジックにより、ビューに組み込まこと、<xref:System.Windows.Controls.ScrollViewer>コントロール</xref:System.Windows.Controls.ScrollViewer>。 どちらも、<xref:System.Windows.FrameworkElement.RequestBringIntoView>イベントも<xref:System.Windows.FrameworkElement.BringIntoView%2A>メソッドについて、成功または失敗したもの以外のイベントは、通常の処理の成功とマーク任意の情報を送信する</xref:System.Windows.FrameworkElement.BringIntoView%2A></xref:System.Windows.FrameworkElement.RequestBringIntoView>。 失敗の原因としては、<xref:System.Windows.UIElement.Visibility%2A>ある<xref:System.Windows.Visibility>。</xref:System.Windows.Visibility>以外のいくつかの値</xref:System.Windows.UIElement.Visibility%2A>など、要素の設定を含めることができます。       指定されていない署名を使用する場合、 `targetRectangle`、全体の要素のサイズし (その<xref:System.Windows.UIElement.RenderSize%2A>) が表示される</xref:System.Windows.UIElement.RenderSize%2A>。       このメソッドを呼び出して、可能性のあるを呼び出す<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>要素を含む親スクロール可能な領域を</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>。 この要素がスクロール可能領域に含まれていない場合、<xref:System.Windows.FrameworkElement.RequestBringIntoView>も、イベントが発生しますが、なければ効果イベント リスナーが存在しないためです</xref:System.Windows.FrameworkElement.RequestBringIntoView>。"
  example:
  - "The following example has a large graphic in a constrained scrolling region. A button on the page has a handler that scrolls the view to a particular region of the large graphic.  \n  \n [!code-xml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/add/codesnippet/xaml/BaseElementsSmorgasbord/Page1.xaml#bringintoviewrectmarkup)]  \n  \n [!code-cs[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#bringintoviewrectcode)]\n [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#bringintoviewrectcode)]"
  syntax:
    content: public void BringIntoView (System.Windows.Rect targetRectangle);
    parameters:
    - id: targetRectangle
      type: System.Windows.Rect
      description: "ビュー内に取り込まれますもする必要がありますを要素のサイズを指定します。"
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または設定を通じて、コンテキスト メニューが要求されたときに表示されるコンテキスト メニュー要素[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]からこの要素内で。"
  remarks: "<xref:System.Windows.Controls.ContextMenu>自体は、<xref:System.Windows.FrameworkElement>クラスを派生しの技術的に可能であれば<xref:System.Windows.Controls.ContextMenu>ContextMenu プロパティを持つ自体</xref:System.Windows.Controls.ContextMenu></xref:System.Windows.FrameworkElement>。</xref:System.Windows.Controls.ContextMenu> ただし、これがユーザーの混乱を招くコンテキスト メニュー エクスペリエンスを作成し、この方法はお勧めできません。      <a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.ContextMenuProperty>"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "この要素に割り当てられているコンテキスト メニュー。"
  overload: System.Windows.FrameworkElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "要素のコンテキスト メニューが閉じられる直前に発生します。"
  remarks: "閉じないようにするには、コンテキスト メニュー、イベントのハンドラーは、処理済みとしてマークします。       としては、このイベントを使用して、<xref:System.Windows.EventTrigger>スタイルでは、イベントの基になるサービスの定義を参照する必要があります: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (ために、この使用法が必要でイベントの実装<xref:System.Windows.FrameworkElement>、基になるを公開するトリガーとして使用することになるように、サービスのイベントで ContextMenuClosing 識別子がマップされていない).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>自体は、<xref:System.Windows.FrameworkElement>クラスを派生が ContextMenuClosing イベントは発生しませんコンテキスト メニューで直接。</xref:System.Windows.FrameworkElement> 。</xref:System.Windows.Controls.ContextMenu> 代わりに、プロパティとして、コンテキスト メニューを&quot;所有&quot;して、ユーザーが UI にコンテキスト メニューを閉じるしようとしたときにだけ発生する要素からイベントが発生します。 ただしこれは<xref:System.Windows.Controls.ContextMenu>自体が、<xref:System.Windows.FrameworkElement.ContextMenu%2A>プロパティ (入れ子になったコンテキスト メニュー).</xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu> この場合、 <xref:System.Windows.Controls.ContextMenu>、入れ子になった実際に所有して<xref:System.Windows.Controls.ContextMenu>し、入れ子になったコンテキスト メニューをされているイベントのソースと、イベントを発生させる可能性があります</xref:System.Windows.Controls.ContextMenu></xref:System.Windows.Controls.ContextMenu>。       <xref:System.Windows.Controls.ContextMenu>クラス自体は、類似のイベントもあります (<xref:System.Windows.Controls.ContextMenu.Closed>) が、<xref:System.Windows.Controls.ContextMenu.Closed>イベントは、ユーザーの操作をキャンセルすることが提供されません</xref:System.Windows.Controls.ContextMenu.Closed></xref:System.Windows.Controls.ContextMenu.Closed></xref:System.Windows.Controls.ContextMenu>。      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Controls.ContextMenuEventHandler>|     -オーバーライド<xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A></xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>。"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "要素のコンテキスト メニューを開いたときに発生します。"
  remarks: "コンテキスト メニューを手動で開く、処理済みとして、イベントのハンドラーは、関連するイベントをマークする必要があります。 それ以外の場合の既存の値、<xref:System.Windows.FrameworkElement.ContextMenu%2A>プロパティが自動的にコンテキスト メニューを開き、使用されます</xref:System.Windows.FrameworkElement.ContextMenu%2A>。 既定のアクションを効果的に取り消し処理イベントをマークすること<xref:System.Windows.FrameworkElement.ContextMenu%2A>プロパティとし、開く新しい<xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu></xref:System.Windows.FrameworkElement.ContextMenu%2A>の値にリセットすること ただしはタイミングの問題を認識する必要があります。 ContextMenuOpening ハンドラーによりコンテキスト メニューを完全に置換するために、初期コンテキスト メニューは null/空には指定できません。 また、イベントを処理し、新しいコンテキスト メニューを手動で開く必要があります。 詳細については、「[する方法: ContextMenuOpening イベントを処理](~/add/includes/ajax-current-ext-md.md)です。       としては、このイベントを使用して、<xref:System.Windows.EventTrigger>スタイルでは、基になる添付イベントを参照する必要があります: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (ために、この使用法が必要でイベントの実装<xref:System.Windows.FrameworkElement>、基になるを公開するトリガーで使用することになるように、サービスのイベントで ContextMenuOpening 識別子がマップされていない).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>自体は、<xref:System.Windows.FrameworkElement>派生クラスには、ソースとして開かれている、コンテキスト メニューからこのイベントは発生しません</xref:System.Windows.FrameworkElement>。</xref:System.Windows.Controls.ContextMenu> イベントは、プロパティとして、コンテキスト メニューを&quot;所有&quot;して、ユーザーが UI のコンテキスト メニューを開くしようとしたときにだけ発生する要素から発生します。 ことが<xref:System.Windows.Controls.ContextMenu>自体が、<xref:System.Windows.FrameworkElement.ContextMenu%2A>がプロパティには、このシナリオを避ける必要があります (詳細については、「 <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName>).</xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu>       <xref:System.Windows.Controls.ContextMenu>クラス自体は、類似のイベントもあります (<xref:System.Windows.Controls.ContextMenu.Opened>) が、<xref:System.Windows.Controls.ContextMenu.Opened>ユーザーの操作をキャンセルする機会を提供しません</xref:System.Windows.Controls.ContextMenu.Opened></xref:System.Windows.Controls.ContextMenu.Opened></xref:System.Windows.Controls.ContextMenu>。      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Controls.ContextMenuEventHandler>|     -オーバーライド<xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A></xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>。"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.ContextMenu*>依存関係プロパティ</xref:System.Windows.FrameworkElement.ContextMenu*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはこの要素上にマウス ポインターがときに表示されるカーソルを設定します。"
  remarks: "このプロパティを設定すると[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]プロセッサがの型の変換に依存しています、<xref:System.Windows.Input.Cursor>文字列を評価するクラス</xref:System.Windows.Input.Cursor>。 指定された文字列に評価される必要があります、<xref:System.Windows.Input.CursorType>値</xref:System.Windows.Input.CursorType>。 参照してください<xref:System.Windows.Input.Cursor>詳細についてはします</xref:System.Windows.Input.Cursor>。       このプロパティによって設定されるカーソルは、マウス ポインターがこの要素上に表示されないかどうかの値に依存しても、<xref:System.Windows.FrameworkElement.ForceCursor%2A>プロパティ</xref:System.Windows.FrameworkElement.ForceCursor%2A>。 また、アクティブなドラッグ、マウスのキャプチャ、テキスト コントロール、および、内のモードの編集など、イベント関連の考慮事項も影響を与えますカーソル、このプロパティで指定した値よりも優先順位の高い。       最終的な既定値にこのプロパティの設定の動作を戻すには、設定`null`もう一度です。       `null`既定を意味実際的なカーソルの値の決定がここでは遅延し、別の場所から入手してください。 提示された場合、ソースからプログラムで値を使用せず、既定のカーソルが視覚的に以上、[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]アプリケーションは矢印になります。 ただし、経由で渡されるとき、カーソルの一時的な変更は、要素のカーソルの値に設定されません。 実際には、インスタンスまたは使用して設定コード スタイルだプロパティのみの非 null 値がレポートされます、カーソルの場合です。 上にあるマウスが移動するたび、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]アプリケーションが発生し、<xref:System.Windows.UIElement.QueryCursor>イベント</xref:System.Windows.UIElement.QueryCursor>。 イベント バブルと経路上の任意の要素、イベントを処理し、このイベントの引数をカーソルの値を設定する機会があります。 これは、ほとんどの場合、視覚的に明らかなカーソルを生成するメカニズムです。 場合、<xref:System.Windows.UIElement.QueryCursor>ハンドラーは、カーソルの結果を返すし、イベントが処理され、引数に変更された値を持つファクトよりも優先任意のレベルでは、カーソルのプロパティの値しない限り、<xref:System.Windows.FrameworkElement.ForceCursor%2A>が設定されています</xref:System.Windows.FrameworkElement.ForceCursor%2A></xref:System.Windows.UIElement.QueryCursor>。       通常、<xref:System.Windows.Input.Cursors>クラス</xref:System.Windows.Input.Cursors>の静的プロパティの値にこのプロパティを設定する場合は、カスタムのカーソルを作成しない、 次のいずれかのコードにカーソルを設定する必要があります:-呼び出し、<xref:System.Windows.Input.Cursor>を取得するコンス トラクター、<xref:System.Windows.Input.Cursor>インスタンス</xref:System.Windows.Input.Cursor></xref:System.Windows.Input.Cursor>。 両方の署名、<xref:System.Windows.Input.Cursor>ストリームまたはファイルの作成中に応じるために、コンス トラクターを使用して、<xref:System.Windows.Input.Cursor>カーソルのカスタム オブジェクトです</xref:System.Windows.Input.Cursor></xref:System.Windows.Input.Cursor>。      -を使用して、<xref:System.Windows.Input.CursorConverter>クラスとその<xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>メソッドによって、カーソルを指定する<xref:System.Windows.Input.CursorType>、または文字列に評価される、 <xref:System.Windows.Input.CursorType>、 <xref:System.Windows.Input.Cursor>.</xref:System.Windows.Input.Cursor>に戻り値のキャストと</xref:System.Windows.Input.CursorType></xref:System.Windows.Input.CursorType></xref:System.Windows.Input.CursorConverter.ConvertFrom%2A></xref:System.Windows.Input.CursorConverter>       設定、<xref:System.Windows.Input.Cursor>にカスタム値が有効でない部分的な信頼</xref:System.Windows.Input.Cursor>。 カスタム カーソルの詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.CursorProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.CursorProperty>"
  example:
  - "The following example shows how to deliberately set the cursor graphic.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "表示するカーソル。 既定値として定義<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>この依存関係プロパティごとです。 ただし、実行時に実用的な既定値は、さまざまな要因から取得されます。"
  overload: System.Windows.FrameworkElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Cursor*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Cursor*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または、データ バインディングに含まれているときに、要素のデータ コンテキストを設定します。"
  remarks: "*データ コンテキスト*概念により、バインディング、だけでなく、バインディング、パスなどの他の特性に使用されるデータ ソースについて、親要素から情報を継承する要素です。       直接データ コンテキストを設定することができます、[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]オブジェクト、そのオブジェクトのプロパティを評価する、バインディングを使用します。 または、データ コンテキストを設定、<xref:System.Windows.Data.DataSourceProvider>オブジェクト</xref:System.Windows.Data.DataSourceProvider>。       この依存関係プロパティでは、プロパティの値を継承します。 ローカル値またはスタイルを介して確立 DataContext の他の値を使用せずに子要素がある場合は、プロパティのシステムの間で割り当てられているこの値を持つ最も近い親要素の DataContext の値を指定する値が設定されます。       次のプロパティのいずれかを使用する代わりに、<xref:System.Windows.Data.Binding>バインディング ソースを明示的に指定するクラス: <xref:System.Windows.Data.Binding.ElementName%2A>、 <xref:System.Windows.Data.Binding.Source%2A>、または<xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> 詳細については、次を参照してください。[する方法: バインド ソースを指定して](~/add/includes/ajax-current-ext-md.md)です。       [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、DataContext として設定最も一般的な<xref:System.Windows.Data.Binding>宣言</xref:System.Windows.Data.Binding>。 プロパティ要素構文または属性の構文のいずれかを使用することができます。 属性構文は、このページの例に示しています。 コードを使用して、DataContext を設定することもできます。       DataContext は、別に&1; つのコンテキストをバインドする場合がありますのシナリオを容易にするために、バインド可能なプロパティです。 ただし、DataContext にバインドする場合は、(バインドしない DataContext をそれ自体に、プロパティ値の継承の性質、DataContext プロパティが可能である) の循環バインディング参照を作成しないように注意します。      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a>## XAML プロパティ要素の使用```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> ## XAML 属性の使用```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> ## XAML 値*dataContextObject*親要素内のすべてのバインディングのデータ コンテキストとして機能する直接埋め込まれたオブジェクト。             通常、このオブジェクトは、<xref:System.Windows.Data.Binding><xref:System.Windows.Data.BindingBase>派生したクラスの</xref:System.Windows.Data.BindingBase>別、または</xref:System.Windows.Data.Binding> または、いずれかの生データ[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]オブジェクトの種類のバインディングは、後で定義されている実際のバインディングをここでは、配置することも対象としています。       *bindingUsage*適切なデータ コンテキストに評価されるバインディングの使用方法です。 詳細については、「[マークアップ拡張機能のバインド](~/add/includes/ajax-current-ext-md.md)です。       *resourceExtension*次のいずれか。 またはします。 この使用法は、リソース内のオブジェクトとして定義されている、生データを参照するときに使用されます。 参照してください[XAML リソース](~/add/includes/ajax-current-ext-md.md)です。       *contextResourceKey* <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>内から要求されたオブジェクトのキー識別子      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.DataContextProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.DataContextProperty>"
  example:
  - "The following example illustrates how a data context acts on a binding and provides the information that defines the specific values of bound properties.  \n  \n [!code-xml[MasterDetail#DataContextProperty](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty)]  \n[!code-xml[MasterDetail#DataContextProperty2](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty2)]  \n[!code-xml[MasterDetail#DataContextProperty3](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty3)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "データ コンテキストとして使用するオブジェクト。"
  overload: System.Windows.FrameworkElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素のデータ コンテキストが変更されたときに発生します。"
  remarks: "データ コンテキストおよびデータ バインディングの詳細については、次を参照してください。[データ バインディングの概要](~/add/includes/ajax-current-ext-md.md)です。      > [!IMPORTANT] > ときに、<xref:System.Windows.FrameworkElement.DataContext%2A>要素変更では、この要素上のすべてのデータ バインド プロパティ可能性のある影響を受けます</xref:System.Windows.FrameworkElement.DataContext%2A>。 これは、データ コンテキストを継承するには、論理ツリーで、現在の要素の子要素である任意の要素も、現在の要素自体に適用されます。 このような既存のすべてのバインドは、新しい再解釈する必要があります<xref:System.Windows.FrameworkElement.DataContext%2A>バインドの結果を再評価および</xref:System.Windows.FrameworkElement.DataContext%2A>。 データ バインディング エンジンは、DataContextChanged イベントの発生に対して、これらの再評価の順序に関する決定的ではないです。 イベントの後、または任意の組み合わせで、再評価は、イベントの前に発生します。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.DataContext*>依存関係プロパティ</xref:System.Windows.FrameworkElement.DataContext*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または設定を使用してテーマ スタイルを使用または定義されているときに、このコントロールのスタイルを参照するキー。"
  remarks: "このプロパティは、通常はその直接のプロパティ アクセサーのいずれかを設定されません。 <xref:System.Windows.FrameworkElement>派生したクラスの</xref:System.Windows.FrameworkElement>新しいを作成するたびにこの依存関係プロパティの型に固有のメタデータをオーバーライドする代わりに、 コントロールを派生するときに呼び出す、<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>メソッドに対して、<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>識別子、コントロールの静的コンス トラクター内で派生したクラス (または同等のクラス初期化) します</xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty></xref:System.Windows.DependencyProperty.OverrideMetadata%2A>。       コントロール通常独自の型にするには、このプロパティの既定値が上書きが場合によってはでしたも使用してテーマ ディクショナリ内のスタイルが存在する基本型です。 これは、基本コントロールのコントロールのテンプレートが完全にその派生したコントロールのビジュアル表現を定義し、どのような追加のメンバーが派生型を公開では、コントロール テンプレートの一部としては、追加の要素は不要な場合のみ実用的です。       要素またはコントロールは意図的にテーマのスタイルを使用する場合は、設定、<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>プロパティを`true`</xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>。      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>"
  example:
  - "The following example illustrates the dependency property metadata override usage discussed in Remarks. This code defines a custom control class `NumericUpDown` intended to be used from a dedicated control library assembly. The illustrated static constructor references some private initialization function, registers a class handler (another common control subclassing scenario; see [Marking Routed Events as Handled, and Class Handling](~/add/includes/ajax-current-ext-md.md)) and finally overrides the DefaultStyleKey dependency property metadata on the `NumericUpDown` class. DefaultStyleKey always returns its own type as the intended key, which is the convention that the theme style system uses to look up the style for some arbitrary otherwise non-styled control. The complete sample also defines the actual control's theme style that is referenced by that key; see [NumericUpDown Custom Control with Theme and UI Automation Support Sample](http://go.microsoft.com/fwlink/?LinkID=160025).  \n  \n [!code-cs[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]\n [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  \n[!code-cs[CustomControlNumericUpDown#Close](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#close)]\n[!code-vb[CustomControlNumericUpDown#Close](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#close)]"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "スタイルのキー。 テーマ スタイル参照の一部として正常に機能するこの値は必要であるが、<xref:System.Type>コントロールのスタイルを設定します</xref:System.Type>。"
  overload: System.Windows.FrameworkElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.DefaultStyleKey*>依存関係プロパティ</xref:System.Windows.FrameworkElement.DefaultStyleKey*>。"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "要素の初期化プロセスが完了したことを示します。"
  remarks: "場合<xref:System.Windows.FrameworkElement.BeginInit%2A>が既に呼び出されて、基本実装を発生させる、<xref:System.Windows.FrameworkElement.Initialized>イベント</xref:System.Windows.FrameworkElement.Initialized></xref:System.Windows.FrameworkElement.BeginInit%2A>。 それ以外の場合<xref:System.Windows.FrameworkElement.BeginInit%2A>が呼び出されていないかではない可能性があるかどうかを確認<xref:System.Windows.FrameworkElement.BeginInit%2A>、呼び出された<xref:System.Windows.FrameworkElement.Initialized>は発生しません代わりに、例外がスローされます</xref:System.Windows.FrameworkElement.Initialized></xref:System.Windows.FrameworkElement.BeginInit%2A></xref:System.Windows.FrameworkElement.BeginInit%2A>。"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.EndInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndInit なしで呼び出されました<xref:System.Windows.FrameworkElement.BeginInit*>以前に、要素で呼び出されるず</xref:System.Windows.FrameworkElement.BeginInit*>。"
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定した識別子の名前を持つ要素を検索します。"
  remarks: "要素に子要素がある場合は、要求された名前を持つ要素を再帰的には、すべて検索は、これらの子要素です。       FindName は、現在の要素の名前スコープ内で動作します。 詳細については、「 [WPF XAML 名前スコープ](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "要求された要素の名前。"
    return:
      type: System.Object
      description: "要求された要素。 これは、 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>一致する要素が見つからなかった場合です。"
  overload: System.Windows.FrameworkElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定されたキーにリソースを検索し、要求されたリソースが見つからない場合に例外をスローします。"
  remarks: "> [!IMPORTANT]> が見つからないキーのこのメソッドを呼び出すと、例外がスローされます。 FindResource、呼び出しを呼び出すことに起因する例外を処理したくない場合<xref:System.Windows.FrameworkElement.TryFindResource%2A>代わりにします</xref:System.Windows.FrameworkElement.TryFindResource%2A>。 <xref:System.Windows.FrameworkElement.TryFindResource%2A>返します`null`要求されたリソースが見つからないし、例外はスローされません。</xref:System.Windows.FrameworkElement.TryFindResource%2A>       呼び出し元の要素で、リソースが見つからない場合論理ツリー内の親要素、検索結果の 次へし、アプリケーション、し、テーマ、最後にシステム リソースです。 この参照方法は、リソースがマークアップで動的リソース参照によって要求された場合に、ツリーを検索する方法と同じです。 リソースの検索の詳細については、次を参照してください。 [XAML リソース](~/add/includes/ajax-current-ext-md.md)です。       通常、戻り値をプロパティの型で返されたリソースの値を設定する FindResource はすぐにキャストします。       リソース キーは必ずしも文字列です。 たとえば、スタイル、テーマのレベルでのコントロールが意図的と適合するため、<xref:System.Type>の管理、およびアプリケーションまたはページのスタイルのコントロールを通常使用してこの同じキー規約</xref:System.Type>。 詳細については、「[スタイルとテンプレート](~/add/includes/ajax-current-ext-md.md)または[XAML リソース](../Topic/XAML%20Resources.md)です。"
  example:
  - "The following example obtains a named resource and casts it to an appropriate type to fill a property.  \n  \n [!code-cs[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/csharp/PropertiesOvwSupport/page3.xaml.cs#resourceproceduralget)]\n [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/visualbasic/propertiesovwsupport/page3.xaml.vb#resourceproceduralget)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要求されたリソースのキー識別子。"
    return:
      type: System.Object
      description: "要求されたリソースです。 指定されたキーを持つリソースが見つからなかった場合、例外がスローされます。 <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>例外の場合で、値を返すも可能性があります。"
  overload: System.Windows.FrameworkElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "<code>resourceKey</code>見つからず、用、イベント ハンドラーがない、 <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref>イベント。       - または -<code>resourceKey</code>が見つかりませんでした、<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled*>プロパティは<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>で、 <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref>イベント。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirection
  id: FlowDirection
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはテキストおよびその他の方向を設定[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]要素のレイアウトを制御する親要素内でのフローします。"
  remarks: "The dependency property usage sets the FlowDirection on this element. Because of property value inheritance, setting FlowDirection on an element can potentially set FlowDirection on all child elements that did not set FlowDirection locally or though other means such as styles.  \n  \n This property is not automatically set as part of any application culture information, because an element might contain content that is not necessarily intended to obey the general flow direction implied by the culture information. For more information on globalization considerations, see [Globalization for WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n This property has a defined [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] property accessor, so it functions as a dependency property. However, it is also registered as attached, so it can also function as an attached property. The attached registration is mainly so that property value inheritance is supported, but the property can also be used as a true attached property. The attached property usage is only relevant if the object you intend to set the flow direction on has a <xref:System.Windows.FrameworkElement> parent element that performs layout upon it, is itself not a <xref:System.Windows.FrameworkElement>, and does not already have a more directly defined `FlowDirection` property. (Some of the flow document classes such as <xref:System.Windows.Documents.Block> and <xref:System.Windows.Documents.Inline> define their own `FlowDirection`, and this property can also set the flow direction. The property value is then read by the eventual content host without requiring attached property usage.)  \n  \n<a name=\"xamlAttributeUsage_FlowDirection\"></a>   \n## XAML Attribute Usage  \n \\<*object* **FlowDirection**=\"<xref:System.Windows.FlowDirection>\"/>  \n  \n<a name=\"xamlTextUsage_FlowDirection\"></a>   \n## XAML Text Usage  \n This property can also be set on classes that are not <xref:System.Windows.FrameworkElement> derived classes, by the following [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] attached property usage:  \n  \n `<` *object* `FrameworkElement.`**FlowDirection**=\"<xref:System.Windows.FlowDirection>`\"/>`  \n  \n<a name=\"dependencyPropertyInfo_FlowDirection\"></a>   \n## Dependency Property Information  \n  \n|||  \n|-|-|  \n|Identifier field|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  \n|Metadata properties set to `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  \n  \n This property is both a dependency property and an attached property; see Remarks."
  syntax:
    content: public System.Windows.FlowDirection FlowDirection { get; set; }
    return:
      type: System.Windows.FlowDirection
      description: "方向そのテキストおよびその他の[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]列挙体の値、親要素内で要素のフローします。 既定値は<xref href=&quot;System.Windows.FlowDirection&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.FlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  id: FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.FlowDirection*>依存関係プロパティ</xref:System.Windows.FrameworkElement.FlowDirection*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FlowDirectionProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または外観、効果、またはこの要素にキーボード フォーカスを受け取ったときに適用するその他のスタイル特性のカスタマイズを可能にするプロパティを設定します。"
  remarks: "このプロパティは、視覚的な外観に影響を与えますが、状況は報告されません<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>メタデータにします</xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>。 これは、視覚的な外観の変更イベント ドリブンなすべての時刻に適用されるおよびしたがっては限らないメタデータに、visual またはレイアウトの情報です。       概念的には、フォーカスがコントロールに適用される視覚的な動作は、コントロール間で一貫している必要があります。 一貫性を実現するための最もわかりやすい方法では、全体のテーマを作成している場合にのみフォーカス visual スタイルを変更します。 個々 のコントロールのスタイルとテーマの一部ではなくこのプロパティを設定キーボード フォーカスに関するユーザー エクスペリエンスに混乱をこれは、このプロパティの使用目的はありません。 コントロール固有の動作は意図的に一貫したテーマにする場合は、はるかに優れた方法を使用してトリガーのスタイルで入力状態の個々 のプロパティのように<xref:System.Windows.UIElement.IsFocused%2A>または<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>が既存のフォーカス visual スタイルに視覚的に干渉しないようにするためです</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A></xref:System.Windows.UIElement.IsFocused%2A>。 FocusVisualStyle と代替フォーカス プロパティの目的で設計の詳細については、次を参照してください。[コントロール、および FocusVisualStyle でフォーカスのスタイルは](~/add/includes/ajax-current-ext-md.md)します。      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a>## XAML 属性の使用```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> ## XAML プロパティ要素の使用<a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> ## XAML 値*resourceExtension*次のいずれかの: または。       参照してください[XAML リソース](~/add/includes/ajax-current-ext-md.md)です。       *styleResourceKey*要求されているスタイルを識別するキー。 このキーは<xref:System.Windows.ResourceDictionary>。</xref:System.Windows.ResourceDictionary>で既存のリソース      > [!NOTE] > プロパティ要素構文は技術的に可能ですが、推奨されません。 参照してください[インライン スタイルとテンプレート](~/add/includes/ajax-current-ext-md.md)です。 バインドの参照を使用して、または<xref:System.Windows.Data.Binding>も可能ですが、一般的ではない</xref:System.Windows.Data.Binding>。      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "フォーカスに適用する目的のスタイル。 依存関係プロパティで宣言されている既定値は、空の静的<xref href=&quot;System.Windows.Style&quot;></xref>です。 ただし、実行時に有効な値は多くの場合 (必ずではありませんが) コントロールのテーマ サポートによって提供されたスタイルです。"
  overload: System.Windows.FrameworkElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.FocusVisualStyle*>依存関係プロパティ</xref:System.Windows.FrameworkElement.FocusVisualStyle*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または設定を示す値かどうかこの<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>強制する必要があります、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]によって宣言されたカーソルを表示するために、<xref:System.Windows.FrameworkElement.Cursor*>プロパティ</xref:System.Windows.FrameworkElement.Cursor*>。"
  remarks: "このプロパティを設定する場合`true`子要素で設定されているカーソル設定よりも優先されます。 そのため、一般にアプリケーション[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]子要素は、カーソルを指定しようとしている場合は特に、ユーザーの混乱する可能性があります。 ForceCursor の設定は、コントロールのサブクラス化または複合のシナリオに適しています。      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor value.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素上でのカーソルの表示を強制的に現在を使用するかどうか<xref:System.Windows.FrameworkElement.Cursor*>(すべての子要素を含む); カーソルの設定をそれ以外の場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.FrameworkElement.Cursor*> 。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.ForceCursor*>依存関係プロパティ</xref:System.Windows.FrameworkElement.ForceCursor*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "返します、 <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref>を表す、指定したプロパティにバインドします。"
  remarks: "戻り値の確認`null`プロパティがアクティブなバインディングを持つかどうかを決定する手法は、します。       このメソッドは、実際には利便性のためのラッパー、<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>メソッド</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>。 GetBindingExpression が現在のインスタンスを渡すと、 `dp` <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName></xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>パラメーター。"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "ターゲット<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>からバインドを取得します。"
    return:
      type: System.Windows.Data.BindingExpression
      description: "A <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref>ターゲット プロパティにアクティブなバインディングがある場合を返しますそれ以外の場合、 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  id: GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "値を取得、<xref:System.Windows.FrameworkElement.FlowDirection*>添付プロパティを指定した<xref href=&quot;System.Windows.DependencyObject&quot;> </xref></xref:System.Windows.FrameworkElement.FlowDirection*> 。"
  remarks: "添付プロパティの構文をサポートするためには、このメソッドの主な目的、<xref:System.Windows.FrameworkElement.FlowDirection%2A>プロパティ、したがって、指定された要素を子に許可<xref:System.Windows.FrameworkElement>を親要素内での配置のフローの方向を指定します</xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement.FlowDirection%2A>。 現在の値を取得する<xref:System.Windows.FrameworkElement>、ダイレクトを使用して[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]アクセサー <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "<xref:System.Windows.FrameworkElement.FlowDirection*>データ型</xref:System.Windows.FrameworkElement.FlowDirection*>を返す要素"
    return:
      type: System.Windows.FlowDirection
      description: "要求されたフローの方向、列挙体の値。"
  overload: System.Windows.FrameworkElement.GetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  id: GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "クリッピング マスクのジオメトリを返します。 使用できる表示スペースよりも大きい要素を整列するレイアウト システムしようとすると、マスクが適用されます。"
  remarks: "減算する余白、`layoutSlotSize`レイアウト システムの動作の一部として。       返される null 参照では、クリップが発生しないことを示します。 既定の実装を常に返します`null`とき<xref:System.Windows.UIElement.ClipToBounds%2A>は`false`</xref:System.Windows.UIElement.ClipToBounds%2A>。 このメソッドは<xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName>。</xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.FrameworkElement>実装を使用して<xref:System.Windows.FrameworkElement.MaxHeight%2A>と<xref:System.Windows.FrameworkElement.MaxWidth%2A>計算</xref:System.Windows.FrameworkElement.MaxWidth%2A></xref:System.Windows.FrameworkElement.MaxHeight%2A></xref:System.Windows.FrameworkElement>。 いくつかのサブクラスの<xref:System.Windows.FrameworkElement>再度このメソッドをオーバーライドします</xref:System.Windows.FrameworkElement>。 <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName>、戻り値を常にオーバーライド`null`のため装飾多くの場合、意図的に通常の範囲外です。</xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>and <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName> return `null` if <xref:System.Windows.UIElement.ClipToBounds%2A> is `false`.</xref:System.Windows.UIElement.ClipToBounds%2A></xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName></xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>"
  syntax:
    content: protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);
    parameters:
    - id: layoutSlotSize
      type: System.Windows.Size
      description: "視覚的な表示を行う要素の一部のサイズ。"
    return:
      type: System.Windows.Media.Geometry
      description: "クリッピング ジオメトリ。"
  overload: System.Windows.FrameworkElement.GetLayoutClip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  id: GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "インスタンス化のビジュアル ツリーの名前付きの要素を返します<xref href=&quot;System.Windows.Controls.ControlTemplate&quot;></xref>です。"
  remarks: "テンプレートで[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]自己完結型の名前スコープがあります。 テンプレートは、再利用し、各コントロールの複数のインスタンスがそのテンプレートをインスタンス化時にテンプレートで定義されている任意の名前の一意性が維持できないためにです。 インスタンス化した後、テンプレートからのオブジェクトへの参照を返す GetTemplateChild メソッドを呼び出します。 使用することはできません、<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>ために、テンプレートから項目を検索するメソッド<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>はで動作しより一般的なスコープとの間の接続がない、<xref:System.Windows.Controls.ControlTemplate>は、クラス自体およびインスタンス化されたテンプレートが適用される</xref:System.Windows.Controls.ControlTemplate></xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName></xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>。       <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>このメソッドと同じ機能を提供します。</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>代わりにパブリックが保護されている、正しい名前スコープの考慮事項要素およびその中の項目を名前付き検索内でテンプレートにアクセスできるようにするを使用しています。</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> 使用して<xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>する必要がある場合、親コントロールの外部要素を取得します</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>。"
  syntax:
    content: protected System.Windows.DependencyObject GetTemplateChild (string childName);
    parameters:
    - id: childName
      type: System.String
      description: "検索する子の名前です。"
    return:
      type: System.Windows.DependencyObject
      description: "要求された要素。 あります<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>要求の名前の要素が存在しない場合。"
  overload: System.Windows.FrameworkElement.GetTemplateChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "ビジュアル親がない場合は、この要素の代替の論理親を返します。"
  remarks: "このメソッドは<xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName>。</xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName> 既定値<xref:System.Windows.FrameworkElement>実装、予想される&1; つ visual の親を返しますの結果の取得と同じである、<xref:System.Windows.FrameworkElement.Parent%2A>値</xref:System.Windows.FrameworkElement.Parent%2A></xref:System.Windows.FrameworkElement>。 派生クラスの実装では、代替親リレーションシップを返す場合があります。"
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "以外の値を返します<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>このメソッドの WPF フレームワーク レベルの実装が非ビジュアルの親接続を持つ場合です。"
  overload: System.Windows.FrameworkElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  id: GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "オーバーライド&lt;xref:System.Windows.Media.Visual.GetVisualChild%2A?displayProperty=fullName&gt;、し、子要素のコレクションから指定したインデックス位置の子を返します。"
  remarks: "<xref:System.Windows.FrameworkElement>実装では、唯一の有効なインデックスは&0; です</xref:System.Windows.FrameworkElement>。 GetVisualChild のコンテンツ モデルには、0 個または&1; つの子要素コレクションではありませんがサポートしています。"
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children. These values are reported through overrides of <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> and GetVisualChild.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override System.Windows.Media.Visual GetVisualChild (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "コレクション内の要求された子要素の&0; から始まるインデックス。"
    return:
      type: System.Windows.Media.Visual
      description: "要求された子要素です。 これは返されません<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>のうち、指定されたインデックスのかどうかは; 範囲、例外がスローされます。"
  overload: System.Windows.FrameworkElement.GetVisualChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Height
  id: Height
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の高さの推奨値を設定します。"
  remarks: "高さは、3 つの書き込み可能なプロパティのいずれかで<xref:System.Windows.FrameworkElement>高さ情報を指定する</xref:System.Windows.FrameworkElement>。 他の&2; つは<xref:System.Windows.FrameworkElement.MinHeight%2A>および<xref:System.Windows.FrameworkElement.MaxHeight%2A>。</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A> 間の競合がある場合これらの値、実際の高さを決定するためのアプリケーションの順序は最初<xref:System.Windows.FrameworkElement.MinHeight%2A>、受け入れられ、する必要があります<xref:System.Windows.FrameworkElement.MaxHeight%2A>、最後に、高さの境界内にある場合</xref:System.Windows.FrameworkElement.MaxHeight%2A></xref:System.Windows.FrameworkElement.MinHeight%2A>。       この要素がその他の要素内の子要素の場合は、値にこのプロパティを設定、本当にのみ推奨される値です。 レイアウト システムだけでなく、親要素の特定のレイアウト ロジックが値として使用 nonbinding 入力レイアウトの処理中にします。 実際<xref:System.Windows.FrameworkElement>;<xref:System.Windows.Window></xref:System.Windows.Window>高さを設定する場合でも、何か他の子要素ではほとんどの場合は、</xref:System.Windows.FrameworkElement> 。 (の<xref:System.Windows.Window>、基になるアプリケーション モデルは、Hwnd を作成する基本的なレンダリング前提条件を確立するときに、値を使用するアプリケーションをホストします)</xref:System.Windows.Window> 。     さらに許容される<xref:System.Double>値、このプロパティには、 <xref:System.Double.NaN?displayProperty=fullName>。</xref:System.Double.NaN?displayProperty=fullName>ことができます。</xref:System.Double> これは、コードの自動サイズ変更動作を指定する方法です。 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 「自動」(大文字と小文字) を自動サイズ変更動作を有効にする文字列値を設定します。 自動サイズ変更動作は、要素が利用できる高さいっぱいになることを意味します。 ただし、特定のコントロールがサイズ変更動作を具体的には、再度有効にしない限り、自動を無効にする既定のテーマのスタイルを使用して既定値を頻繁に指定します。       このプロパティの戻り値は、それに設定された任意の値と同じでは常にします。 これに対しての値、<xref:System.Windows.FrameworkElement.ActualHeight%2A>異なる場合があります</xref:System.Windows.FrameworkElement.ActualHeight%2A>。 これは、原因が考えられますか静的にレイアウトが何らかの理由により推奨されるサイズを拒否または一時的にします。 レイアウト システム自体では、高さのプロパティ システムのセットに対して相対的に非同期的に機能し、処理されない可能性がある特定のプロパティの変更をまだサイズ変更します。       値の制限、<xref:System.Double>によって値が適用される、<xref:System.Windows.ValidateValueCallback>メカニズム</xref:System.Windows.ValidateValueCallback></xref:System.Double>。 無効な値を設定しようとすると、実行時例外がスローされます。       レイアウト システムによって適用される高さにバインドされている、非決定的上限の値があるだけでなく、検証チェック (これは非常に大きな数より大きい<xref:System.Single.MaxValue?displayProperty=fullName>がよりも小さい<xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> この上限値を超えた場合は、要素は表示されず、例外はスローされません。 高さは表示可能な最大サイズよりもずっと大きな値に設定しないでください、またはこの非決定的の上限を超える可能性があります。      <a name=&quot;xamlAttributeUsage_Height&quot;></a>## XAML 属性の使用```   <object Height=&quot;double&quot;/>   - or -   <object Height=&quot;qualifiedDouble&quot;/>   - or -   <object Height=&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Height&quot;> </a> ## XAML 値*二重*<xref:System.Double>の文字列表現を<xref:System.Double>0.0 以上の値</xref:System.Double></xref:System.Double>。           上限については、「解説」を参照してください。 この値として解釈されます、[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]測定します。 明示的に、文字列では、小数点を含める必要がありますされません。 値のインスタンス`1`は許容されます。       *qualifiedDouble* A*二重*値、上記と続けて次の単位の宣言文字列のいずれかの: `px`、 `in`、 `cm`、`pt`です。       `px`(既定値) は[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]`in`インチ; に 1 96px を = =`cm`センチメートル; は、1cm==(96/2.54) px`pt`ポイント; 1pt==(96/72) px**自動**自動動作を有効にします。        「解説」を参照してください。      <a name=&quot;dependencyPropertyInfo_Height&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.HeightProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.HeightProperty>"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "要素の高さの[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]します。 既定値は&lt;xref:System.Double?displayProperty=fullName&gt;です。 この値は、0.0 以上にする必要があります。 上限については、「解説」を参照してください。"
  overload: System.Windows.FrameworkElement.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HeightProperty
  id: HeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Height*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Height*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  id: HorizontalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはなど、panel またはアイテム コントロールの親要素内で構成されるときに、この要素に適用される水平方向の配置特性を設定します。"
  remarks: "ときに<xref:System.Windows.FrameworkElement.Height%2A><xref:System.Windows.FrameworkElement.Width%2A>要素のプロパティが明示的に設定されている</xref:System.Windows.FrameworkElement.Width%2A>、これらの測定値より高い優先レイアウト時に行い<xref:System.Windows.HorizontalAlignment></xref:System.Windows.HorizontalAlignment>HorizontalAlignment の設定の標準的な効果が取り消されます</xref:System.Windows.FrameworkElement.Height%2A>。       HorizontalAlignment は、[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]新機能は、実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、コントロールでは特に、サブクラス化された要素で設定が異なります見かけ上の「既定」値がよくあります。 これは、2 つの方法のいずれかで一般的に発生します特定のサブクラスでは、にはその既定値を設定するためのさまざまなメタデータと、依存関係プロパティが再登録。またはが適用されている既定のスタイルが異なるその依存関係プロパティの値を設定します。 など、明確な&quot;default&quot;の HorizontalAlignment の<xref:System.Windows.Controls.Label>コントロールする<xref:System.Windows.HorizontalAlignment>場合でも、<xref:System.Windows.Controls.Label>継承<xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement>HorizontalAlignment ダイレクト</xref:System.Windows.Controls.Label></xref:System.Windows.HorizontalAlignment></xref:System.Windows.Controls.Label>。 これは、既定のスタイル内でその値がリセットされたため<xref:System.Windows.Controls.Label>、スタイルのコントロール テンプレート内で</xref:System.Windows.Controls.Label>。       <xref:System.Windows.Controls.Canvas>使用しません HorizontalAlignment のレイアウトを作成するときに<xref:System.Windows.Controls.Canvas>絶対位置に基づきます</xref:System.Windows.Controls.Canvas>。</xref:System.Windows.Controls.Canvas>       <xref:System.Windows.Controls.Label>または<xref:System.Windows.Controls.Label><xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment>にするには、この依存関係プロパティの既定値を再定義</xref:System.Windows.Controls.Label>の派生クラス</xref:System.Windows.Controls.Label>によって継承された場合      <a name=&quot;dependencyPropertyInfo_HorizontalAlignment&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>"
  syntax:
    content: public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }
    return:
      type: System.Windows.HorizontalAlignment
      description: "列挙体の値としての水平方向の配置設定します。 既定値は<xref href=&quot;System.Windows.HorizontalAlignment&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.HorizontalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  id: HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.HorizontalAlignment*>依存関係プロパティ</xref:System.Windows.FrameworkElement.HorizontalAlignment*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  id: InheritanceBehavior
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはプロパティ値の継承、リソース キーの検索、および RelativeSource FindAncestor 参照スコープの制限を設定します。"
  remarks: "要素ツリー内の特定の境界は、意図的に、アプリケーションのリソースを確認したり、さらに、現在の要素またはそのいずれかのクエリから RelativeSource FindAncestor 参照を防ぐためには、force リソースの検索に、継承動作のスコープを制限する InheritanceBehavior を設定します。 RelativeSource FindAncestor 参照の場合は、バインディングを使用して、<xref:System.Windows.Data.RelativeSource>を持つその<xref:System.Windows.Data.RelativeSource.Mode%2A>プロパティに設定、<xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName>値</xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName></xref:System.Windows.Data.RelativeSource.Mode%2A></xref:System.Windows.Data.RelativeSource>。       派生クラスをこのプロパティを設定する場合は、する必要がありますこれを行う、静的コンス トラクター内またはその他の初期化ルーチンです。"
  syntax:
    content: protected System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }
    return:
      type: System.Windows.InheritanceBehavior
      description: "列挙体の値です。 既定値は<xref href=&quot;System.Windows.InheritanceBehavior&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.InheritanceBehavior*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "発生したときにこの<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>が初期化されています。 このイベントがケースに一致している場所の値、<xref:System.Windows.FrameworkElement.IsInitialized*>からプロパティの変更<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (または未定義) を<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Windows.FrameworkElement.IsInitialized*> 。"
  remarks: "このイベントになるたびに発生、<xref:System.Windows.FrameworkElement.EndInit%2A>または<xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>メソッドが呼び出される</xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A></xref:System.Windows.FrameworkElement.EndInit%2A>。 アプリケーション コードからまたはいずれかのメソッドの呼び出しが同梱されている可能性があります、[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]プロセッサの動作時に、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]ページを処理します。       処理するかどうかを選択する<xref:System.Windows.FrameworkElement.Loaded>または Initialized ニーズによって異なります</xref:System.Windows.FrameworkElement.Loaded>。 要素のプロパティを読み取りのプロパティをリセットする必要はありませんし場合、レイアウト情報は必要ありません、Initialized が対象となるイベントの向上にあります。 使用できる要素のすべてのプロパティを必要と、レイアウトをリセットすると思われるプロパティを設定する場合<xref:System.Windows.FrameworkElement.Loaded>の対象となるイベントの向上があります</xref:System.Windows.FrameworkElement.Loaded>。 必ず再入の場合は、ハンドラーが新しいレイアウト パスが必要であることを意味するレイアウト システムで解釈される任意のプロパティをリセットします。 (を確認する必要があります、<xref:System.Windows.FrameworkPropertyMetadata>プロパティは、新しいレイアウトを要求できますのことを確認していない場合は、プロパティの値が変更された場合に通過します)</xref:System.Windows.FrameworkPropertyMetadata> 。     オブジェクトのイベントのシーケンスに関する詳細については、<xref:System.Windows.FrameworkElement>もいくつかの関連アプリケーションと要素のクラスを参照してください、[オブジェクトの有効期間イベント](~/add/includes/ajax-current-ext-md.md)</xref:System.Windows.FrameworkElement>。"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "これで使用される入力のコンテキストを設定を取得または<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>です。"
  remarks: "この依存関係プロパティでは、プロパティの値を継承します。 ローカル値またはスタイルを介して確立 InputScope の他の値を使用せずに子要素がある場合は、プロパティのシステムの間で割り当てられているこの値を持つ最も近い先祖の要素の InputScope 値に値が設定されます。       ただし、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]構文の使用状況が表示されているし、は構文的に許可されているのこのプロパティを設定[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]一般的ではありません。      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.InputScopeProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "代替の入力メソッドからの入力を解釈する方法を変更する入力スコープ。 既定値は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (結果はコマンドの既定の処理)。"
  overload: System.Windows.FrameworkElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.InputScope*>依存関係プロパティ</xref:System.Windows.FrameworkElement.InputScope*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素が初期化されているかどうかを示す値を取得で処理中にいずれか、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]プロセッサ、または明示的に用意することによってその<xref:System.Windows.FrameworkElement.EndInit*>呼び出されるメソッドです</xref:System.Windows.FrameworkElement.EndInit*>。"
  remarks: "このプロパティがありますも`true`新しい親要素を持つし、そのために再読み込みされたことになるように、この要素が論理ツリー内で移動されたかどうか。       このプロパティは、使用する場合も<xref:System.Windows.FrameworkElement.BeginInit%2A>、 <xref:System.Windows.FrameworkElement.EndInit%2A>。</xref:System.Windows.FrameworkElement.EndInit%2A></xref:System.Windows.FrameworkElement.BeginInit%2A>便利です。 によって読み込まれる論理ツリー内の要素、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]プロセッサを初期化する確実に実行されます。 論理ツリーに存在しない要素が初期化されるときに<xref:System.Windows.FrameworkElement.EndInit%2A>が呼び出された</xref:System.Windows.FrameworkElement.EndInit%2A>。 特定の処理がない場合に<xref:System.Windows.FrameworkElement.BeginInit%2A>と<xref:System.Windows.FrameworkElement.EndInit%2A>、コンス トラクターが初期化された結果を返すとすぐにこれは行われます</xref:System.Windows.FrameworkElement.EndInit%2A></xref:System.Windows.FrameworkElement.BeginInit%2A>。"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、ここに挙げたごとに、要素が初期化された[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]処理やメソッドの呼び出し、それ以外の<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "プレゼンテーションについては、この要素が読み込まれているかどうかを示す値を取得します。"
  remarks: "新しく構築されたから<xref:System.Windows.FrameworkElement>、このプロパティは、まず`false`、開いたまま`true`に設定されている後`true`コードによって接続されている論理ツリーから要素が、後で削除された場合でも、</xref:System.Windows.FrameworkElement> 。 `true`状態は、要素が、プレゼンテーション エンジンに読み込まれるときに、一般的なプレゼンテーション ロジックによって設定されます。       通常、読み込まれた要素は、レンダリングされた、すべてではなく<xref:System.Windows.FrameworkElement>派生クラスは、プレゼンテーション、およびなどの他のプロパティがある<xref:System.Windows.UIElement.Visibility%2A>プレゼンテーションに影響を与えることができます</xref:System.Windows.UIElement.Visibility%2A></xref:System.Windows.FrameworkElement>。"
  example:
  - "The following example implements two handlers: one is handling the <xref:System.Windows.FrameworkElement.Loaded> event of the root element, so it is certain that the page root element is loaded because that is the significance of the event. The other handler is hooked to a user control, and calls IsLoaded to assure that the root element is loaded completely. Both handlers call the same function (not shown) that will populate child elements with fresh data.  \n  \n [!code-cs[GroupBoxExample#FEIsLoaded](~/add/codesnippet/csharp/GroupBoxExample/Page1.xaml.cs#feisloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>現在の要素が、要素ツリーにアタッチされている場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>要素が読み込まれた要素ツリーにアタッチされていない場合。"
  overload: System.Windows.FrameworkElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Language
  id: Language
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素に適用されるローカリゼーション/グローバリゼーション言語情報を設定します。"
  remarks: "文字列の形式では、RFC 3066 標準に従います。 たとえば、米国&quot;EN-US&quot;は英語です。 値と形式の詳細については、 <xref:System.Windows.Markup.XmlLanguage>。</xref:System.Windows.Markup.XmlLanguage>を参照してください。       この依存関係プロパティでは、プロパティの値を継承します。 ローカル値またはスタイルを介して確立言語の他の値を使用せずに子要素がある場合は、プロパティのシステムは、値を割り当てられているこの値を持つ最も近い先祖の要素の言語の値を設定します。       [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]一般的な意味を定義、`xml:lang`属性。 言語は、本質的には、依存関係プロパティとして、この属性の意味を公開します。 言語が、プログラムで調整されることができます、匹敵する方法でプロパティ システムの値の継承に参加できますが、どのように`xml:lang`子要素のスコープ内に属性が継承される[!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]です。 言語を設定すると、その値が、`xml:lang`し、以前の値を上書きします。 詳細については、次を参照してください。 [xml:lang XAML での処理](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.LanguageProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "この要素の言語情報。 既定値は、 <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref>でその<xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>値、文字列&quot;EN-US&quot;に設定します</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>。"
  overload: System.Windows.FrameworkElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Language*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Language*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransform
  id: LayoutTransform
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはレイアウトの実行時にこの要素に適用されるグラフィックス変換を設定します。"
  remarks: "対照的に<xref:System.Windows.UIElement.RenderTransform%2A>、LayoutTransform がレイアウトの結果に影響されます</xref:System.Windows.UIElement.RenderTransform%2A>。       トランス フォームを設定するには、スケールおよび回転の強力な機能が備わっています。 しかし、LayoutTransform を無視<xref:System.Windows.Media.TranslateTransform>操作</xref:System.Windows.Media.TranslateTransform>。 これは子要素をレイアウト システムの動作、<xref:System.Windows.FrameworkElement>任意のオフセットがレイアウトにスケールまたは回転した要素の位置および親要素の座標システムへの自動修正します</xref:System.Windows.FrameworkElement>。       レイアウト システムで完全パスを必要としないシナリオで起動する場合、LayoutTransform は不十分なアプリケーションのパフォーマンスにつながります。 LayoutTransform を適用すると、<xref:System.Windows.Controls.Panel.Children%2A>を集めた、<xref:System.Windows.Controls.Panel>レイアウト システムによって新しいパスがトリガー、および画面に表示されるすべて remeasured して再配置するオブジェクトを強制的に実行します</xref:System.Windows.Controls.Panel></xref:System.Windows.Controls.Panel.Children%2A>。 完全なアプリケーションを更新する場合は[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]、この機能は必要なものだけする可能性があります。 ただし、完全な配置パスを使用する必要はありません、使用、<xref:System.Windows.UIElement.RenderTransform%2A>プロパティが、レイアウト システムを呼び出しませんそのため、このシナリオの方が適切では通常。</xref:System.Windows.UIElement.RenderTransform%2A> 。       LayoutTransform が役に立つ、シナリオ例にはが含まれます: フォーカス、編集の動作などを提供することで (拡大) 要素を拡大/縮小から水平方向の垂直方向に、またはその逆の場合は、メニュー コンポーネントなどの要素を回転します。     <a name=&quot;dependencyPropertyInfo_LayoutTransform&quot;> </a> ## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.LayoutTransformProperty>"
  example:
  - "The following example shows how to apply a LayoutTransform to an element. The example creates an instance of <xref:System.Windows.Controls.Button> and hosts it within a parent <xref:System.Windows.Controls.Grid>. It also uses the LayoutTransform property to apply a <xref:System.Windows.Media.RotateTransform> to the <xref:System.Windows.Controls.Button>.  \n  \n [!code-vb[LayoutTransform#1](~/add/codesnippet/visualbasic/LayoutTransformVB/LayoutTransform.vb#1)]\n [!code-cpp[LayoutTransform#1](~/add/codesnippet/cpp/layouttransform/LayoutTransform.cpp#1)]\n [!code-xml[LayoutTransform#1](~/add/codesnippet/xaml/LayoutTransform/default.xaml#1)]\n [!code-cs[LayoutTransform#1](~/add/codesnippet/csharp/LayoutTransformCsharp/LayoutTransform.cs#1)]"
  syntax:
    content: public System.Windows.Media.Transform LayoutTransform { get; set; }
    return:
      type: System.Windows.Media.Transform
      description: "変換で、この要素を使用する必要があります。 既定値は<xref:System.Windows.Media.Transform.Identity*>.</xref:System.Windows.Media.Transform.Identity*>"
  overload: System.Windows.FrameworkElement.LayoutTransform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  id: LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.LayoutTransform*>依存関係プロパティ</xref:System.Windows.FrameworkElement.LayoutTransform*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LayoutTransformProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "要素のレイアウト、レンダリングされ、操作を受け入れる準備と発生します。"
  remarks: "読み込まれたは通常最後のイベント発生要素の初期化シーケンスでします。 常に<xref:System.Windows.FrameworkElement.Initialized>。</xref:System.Windows.FrameworkElement.Initialized>後に発生します。 Loaded を処理するかどうかを選択するか、<xref:System.Windows.FrameworkElement.Initialized>要件によって異なります</xref:System.Windows.FrameworkElement.Initialized>。 要素のプロパティを読み取る必要がない場合、プロパティをリセットして、レイアウト情報は必要ありません<xref:System.Windows.FrameworkElement.Initialized>対象となるイベントの向上があります</xref:System.Windows.FrameworkElement.Initialized>。 すべてのプロパティを必要がある場合に、使用できる要素とするプロパティも設定するレイアウトをリセットすると思われる、読み込まれる可能性がありますが作用するイベントの向上。 必ず再入の場合は、ハンドラーが新しいレイアウト パスが必要であることを意味するレイアウト システムで解釈される任意のプロパティをリセットします。 (を確認する必要があります、<xref:System.Windows.FrameworkPropertyMetadata>プロパティは、新しいレイアウトを要求できますのことを確認していない場合は、プロパティの値が変更された場合に通過します)</xref:System.Windows.FrameworkPropertyMetadata> 。     オブジェクトのイベントのシーケンスに関する詳細については、<xref:System.Windows.FrameworkElement>もいくつかの関連アプリケーションと要素のクラスを参照してください、[オブジェクトの有効期間イベント](~/add/includes/ajax-current-ext-md.md)</xref:System.Windows.FrameworkElement>。       ルーティング イベントを直接ルートに従っていない、発生したが、同じ要素内でのみ処理されます。 ルーティング イベントがその他のルーティング イベントの動作をサポートして直接: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<xref:System.Windows.EventTrigger>スタイルでします</xref:System.Windows.EventTrigger>。       読み込まれると<xref:System.Windows.FrameworkElement.Unloaded>両方のユーザーによるシステムのテーマを変更した結果のコントロールで発生する可能性があります</xref:System.Windows.FrameworkElement.Unloaded>。 テーマの変更では、コントロール テンプレートと、コントロール全体をアンロードして再読み込みが含まれているビジュアル ツリーの無効化が発生します。 したがってロードの場合は、のみページが最初に読み込まれるときに、ページへの移動を発生すると見なされますことはできません。      <a name=&quot;routedEventInfo_Loaded&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.LoadedEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.Loaded&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の論理上の子要素の列挙子を取得します。"
  remarks: "LogicalChildren では、子要素を反復処理することができます。 これは、可能性があります、定義済みの専用のコレクションはありませんが、まだ特に複数の子要素が含まれている要素に便利です<xref:System.Windows.FrameworkContentElement>子要素です</xref:System.Windows.FrameworkContentElement>。       LogicalChildren を使用する方法の詳細については、<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>を参照してください[wpf ツリー](~/add/includes/ajax-current-ext-md.md)</xref:System.Windows.FrameworkElement.AddLogicalChild%2A> 。"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "この要素の論理上の子要素に対する列挙子。"
  overload: System.Windows.FrameworkElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Margin
  id: Margin
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の外側の余白を設定します。"
  remarks: "余白は、この要素とレイアウトを作成するときに、隣接するその他の要素間の空白、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]です。 共有要素は、ピア要素 (その他のコレクション内の要素、共通の親コントロールの) などがあります。 または、この要素の親の場合もあります。       として余白が設定されて、<xref:System.Windows.Thickness>構造数値としてではなく、余白を非対称的設定できるようにします</xref:System.Windows.Thickness>。 <xref:System.Windows.Thickness>構造体自体は、非対称の余白を指定できるように、文字列型の変換をサポートしている[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]属性構文も</xref:System.Windows.Thickness>。       0 以外の余白は要素のレイアウト<xref:System.Windows.FrameworkElement.ActualWidth%2A>と<xref:System.Windows.FrameworkElement.ActualHeight%2A></xref:System.Windows.FrameworkElement.ActualHeight%2A></xref:System.Windows.FrameworkElement.ActualWidth%2A>       余白は、レイアウトの兄弟要素の追加たとえば、2 つの隣接する要素が隣接する端に 30 の余白がどちらも設定は、60 の単位の間にスペースがあります。       余白の設定を持つ要素通常を制約しない指定の余白のサイズ、割り当てられた四角形領域がない場合、余白と要素のコンテンツ領域に十分な大きさです。 要素のコンテンツ領域は、代わりにレイアウトの計算時に制限されます。 コンテンツが既に&0; に制約されていますもは余白が制限される場合だけです。      <a name=&quot;xamlAttributeUsage_Margin&quot;></a>## XAML 属性の使用```   <object Margin=&quot;left,top,right,bottom&quot;/>   - or -   <object Margin=&quot;left,top&quot;/>   - or -   <object Margin=&quot;thicknessReference&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Margin&quot;> </a> ## XAML プロパティ要素の使用```   <object>     <object.Margin>       <Thickness Left=&quot;left&quot; Top=&quot;top&quot; Right=&quot;right&quot; Bottom=&quot;bottom&quot;/>     </object.Margin>   </object>   ``` <a name=&quot;xamlValues_Margin&quot;> </a> ## XAML 値*左、上、右、下の*番号を 0 までの値と<xref:System.Double.PositiveInfinity>の 4 つの可能なディメンション プロパティを指定する、<xref:System.Windows.Thickness>構造</xref:System.Windows.Thickness></xref:System.Double.PositiveInfinity>。                   属性の使用方法も指定すると、対称的、論理的な順序で適用される省略形の値を受け取ります。 たとえば、`Margin=&quot;20&quot;`という意味に解釈されます、<xref:System.Windows.Thickness>すべてのプロパティが 20 に設定します</xref:System.Windows.Thickness>。 `Margin=&quot;20,50&quot;`という意味に解釈されます、<xref:System.Windows.Thickness>で<xref:System.Windows.Thickness.Left%2A>と<xref:System.Windows.Thickness.Right%2A>を 20 に設定し、<xref:System.Windows.Thickness.Top%2A>と<xref:System.Windows.Thickness.Bottom%2A>は 50 に設定します</xref:System.Windows.Thickness.Bottom%2A></xref:System.Windows.Thickness.Top%2A></xref:System.Windows.Thickness.Right%2A></xref:System.Windows.Thickness.Left%2A></xref:System.Windows.Thickness>。       既定の単位、<xref:System.Windows.Thickness>メジャーが[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]</xref:System.Windows.Thickness>。 単位の種類の文字列を追加することによって、他の単位を指定することも`cm`、 `in`、または`pt`任意の測定値にします。       数値として提供される[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]属性が必要な 10 進数のポイントを指定しない (0 が許容される、0.0 として指定する必要はありません)。 詳細については[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]使用状況、 <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>を参照してください。       *thicknessReference*既存<xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>へのオブジェクト参照 可能性があります、 `}`、または`}`参照します。 詳細については[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]使用状況、 <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>を参照してください。      <a name=&quot;dependencyPropertyInfo_Margin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.MarginProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MarginProperty>"
  syntax:
    content: public System.Windows.Thickness Margin { get; set; }
    return:
      type: System.Windows.Thickness
      description: "要素の余白の値を提供します。 既定値は、 <xref href=&quot;System.Windows.Thickness&quot;> </xref>すべてのプロパティが 0 (ゼロ)。"
  overload: System.Windows.FrameworkElement.Margin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MarginProperty
  id: MarginProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Margin*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Margin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MarginProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeight
  id: MaxHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の高さの最大値の制約を設定します。"
  remarks: "これには&3; つのプロパティのいずれかの<xref:System.Windows.FrameworkElement>高さ情報を指定する</xref:System.Windows.FrameworkElement>。 他の&2; つは<xref:System.Windows.FrameworkElement.MinHeight%2A>および<xref:System.Windows.FrameworkElement.Height%2A>。</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>  実際の高さを決定するためのアプリケーションの順序は最初、これらの値の間で競合がある場合<xref:System.Windows.FrameworkElement.MinHeight%2A>受け入れられ、する必要があります、MaxHeight、最後に<xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A>の境界内にある場合のこれら各</xref:System.Windows.FrameworkElement.MinHeight%2A>       値の制限、<xref:System.Double>によって値が適用される、<xref:System.Windows.ValidateValueCallback>メカニズム</xref:System.Windows.ValidateValueCallback></xref:System.Double>。 無効な値を設定しようとする場合、実行時に例外がスローされます。      <a name=&quot;xamlAttributeUsage_MaxHeight&quot;></a>## XAML 属性の使用```   <object MaxHeight=&quot;double&quot;/>   - or –   <object MaxHeight =&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxHeight&quot;> </a> ## XAML 値*二重*<xref:System.Double>の文字列表現を<xref:System.Double>0.0 以上の値</xref:System.Double></xref:System.Double>。           これは、[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]測定します。 明示的に、文字列では、小数点を含める必要がありますされません。 値のインスタンス`1`は許容されます。       同じ<xref:System.Double>プロパティの値セクションで説明したように範囲の制限を適用する必要がありますを使用する点を除いて[X:static マークアップ拡張機能](~/add/includes/ajax-current-ext-md.md) <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity>られる値を明示的に設定する必要があるかどうかは</xref:System.Double>       *qualifiedDouble* A*二重*値、上記と続けて次の単位の宣言文字列のいずれかの: `px`、 `in`、 `cm`、`pt`です。       `px`(既定値) は[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]`in`インチ; は、1 in 96px を = =`cm`センチメートル; は、1cm==(96/2.54) px`pt`ポイント; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxHeight&quot;> </a> ## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxHeightProperty>       "
  syntax:
    content: public double MaxHeight { get; set; }
    return:
      type: System.Double
      description: "要素の高さの最大値で、[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]です。 既定値は<xref:System.Double>。</xref:System.Double> この値は、0.0 以上の任意の値を指定できます。 <xref:System.Double>でも有効です。</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  id: MaxHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.MaxHeight*>依存関係プロパティ</xref:System.Windows.FrameworkElement.MaxHeight*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidth
  id: MaxWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の幅の最大値の制約を設定します。"
  remarks: "これには&3; つのプロパティのいずれかの<xref:System.Windows.FrameworkElement>幅情報を指定する</xref:System.Windows.FrameworkElement>。 他の&2; つは<xref:System.Windows.FrameworkElement.MinWidth%2A>および<xref:System.Windows.FrameworkElement.Width%2A>。</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A> 実際の幅を決定するためのアプリケーションの順序は最初、これらの値の間で競合がある場合<xref:System.Windows.FrameworkElement.MinWidth%2A>受け入れられ、する必要があります MaxWidth、し、最後に、 <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A>境界内にあるこれらの各場合</xref:System.Windows.FrameworkElement.MinWidth%2A>       値の制限、<xref:System.Double>によって値が適用される、<xref:System.Windows.ValidateValueCallback>メカニズム</xref:System.Windows.ValidateValueCallback></xref:System.Double>。 無効な値を設定しようとすると、実行時例外がスローされます。      <a name=&quot;xamlAttributeUsage_MaxWidth&quot;></a>## XAML 属性の使用```   <object MaxWidth=&quot;double&quot;/>   - or -   <object MaxWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxWidth&quot;> </a> ## XAML 値*二重*<xref:System.Double>の文字列表現を<xref:System.Double>0.0 以上の値</xref:System.Double></xref:System.Double>。           これは、[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]測定します。 明示的に、文字列では、小数点を含める必要がありますされません。 値のインスタンス`1`は許容されます。       同じ<xref:System.Double>プロパティの値セクションで説明したように範囲の制限を適用する必要がありますを使用する点を除いて[X:static マークアップ拡張機能](~/add/includes/ajax-current-ext-md.md) <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity>する値を設定する</xref:System.Double>       *qualifiedDouble* A*二重*値、上記と続けて次の単位の宣言文字列のいずれかの: `px`、 `in`、 `cm`、`pt`です。       `px`(既定値) は[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]`in`インチ; は、1 in 96px を = =`cm`センチメートル; は、1cm==(96/2.54) px`pt`ポイント; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxWidth&quot;> </a> ## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxWidthProperty>       "
  syntax:
    content: public double MaxWidth { get; set; }
    return:
      type: System.Double
      description: "要素の最大の幅の[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]します。 既定値は<xref:System.Double>。</xref:System.Double> この値は、0.0 以上の任意の値を指定できます。 <xref:System.Double>でも有効です。</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  id: MaxWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.MaxWidth*>依存関係プロパティ</xref:System.Windows.FrameworkElement.MaxWidth*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  id: MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "実装して basic 測定パス レイアウト システムの動作<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>です。"
  remarks: "このメソッドは<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>WPF コア レベルと WPF フレームワーク レベルのレイアウトの測定の実装に接続する</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>。 <xref:System.Windows.FrameworkElement>実装メソッドをシールします</xref:System.Windows.FrameworkElement>。 WPF フレームワーク レベル上に構築される要素の測定パス レイアウト動作を調整するのには、オーバーライド<xref:System.Windows.FrameworkElement.MeasureOverride%2A>代わりにします</xref:System.Windows.FrameworkElement.MeasureOverride%2A>。 意図的に、WPF フレームワーク レベルでの構築やしない<xref:System.Windows.FrameworkElement><xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>。</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>の上書き</xref:System.Windows.FrameworkElement>を使用して要素の測定パス レイアウト動作を調整するには"
  syntax:
    content: protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "親要素が子要素に提供できるサイズ。"
    return:
      type: System.Windows.Size
      description: "この要素のレイアウトでの目的のサイズ。"
  overload: System.Windows.FrameworkElement.MeasureCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  id: MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、子要素に必要なレイアウトのサイズを測定しのサイズを決定、 <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>-クラスを派生します。"
  remarks: "上書きに含まれているように、要素のカスタム レイアウトのサイズ変更動作を実装する MeasureOverride、[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]レイアウト システムです。 実装は、以下を実行する必要があります: 1。  レイアウト、呼び出しの一部である子の要素の特定のコレクションを反復処理する<xref:System.Windows.UIElement.Measure%2A>で各子要素です</xref:System.Windows.UIElement.Measure%2A>。      2.  すぐに<xref:System.Windows.UIElement.DesiredSize%2A>の子で (これには、設定後にプロパティとして<xref:System.Windows.UIElement.Measure%2A>と呼びます).</xref:System.Windows.UIElement.Measure%2A> </xref:System.Windows.UIElement.DesiredSize%2A>      3.  子要素の測定に基づく親の net 目的のサイズを計算します。       MeasureOverride の戻り値は、現在の要素の親要素のメジャーの入力となる要素の独自必要なサイズにする必要があります。 ページのルート要素に到達するまでは、レイアウト システムでこの同じプロセスが続行されます。       このプロセス中には、子要素より大規模なに返す場合があります<xref:System.Windows.UIElement.DesiredSize%2A>最初よりもサイズ`availableSize`を子要素がより多くの領域を依頼するかを示します</xref:System.Windows.UIElement.DesiredSize%2A>。 これは、何らかのスタックの順序、または任意の数の測定] または [コンテンツの配置のソリューションを確立することによって、親コントロールのサイズを変更して、スクロール可能な領域を導入することにより、独自の実装で処理可能性があります。      > [!IMPORTANT] > 要素を呼び出す必要があります<xref:System.Windows.UIElement.Measure%2A>でこの処理中にそれぞれの子では、それ以外の場合、子要素は正しくサイズまたはされません配置</xref:System.Windows.UIElement.Measure%2A>。"
  syntax:
    content: protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "この要素は子要素に提供できるサイズ。 無限大は、どのようなコンテンツが利用可能な要素のサイズはことを示す値として指定できます。"
    return:
      type: System.Windows.Size
      description: "この要素が判断するサイズは、子要素のサイズの計算に基づいて、レイアウト時に必要があります。"
  overload: System.Windows.FrameworkElement.MeasureOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeight
  id: MinHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の高さの最小値制約を設定します。"
  remarks: "これには&3; つのプロパティのいずれかの<xref:System.Windows.FrameworkElement>高さ情報を指定する</xref:System.Windows.FrameworkElement>。  他の&2; つは<xref:System.Windows.FrameworkElement.Height%2A>および<xref:System.Windows.FrameworkElement.MaxHeight%2A>。</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.Height%2A> 競合する場合、これらの値では、アプリケーションの順序との間の実際の高さの決定は、最初の MinHeight 受け付ける必要があります、し<xref:System.Windows.FrameworkElement.MaxHeight%2A>、最後に、 <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A>境界内にあるこれらの各場合</xref:System.Windows.FrameworkElement.MaxHeight%2A>       値の制限、<xref:System.Double>によって値が適用される、<xref:System.Windows.ValidateValueCallback>メカニズム</xref:System.Windows.ValidateValueCallback></xref:System.Double>。 無効な値を設定しようとすると、実行時例外がスローされます。      <a name=&quot;xamlAttributeUsage_MinHeight&quot;></a>## XAML 属性の使用```   <object MinHeight=&quot;double&quot;/>   - or -   <object MinHeight=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinHeight&quot;> </a> ## XAML 値*二重*<xref:System.Double>の文字列表現を<xref:System.Double>0.0 以上の値</xref:System.Double></xref:System.Double>。           これは、[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]測定します。 明示的に、文字列では、小数点を含める必要がありますされません。 値のインスタンス`1`は許容されます。       同じ<xref:System.Double>プロパティの値セクションで説明したように範囲の制限が適用されます</xref:System.Double>。       *qualifiedDouble* A*二重*値、上記と続けて次の単位の宣言文字列のいずれかの: `px`、 `in`、 `cm`、`pt`です。       `px`(既定値) は[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]`in`インチ; は、1 in 96px を = =`cm`センチメートル; は、1cm==(96/2.54) px`pt`ポイント; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinHeight&quot;> </a> ## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.MinHeightProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinHeightProperty>       "
  syntax:
    content: public double MinHeight { get; set; }
    return:
      type: System.Double
      description: "要素の高さの最小値で、[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]です。 既定値は 0.0 です。 この値は、0.0 以上の任意の値を指定できます。 ただし、<xref:System.Double>が有効でもありません&lt;xref:System.Double?displayProperty=fullName&gt;</xref:System.Double> 。"
  overload: System.Windows.FrameworkElement.MinHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeightProperty
  id: MinHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.MinHeight*>依存関係プロパティ</xref:System.Windows.FrameworkElement.MinHeight*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidth
  id: MinWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の幅の最小値制約を設定します。"
  remarks: "これには&3; つのプロパティのいずれかの<xref:System.Windows.FrameworkElement>幅情報を指定する</xref:System.Windows.FrameworkElement>。  他の&2; つは<xref:System.Windows.FrameworkElement.Width%2A>および<xref:System.Windows.FrameworkElement.MaxWidth%2A>。</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.Width%2A>  競合する場合、これらの値では、アプリケーションの順序との間の実際の幅の決定は、最初の MinWidth 受け付ける必要があります、し<xref:System.Windows.FrameworkElement.MaxWidth%2A>、最後に、 <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A>境界内にあるこれらの各場合</xref:System.Windows.FrameworkElement.MaxWidth%2A>       値の制限、<xref:System.Double>によって値が適用される、<xref:System.Windows.ValidateValueCallback>メカニズム</xref:System.Windows.ValidateValueCallback></xref:System.Double>。 無効な値を設定しようとすると、実行時例外がスローされます。      <a name=&quot;xamlAttributeUsage_MinWidth&quot;></a>## XAML 属性の使用```   <object MinWidth=&quot;double&quot;/>   - or -   <object MinWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> ## XAML 値*二重*<xref:System.Double>の文字列表現を<xref:System.Double>0.0 以上の値</xref:System.Double></xref:System.Double>。           これは、[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]測定します。 明示的に、文字列では、小数点を含める必要がありますされません。 値のインスタンス`1`は許容されます。       同じ<xref:System.Double>プロパティの値セクションで説明したように範囲の制限が適用されます</xref:System.Double>。       *qualifiedDouble* A*二重*値、上記と続けて次の単位の宣言文字列のいずれかの: `px`、 `in`、 `cm`、`pt`です。       `px`(既定値) は[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]`in`インチ; は、1 in 96px を = =`cm`センチメートル; は、1cm==(96/2.54) px`pt`ポイント; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinWidth&quot;> </a> ## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.MinWidthProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinWidthProperty>       "
  syntax:
    content: public double MinWidth { get; set; }
    return:
      type: System.Double
      description: "要素の幅の最小値で、[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]です。 既定値は 0.0 です。 この値は、0.0 以上の任意の値を指定できます。 ただし、<xref:System.Double>が無効でもありません&lt;xref:System.Double?displayProperty=fullName&gt;</xref:System.Double> 。"
  overload: System.Windows.FrameworkElement.MinWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidthProperty
  id: MinWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.MinWidth*>依存関係プロパティ</xref:System.Windows.FrameworkElement.MinWidth*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定した移動の方向には、この要素から離れた場所および別の要素にキーボード フォーカスを移動します。"
  remarks: "この実装をオーバーライド<xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>メソッドをシールと</xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>。"
  example:
  - "The following example implements a handler that handles several possible button inputs. Each button represents a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls MoveFocus on that element, by specifying the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided.  \n  \n [!code-cs[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#focussamplemovefocus)]\n [!code-vb[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#focussamplemovefocus)]"
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "フォーカスが列挙体の値として、移動するのには方向です。"
    return:
      type: System.Boolean
      description: "返します<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>フォーカスが正常に移動された場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>でしたいないキーボード フォーカスするか、存在しないと方向にターゲット要素が指定されている場合。"
  overload: System.Windows.FrameworkElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Name
  id: Name
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の識別名を設定します。 処理中に、構築された後、マークアップ要素を分離コード、イベント ハンドラー コードなどが参照できるように、この名前が、参照を提供する[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]プロセッサ。"
  remarks: "このプロパティの最も一般的な使用法を指定する、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]マークアップの属性と要素の名前。       このプロパティでは、WPF フレームワーク レベルの便利なプロパティを設定する基本的にでは、 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [X:name ディレクティブ](~/add/includes/ajax-current-ext-md.md)です。       名は、名前スコープ内で一意でなければなりません。 詳細については、次を参照してください。 [WPF XAML 名前スコープ](~/add/includes/ajax-current-ext-md.md)です。       コード内の要素を作成する場合、名前を取得することは、一般的ではありません。 既に適切な参照をコードにある場合だけメソッドを呼び出すことができ、要素のプロパティを参照し、名前を通常は必要はありません。 この例外は、名前文字列オーバー ロードされたに意味が内でその名前を表示すると便利である場合[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]です。 元の名前は、マークアップから設定した場合のコード ビハインドから名前もお勧めしません設定と読み込み後、プロパティを変更する、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]元のオブジェクト参照は変更されません。 基になる名前スコープは、解析時に明示的に作成された場合にのみ、オブジェクト参照が作成されます。 具体的に呼び出す必要があります<xref:System.Windows.FrameworkElement.RegisterName%2A>、効果的な既に読み込まれた要素の Name プロパティに変更します</xref:System.Windows.FrameworkElement.RegisterName%2A>。       コードから設定名が重要となる&1; つの主なケースは、実行時に参照できるように、ストーリー ボードの実行対象を要素の名前を登録する場合です。 名前を登録することができます、前にも必要になるをインスタンス化し、割り当てます、<xref:System.Windows.NameScope>インスタンス</xref:System.Windows.NameScope>。 使用例」を参照してください。 または[ストーリー ボードの概要](~/add/includes/ajax-current-ext-md.md)です。       アプリケーションが制限されているコードから設定名が、名前で要素を取得するが一般的です。 1 つのシナリオは、アプリケーションがここで、アプリケーションにページが再読み込みされ、必ずしもそのページに対して定義されている分離コードが実行時のコードではありませんは、ナビゲーション モデルをサポートするかどうかです。 ユーティリティ メソッド<xref:System.Windows.FrameworkElement.FindName%2A>、これは、 <xref:System.Windows.FrameworkElement>、検索の必要に応じて、ツリーを再帰的に、その要素の論理ツリーの名前で要素を検索できます</xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement.FindName%2A>。 使用することができます、<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>の静的メソッド<xref:System.Windows.LogicalTreeHelper>、名前の文字列を引数としても扱う</xref:System.Windows.LogicalTreeHelper></xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>。       通常使用されるルート要素 (<xref:System.Windows.Window>、<xref:System.Windows.Controls.Page>たとえば) <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope>インターフェイスを実装して</xref:System.Windows.Controls.Page></xref:System.Windows.Window> 名前をそのスコープ内で明確にすることを強制するには、このインターフェイスの実装が予想されます。 このインターフェイスを定義するルート要素は、すべての名前スコープの動作の境界を定義するも、関連する[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]です。       Name プロパティは、他のプロセスの識別子としても機能します。 インスタンス、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]オートメーション モデルはクライアントとプロバイダーの AutomationId として名前を使用するがします。       名に使用される文字列値は、基になるによって課されるようにいくつかの制限をある[X:name ディレクティブ](../Topic/x:Name%20Directive.md)によって定義された、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]仕様です。 最も顕著な名前はアルファベットまたはアンダー スコア文字 (_) で始める必要があり、文字、数字、またはアンダー スコアのみを含める必要があります。 詳細については、次を参照してください。 [WPF XAML 名前スコープ](../Topic/WPF%20XAML%20Namescopes.md)です。       アニメーション化することはできません非常にいくつかの依存関係プロパティのいずれかが名 (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>は`true`メタデータに) 名前自体は、アニメーションを対象とするための重要なので、</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 。 名前のバインド データ技術的に可能ですが、非常に一般的ではないシナリオでは、データ バインドの名前がプロパティの主な使用目的を使用できません。 分離コードの識別子の接続ポイントを提供します。      <a name=&quot;dependencyPropertyInfo_Name&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.NameProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkElement.NameProperty>"
  example:
  - "The following example sets the Name property in code, and then registers the name into the newly created <xref:System.Windows.NameScope> by calling <xref:System.Windows.FrameworkElement.RegisterName%2A>. The technique illustrated here is a requirement for animating with storyboards, because storyboards require targeting by the Name, and cannot be targeted by object reference.  \n  \n [!code-vb[animateHeight_procedural#FEName](~/add/codesnippet/visualbasic/animateheight/animatedheightexample.vb#fename)]\n [!code-cs[animateHeight_procedural#FEName](~/add/codesnippet/csharp/animateheight_csharp/AnimatedHeightExample.cs#fename)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "要素の名前です。 既定では、空の文字列です。"
  overload: System.Windows.FrameworkElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Name*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Name*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  id: OnApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされるが必ず呼び出されます<xref:System.Windows.FrameworkElement.ApplyTemplate*>。</xref:System.Windows.FrameworkElement.ApplyTemplate*>を呼び出すアプリケーション コードまたは内部プロセス"
  remarks: "このメソッドには、既定の実装ではありません。       テンプレートのテンプレートのプロパティから派生した要素の完成したビジュアル ツリーのセクションでは、<xref:System.Windows.Style>要素に適用されている</xref:System.Windows.Style>。 詳細については、次を参照してください。[スタイルとテンプレート](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public virtual void OnApplyTemplate ();
    parameters: []
  overload: System.Windows.FrameworkElement.OnApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未処理のたびに呼び出されます<xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;></xref>ルーティング イベントがそのルート上で、このクラスに到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "イベントに関するデータを提供します。"
  overload: System.Windows.FrameworkElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未処理のたびに呼び出されます<xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;></xref>ルーティング イベントがそのルート上で、このクラスに到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.FrameworkElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未処理のたびに呼び出されます<xref href=&quot;System.Windows.UIElement.GotFocus&quot;></xref>イベントがそのルート上でこの要素に到達します。"
  remarks: "その他のとは異なり * ベースの要素では、フォーカスで公開されたメソッドには、既定の実装です。 具体的には、 <xref:System.Windows.UIElement.OnGotFocus%2A>。</xref:System.Windows.UIElement.OnGotFocus%2A>ダウン基本要素の次のレベルで null の実装をオーバーライドする実装があります。 呼び出されると、フォーカスはキーボード フォーカスのため、現在の要素からイベントが発生した場合は、この要素の適切なフォーカスの動作を設定します。 フォーカス ハンドラーは、現在の要素にフォーカスが設定されている場合でも、処理済みとしてイベント引数をマークしません。 イベントのソースが別の要素ツリーで、(現在の要素ではなく) の場合は、ハンドラーは、何も実行します。       要素のフォーカスの既定の動作を変更するは、この方法でフォーカスの動作を変更する向上を実現するのにまったくフォーカス可能な要素を許可しないことによって対応するためにこのメソッドをオーバーライドすることができます (を参照してください<xref:System.Windows.UIElement.Focusable%2A>).</xref:System.Windows.UIElement.Focusable%2A>"
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.FrameworkElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "発生させる、 <xref href=&quot;System.Windows.FrameworkElement.Initialized&quot;> </xref>イベント。 このメソッドが呼び出されるたびに<xref:System.Windows.FrameworkElement.IsInitialized*>に設定されている<xref uid=&quot;langword_csharp_true &quot; name=&quot;true &quot; href=&quot;&quot;></xref>内部的にします</xref:System.Windows.FrameworkElement.IsInitialized*>。"
  remarks: "This particular On* method is not a class handler hook. Nor does it exactly follow the established [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] On\\* method convention that the matching event could be suppressed by overriding this method and not calling the base implementation.  \n  \n Note that the <xref:System.Windows.FrameworkElement.IsInitialized%2A> property is read-only, so you cannot set <xref:System.Windows.FrameworkElement.IsInitialized%2A> to force initialization behavior. Setting the initialization state is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.FrameworkElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "ときに呼び出されるこの依存関係プロパティの有効な値<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>が更新されました。 変更された特定の依存関係プロパティが引数パラメーターで報告されます。 <xref:System.Windows.DependencyObject.OnPropertyChanged*>。</xref:System.Windows.DependencyObject.OnPropertyChanged*>をオーバーライドします。"
  remarks: "このメソッドは、通常、プロパティの変更または無効化を検出するものではありません。 代わりに目的が、一般的な無効化パターンの変更があったプロパティの広範な分類に関する特定の情報がわかっている場合。       このメソッドでは、オブジェクトの有効期間中に何度もを呼び出す可能性があります。 したがって、特定のプロパティのメタデータをオーバーライドし、適用するを使用するパフォーマンスが向上を実現できます<xref:System.Windows.CoerceValueCallback>または<xref:System.Windows.PropertyChangedCallback>個々 のプロパティ</xref:System.Windows.PropertyChangedCallback></xref:System.Windows.CoerceValueCallback>。 場合にこのメソッドを使用すると、<xref:System.Windows.FrameworkElement>多数の値と相互に依存関係プロパティを含む動作をレンダリングする必要がありますを再実行関連のプロパティの無効化のケースのいくつかのようにロジックが含まれている場合またはします</xref:System.Windows.FrameworkElement>。       ある同じ名前に注意してください`OnPropertyChanged`異なるシグネチャを持つメソッド (パラメーターの型が<xref:System.ComponentModel.PropertyChangedEventArgs>) に多数のクラスに表示されることができます</xref:System.ComponentModel.PropertyChangedEventArgs>。 ある`OnPropertyChanged` <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged>のコントラクトの一部であり、データ オブジェクトの通知に使用"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "変更されたプロパティを説明するイベント データだけでなく古い値と新しい値。"
  overload: System.Windows.FrameworkElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  id: OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "発生させます、 <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref>イベント、最終的なイベント データの一部として指定した情報を使用します。"
  remarks: "このメソッドは<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>。</xref:System.Windows.UIElement.OnRenderSizeChanged%2A> このメソッドを呼び出す場合は、リセット、 <xref:System.Windows.FrameworkElement.ActualWidth%2A>、プロパティ、<xref:System.Windows.FrameworkElement.ActualHeight%2A>プロパティ、またはその両方として指定されている内容によっては、指定された引数で変更されは常にイベントが発生する</xref:System.Windows.FrameworkElement.ActualHeight%2A></xref:System.Windows.FrameworkElement.ActualWidth%2A>。"
  syntax:
    content: protected override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);
    parameters:
    - id: sizeInfo
      type: System.Windows.SizeChangedInfo
      description: "古いマスター_キーと新しいサイズ変更に関係の詳細です。"
  overload: System.Windows.FrameworkElement.OnRenderSizeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素で使用中でスタイルが変更されたときに呼び出されると、レイアウトを無効になります。"
  remarks: "このメソッドには、スタイルが変更された状態を記録する内部フラグを設定する既定の実装があります。"
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "古いスタイルです。"
    - id: newStyle
      type: System.Windows.Style
      description: "新しいスタイルです。"
  overload: System.Windows.FrameworkElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未処理のたびに呼び出されます<xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;></xref>ルーティング イベントがそのルート上で、このクラスに到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "イベントに関するデータを提供します。"
  overload: System.Windows.FrameworkElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "呼び出されるたびに、 <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref>ルーティング イベントがそのルート上で、このクラスに到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "イベントに関するデータを提供します。"
  overload: System.Windows.FrameworkElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "ビジュアル ツリー内のこの要素の親が変更されたときに呼び出されます。 <xref:System.Windows.UIElement.OnVisualParentChanged*>。</xref:System.Windows.UIElement.OnVisualParentChanged*>をオーバーライドします。"
  remarks: "ビジュアル ツリーは、コレクションなどに視覚的にレンダリングされない要素を省略しているので、論理ツリーから異なる可能性がありますし、そのテーマとスタイルの合成に基づいていくつかの要素を展開します。 詳細については、次を参照してください。 [wpf ツリー](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "前の親要素です。 あります<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>する要素がありませんでしたビジュアル親以前を示すためにします。"
  overload: System.Windows.FrameworkElement.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはテーマ スタイルのスタイル プロパティがこの要素に組み込むかどうかを示す値を設定します。"
  remarks: "このプロパティの最も一般的な使用法は、テーマとスタイルを提供しているスタイルのセッター内の間接的な使用率です。      > [!IMPORTANT] > 設定した場合は、OverridesDefaultStyle`true`テーマ スタイルによって提供される既定のコントロール テンプレートをコントロールに抑制されます。 コンテンツの発表者と基本を提供するその他の合成要素が通常コントロール テンプレートに含まれています[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]機能およびコントロールのビジュアル化。 を、既定のテーマ スタイルと同じ機能をサポートするために続行するには、制御する場合は、同じ構造をレプリケートするコントロール テンプレートを使用して別のスタイルを指定してください。 詳細については、次を参照してください。[コントロールの作成の概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素は、テーマのスタイル プロパティを使用していない場合すべての元のスタイル プロパティはローカル アプリケーションのスタイルから取り出され、テーマのスタイル プロパティは適用されません。 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>場合はアプリケーション スタイルが最初に、適用し、アプリケーションのスタイルで具体的には設定されていないプロパティのテーマ スタイルを適用します。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>依存関係プロパティ</xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Parent
  id: Parent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の論理上の親要素を取得します。"
  remarks: "親があります`null`要素がインスタンス化されましたが、最終的に、ページ レベルのルート要素、または、アプリケーション オブジェクトに接続するすべての論理ツリーにアタッチされていない場合。       要素の論理上の親が、アプリケーションの機能に応じて変わることが可能性のある、このプロパティの値を維持するその変更は反映されないことに注意してください。 通常必要があります値を取得する必要がある直前です。       参照してください[wpf ツリー](~/add/includes/ajax-current-ext-md.md)論理ツリーの移動、および親要素の検出の手法として親を使用して、適切なシナリオの詳細についてはします。       プロパティのエンジンは可能性があると再計算要素のすべてのプロパティ値が親を再指定、いくつかのプロパティは、論理ツリーを使用して値を継承するため。 <xref:System.Windows.FrameworkElement.DataContext%2A>にバインドできますも変更を適用します</xref:System.Windows.FrameworkElement.DataContext%2A>。       要素の親の変更は通常によってのみ行われますコレクションの操作、dedicated を使用して追加または削除メソッド、または、要素のコンテンツのプロパティを設定します。       親プロパティを使用する最も一般的なシナリオでは参照を取得して、さまざまな取得を<xref:System.Windows.FrameworkElement>親からのプロパティ値</xref:System.Windows.FrameworkElement>。 最終的に、テンプレートの親であるが、テンプレートの`null`します。 このポイント以降をテンプレートが実際に適用されている論理ツリーにまで拡張<xref:System.Windows.FrameworkElement.TemplatedParent%2A>。</xref:System.Windows.FrameworkElement.TemplatedParent%2A>を使用します。       このプロパティに論理ツリーの親と異なる場合のビジュアル ツリーの親が報告されていないことに注意してください。 ビジュアル ツリーの親では、通常重要アプリケーションの一般的なケースではないが、visual 特定レベルの場合に必要な親要素があります。 <xref:System.Windows.Media.VisualTreeHelper>。</xref:System.Windows.Media.VisualTreeHelper>を参照してください。"
  example:
  - "The following example shows code that checks for an element's parent, and then uses property values from the parent to set properties on the child element to match. In this case these are properties that affect the rendering size.  \n  \n [!code-vb[GeometryDesigner#FEParentProperty](~/add/codesnippet/visualbasic/geometrydesigner/window1.xaml.vb#feparentproperty)]\n [!code-cs[GeometryDesigner#FEParentProperty](~/add/codesnippet/csharp/GeometryDesigner/Window1.xaml.cs#feparentproperty)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "この要素の論理上の親です。"
  overload: System.Windows.FrameworkElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  id: ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "特殊なサブクラスでインクリメンタル レイアウトの実装をサポートしている<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>です。 ParentLayoutInvalidated は子要素が親のメジャーに影響を与えるとしてのメタデータでマークされているプロパティを無効にすると呼び出されるまたは配置レイアウト時にパスします。"
  remarks: "この要素の子要素をいくつかのプロパティは無効化およびプロパティがあるとマークされた場合<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>または<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>でプロパティのメタデータの登録中に、このメソッドが呼び出されます</xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A></xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>。 メソッドの呼び出しでは、この要素は、レイアウトの部分 (増分) の更新をサポートしている場合は、特定の子要素を再測定する必要があります、親要素に通知します。       既定では、<xref:System.Windows.FrameworkElement>増分のレイアウトをサポートしていませんし、、<xref:System.Windows.FrameworkElement>クラスのこのメソッドは既定の実装を持ちません</xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement>。 既定のレイアウト システムの動作を変更することが必要なために、ここでこのメソッドをオーバーライドする必要があるシナリオは一般的ではありません。       クラスが、WPF フレームワーク レベルのレイアウト システムよりも大幅に制限は、使用可能な子要素の型の制限を持っているかどうかには、実装のシナリオ例があります。 これらのカスタム要素の性質上、プロパティが変更された可能性があります意図的を延期する一部のカスタム レイアウトの動作を実装する場合。 たとえば、特定の種類別のレイアウト パスになる通常の変更のメジャー/配置メソッドのオーバーライドを描画パスを子要素を最適化しようとするを遅らせることができます。"
  syntax:
    content: protected virtual void ParentLayoutInvalidated (System.Windows.UIElement child);
    parameters:
    - id: child
      type: System.Windows.UIElement
      description: "変更を報告する子要素です。"
  overload: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定したフォーカスの移動方向をこの要素に相対的なフォーカスを受け取るが、実際には、フォーカスを移動できない次の要素を決定します。"
  remarks: "<xref:System.Windows.FrameworkElement.MoveFocus%2A>実際には、フォーカスを移動するが関連する方法です。</xref:System.Windows.FrameworkElement.MoveFocus%2A>"
  example:
  - "The following example implements a handler that handles several possible button inputs, each button representing a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls PredictFocus on that element, and specifies the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided. Instead of moving to that element as <xref:System.Windows.FrameworkElement.MoveFocus%2A> would do, the handler changes the physical dimensions of the predicted focus destination for visualization purposes.  \n  \n [!code-cs[FocusSample#FEPredictFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#fepredictfocus)]\n [!code-vb[FocusSample#FEPredictFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#fepredictfocus)]"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "使用予定のフォーカスの変更を決定する必要があります方向です。"
    return:
      type: System.Windows.DependencyObject
      description: "対象にした次の要素は、フォーカスが実際に走査された場合に移動します。 返す可能性があります<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>フォーカスをこの要素に相対的な指定した方向に移動できない場合。"
  overload: System.Windows.FrameworkElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. PredictFocus を次の手順はできません (の法律が<xref:System.Windows.FrameworkElement.MoveFocus*>).</xref:System.Windows.FrameworkElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "アクセスを簡素化するアクセサーを提供、<xref:System.Windows.NameScope>登録方法</xref:System.Windows.NameScope>。"
  remarks: "このメソッドは<xref:System.Windows.NameScope.RegisterName%2A>。</xref:System.Windows.NameScope.RegisterName%2A>を呼び出すための便利なメソッド 実装は、該当する<xref:System.Windows.NameScope><xref:System.Windows.Markup.INameScope>。</xref:System.Windows.Markup.INameScope>を実装する要素を検索して検出される実装</xref:System.Windows.NameScope>が見つかるまで、連続する親要素は確認します。 名前スコープの詳細については、次を参照してください。 [WPF XAML 名前スコープ](~/add/includes/ajax-current-ext-md.md)です。       RegisterName を呼び出すことは、アプリケーション コードで作成されたときのアニメーションのストーリー ボードを正しくフックするために必要があります。 これは、プロパティ、キーのいずれかのストーリー ボード作成ため<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>、ターゲット要素への参照を実行することではなく実行時の名前検索を使用します</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>。 これは、その要素が、コードから参照渡しでアクセス可能な場合でも当てはまります。 ストーリー ボードのターゲットの名前を登録する必要がある理由の詳細については、次を参照してください。[ストーリー ボードの概要](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - >-
    [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/visualbasic/animateproperty_storyboards_vb/scopeexample.vb#namescopeexample)]
     [!code-cs[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/csharp/AnimateProperty_Storyboards_csharp/ScopeExample.cs#namescopeexample)]
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "指定した名前とオブジェクトのマッピングに使用する名前です。"
    - id: scopedElement
      type: System.Object
      description: "マッピングのオブジェクトです。"
  overload: System.Windows.FrameworkElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の論理ツリーから指定されたオブジェクトを削除します。 <xref href=&quot;System.Windows.FrameworkElement&quot;></xref>この削除と同期を維持する影響を受ける論理ツリーの親ポインターを更新します。"
  remarks: "要素の論理子を表すオブジェクトのコレクションの実装には、このメソッドを使用します。 これは、プロパティの getter または setter、クラスのハンドラーで行うことがあります`Changed`イベント、コンス トラクター、またはコレクション内でそれ自体の種類します。       指定された基本コントロール クラスのコンテンツ モデルに適切なものがない限りは、コントロールの作成者がこのレベルで論理ツリーを操作するはお勧めできません。 レベルのサブクラス化を検討してください<xref:System.Windows.Controls.ContentControl>、 <xref:System.Windows.Controls.ItemsControl>、 <xref:System.Windows.Controls.HeaderedItemsControl></xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 。 これらのクラスを介して専用の論理子の特定の強制使用したモデルのコンテンツを提供する[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]、その他の機能では通常望ましくのサポートに加えて、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]テンプレートを介してスタイルなどのコントロールです。"
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property's setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The values are cached, and then the new value is added to both the standard WPF framework level logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "削除する要素。"
  overload: System.Windows.FrameworkElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  id: RequestBringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "発生したときに<xref:System.Windows.FrameworkElement.BringIntoView*>はこの要素で呼び出されます</xref:System.Windows.FrameworkElement.BringIntoView*>。"
  remarks: "このイベントは、親を示します<xref:System.Windows.Controls.ScrollViewer>(またはその派生クラス) を RequestBringIntoView イベントを発生させる要素表示できるようにする、スクロール可能な地域内。</xref:System.Windows.Controls.ScrollViewer> 。 <xref:System.Windows.Controls.ScrollViewer>イベントのクラス処理を使用して、処理されると、マークは、RequestBringIntoView イベントが</xref:System.Windows.Controls.ScrollViewer>。 一般にイベント データ マークしないでまたはいずれかではスクロール可能な領域を制御するすべてのクラスによって処理される RequestBringIntoView インスタンス ハンドラー <xref:System.Windows.FrameworkElement.BringIntoView%2A>。</xref:System.Windows.FrameworkElement.BringIntoView%2A>と呼ばれる要素の目的の目標を妨害するそう      <a name=&quot;routedEventInfo_RequestBringIntoView&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.RequestBringIntoViewEventHandler>|</xref:System.Windows.RequestBringIntoViewEventHandler></xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>"
  syntax:
    content: public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;
    return:
      type: System.Windows.RequestBringIntoViewEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  id: RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.RequestBringIntoView&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Resources
  id: Resources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはローカルに定義されたリソース ディクショナリを設定します。"
  remarks: "完全または部分的に定義できるリソース ディクショナリ[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]は、通常、プロパティ要素として作成し、個々 のページまたはアプリケーションのルート要素には、通常します。 このレベルでリソース ディクショナリを配置すると、ページ内の個々 の子要素 (またはアプリケーションの場合、任意のページ) を検索しやすきます。 ほとんどのアプリケーション シナリオでは、ことをお勧めスタイルが、リソース ディクショナリ内のオブジェクト要素として定義されているスタイル リソース全体を自己完結型できるように、外部リソースとして定義するか (このアプローチは、分担デザイナーと開発者の責任を編集することが必要な物理ファイルを分離することにより、役立ちます)。       このプロパティをリソース ディクショナリだけがその要素内で直接宣言を返すことに注意してください。 これは、実際のリソース ルックアップ プロセスの子要素がアクセスできる場所の検索方向を再帰的に、各親要素で定義されているリソースとは異なるです。       リソースは、コレクション内からコードで参照することもできますでリソースが作成されたことに注意してください[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]確実アクセスできなくなりますまで後<xref:System.Windows.FrameworkElement.Loaded>ディクショナリを宣言する要素で発生します</xref:System.Windows.FrameworkElement.Loaded>。 実際には、リソースが解析されるに非同期的におよび not であっても、<xref:System.Windows.FrameworkElement.Loaded>イベントが参照できるように保証、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]リソースを定義します</xref:System.Windows.FrameworkElement.Loaded>。 このため、通常のみにアクセスする[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]またはその他の実行時のコードの一部としてリソースを定義[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]スタイルや属性の値をリソース拡張機能の参照などの手法です。 コードによって、リソースにアクセスするときに基本的と等価であるから行われます。 参照に[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]です。       基になる<xref:System.Windows.ResourceDictionary>追加、削除、またはコードを使用してから、コレクション内のリソースを照会するために必要なメソッドをサポートします</xref:System.Windows.ResourceDictionary>。 リソース プロパティは、完全に新しい要素のリソースのコレクションを置き換えるのシナリオをサポートする設定、または異なる<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       注意して、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]に示す構文は<xref:System.Windows.ResourceDictionary></xref:System.Windows.ResourceDictionary>要素が含まれません。 これは、暗黙の型のコレクション構文の例コレクションの要素を表すタグを省略できます。 代わりに、コレクションに項目として追加される要素を指定します。 暗黙の型のコレクションの詳細については、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]を参照してください[XAML 構文の詳細](~/add/includes/ajax-current-ext-md.md)です。 1 つ<xref:System.Windows.ResourceDictionary>要素は、マージされたディクショナリを導入する場合に要素がある通常ありません子<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>のように明示的に指定されています</xref:System.Windows.ResourceDictionary>がの場合 詳細については、「[リソース ディクショナリのトピックとマージ](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a>## XAML プロパティ要素の使用```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> ## XAML 値*oneOrMoreResourceElements*&1; つまたは複数のオブジェクト要素、それぞれのリソースを定義します。       各リソースのプロパティ要素内で各<xref:System.Windows.ResourceDictionary>に一意の値を持つ必要があります、 [X:key ディレクティブ](~/add/includes/ajax-current-ext-md.md)、 <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>から値を取得する際に一意のキーとして機能する</xref:System.Windows.ResourceDictionary>"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "ローカルで定義されたの現在のディクショナリ キーで各リソースにアクセスできる場所のリソース。"
  overload: System.Windows.FrameworkElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "データ ソースへのパスの修飾として指定されたソースのプロパティ名に基づく、この要素にバインドをアタッチします。"
  remarks: "このメソッドは、便利なメソッドを呼び出す<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>、として現在のインスタンスを渡しますが、 <xref:System.Windows.DependencyObject>、新たに作成および<xref:System.Windows.Data.Binding>に基づいて、指定した`path`パラメーター</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> 。 この署名は、単純な既定のバインディングを確立する場合に便利です。 既定以外の条件へのバインディング プロパティを指定するか、使用する必要がある場合、<xref:System.Windows.Data.MultiBinding>または<xref:System.Windows.Data.PriorityBinding>、使用する必要があります、<xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>署名</xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29></xref:System.Windows.Data.PriorityBinding></xref:System.Windows.Data.MultiBinding>。"
  example:
  - "The following example sets a binding using a specific path.  \n  \n [!code-cs[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#setbindingpath)]\n [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#setbindingpath)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "バインドを確立する必要がある対象になるプロパティを識別します。"
    - id: path
      type: System.String
      description: "ソースのプロパティ名、または、バインディングの使用プロパティへのパス。"
    return:
      type: System.Windows.Data.BindingExpression
      description: "バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。"
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定したバインディング オブジェクトに基づいて、この要素にバインドをアタッチします。"
  remarks: "このメソッドは<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName><xref:System.Windows.DependencyObject>。</xref:System.Windows.DependencyObject>として現在のインスタンスを渡します</xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>を呼び出すための便利なメソッド"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "バインドを確立する必要があるプロパティを識別します。"
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "データ バインディングの詳細を表します。"
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。"
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  id: SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "値を設定、<xref:System.Windows.FrameworkElement.FlowDirection*>添付プロパティを指定した要素</xref:System.Windows.FrameworkElement.FlowDirection*>。"
  remarks: "このメソッドは、の添付プロパティの構文をサポートしている、<xref:System.Windows.FrameworkElement.FlowDirection%2A>プロパティを指定された要素に子をそのためようにする<xref:System.Windows.FrameworkElement>親要素内での配置のフロー方向を指定します</xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement.FlowDirection%2A>。 現在の値を設定する<xref:System.Windows.FrameworkElement>、ダイレクトを使用して[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]アクセサー <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "フローの方向を指定する要素。"
    - id: value
      type: System.Windows.FlowDirection
      description: "方向を指定する列挙体の値です。"
  overload: System.Windows.FrameworkElement.SetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定した名前のリソースを検索しへのリソース参照を指定したプロパティを設定します。"
  remarks: "リソースの参照の使用に似ていますが、 [DynamicResource マークアップ拡張機能](~/add/includes/ajax-current-ext-md.md)マークアップでします。 リソース参照では、実行時の遅延単位で指定したプロパティの値を提供する内部式を作成します。 式は、現在の要素が親を再指定する場合や、リソース ディクショナリが内部のイベントによって変更された値が示すされるたびに再評価されます (親の変更は、ディクショナリの検索パスを変更は)。"
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "リソースがバインドされているプロパティです。"
    - id: name
      type: System.Object
      description: "リソースの名前。"
  overload: System.Windows.FrameworkElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "シリアル化プロセスでの内容をシリアル化する必要かどうかを返します、<xref:System.Windows.FrameworkElement.Resources*>プロパティ</xref:System.Windows.FrameworkElement.Resources*>。"
  remarks: "これは、戻り値は`true`ローカル<xref:System.Windows.FrameworkElement.Resources%2A>.</xref:System.Windows.FrameworkElement.Resources%2A>の少なくとも&1; つのキーを持つリソースがある限り、"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、<xref:System.Windows.FrameworkElement.Resources*>プロパティの値が、それ以外のシリアル化する必要があります<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.FrameworkElement.Resources*> 。"
  overload: System.Windows.FrameworkElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "シリアル化プロセスでの内容をシリアル化する必要かどうかを返します、<xref:System.Windows.FrameworkElement.Style*>プロパティ</xref:System.Windows.FrameworkElement.Style*>。"
  remarks: "返されます`true`場合、<xref:System.Windows.Style>ローカルに設定します</xref:System.Windows.Style>。"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、<xref:System.Windows.FrameworkElement.Style*>プロパティの値が、それ以外のシリアル化する必要があります<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.FrameworkElement.Style*> 。"
  overload: System.Windows.FrameworkElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  id: ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "シリアル化プロセスでの内容をシリアル化する必要かどうかを返します、<xref:System.Windows.FrameworkElement.Triggers*>プロパティ</xref:System.Windows.FrameworkElement.Triggers*>。"
  remarks: "このメソッドが戻る`true`場合、<xref:System.Windows.FrameworkElement.Triggers%2A>プロパティがローカルに設定します</xref:System.Windows.FrameworkElement.Triggers%2A>。"
  syntax:
    content: public bool ShouldSerializeTriggers ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、<xref:System.Windows.FrameworkElement.Triggers*>プロパティの値が、それ以外のシリアル化する必要があります<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.FrameworkElement.Triggers*> 。"
  overload: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChanged
  id: SizeChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "発生したときにいずれか、 <> </> *> または<> *> プロパティは、この要素の値を変更します。"
  remarks: "ルーティング イベントを直接ルートに従っていない、発生したが、同じ要素内でのみ処理されます。 ルーティング イベントがその他のルーティング イベントの動作をサポートして直接: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<xref:System.Windows.EventTrigger>スタイルでします</xref:System.Windows.EventTrigger>。       レイアウト システム内のプロパティを読み取り、<xref:System.Windows.SizeChangedEventArgs>報告されるサイズの変更を重要な考慮するかどうかを決定する、このイベントの引数のクラス</xref:System.Windows.SizeChangedEventArgs>。 これにより、レイアウト システムや、コントロールに固有のレイアウトの実装を強制的に新旧の高さまたは幅の値の視覚的にこうしたわずかな違いのためのレイアウト変更を回避します。 こうしたわずかな違いは、浮動小数点データ型の丸め処理を行うか、同じ結果の計算があります。      <a name=&quot;routedEventInfo_SizeChanged&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.SizeChangedEventHandler>|</xref:System.Windows.SizeChangedEventHandler></xref:System.Windows.FrameworkElement.SizeChangedEvent>"
  syntax:
    content: public event System.Windows.SizeChangedEventHandler SizeChanged;
    return:
      type: System.Windows.SizeChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  id: SizeChangedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent SizeChangedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素にバインドする既存のプロパティの元の値が変更されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Data.Binding.SourceUpdated>いずれかが発生するイベントを<xref:System.Windows.Data.Binding>この要素に関連付けられている</xref:System.Windows.Data.Binding></xref:System.Windows.Data.Binding.SourceUpdated>。      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a>## XAML 属性の使用方法```   <object SourceUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Style
  id: Style
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはが表示される場合、この要素で使用されるスタイルを設定します。"
  remarks: "コントロールの現在のスタイルは多くの場合、コントロール テーマから既定のスタイルによって提供されるまたはスタイルから通常によって適用されるその種類のコントロールにページまたはアプリケーション レベル (暗黙的なスタイル) のリソース。 このプロパティは既定の設定したり返したり (テーマ) のスタイルが、暗黙的なスタイルまたは明示的なスタイル要素で動作しているのか、返します。 暗黙的または明示的なスタイルの場合、スタイルをリソースとして指定またはローカルに定義されているかどうかは関係ありません。       スタイルの設定の制限があります。 全体のスタイル プロパティをリセットするには新しい<xref:System.Windows.Style>、いつでもレイアウト再構成を強制する</xref:System.Windows.Style>。 ただし、そのスタイルが使用中で読み込まれた要素で配置されるとすぐとして、<xref:System.Windows.Style>と見なすべきシール</xref:System.Windows.Style>。 使用するスタイルの個々 のプロパティを変更しようとしています (などのコレクション内のすべて<xref:System.Windows.Style.Setters%2A>) 例外がスローされます</xref:System.Windows.Style.Setters%2A>。 マークアップで定義されているスタイルは、(リソース) のリソース ディクショナリから読み込まれるか (インライン スタイル) に含まれているページが読み込まれるとすぐに使用すると見なされます。       スタイルは、特別な優先順位を持つ依存関係プロパティです。 ローカルに設定スタイルが通常プロパティ システムに最高の優先順位で動作します。 スタイルが null の場合この時点でのプロパティの読み込み中に、システムがその型を指定するローカルまたはアプリケーションのリソースで暗黙的なスタイルを確認します。 スタイルがこの手順の後にも null である場合、し、プレゼンテーションのための機能を実行するスタイル一般にソース (テーマ) の既定のスタイル、にもかかわらずスタイル プロパティの値に既定のスタイルは返されません。 参照してください[依存関係プロパティの値の優先順位](~/add/includes/ajax-current-ext-md.md)または[スタイルとテンプレート](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;xamlAttributeUsage_Style&quot;></a>## XAML 属性の使用```   <object Style=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Style&quot;> </a> ## XAML プロパティ要素の使用<a name=&quot;xamlValues_Style&quot;> </a> ## XAML 値*resourceExtension*次のいずれかの: または。       参照してください[XAML リソース](~/add/includes/ajax-current-ext-md.md)です。       *styleResourceKey*要求されているスタイルを識別するキー。 このキーは<xref:System.Windows.ResourceDictionary>。</xref:System.Windows.ResourceDictionary>で既存のリソース      > [!NOTE] > プロパティ要素構文は技術的に可能ですが、ほとんどのシナリオでスタイルをお勧めしません。 参照してください[インライン スタイルとテンプレート](~/add/includes/ajax-current-ext-md.md)です。 バインドの参照を使用して、または<xref:System.Windows.Data.Binding>も可能ですが、一般的ではない</xref:System.Windows.Data.Binding>。      <a name=&quot;dependencyPropertyInfo_Style&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.StyleProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.StyleProperty>"
  example:
  - "The following example defines a style in a resource dictionary.  \n  \n [!code-xml[FEResource#StyleProperty](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty)]  \n[!code-xml[FEResource#StyleProperty2](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty2)]  \n[!code-xml[FEResource#StyleProperty3](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty3)]  \n[!code-xml[FEResource#StyleProperty4](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty4)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "存在する場合は、要素に適用すると、既定以外のスタイル。 それ以外の場合、 <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。 既定で構築された既定<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Style*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Style*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "このメンバーの説明は、次を参照してください、<xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>メソッド。</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*> 。"
  remarks: "このメンバーは、明示的なインターフェイス メンバーの実装です。 使用する場合にのみ、<xref:System.Windows.FrameworkElement>にインスタンスをキャスト、<xref:System.Windows.Markup.IQueryAmbient>インターフェイス</xref:System.Windows.Markup.IQueryAmbient></xref:System.Windows.FrameworkElement>。"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "要求されたアンビエント プロパティの名前。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合<code> propertyName </code> 、それ以外の使用可能な<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Tag
  id: Tag
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはこの要素のカスタム情報を格納するために使用する任意のオブジェクトの値を設定します。"
  remarks: "このプロパティは、他のタグのプロパティに似た[!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)]などのプログラミング モデル[!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)]または[!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]です。 タグは、いずれかに関する基本的なカスタム情報を格納する既存プロパティの場所を指定して<xref:System.Windows.FrameworkElement>しなくてをサブクラス化要素です</xref:System.Windows.FrameworkElement>。       このプロパティは、オブジェクトを受け取り、ためにはタグ プロパティで設定するためにプロパティ要素の使用方法を使用する必要があります。[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]文字列などの、組み込みの既知の型コンバーターを使用したオブジェクト以外のすべてにします。 この方法で使用されるオブジェクトが、通常、標準[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]名前空間として導入するためを外部の名前空間を名前空間のマッピングに要する場合がありますので[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]要素。 詳細については、「 [XAML 名前空間と WPF XAML のマッピングの Namespace](~/add/includes/ajax-current-ext-md.md)と[XAML と WPF のカスタム クラス](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.TagProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "任意の値。 このプロパティには、既定値はありません。"
  overload: System.Windows.FrameworkElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Tag*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Tag*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素にプロパティ バインディングのターゲット値が変更されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Data.Binding.TargetUpdated>いずれかが発生するイベントを<xref:System.Windows.Data.Binding>この要素に関連付けられている</xref:System.Windows.Data.Binding></xref:System.Windows.Data.Binding.TargetUpdated>。 通常つまり、対象のバインディングは双方向のバインドおよびバインドされた依存関係プロパティが確認された、以前プロパティの値が現在の検証またはプロパティまたはデータ ソースをサポートするキャッシュのスキームに従った有効なです。       TargetUpdated イベントのイベント データを使用して、ターゲット値の更新を報告している特定のプロパティを決定します。      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a>## XAML 属性の使用方法```   <object TargetUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素の親テンプレートへの参照を取得します。 このプロパティは無効、要素がテンプレートから作成されていない場合です。"
  remarks: "TemplatedParent が頻繁に`null`アプリケーション マークアップやコード内に作成されるオブジェクト。 これは、テンプレートではなく、それらのオブジェクトを直接作成するためです。 オブジェクト参照を取得するかの一般的な名前参照で、ルートから論理ツリーをウォークすることによって、テンプレートから付属していません。       TemplatedParent ができない場合`null`visual を使用してツリーをウォーク特定低水準入力イベントのイベント処理のヒット テストなどの操作を含める<xref:System.Windows.Media.VisualTreeHelper>、または列挙子を使用する場合があります戻り値のテンプレートから得られた要素</xref:System.Windows.Media.VisualTreeHelper>。 別の場合は、明示的に呼び出すかどうか<xref:System.Windows.FrameworkTemplate.FindName%2A>既存に対して<xref:System.Windows.FrameworkTemplate>され、返されたオブジェクトを操作します</xref:System.Windows.FrameworkTemplate></xref:System.Windows.FrameworkTemplate.FindName%2A>。       テンプレートは、実際には共有オブジェクト、テンプレートの内容が&1; 回だけ作成される場所です。 そのため、テンプレートから得られた要素へのオブジェクト参照を取得する場合があります、見かけ上の論理ツリーは、ページのルートには到達できません。 このようなテンプレートへの参照をページの論理ツリーを接続するのには、TemplatedParent 値を取得し、必要に応じて、その要素ツリーのナビゲーションを続行する必要があります。"
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "要素が<xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>を作成するには、この要素の原因となった</xref:System.Windows.FrameworkTemplate.VisualTree*>。 この値は、頻繁に<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。「解説」を参照してください。"
  overload: System.Windows.FrameworkElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または設定でこの要素に対して表示されるツールヒント オブジェクト、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]です。"
  remarks: "このプロパティの値が型の場合<xref:System.Windows.Controls.ToolTip>、その値は、ツール ヒントで使用される、 [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]</xref:System.Windows.Controls.ToolTip> 。  値は、他の任意の型のかどうかは、その値として使用されます、*コンテンツ*の<xref:System.Windows.Controls.ToolTip>提供システムによって (作成).</xref:System.Windows.Controls.ToolTip> 詳細については、 <xref:System.Windows.Controls.ToolTipService>。</xref:System.Windows.Controls.ToolTipService>を参照してください。 サービス クラスには、 <xref:System.Windows.Controls.ToolTip>。</xref:System.Windows.Controls.ToolTip>をさらにカスタマイズするために使用する接続のプロパティが用意されています      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a>## XAML 属性の使用```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> ## XAML プロパティ要素の使用```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> ## XAML 値*toolTipContent*ツールヒントの表示テキストになる文字列。                   *方法*<xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement>コンテンツとして使用されるオブジェクト要素の形式、で提供される一部のオブジェクト。 通常、<xref:System.Windows.FrameworkElement>または最終的にテキストを含む、ツールヒントのレイアウトの合成を複合内でコンテンツを作成するその他の要素</xref:System.Windows.FrameworkElement>。 この使用率、<xref:System.Windows.Controls.ToolTip>要素が作成、解析されたから暗黙的に[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、および*方法*としてコンテンツを設定その<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>プロパティ</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName></xref:System.Windows.Controls.ToolTip>。       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ToolTipProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.FrameworkElement.ToolTipProperty>"
  example:
  - "The following example creates a <xref:System.Windows.Controls.ToolTip> in code and then sets the ToolTip property on a <xref:System.Windows.Controls.Primitives.StatusBar> control.  \n  \n [!code-vb[StatusBar#MakeProgressBar](~/add/codesnippet/visualbasic/statusbar/window1.xaml.vb#makeprogressbar)]\n [!code-cs[StatusBar#MakeProgressBar](~/add/codesnippet/csharp/StatusBar/Window1.xaml.cs#makeprogressbar)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "ツールヒントのオブジェクト。 なぜこのパラメーターがない厳密に型指定の詳細については、下の「解説」を参照してください。"
  overload: System.Windows.FrameworkElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "要素のツールヒントが閉じられる直前に発生します。"
  remarks: "ToolTipClosing イベントを処理済みとしてマークすることがキャンセルしていない、ツールヒントを終了します。 ツールヒントが表示されたらは、UI でのユーザー操作への応答でのみ行われますツールヒントを終了します。       このイベントをすることはできません、<xref:System.Windows.EventTrigger>スタイルでします</xref:System.Windows.EventTrigger>。 これは、このイベントの識別子フィールドが、サービスからのサービス レベルのイベントの追加と削除イベント メソッドを公開しない実装を再使用するためです。      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Controls.ToolTipEventHandler>|     -オーバーライド<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A></xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkElement.ToolTipClosingEvent>。"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "要素のツールヒントが開かれたときに発生します。"
  remarks: "ツールヒントが UI に表示されないようにするに関するのハンドラーをマークできます、<xref:System.Windows.Controls.ToolTipEventArgs>処理されるイベント データ</xref:System.Windows.Controls.ToolTipEventArgs>。 それ以外の場合、ツールヒントが表示されるの値を使用して、<xref:System.Windows.FrameworkElement.ToolTip%2A>ツールヒントのコンテンツとプロパティ</xref:System.Windows.FrameworkElement.ToolTip%2A>。 もう&1; つの可能なシナリオは、の値をリセットするハンドラーを記述することも、<xref:System.Windows.FrameworkElement.ToolTip%2A>ツールヒントが表示される直前にイベント ソースである要素のプロパティ</xref:System.Windows.FrameworkElement.ToolTip%2A>。       関するは発生しません場合の値<xref:System.Windows.FrameworkElement.ToolTip%2A>は`null`それ以外の場合、または設定解除します。</xref:System.Windows.FrameworkElement.ToolTip%2A> 。 意図的に設定しないでください<xref:System.Windows.FrameworkElement.ToolTip%2A>に`null`tooltip が開いているか、; これは、ツールヒントを閉じるための効果がありませんを開き、UI に望ましくない visual アーティファクトを作成、代わりにします</xref:System.Windows.FrameworkElement.ToolTip%2A>。       関するをすることはできません、<xref:System.Windows.EventTrigger>スタイルでします</xref:System.Windows.EventTrigger>。 これは、このイベントの識別子フィールドが、サービスからのサービス レベルのイベントの追加と削除イベント メソッドを公開しない実装を再使用するためです。      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Controls.ToolTipEventHandler>|     -オーバーライド<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A></xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>。"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.ToolTip*>依存関係プロパティ</xref:System.Windows.FrameworkElement.ToolTip*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Triggers
  id: Triggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素に直接または子要素で設定されているトリガーのコレクションを取得します。"
  remarks: "> [!NOTE]> このプロパティのみ設定できます[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]コレクション オブジェクトにアクセスして、追加などのさまざまなメソッドを使用して、表示、コレクション構文を使用します。 コレクション オブジェクト自体にアクセスするプロパティは読み取り専用で、コレクション自体は読み取り/書き込みです。 プロパティは、ルート要素にのみ存在します。検索や他の場所で設定しようとしています。 には、スローされる例外が発生します。       このプロパティでは、この要素で使用されているスタイルの一部として存在するトリガーを確認できません。 マークアップまたはコードで、このコレクションに追加されることはトリガーのコレクションを報告するだけです。 要素は、既存の既定では、このような要素を通常必要はありません (テンプレートからのインスタンス)。コントロールの複合スタイルの代わりに確立されるまでに由来するトリガーの一般的なであります。       動作 (およびのどの要素には、トリガーのコレクションが宣言されている元のどちらの効果を確立しようとしています) の観点からは、この要素があります、トリガーを起動する条件とトリガーの影響の両方または、論理ツリーの子要素にあります。 などの有効期間イベントを使用する場合は、<xref:System.Windows.FrameworkElement.Loaded>をこのコレクションを取得するには、子要素のトリガーできない可能性がありますまだ完全に読み込まれると、コレクションが実行時に真にするより小さくなります</xref:System.Windows.FrameworkElement.Loaded>。       要素に設定されているトリガーのコレクションのみをサポートする注<xref:System.Windows.EventTrigger>、ありませんプロパティ トリガー (<xref:System.Windows.Trigger>).</xref:System.Windows.Trigger> </xref:System.Windows.EventTrigger> プロパティ トリガーを必要とする場合は、スタイルまたはテンプレート内でこれらを挿入し、し、そのスタイルまたはテンプレートの要素に代入するかする必要があります経由で直接、<xref:System.Windows.FrameworkElement.Style%2A>プロパティ、または暗黙的なスタイル参照を通じて間接的にします</xref:System.Windows.FrameworkElement.Style%2A>。      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a>## XAML プロパティ要素の使用```   <object>     <object.Triggers>       oneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> ## XAML 値*oneOrMoreTriggers*&1; つ以上定義されている<xref:System.Windows.EventTrigger>要素</xref:System.Windows.EventTrigger>。       このような個々 のトリガーは、有効なストーリー ボード操作および参照を格納すると想定されます。 このコレクションは、ページのルート要素でのみ設定できますに注意してください。 詳細については、次を参照してください。[ストーリー ボードの概要](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "厳密に型指定されたコレクションの<xref href=&quot;System.Windows.Trigger&quot;></xref>オブジェクト。"
  overload: System.Windows.FrameworkElement.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定されたキーにリソースを検索し、場合、そのリソースを返しますが見つかりました。"
  remarks: "呼び出し元の要素で、リソースが見つからない場合は、親リソースのツリーが論理ツリーを上方向へ検索ツリーになる同じ方法で検索すると、リソースが要求されたキーによって実行時にします。 このメソッドを返します`null`任意の場所、リソースのツリーでそのキーのリソースが存在しなかった時点で、ツリーの既存の条件ごとその TryFindResource が呼び出された場合のみです。       通常返されたリソース値に設定しようとしているプロパティの型を戻り値をキャストするとすぐにします。       <xref:System.Windows.FrameworkElement.FindResource%2A>メソッドが指定されたキーを持つリソースが返されない場合、例外をスローする点を除いて、同様の動作が</xref:System.Windows.FrameworkElement.FindResource%2A>。"
  example:
  - "The following example is implemented as a button handler, where the button being clicked sets its background to a resource-defined brush obtained by calling TryFindResource on itself. This walks the element tree and finds the resource (the resource itself is defined in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] and is not shown).  \n  \n [!code-cs[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#fetryfindresource)]\n [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#fetryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "検索するリソースのキー識別子。"
    return:
      type: System.Object
      description: "見つかったリソースまたは<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>場合に指定されたリソースがありません<code> key </code>が見つかった。"
  overload: System.Windows.FrameworkElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "要素が読み込まれた要素の要素ツリーから削除されたときに発生します。"
  remarks: "ルーティング イベントを直接ルートに従っていない、発生したが、同じ要素内でのみ処理されます。 ルーティング イベントがその他のルーティング イベントの動作をサポートして直接: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<xref:System.Windows.EventTrigger>スタイルでします</xref:System.Windows.EventTrigger>。       <xref:System.Windows.FrameworkElement.Loaded>アンロードが両方で発生するユーザーによるシステムのテーマを変更した結果のコントロールです。</xref:System.Windows.FrameworkElement.Loaded> テーマの変更では、コントロール テンプレートと、コントロール全体をアンロードして再読み込みが含まれているビジュアル ツリーの無効化が発生します。 したがってアンロードの場合は、そのページから移動したときにのみ発生すると見なされますことはできません。       アプリケーションがシャット ダウン後にアンロード イベントは発生しませんに注意してください。 によって、条件が定義されているときに、アプリケーションのシャット ダウンが発生、<xref:System.Windows.Application.ShutdownMode%2A>プロパティが発生します</xref:System.Windows.Application.ShutdownMode%2A>。 ように、アンロード イベントのハンドラー内でクリーンアップ コードを配置した場合、<xref:System.Windows.Window>または<xref:System.Windows.Controls.UserControl>が呼び出すことはできませんどおり</xref:System.Windows.Controls.UserControl></xref:System.Windows.Window>。      <a name=&quot;routedEventInfo_Unloaded&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.UnloadedEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.FrameworkElement.Unloaded&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "アクセスを簡素化、<xref:System.Windows.NameScope>メソッドの登録を解除します</xref:System.Windows.NameScope>。"
  remarks: "だけで済みます名の登録解除に同じ名前の別の要素を再登録する場合。"
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "現在のスコープから削除する名前とオブジェクトのペアの名前です。"
  overload: System.Windows.FrameworkElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "現在の既定のスタイルを再適用<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>です。"
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  id: UseLayoutRounding
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得またはレイアウトの丸め適用するかをこの要素のサイズと位置レイアウト時を示す値を設定します。"
  remarks: "要素を受けるプロパティが`true`、中に計算されるすべての整数以外のピクセル値、<xref:System.Windows.UIElement.Measure%2A>と<xref:System.Windows.UIElement.Arrange%2A>パスは全体のピクセル値に丸められます</xref:System.Windows.UIElement.Arrange%2A></xref:System.Windows.UIElement.Measure%2A>。       このプロパティは、子要素によって継承されます。      > [!NOTE] > を受ける可能性を設定する必要があります`true`ルート要素にします。 レイアウト システムを親座標です。 子座標を追加します。そのため、親座標がピクセルの境界にない場合は、子座標もいないピクセルの境界にします。 受けるは、ルートに設定することはできません、設定<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>を希望する効果を取得する子にします</xref:System.Windows.UIElement.SnapsToDevicePixels%2A>。       半透明のエッジ デバイス ピクセルの途中で、エッジになった場合に、アンチ エイリアス処理によって生成されるを排除するピクセルの境界にオブジェクトを描画します。 次の図は、デバイスのピクセルの中央にある単一のピクセル幅の行の出力を示します。 左側の線はレイアウトの丸めが使用されないため、アンチ エイリアス処理します。 右側の線は、レイアウトの丸めを使用します。       ![単一のピクセル線と比較したアンチ エイリアス線。](~/add/media/pixelsnaplinecompare.PNG &quot;単一のピクセル線と比較したアンチ エイリアス線。&quot;)       レイアウトの丸めを使用する場合と<xref:System.Windows.GridUnitType>サイズ変更、レイアウト システムを作成小さな違いサブピクセル レンダリングを避けるために、列または行の計測結果にします</xref:System.Windows.GridUnitType>。 たとえば、グリッドがある 3 列のサイズの 100 の合計幅<xref:System.Windows.GridUnitType>、3 つの列を作成する代わりに 33.3 の幅が同じ、レイアウト システムは、幅が 33 と 34 の幅を持つ 2 つの列を作成します</xref:System.Windows.GridUnitType>。      > [!NOTE] >.NET 4.6 に変更を加えましたレイアウトの丸めを枠で囲まれたコントロールのクリッピングの発生を削減します。 既定では、この機能は、ターゲット フレームワークが .NET Framework 4.6 以降である場合に有効にします。 App.config ファイルに次の設定を追加することで、新しい動作を以前のバージョンの framework を対象とするアプリケーションで選択できます:`<runtime>``<AppContextSwitchOverrides      value=&quot;Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false&quot;/>``</runtime>`設定は、のみ、アプリケーションが .NET Framework 4.6 で実行されているときにします。"
  example:
  - "The following example demonstrates the effect that the UseLayoutRounding property has on a single pixel-width line. The line on the left does not use layout rounding and the line on the right uses layout rounding. If you slowly resize the window, you can see the difference that layout rounding makes.  \n  \n```xaml  \n  \n<Page x:Class=\"LayoutRounding.Lines\"  \n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"  \n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  \n    Title=\"Lines\" Name=\"linesPage\"  \n    >  \n  <StackPanel Width=\"150\"  Margin=\"7\" Orientation=\"Horizontal\">  \n    <!-- Single pixel line with layout rounding turned OFF.-->  \n    <Rectangle UseLayoutRounding=\"False\"  \n       Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n    <!-- Single pixel line with layout rounding turned ON.-->  \n    <Rectangle UseLayoutRounding=\"True\"  \n      Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n  </StackPanel>  \n  <!-- Background Grid -->  \n  <Page.Background>  \n    <DrawingBrush  Viewport=\"0,0,10,10\" ViewportUnits=\"Absolute\" TileMode=\"Tile\">  \n      <DrawingBrush.Drawing>  \n        <DrawingGroup>  \n          <GeometryDrawing Brush=\"White\">  \n            <GeometryDrawing.Geometry>  \n              <RectangleGeometry Rect=\"0,0,1,1\" />  \n            </GeometryDrawing.Geometry>  \n          </GeometryDrawing>  \n          <GeometryDrawing Geometry=\"M0,0 L1,0 1,0.1, 0,0.1Z \" Brush=\"#CCCCFF\" />  \n          <GeometryDrawing Geometry=\"M0,0 L0,1 0.1,1, 0.1,0Z\" Brush=\"#CCCCFF\" />  \n        </DrawingGroup>  \n      </DrawingBrush.Drawing>  \n    </DrawingBrush>  \n  </Page.Background>  \n</Page>  \n```"
  syntax:
    content: public bool UseLayoutRounding { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>レイアウトの丸めが適用される場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.UseLayoutRounding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  id: UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.UseLayoutRounding*>依存関係プロパティ</xref:System.Windows.FrameworkElement.UseLayoutRounding*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignment
  id: VerticalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または、panel またはアイテム コントロールのような親要素内で構成されるときに、この要素に適用される垂直方向の配置特性を設定します。"
  remarks: "とき<xref:System.Windows.FrameworkElement.Height%2A>と<xref:System.Windows.FrameworkElement.Width%2A>要素でプロパティが明示的に設定は、これらの測定値がレイアウトで優先に行い<xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment>にこのプロパティの設定の通常の効果を取り消す</xref:System.Windows.FrameworkElement.Width%2A></xref:System.Windows.FrameworkElement.Height%2A>       VerticalAlignment は、[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]新機能は、実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、派生した要素のクラス、特にコントロールで設定が異なります見かけ上の「既定」値がよくあります。 これは、2 つの方法のいずれかで一般的に発生します特定の派生クラスがその既定値を設定するためのさまざまなメタデータ、依存関係プロパティが再登録されている。またはが適用されている既定のスタイルが異なるその依存関係プロパティの値を設定します。 たとえば、明らかな「既定」の VerticalAlignment の<xref:System.Windows.Controls.ComboBoxItem>コントロールがある<xref:System.Windows.VerticalAlignment>場合でも、 <xref:System.Windows.Controls.ComboBoxItem> <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement>から VerticalAlignment 直接の継承</xref:System.Windows.Controls.ComboBoxItem></xref:System.Windows.VerticalAlignment></xref:System.Windows.Controls.ComboBoxItem> これは、既定のスタイル内でその値がリセットされたため<xref:System.Windows.Controls.ComboBoxItem>、スタイルのコントロール テンプレート内で</xref:System.Windows.Controls.ComboBoxItem>。       <xref:System.Windows.Controls.Canvas>使用しません VerticalAlignment レイアウトを作成するときに<xref:System.Windows.Controls.Canvas>絶対位置に基づきます</xref:System.Windows.Controls.Canvas>。</xref:System.Windows.Controls.Canvas>       <xref:System.Windows.Controls.ComboBoxItem>または<xref:System.Windows.Controls.ComboBoxItem><xref:System.Windows.VerticalAlignment>。</xref:System.Windows.VerticalAlignment>にするには、このプロパティの既定値を再定義</xref:System.Windows.Controls.ComboBoxItem>のすべての派生クラス</xref:System.Windows.Controls.ComboBoxItem>によって継承された場合      <a name=&quot;dependencyPropertyInfo_VerticalAlignment&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>"
  syntax:
    content: public System.Windows.VerticalAlignment VerticalAlignment { get; set; }
    return:
      type: System.Windows.VerticalAlignment
      description: "垂直方向の配置設定です。 既定値は<xref href=&quot;System.Windows.VerticalAlignment&quot;></xref>です。"
  overload: System.Windows.FrameworkElement.VerticalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  id: VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.VerticalAlignment*>依存関係プロパティ</xref:System.Windows.FrameworkElement.VerticalAlignment*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  id: VisualChildrenCount
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "この要素内でビジュアル子要素の数を取得します。"
  remarks: "<xref:System.Windows.FrameworkElement>VisualChildrenCount の実装は常に&0; または&1; 個のいずれかを返します</xref:System.Windows.FrameworkElement>。 クラスで&1; つを超える可能性がある子ビジュアル コレクションを保持するには、このプロパティと<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。</xref:System.Windows.FrameworkElement.GetVisualChild%2A>の両方を上書きする必要があります。       このプロパティは、現在の子コレクションのレイアウトのオーバーライドを実装するための上限を決定する使用一般的に (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>、 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.FrameworkElement.MeasureOverride%2A>"
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children and reports these values through overrides of VisualChildrenCount and <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override int VisualChildrenCount { get; }
    return:
      type: System.Int32
      description: "この要素のビジュアル子要素の数。"
  overload: System.Windows.FrameworkElement.VisualChildrenCount*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Width
  id: Width
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得または要素の幅を設定します。"
  remarks: "これには&3; つのプロパティのいずれかの<xref:System.Windows.FrameworkElement>幅情報を指定する</xref:System.Windows.FrameworkElement>。  他の&2; つは<xref:System.Windows.FrameworkElement.MinWidth%2A>および<xref:System.Windows.FrameworkElement.MaxWidth%2A>。</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>  実際の幅を決定するためのアプリケーションの順序は最初、これらの値の間で競合がある場合<xref:System.Windows.FrameworkElement.MinWidth%2A>、受け入れられ、する必要があります<xref:System.Windows.FrameworkElement.MaxWidth%2A>、し、最後に、境界の幅内では、これらの各場合</xref:System.Windows.FrameworkElement.MaxWidth%2A></xref:System.Windows.FrameworkElement.MinWidth%2A>。       このプロパティの戻り値は、それに設定された任意の値と同じでは常にします。 これに対しての値、<xref:System.Windows.FrameworkElement.ActualWidth%2A>異なる場合があります</xref:System.Windows.FrameworkElement.ActualWidth%2A>。 レイアウトが、何らかの理由により推奨されるサイズを拒否している可能性がありますがします。 また、レイアウト システム自体は、システムのプロパティ セットの幅に対して相対的に非同期的に動作し、処理されない可能性がある特定のプロパティの変更をまだサイズ変更します。       さらに許容される<xref:System.Double>値、このプロパティには、 <xref:System.Double.NaN?displayProperty=fullName>。</xref:System.Double.NaN?displayProperty=fullName>ことができます。</xref:System.Double> これは、自動サイズ変更動作を指定する方法です。 [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] 「自動」(大文字と小文字) を自動サイズ変更動作を有効にする文字列値を設定します。 自動サイズ変更動作は、要素が利用できる幅いっぱいになることを意味します。 ただし、特定のコントロールがサイズ変更動作を具体的には、再度有効にしない限り、自動を無効にする既定のスタイルでの既定値を頻繁に指定します。       レイアウト システムによって適用される幅にバインドされている、非決定的上限の値があるだけでなく、検証チェック (非常に大きな数より大きいです<xref:System.Single.MaxValue?displayProperty=fullName>がよりも小さい<xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> この上限値を超えた場合は、要素は表示されず、例外はスローされません。 幅は表示可能な最大サイズよりもずっと大きな値に設定しないでください、またはこの非決定的の上限を超える可能性があります。      <a name=&quot;xamlAttributeUsage_Width&quot;></a>## XAML 属性の使用```   <object Width=&quot;double&quot;/>   - or –   <object Width =&quot;qualifiedDouble&quot;/>   - or -   <object Width =&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Width&quot;> </a> ## XAML 値*二重*<xref:System.Double>の文字列表現を<xref:System.Double>0.0 以上の値</xref:System.Double></xref:System.Double>。           上限については、「解説」を参照してください。 この値として解釈されます、[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]測定します。 明示的に、文字列では、小数点を含める必要がありますされません。 値のインスタンス`1`は許容されます。       *qualifiedDouble* A*二重*値、上記と続けて次の単位の宣言文字列のいずれかの: `px`、 `in`、 `cm`、`pt`です。       `px`(既定値) は[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]`in`インチ; に 1 96px を = =`cm`センチメートル; は、1cm==(96/2.54) px`pt`ポイント; 1pt==(96/72) px`Auto`自動動作を有効にします。        「解説」を参照してください。      <a name=&quot;dependencyPropertyInfo_Width&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.FrameworkElement.WidthProperty>|  |メタデータ プロパティに設定`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.WidthProperty>"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "要素の幅の[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]します。 既定値は&lt;xref:System.Double?displayProperty=fullName&gt;です。 この値は、0.0 以上にする必要があります。 上限については、「解説」を参照してください。"
  overload: System.Windows.FrameworkElement.Width*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.WidthProperty
  id: WidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.FrameworkElement.Width*>依存関係プロパティ</xref:System.Windows.FrameworkElement.Width*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.UIElement
  isExternal: false
  name: System.Windows.UIElement
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkElement.#ctor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
- uid: System.Windows.FrameworkElement.ActualHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkElement.ActualWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkElement.ApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.FrameworkElement.BeginInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Windows.FrameworkElement.BindingGroup
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
- uid: System.Windows.FrameworkElement.BringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
- uid: System.Windows.FrameworkElement.ContextMenu
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
- uid: System.Windows.FrameworkElement.Cursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkElement.CursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
- uid: System.Windows.FrameworkElement.DataContext
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DataContextChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkElement.DataContextProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkElement.EndInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
- uid: System.Windows.FrameworkElement.FindName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
- uid: System.Windows.FrameworkElement.FlowDirection
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
- uid: System.Windows.FlowDirection
  parent: System.Windows
  isExternal: false
  name: FlowDirection
  nameWithType: FlowDirection
  fullName: System.Windows.FlowDirection
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkElement.ForceCursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
- uid: System.Windows.Media.Geometry
  parent: System.Windows.Media
  isExternal: false
  name: Geometry
  nameWithType: Geometry
  fullName: System.Windows.Media.Geometry
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
- uid: System.Windows.FrameworkElement.GetUIParentCore
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
- uid: System.Windows.Media.Visual
  parent: System.Windows.Media
  isExternal: false
  name: Visual
  nameWithType: Visual
  fullName: System.Windows.Media.Visual
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.FrameworkElement.Height
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
- uid: System.Windows.HorizontalAlignment
  parent: System.Windows
  isExternal: false
  name: HorizontalAlignment
  nameWithType: HorizontalAlignment
  fullName: System.Windows.HorizontalAlignment
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
- uid: System.Windows.InheritanceBehavior
  parent: System.Windows
  isExternal: false
  name: InheritanceBehavior
  nameWithType: InheritanceBehavior
  fullName: System.Windows.InheritanceBehavior
- uid: System.Windows.FrameworkElement.Initialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkElement.InputScope
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkElement.InputScopeProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
- uid: System.Windows.FrameworkElement.IsInitialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkElement.LanguageProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
- uid: System.Windows.FrameworkElement.LayoutTransform
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
- uid: System.Windows.Media.Transform
  parent: System.Windows.Media
  isExternal: false
  name: Transform
  nameWithType: Transform
  fullName: System.Windows.Media.Transform
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
- uid: System.Windows.FrameworkElement.Loaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkElement.LoadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
- uid: System.Windows.FrameworkElement.LogicalChildren
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkElement.Margin
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
- uid: System.Windows.Thickness
  parent: System.Windows
  isExternal: false
  name: Thickness
  nameWithType: Thickness
  fullName: System.Windows.Thickness
- uid: System.Windows.FrameworkElement.MarginProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
- uid: System.Windows.FrameworkElement.MaxHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
- uid: System.Windows.FrameworkElement.MaxWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
- uid: System.Windows.FrameworkElement.MinHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
- uid: System.Windows.FrameworkElement.MinWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MinWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkElement.Name
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
- uid: System.Windows.FrameworkElement.NameProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
- uid: System.Windows.SizeChangedInfo
  parent: System.Windows
  isExternal: false
  name: SizeChangedInfo
  nameWithType: SizeChangedInfo
  fullName: System.Windows.SizeChangedInfo
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkElement.Parent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
- uid: System.Windows.RequestBringIntoViewEventHandler
  parent: System.Windows
  isExternal: false
  name: RequestBringIntoViewEventHandler
  nameWithType: RequestBringIntoViewEventHandler
  fullName: System.Windows.RequestBringIntoViewEventHandler
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
- uid: System.Windows.FrameworkElement.Resources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
- uid: System.Windows.FrameworkElement.SizeChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
- uid: System.Windows.SizeChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: SizeChangedEventHandler
  nameWithType: SizeChangedEventHandler
  fullName: System.Windows.SizeChangedEventHandler
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
- uid: System.Windows.FrameworkElement.SourceUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkElement.Style
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
- uid: System.Windows.FrameworkElement.StyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkElement.Tag
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TagProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
- uid: System.Windows.FrameworkElement.TargetUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
- uid: System.Windows.FrameworkElement.TemplatedParent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.ToolTipClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkElement.ToolTipOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkElement.ToolTipProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
- uid: System.Windows.FrameworkElement.Triggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
- uid: System.Windows.FrameworkElement.Unloaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
- uid: System.Windows.FrameworkElement.UnloadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
- uid: System.Windows.FrameworkElement.VerticalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
- uid: System.Windows.VerticalAlignment
  parent: System.Windows
  isExternal: false
  name: VerticalAlignment
  nameWithType: VerticalAlignment
  fullName: System.Windows.VerticalAlignment
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
- uid: System.Windows.FrameworkElement.WidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
- uid: System.Windows.FrameworkElement.#ctor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement
  nameWithType: FrameworkElement.FrameworkElement
- uid: System.Windows.FrameworkElement.ActualHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
- uid: System.Windows.FrameworkElement.ActualWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.AddLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkElement.AddLogicalChild
- uid: System.Windows.FrameworkElement.ApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate
  nameWithType: FrameworkElement.ApplyTemplate
- uid: System.Windows.FrameworkElement.ArrangeCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore
  nameWithType: FrameworkElement.ArrangeCore
- uid: System.Windows.FrameworkElement.ArrangeOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride
  nameWithType: FrameworkElement.ArrangeOverride
- uid: System.Windows.FrameworkElement.BeginInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkElement.BeginInit
- uid: System.Windows.FrameworkElement.BeginStoryboard*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkElement.BeginStoryboard
- uid: System.Windows.FrameworkElement.BindingGroup*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
- uid: System.Windows.FrameworkElement.BringIntoView*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkElement.BringIntoView
- uid: System.Windows.FrameworkElement.ContextMenu*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
- uid: System.Windows.FrameworkElement.Cursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
- uid: System.Windows.FrameworkElement.DataContext*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DefaultStyleKey*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.EndInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkElement.EndInit
- uid: System.Windows.FrameworkElement.FindName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkElement.FindName
- uid: System.Windows.FrameworkElement.FindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkElement.FindResource
- uid: System.Windows.FrameworkElement.FlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
- uid: System.Windows.FrameworkElement.FocusVisualStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
- uid: System.Windows.FrameworkElement.ForceCursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.GetBindingExpression*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkElement.GetBindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection
  nameWithType: FrameworkElement.GetFlowDirection
- uid: System.Windows.FrameworkElement.GetLayoutClip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip
  nameWithType: FrameworkElement.GetLayoutClip
- uid: System.Windows.FrameworkElement.GetTemplateChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild
  nameWithType: FrameworkElement.GetTemplateChild
- uid: System.Windows.FrameworkElement.GetUIParentCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkElement.GetUIParentCore
- uid: System.Windows.FrameworkElement.GetVisualChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild
  nameWithType: FrameworkElement.GetVisualChild
- uid: System.Windows.FrameworkElement.Height*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HorizontalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
- uid: System.Windows.FrameworkElement.InheritanceBehavior*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
- uid: System.Windows.FrameworkElement.InputScope*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
- uid: System.Windows.FrameworkElement.IsInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
- uid: System.Windows.FrameworkElement.LayoutTransform*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
- uid: System.Windows.FrameworkElement.LogicalChildren*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
- uid: System.Windows.FrameworkElement.Margin*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
- uid: System.Windows.FrameworkElement.MaxHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MeasureCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore
  nameWithType: FrameworkElement.MeasureCore
- uid: System.Windows.FrameworkElement.MeasureOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride
  nameWithType: FrameworkElement.MeasureOverride
- uid: System.Windows.FrameworkElement.MinHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MoveFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkElement.MoveFocus
- uid: System.Windows.FrameworkElement.Name*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
- uid: System.Windows.FrameworkElement.OnApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate
  nameWithType: FrameworkElement.OnApplyTemplate
- uid: System.Windows.FrameworkElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkElement.OnContextMenuClosing
- uid: System.Windows.FrameworkElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkElement.OnContextMenuOpening
- uid: System.Windows.FrameworkElement.OnGotFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkElement.OnGotFocus
- uid: System.Windows.FrameworkElement.OnInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkElement.OnInitialized
- uid: System.Windows.FrameworkElement.OnPropertyChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkElement.OnPropertyChanged
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged
  nameWithType: FrameworkElement.OnRenderSizeChanged
- uid: System.Windows.FrameworkElement.OnStyleChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkElement.OnStyleChanged
- uid: System.Windows.FrameworkElement.OnToolTipClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkElement.OnToolTipClosing
- uid: System.Windows.FrameworkElement.OnToolTipOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkElement.OnToolTipOpening
- uid: System.Windows.FrameworkElement.OnVisualParentChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: FrameworkElement.OnVisualParentChanged
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.Parent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated
  nameWithType: FrameworkElement.ParentLayoutInvalidated
- uid: System.Windows.FrameworkElement.PredictFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkElement.PredictFocus
- uid: System.Windows.FrameworkElement.RegisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkElement.RegisterName
- uid: System.Windows.FrameworkElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkElement.RemoveLogicalChild
- uid: System.Windows.FrameworkElement.Resources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
- uid: System.Windows.FrameworkElement.SetBinding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkElement.SetBinding
- uid: System.Windows.FrameworkElement.SetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection
  nameWithType: FrameworkElement.SetFlowDirection
- uid: System.Windows.FrameworkElement.SetResourceReference*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkElement.SetResourceReference
- uid: System.Windows.FrameworkElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkElement.ShouldSerializeResources
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers
  nameWithType: FrameworkElement.ShouldSerializeTriggers
- uid: System.Windows.FrameworkElement.Style*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkElement.Tag*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TemplatedParent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.Triggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
- uid: System.Windows.FrameworkElement.TryFindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkElement.TryFindResource
- uid: System.Windows.FrameworkElement.UnregisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkElement.UnregisterName
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkElement.UpdateDefaultStyle
- uid: System.Windows.FrameworkElement.UseLayoutRounding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.VerticalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
- uid: System.Windows.FrameworkElement.VisualChildrenCount*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
