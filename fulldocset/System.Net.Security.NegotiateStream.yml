### YamlMime:ManagedReference
items:
- uid: System.Net.Security.NegotiateStream
  id: NegotiateStream
  children:
  - System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  - System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServer
  - System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  - System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Security.NegotiateStream.CanRead
  - System.Net.Security.NegotiateStream.CanSeek
  - System.Net.Security.NegotiateStream.CanTimeout
  - System.Net.Security.NegotiateStream.CanWrite
  - System.Net.Security.NegotiateStream.Dispose(System.Boolean)
  - System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)
  - System.Net.Security.NegotiateStream.Flush
  - System.Net.Security.NegotiateStream.ImpersonationLevel
  - System.Net.Security.NegotiateStream.IsAuthenticated
  - System.Net.Security.NegotiateStream.IsEncrypted
  - System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  - System.Net.Security.NegotiateStream.IsServer
  - System.Net.Security.NegotiateStream.IsSigned
  - System.Net.Security.NegotiateStream.Length
  - System.Net.Security.NegotiateStream.Position
  - System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.NegotiateStream.ReadTimeout
  - System.Net.Security.NegotiateStream.RemoteIdentity
  - System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Security.NegotiateStream.SetLength(System.Int64)
  - System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.NegotiateStream.WriteTimeout
  langs:
  - csharp
  name: NegotiateStream
  nameWithType: NegotiateStream
  fullName: System.Net.Security.NegotiateStream
  type: Class
  summary: "Negotiate セキュリティ プロトコルを使用して、クライアント、および必要に応じてサーバーのクライアント サーバー間の通信で認証するストリームを提供します。"
  remarks: "認証およびセキュリティで保護された情報がクライアントとサーバー間で送信するためには、NegotiateStream クラスを使用します。 NegotiateStream では、次の操作を行うことができます。      -サーバーへのクライアントの資格情報を権限の借用または委任用に送信します。      -サーバー認証を要求します。      -暗号化または転送する前にデータに署名します。       認証は、情報を送信する前に実行する必要があります。 クライアントが、同期を使用して認証を要求<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>メソッドで、認証が完了するまでブロック、または非同期<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>メソッドで、認証が完了するを待っているときにブロックしません</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A></xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。 サーバーは、同期を使用して認証を要求<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>または非同期<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A></xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。 クライアント、および必要に応じて、サーバーは、Negotiate セキュリティ プロトコルを使用して認証されます。 Windows 95/98 システムでは、Windows NT LAN Manager (NTLM) は、認証に使用されるプロトコルです。 その他のプラットフォームでは、Kerberos プロトコルが使用認証の場合、クライアントとサーバーの両方をサポートします。それ以外の場合、NTLM が使用されます。 これらのプロトコルの詳細な説明についてには、msdn、プラットフォーム SDK ドキュメントを参照して msdn.microsoft.com/library/ にします。 NegotiateStream クラスでは、セキュリティ サポート プロバイダー インターフェイス (SSPI) を使用して認証を実行します。       認証が成功した場合、確認する必要があります、<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>と<xref:System.Net.Security.NegotiateStream.IsSigned%2A>転送中に、データを保護するために、NegotiateStream によってどのようなセキュリティ サービスを決定するプロパティが使用されます</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。 リモート クライアントまたはサーバーの使用に関する情報を取得することができます、<xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A>プロパティ</xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A>。       認証が失敗した場合が表示されます、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。       同期を使用してデータを送信する<xref:System.Net.Security.NegotiateStream.Write%2A>または非同期<xref:System.Net.Security.NegotiateStream.BeginWrite%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginWrite%2A></xref:System.Net.Security.NegotiateStream.Write%2A>。 同期を使用してデータを受信する<xref:System.Net.Security.NegotiateStream.Read%2A>または非同期<xref:System.Net.Security.NegotiateStream.BeginRead%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginRead%2A></xref:System.Net.Security.NegotiateStream.Read%2A>。 セキュリティ サービスの暗号化や署名が有効になっているなど、これらは自動的に適用、データを NegotiateStream によって。       NegotiateStream、NegotiateStream を作成するときに指定するストリームを使用してデータを送信します。 この基になるストリームを指定するときに、NegotiateStream を終了すると、基になるストリームも閉じるかどうかを指定するオプションがあります。"
  example:
  - "The following code example demonstrates the client side of a client-server connection that uses the NegotiateStream. The client authenticates and sends a message to the server asynchronously.  \n  \n [!code-cpp[NclNegoAsyncClient#0](~/add/codesnippet/cpp/t-system.net.security.ne_1.cpp)]\n [!code-cs[NclNegoAsyncClient#0](~/add/codesnippet/csharp/t-system.net.security.ne_1.cs)]  \n  \n The following code example demonstrates the server side of a client-server connection that uses the NegotiateStream to authenticate the client and read a message sent by the client.  \n  \n [!code-cs[NclNegoAsyncServer#0](~/add/codesnippet/csharp/t-system.net.security.ne_2.cs)]\n [!code-cpp[NclNegoAsyncServer#0](~/add/codesnippet/cpp/t-system.net.security.ne_2.cpp)]"
  syntax:
    content: 'public class NegotiateStream : System.Net.Security.AuthenticatedStream'
  inheritance:
  - System.IO.Stream
  - System.Net.Security.AuthenticatedStream
  implements: []
  inheritedMembers:
  - System.Net.Security.AuthenticatedStream.InnerStream
  - System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: NegotiateStream(Stream)
  nameWithType: NegotiateStream.NegotiateStream(Stream)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Net.Security.NegotiateStream&quot;> </xref>指定<xref:System.IO.Stream>.</xref:System.IO.Stream>を使用してクラス"
  remarks: ''
  example:
  - "The following code example demonstrates calling this constructor.  \n  \n [!code-cs[NclNegoSyncClient#3](~/add/codesnippet/csharp/m-system.net.security.ne_1_1.cs)]\n [!code-cpp[NclNegoSyncClient#3](~/add/codesnippet/cpp/m-system.net.security.ne_1_1.cpp)]"
  syntax:
    content: public NegotiateStream (System.IO.Stream innerStream);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>によって使用されるオブジェクト、 <xref href=&quot;System.Net.Security.NegotiateStream&quot;> </xref>データを送受信するためです</xref:System.IO.Stream>。"
  overload: System.Net.Security.NegotiateStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  id: '#ctor(System.IO.Stream,System.Boolean)'
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: NegotiateStream(Stream,Boolean)
  nameWithType: NegotiateStream.NegotiateStream(Stream,Boolean)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Net.Security.NegotiateStream&quot;> </xref>クラスの指定して<xref:System.IO.Stream>およびクロージャの動作をストリーミングします</xref:System.IO.Stream>。"
  remarks: "指定すると`true`の`leaveStreamOpen`パラメーター、閉じる、<xref:System.Net.Security.NegotiateStream>に影響を与えません、`innerStream`ストリーム; 明示的に閉じる必要があります`innerStream`とそれが不要になった</xref:System.Net.Security.NegotiateStream>"
  example:
  - "The following code example demonstrates calling this constructor. This code example is part of a larger example provided for the <xref:System.Net.Security.NegotiateStream> class.  \n  \n [!code-cpp[NclNegoAsyncClient#1](~/add/codesnippet/cpp/m-system.net.security.ne_4_1.cpp)]\n [!code-cs[NclNegoAsyncClient#1](~/add/codesnippet/csharp/m-system.net.security.ne_4_1.cs)]"
  syntax:
    content: public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>によって使用されるオブジェクト、 <xref href=&quot;System.Net.Security.NegotiateStream&quot;> </xref>データを送受信するためです</xref:System.IO.Stream>。"
    - id: leaveInnerStreamOpen
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>閉じるこのことを示すために<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>影響を与えません`innerstream`です。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>閉じるこのことを示すために<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>も閉じられます`innerStream`です。 詳細については「解説」セクションを参照してください。"
  overload: System.Net.Security.NegotiateStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>innerStream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>innerStream</code> is equal to <xref:System.IO.Stream.Null>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient
  id: AuthenticateAsClient
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient()
  nameWithType: NegotiateStream.AuthenticateAsClient()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続での認証にクライアントによって呼び出されます。"
  remarks: "認証で使用するクライアントの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>、および相互認証を要求します</xref:System.Net.Security.ProtectionLevel></xref:System.Security.Principal.TokenImpersonationLevel>。 <xref:System.Net.Security.NegotiateStream>クラスが相互認証に使用する SPN を作成します</xref:System.Net.Security.NegotiateStream>。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual void AuthenticateAsClient ();
    parameters: []
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続での認証にクライアントによって呼び出されます。 認証プロセスでは、指定したクライアントの資格情報を使用します。"
  remarks: "偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>、および相互認証を要求します</xref:System.Net.Security.ProtectionLevel></xref:System.Security.Principal.TokenImpersonationLevel>。 <xref:System.Net.Security.NegotiateStream>クラスが相互認証に使用する SPN を作成します</xref:System.Net.Security.NegotiateStream>。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続での認証にクライアントによって呼び出されます。 認証プロセスでは、指定したクライアントの資格情報とチャネル バインドを使用します。"
  remarks: "偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>、および相互認証を要求します</xref:System.Net.Security.ProtectionLevel></xref:System.Security.Principal.TokenImpersonationLevel>。 <xref:System.Net.Security.NegotiateStream>クラスが相互認証に使用する SPN を作成します</xref:System.Net.Security.NegotiateStream>。       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>でこのメソッドに渡される拡張保護の使用、`binding`パラメーターは<xref:System.Net.Security.SslStream.TransportContext%2A>、関連付けられている<xref:System.Net.Security.SslStream></xref:System.Net.Security.SslStream>プロパティ</xref:System.Net.Security.SslStream.TransportContext%2A>からのアプリケーションによって取得は</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>拡張保護に使用される</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続での認証にクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報と認証オプションを使用します。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんを要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>有効な値ではありません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>null です。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続での認証にクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報、認証オプションとチャネル バインドを使用します。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんを要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>でこのメソッドに渡される拡張保護の使用、`binding`パラメーターは<xref:System.Net.Security.SslStream.TransportContext%2A>、関連付けられている<xref:System.Net.Security.SslStream></xref:System.Net.Security.SslStream>プロパティ</xref:System.Net.Security.SslStream.TransportContext%2A>からのアプリケーションによって取得は</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>拡張保護に使用される</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>有効な値ではありません。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  id: AuthenticateAsClientAsync
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync()
  nameWithType: NegotiateStream.AuthenticateAsClientAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じて、非同期操作としてクライアント サーバー接続で、サーバーの認証にクライアントによって呼び出されます。"
  remarks: "認証で使用するクライアントの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>、および相互認証を要求します</xref:System.Net.Security.ProtectionLevel></xref:System.Security.Principal.TokenImpersonationLevel>。 <xref:System.Net.Security.NegotiateStream>クラスが相互認証に使用する SPN を作成します</xref:System.Net.Security.NegotiateStream>。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じて、非同期操作としてクライアント サーバー接続で、サーバーの認証にクライアントによって呼び出されます。 認証プロセスでは、指定したクライアントの資格情報を使用します。"
  remarks: "偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>、および相互認証を要求します</xref:System.Net.Security.ProtectionLevel></xref:System.Security.Principal.TokenImpersonationLevel>。 <xref:System.Net.Security.NegotiateStream>クラスが相互認証に使用する SPN を作成します</xref:System.Net.Security.NegotiateStream>。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じて、非同期操作としてクライアント サーバー接続で、サーバーの認証にクライアントによって呼び出されます。 認証プロセスでは、指定したクライアントの資格情報とチャネル バインドを使用します。"
  remarks: "偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>、および相互認証を要求します</xref:System.Net.Security.ProtectionLevel></xref:System.Security.Principal.TokenImpersonationLevel>。 <xref:System.Net.Security.NegotiateStream>クラスが相互認証に使用する SPN を作成します</xref:System.Net.Security.NegotiateStream>。       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>でこのメソッドに渡される拡張保護の使用、`binding`パラメーターは<xref:System.Net.Security.SslStream.TransportContext%2A>、関連付けられている<xref:System.Net.Security.SslStream></xref:System.Net.Security.SslStream>プロパティ</xref:System.Net.Security.SslStream.TransportContext%2A>からのアプリケーションによって取得は</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>拡張保護に使用される</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じて、非同期操作としてクライアント サーバー接続で、サーバーの認証にクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報と認証オプションを使用します。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんを要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>有効な値ではありません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code>null です。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じて、非同期操作としてクライアント サーバー接続で、サーバーの認証にクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報、認証オプションとチャネル バインドを使用します。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんを要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>でこのメソッドに渡される拡張保護の使用、`binding`パラメーターは<xref:System.Net.Security.SslStream.TransportContext%2A>、関連付けられている<xref:System.Net.Security.SslStream></xref:System.Net.Security.SslStream>プロパティ</xref:System.Net.Security.SslStream.TransportContext%2A>からのアプリケーションによって取得は</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>拡張保護に使用される</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>allowedImpersonationLevel</code>有効な値ではありません。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer
  id: AuthenticateAsServer
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer()
  nameWithType: NegotiateStream.AuthenticateAsServer()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、クライアントとサーバーの接続とによって呼び出されます。"
  remarks: "認証で使用するサーバーの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>.</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       このメソッドは、操作が完了するまでブロックします。 操作が完了するまでブロックを防ぐためには、いずれかの操作を使用して、<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual void AuthenticateAsServer ();
    parameters: []
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  id: AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、クライアントとサーバーの接続とによって呼び出されます。 認証プロセスでは、指定された拡張保護ポリシーを使用します。"
  remarks: "認証で使用するサーバーの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>.</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       場合、`policy`パラメーターは`null`、<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A><xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement></xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>設定</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>が拡張保護ポリシーが使用されます。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       このメソッドは、操作が完了するまでブロックします。 操作が完了するまでブロックを防ぐためには、いずれかの操作を使用して、<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>拡張保護に使用されます。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *> と<> *> で渡される拡張保護ポリシーで、 <code> policy </code>パラメーターが両方とも<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>パラメーターに設定された<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>拡張保護をサポートしていないプラットフォームでします。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、クライアントとサーバーの接続とによって呼び出されます。 認証プロセスでは、指定したサーバーの資格情報と認証オプションを使用します。"
  remarks: "認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       このメソッドは、操作が完了するまでブロックします。 操作が完了するまでブロックを防ぐためには、いずれかの操作を使用して、<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>、サーバーの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、r 認証を行うことができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、クライアントとサーバーの接続とによって呼び出されます。 認証プロセスでは、指定したサーバーの資格情報、認証オプションを使用し、拡張保護ポリシー。"
  remarks: "場合、`policy`パラメーターは`null`、<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A><xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement></xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>設定</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>が拡張保護ポリシーが使用されます。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       このメソッドは、操作が完了するまでブロックします。 操作が完了するまでブロックを防ぐためには、いずれかの操作を使用して、<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>拡張保護に使用されます。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *> と<> *> で渡される拡張保護ポリシーで、 <code> policy </code>パラメーターが両方とも<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、r 認証を行うことができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>パラメーターに設定された<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>拡張保護をサポートしていないプラットフォームでします。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  id: AuthenticateAsServerAsync
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync()
  nameWithType: NegotiateStream.AuthenticateAsServerAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、非同期操作としてクライアント サーバー接続とによって呼び出されます。"
  remarks: "認証で使用するサーバーの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>.</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  id: AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、非同期操作としてクライアント サーバー接続とによって呼び出されます。 認証プロセスでは、指定された拡張保護ポリシーを使用します。"
  remarks: "認証で使用するサーバーの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>.</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       場合、`policy`パラメーターは`null`、<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A><xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement></xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>設定</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>が拡張保護ポリシーが使用されます。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>拡張保護に使用されます。"
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *> と<> *> で渡される拡張保護ポリシーで、 <code> policy </code>パラメーターが両方とも<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>パラメーターに設定された<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>拡張保護をサポートしていないプラットフォームでします。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、非同期操作としてクライアント サーバー接続とによって呼び出されます。 認証プロセスでは、指定したサーバーの資格情報と認証オプションを使用します。"
  remarks: "認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>、サーバーの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、r 認証を行うことができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバー、クライアントの認証を必要に応じて、サーバー、非同期操作としてクライアント サーバー接続とによって呼び出されます。 認証プロセスでは、指定したサーバーの資格情報、認証オプションを使用し、拡張保護ポリシー。"
  remarks: "場合、`policy`パラメーターは`null`、<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A><xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement></xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>設定</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>が拡張保護ポリシーが使用されます。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>拡張保護に使用されます。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    return:
      type: System.Threading.Tasks.Task
      description: "返します<xref:System.Threading.Tasks.Task>非同期操作を表すタスク オブジェクト</xref:System.Threading.Tasks.Task>。"
  overload: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *> と<> *> で渡される拡張保護ポリシーで、 <code> policy </code>パラメーターが両方とも<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、r 認証を行うことができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>パラメーターに設定された<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>拡張保護をサポートしていないプラットフォームでします。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続で認証する非同期操作を開始するクライアントによって呼び出されます。 このメソッドをブロックしません。"
  remarks: "認証で使用するクライアントの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルが<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>.</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel> <xref:System.Net.Security.NegotiateStream>クラスが相互認証に使用する SPN を作成します</xref:System.Net.Security.NegotiateStream>。       このメソッドは、非同期操作の完了もブロックしません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。       呼び出しで、認証の非同期操作を完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException></xref:System.Security.Authentication.AuthenticationException>を受信する、認証に失敗した場合。 ここでは、別の資格情報を使用して認証を再試行することができます。"
  example:
  - "The following code example demonstrates calling this method to begin an asynchronous authentication for the client.  \n  \n [!code-cpp[NclNegoAsyncClient#2](~/add/codesnippet/cpp/66fdfed9-ce77-41e0-af55-_1.cpp)]\n [!code-cs[NclNegoAsyncClient#2](~/add/codesnippet/csharp/66fdfed9-ce77-41e0-af55-_1.cs)]"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続で認証する非同期操作を開始するクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報を使用します。 このメソッドをブロックしません。"
  remarks: "このメソッドは、非同期操作の完了もブロックしません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。       呼び出しで、認証の非同期操作を完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException></xref:System.Security.Authentication.AuthenticationException>を受信する、認証に失敗した場合。 ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "書き込み操作に関する情報を含むユーザー定義オブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続で認証する非同期操作を開始するクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報とチャネル バインドを使用します。 このメソッドをブロックしません。"
  remarks: "このメソッドは、非同期操作の完了もブロックしません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。       呼び出しで、認証の非同期操作を完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException></xref:System.Security.Authentication.AuthenticationException>を受信する、認証に失敗した場合。 ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>拡張保護に使用される</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "書き込み操作に関する情報を含むユーザー定義オブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続で認証する非同期操作を開始するクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報と認証オプションを使用します。 このメソッドをブロックしません。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんを要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       このメソッドは、非同期操作の完了もブロックしません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。       呼び出しで、認証の非同期操作を完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException></xref:System.Security.Authentication.AuthenticationException>を受信する、認証に失敗した場合。 ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "書き込み操作に関する情報を含むユーザー定義オブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアント、および必要に応じてサーバーのクライアントとサーバーの接続で認証する非同期操作を開始するクライアントによって呼び出されます。 認証プロセスでは、指定された資格情報、認証オプションとチャネル バインドを使用します。 このメソッドをブロックしません。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんを要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       このメソッドは、非同期操作の完了もブロックしません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。       呼び出しで、認証の非同期操作を完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException></xref:System.Security.Authentication.AuthenticationException>を受信する、認証に失敗した場合。 ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
      description: "<xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>拡張保護に使用される</xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>。"
    - id: targetName
      type: System.String
      description: "サービス プリンシパル名 (SPN) を認証するサーバーを一意に識別します。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "書き込み操作に関する情報を含むユーザー定義オブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>targetName</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアントを認証する非同期操作を開始するサーバーと必要に応じてクライアント サーバー接続で、サーバーによって呼び出されます。 このメソッドをブロックしません。"
  remarks: "認証で使用するサーバーの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルは<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアントを認証する非同期操作を開始するサーバーと必要に応じてクライアント サーバー接続で、サーバーによって呼び出されます。 認証プロセスでは、指定された拡張保護ポリシーを使用します。 このメソッドをブロックしません。"
  remarks: "認証で使用するサーバーの<xref:System.Net.CredentialCache.DefaultCredentials%2A>。</xref:System.Net.CredentialCache.DefaultCredentials%2A> サーバーのサービス プリンシパル名 (SPN) が指定されていません。 偽装レベルは<xref:System.Security.Principal.TokenImpersonationLevel>、セキュリティ レベルは<xref:System.Net.Security.ProtectionLevel>。</xref:System.Net.Security.ProtectionLevel> </xref:System.Security.Principal.TokenImpersonationLevel>       場合、`policy`パラメーターは`null`、<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A><xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement></xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>設定</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>が拡張保護ポリシーが使用されます。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>拡張保護に使用されます。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "書き込み操作に関する情報を含むユーザー定義オブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *> と<> *> で渡される拡張保護ポリシーで、 <code> policy </code>パラメーターが両方とも<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>パラメーターに設定された<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>拡張保護をサポートしていないプラットフォームでします。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアントを認証する非同期操作を開始するサーバーと必要に応じてクライアント サーバー接続で、サーバーによって呼び出されます。 認証プロセスでは、指定したサーバーの資格情報と認証オプションを使用します。 このメソッドをブロックしません。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんが、要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       このメソッドは、非同期操作の完了もブロックしません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。       呼び出しで、認証の非同期操作を完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException></xref:System.Security.Authentication.AuthenticationException>を受信する、認証に失敗した場合。 ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "クライアントを認証する非同期操作を開始するサーバーと必要に応じてクライアント サーバー接続で、サーバーによって呼び出されます。 認証プロセスでは、指定したサーバーの資格情報、認証オプションを使用し、拡張保護ポリシー。 このメソッドをブロックしません。"
  remarks: "使用して、`requiredProtectionLevel`パラメーターを認証されたストリームを使用して送信されるデータのセキュリティ サービスを要求します。 たとえば、暗号化および署名されたデータを表示するには、次のように指定します、<xref:System.Net.Security.ProtectionLevel>値。</xref:System.Net.Security.ProtectionLevel> 。 成功した認証とは限りませんが、要求された<xref:System.Net.Security.ProtectionLevel>が許可されています</xref:System.Net.Security.ProtectionLevel>。 <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>を確認する必要があります。       場合、`policy`パラメーターは`null`、<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A><xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement></xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>設定</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>が拡張保護ポリシーが使用されます。       このメソッドは、非同期操作の完了もブロックしません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>メソッドのオーバー ロード</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。       呼び出しで、認証の非同期操作を完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException></xref:System.Security.Authentication.AuthenticationException>を受信する、認証に失敗した場合。 ここでは、別の資格情報を使用して認証を再試行することができます。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: credential
      type: System.Net.NetworkCredential
      description: "<xref:System.Net.NetworkCredential>クライアントの id を確立するために使用される</xref:System.Net.NetworkCredential>。"
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref>拡張保護に使用されます。"
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
      description: "1 つ、 <xref href=&quot;System.Net.Security.ProtectionLevel&quot;> </xref>したストリーム用のセキュリティ サービスを示す値。"
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>サーバーがクライアントの資格情報を使用して、リソースにアクセスする方法を示す値</xref:System.Security.Principal.TokenImpersonationLevel>。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>、認証が完了したときに呼び出されるメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "書き込み操作に関する情報を含むユーザー定義オブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<> </> *> と<> *> で渡される拡張保護ポリシーで、 <code> policy </code>パラメーターが両方とも<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>credential</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>requiredImpersonationLevel</code>must be <xref:System.Security.Principal.TokenImpersonationLevel>, <xref:System.Security.Principal.TokenImpersonationLevel>, or <xref:System.Security.Principal.TokenImpersonationLevel>,"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Authentication has already occurred.  \n  \n \\- or -  \n  \n This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Windows 95 および Windows 98 はサポートされていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<code> policy </code>パラメーターに設定された<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>拡張保護をサポートしていないプラットフォームでします。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "ストリームからデータを読み取り、指定した配列に格納する非同期読み取り操作を開始します。"
  remarks: "暗号化、署名、または暗号化および署名が有効になっている場合、読み取り操作は基になるストリームからデータを読み取ります、データの整合性をチェックし、復号化します。 セキュリティには、使用するには、データの暗号化や署名などサービスなし、されていない場合、このメソッドは、基になるストリームで非同期読み取り操作を開始します。       このメソッドは、非同期操作の完了もブロックしません。 使用して、操作が完了するまで、禁止する、<xref:System.Net.Security.NegotiateStream.Read%2A>メソッド</xref:System.Net.Security.NegotiateStream.Read%2A>。       非同期の読み取り操作を呼び出すことによって完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndRead%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndRead%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Net.Security.NegotiateStream>クラスが複数の同時読み取り操作をサポートしていません。</xref:System.Net.Security.NegotiateStream> 。 他の操作は、同一のストリームで既に実行中の読み取り中に、読み取り操作を開始しようとする場合、<xref:System.NotSupportedException>例外がスローされます</xref:System.NotSupportedException>。       正常に認証が完了するまでは、このメソッドを呼び出すことはできません。 を認証するには、のいずれかを呼び出して、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>、または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates starting an asynchronous read operation. This code example is part of a larger example provided for the <xref:System.Net.Security.NegotiateStream> class.  \n  \n [!code-cs[NclNegoAsyncServer#1](~/add/codesnippet/csharp/45085c2d-bb14-48e7-a75f-_1.cs)]\n [!code-cpp[NclNegoAsyncServer#1](~/add/codesnippet/cpp/45085c2d-bb14-48e7-a75f-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>ストリームから読み取ったバイトを受け取る配列</xref:System.Byte>。"
    - id: offset
      type: System.Int32
      description: "内の&0; から始まる場所`buffer`このストリームから読み取ったデータの格納を開始する位置。"
    - id: count
      type: System.Int32
      description: "ストリームから読み取るバイトの最大数。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>読み取り操作の完了時に呼び出すメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "読み取り操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code> is less than 0.  \n  \n \\- or -  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n \\- or -  \n  \n <code>offset</code> plus <code>count</code> is greater than the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The read operation failed.  \n  \n \\- or -  \n  \n Encryption is in use, but the data could not be decrypted."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "実行中の読み取り操作が既に存在します。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が行われていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "書き込む非同期の書き込み操作を開始<xref:System.Byte>ストリームに指定されたバッファーから s</xref:System.Byte> 。"
  remarks: "暗号化、署名、または暗号化および署名が有効になっている場合このメソッド バッファーからデータを読み取ります、暗号化、署名、または暗号化し署名、および基になるストリームを使用して送信します。 セキュリティには、使用するには、データの暗号化や署名などサービスなし、されていない場合、このメソッドは、基になるストリームに非同期の書き込み操作を開始します。       このメソッドは、非同期操作の完了もブロックしません。 使用して、操作が完了するまで、禁止する、<xref:System.Net.Security.NegotiateStream.Read%2A>メソッド</xref:System.Net.Security.NegotiateStream.Read%2A>。       非同期の読み取り操作を呼び出すことによって完了する必要があります、<xref:System.Net.Security.NegotiateStream.EndWrite%2A>メソッド</xref:System.Net.Security.NegotiateStream.EndWrite%2A>。 通常、このメソッドはによって、`asyncCallback`を委任します。 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す](~/add/includes/ajax-current-ext-md.md)、<xref:System.Net.Security.NegotiateStream>クラスが複数の同時書き込み操作をサポートしていません。</xref:System.Net.Security.NegotiateStream> 。 別の書き込み操作は、同じストリームで既に実行中に、書き込み操作を開始しようとする場合、<xref:System.NotSupportedException>例外がスローされます</xref:System.NotSupportedException>。       正常に認証が完了するまでは、このメソッドを呼び出すことはできません。 を認証するには、のいずれかを呼び出して、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>、または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates beginning an asynchronous write operation.  \n  \n [!code-cpp[NclNegoAsyncClient#3](~/add/codesnippet/cpp/5748c807-4e74-4d4c-a4e4-_1.cpp)]\n [!code-cs[NclNegoAsyncClient#3](~/add/codesnippet/csharp/5748c807-4e74-4d4c-a4e4-_1.cs)]  \n  \n The following method is called when the operation completes.  \n  \n [!code-cpp[NclNegoAsyncClient#4](~/add/codesnippet/cpp/5748c807-4e74-4d4c-a4e4-_2.cpp)]\n [!code-cs[NclNegoAsyncClient#4](~/add/codesnippet/csharp/5748c807-4e74-4d4c-a4e4-_2.cs)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>をストリームに書き込まれるバイト数を提供します</xref:System.Byte>。"
    - id: offset
      type: System.Int32
      description: "内の&0; から始まる場所`buffer`ストリームに書き込まれるバイトの読み取りを開始する位置。"
    - id: count
      type: System.Int32
      description: "<xref:System.Int32>から読み取るバイト数を指定する値`buffer`</xref:System.Int32>。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>書き込み操作の完了時に呼び出すメソッドを参照するデリゲート</xref:System.AsyncCallback>。"
    - id: asyncState
      type: System.Object
      description: "書き込み操作に関する情報を含むユーザー定義オブジェクト。 このオブジェクトは、`asyncCallback`操作の完了時に委任します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>非同期操作の状態を示すオブジェクト</xref:System.IAsyncResult>。"
  overload: System.Net.Security.NegotiateStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset is less than 0</code>.  \n  \n \\- or -  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n \\- or -  \n  \n <code>offset</code> plus count is greater than the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The write operation failed.  \n  \n \\- or -  \n  \n Encryption is in use, but the data could not be encrypted."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "実行中の書き込み操作が既に存在します。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が行われていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanRead
  id: CanRead
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NegotiateStream.CanRead
  fullName: System.Net.Security.NegotiateStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>を基になるストリームが読み取り可能かどうかを示す値</xref:System.Boolean>。"
  remarks: "成功した認証が発生した場合、このプロパティは呼び出しによって返される値を返します、<xref:System.IO.Stream.CanRead%2A>基になるストリームのプロパティ</xref:System.IO.Stream.CanRead%2A>。 <xref:System.Net.Security.NegotiateStream>クラス</xref:System.Net.Security.NegotiateStream>のインスタンスを作成するときに、基になるストリームが指定されています。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_4_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_4_1.cpp)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>認証が行われ、基になるストリームが読み取り可能な場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanSeek
  id: CanSeek
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NegotiateStream.CanSeek
  fullName: System.Net.Security.NegotiateStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>を基になるストリームがシーク可能かどうかを示す値</xref:System.Boolean>。"
  remarks: "位置を設定しないで、<xref:System.Net.Security.NegotiateStream>オブジェクトまたはその基になるストリーム</xref:System.Net.Security.NegotiateStream>。 <xref:System.Net.Security.NegotiateStream>クラス</xref:System.Net.Security.NegotiateStream>のインスタンスを作成するときに、基になるストリームが指定されています。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_3_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_3_1.cpp)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "このプロパティは常に返します<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NegotiateStream.CanTimeout
  fullName: System.Net.Security.NegotiateStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>基になるストリームがタイムアウトをサポートするかどうかを示す値</xref:System.Boolean>。"
  remarks: "このプロパティを呼び出すことによって返される値を返します、<xref:System.IO.Stream.CanTimeout%2A>基になるストリームのプロパティ</xref:System.IO.Stream.CanTimeout%2A>。 <xref:System.Net.Security.NegotiateStream>クラス</xref:System.Net.Security.NegotiateStream>のインスタンスを作成するときに、基になるストリームが指定されています。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_2_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_2_1.cpp)]"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>基になるストリームがタイムアウトをサポートしている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.CanWrite
  id: CanWrite
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NegotiateStream.CanWrite
  fullName: System.Net.Security.NegotiateStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>を基になるストリームが書き込み可能かどうかを示す値</xref:System.Boolean>。"
  remarks: "成功した認証が発生した場合、このプロパティは呼び出しによって返される値を返します、<xref:System.IO.Stream.CanWrite%2A>基になるストリームのプロパティ</xref:System.IO.Stream.CanWrite%2A>。 <xref:System.Net.Security.NegotiateStream>クラス</xref:System.Net.Security.NegotiateStream>のインスタンスを作成するときに、基になるストリームが指定されています。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_6_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_6_1.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>認証が行われ、基になるストリームが書き込み可能な場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NegotiateStream.Dispose(Boolean)
  fullName: System.Net.Security.NegotiateStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "によって使用されるアンマネージ リソースを解放、 <xref href=&quot;System.Net.Security.NegotiateStream&quot;> </xref>し、必要に応じてマネージ リソースを解放します。"
  remarks: "このメソッドは、パブリック`Dispose()`メソッドおよび<xref:System.Object.Finalize%2A>メソッド</xref:System.Object.Finalize%2A>。 `Dispose()`プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A>呼び出す`Dispose`で`disposing`&quot;éý&quot;`false`です。</xref:System.Object.Finalize%2A>       ときに、`disposing`パラメーターが true の場合、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放しますこの<xref:System.Net.Security.NegotiateStream>参照。</xref:System.Net.Security.NegotiateStream> 。 このメソッドを呼び出して、`Dispose()`参照される各オブジェクトのメソッドです。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マネージ コードとアンマネージ リソースを解放するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>アンマネージ リソースだけを解放します。"
  overload: System.Net.Security.NegotiateStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)
  id: EndAuthenticateAsClient(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndAuthenticateAsClient(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>への呼び出しで開始した保留中の非同期クライアントの認証操作を終了します。"
  remarks: "操作が完了していない場合、このメソッドはそれまでブロックします。 認証に成功した場合、必要がありますをチェックする<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A><xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>が使用されるセキュリティ サービスの種類を決定して<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。       この操作を同期的に実行するには、いずれかの操作を使用して、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。"
  syntax:
    content: public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "の<xref:System.IAsyncResult>インスタンスは<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>への呼び出しによって返されます。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.EndAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>呼び出しによって作成されていない<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*>です。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "保留中のクライアント認証が完了することはありません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)
  id: EndAuthenticateAsServer(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndAuthenticateAsServer(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>への呼び出しで開始した保留中の非同期クライアントの認証操作を終了します。"
  remarks: "操作が完了していない場合、このメソッドはそれまでブロックします。       認証に成功した場合<xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>および<xref:System.Net.Security.NegotiateStream.IsSigned%2A>プロパティ</xref:System.Net.Security.NegotiateStream.IsSigned%2A></xref:System.Net.Security.NegotiateStream.IsEncrypted%2A>をチェックする必要があります。 チェック、<xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>相互認証が行われたかどうかを決定するプロパティ</xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A>。       認証が失敗した場合が表示されたら、<xref:System.Security.Authentication.AuthenticationException>または<xref:System.Security.Authentication.InvalidCredentialException>。</xref:System.Security.Authentication.InvalidCredentialException> </xref:System.Security.Authentication.AuthenticationException> ここでは、別の資格情報を使用して認証を再試行することができます。       この操作を同期的に実行するを使用して、<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>メソッド</xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。"
  syntax:
    content: public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "の<xref:System.IAsyncResult>インスタンスは<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>への呼び出しによって返されます。</xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.EndAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>呼び出しによって作成されていない<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*>です。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "認証に失敗しました。 このオブジェクトを使用して、認証を再試行することができます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "保留中の認証が完了することはありません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NegotiateStream.EndRead(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "<xref:System.Net.Security.NegotiateStream.BeginRead*>。</xref:System.Net.Security.NegotiateStream.BeginRead*>への呼び出しで開始した非同期読み取り操作を終了します。"
  remarks: "操作が完了していない場合、このメソッドはそれまでブロックします。       この操作を同期的に実行するを使用して、<xref:System.Net.Security.NegotiateStream.Read%2A>メソッド</xref:System.Net.Security.NegotiateStream.Read%2A>。       正常に認証が完了するまでは、このメソッドを呼び出すことはできません。 を認証するには、のいずれかを呼び出して、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>、または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates ending an asynchronous read operation. For an example that demonstrates starting the operation, see <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  \n  \n [!code-cs[NclNegoAsyncServer#3](~/add/codesnippet/csharp/m-system.net.security.ne_2_1.cs)]\n [!code-cpp[NclNegoAsyncServer#3](~/add/codesnippet/cpp/m-system.net.security.ne_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>への呼び出しによって返されるインスタンス<xref:System.Net.Security.NegotiateStream.BeginRead*></xref:System.Net.Security.NegotiateStream.BeginRead*></xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "A<xref:System.Int32>基になるストリームから読み取ったバイト数を指定する値</xref:System.Int32>。"
  overload: System.Net.Security.NegotiateStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "AsyncResult は<xref:System.Net.Security.NegotiateStream.BeginRead*>。</xref:System.Net.Security.NegotiateStream.BeginRead*>への呼び出しによって作成されませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が行われていません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "読み取り操作が失敗しました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NegotiateStream.EndWrite(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "<xref:System.Net.Security.NegotiateStream.BeginWrite*>。</xref:System.Net.Security.NegotiateStream.BeginWrite*>への呼び出しで開始した非同期の書き込み操作を終了します。"
  remarks: "操作が完了していない場合、このメソッドはそれまでブロックします。       正常に認証が完了するまでは、このメソッドを呼び出すことはできません。 を認証するには、のいずれかを呼び出して、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>、または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       この操作を同期的に実行するを使用して、<xref:System.Net.Security.NegotiateStream.Write%2A>メソッド</xref:System.Net.Security.NegotiateStream.Write%2A>。"
  example:
  - "The following code example demonstrates a method that is called to complete the asynchronous write operation. For an example that demonstrates starting the operation, see <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  \n  \n [!code-cpp[NclNegoAsyncClient#4](~/add/codesnippet/cpp/m-system.net.security.ne_0_1.cpp)]\n [!code-cs[NclNegoAsyncClient#4](~/add/codesnippet/csharp/m-system.net.security.ne_0_1.cs)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>への呼び出しによって返されるインスタンス<xref:System.Net.Security.NegotiateStream.BeginWrite*></xref:System.Net.Security.NegotiateStream.BeginWrite*></xref:System.IAsyncResult>"
  overload: System.Net.Security.NegotiateStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "AsyncResult は<xref:System.Net.Security.NegotiateStream.BeginWrite*>。</xref:System.Net.Security.NegotiateStream.BeginWrite*>への呼び出しによって作成されませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が行われていません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "書き込み操作に失敗しました。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Flush
  id: Flush
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NegotiateStream.Flush()
  fullName: System.Net.Security.NegotiateStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "基になるデバイスに書き込まれるバッファー内のデータが発生します。"
  remarks: "このメソッドを呼び出して<xref:System.IO.Stream.Flush%2A>基になるストリーム</xref:System.IO.Stream.Flush%2A>。"
  example:
  - "The following code example demonstrates flushing the stream.  \n  \n [!code-cs[NclNegoSyncClient#4](~/add/codesnippet/csharp/m-system.net.security.ne_3_1.cs)]\n [!code-cpp[NclNegoSyncClient#4](~/add/codesnippet/cpp/m-system.net.security.ne_3_1.cpp)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Security.NegotiateStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.ImpersonationLevel
  id: ImpersonationLevel
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: ImpersonationLevel
  nameWithType: NegotiateStream.ImpersonationLevel
  fullName: System.Net.Security.NegotiateStream.ImpersonationLevel
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "サーバーがクライアントの資格情報を使用する方法を示す値を取得します。"
  remarks: "正常に、このメソッドを呼び出す前に認証する必要があります。 クライアントは、のいずれかを呼び出すことによって認証を要求するときに、偽装レベルを指定、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A></xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。 指定せずに認証する場合、 <xref:System.Security.Principal.TokenImpersonationLevel>、<xref:System.Security.Principal.TokenImpersonationLevel>を使用します</xref:System.Security.Principal.TokenImpersonationLevel></xref:System.Security.Principal.TokenImpersonationLevel>。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_5_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_5_1.cpp)]"
  syntax:
    content: public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }
    return:
      type: System.Security.Principal.TokenImpersonationLevel
      description: "1 つ、<xref:System.Security.Principal.TokenImpersonationLevel>値</xref:System.Security.Principal.TokenImpersonationLevel>。"
  overload: System.Net.Security.NegotiateStream.ImpersonationLevel*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が失敗したかが発生していません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsAuthenticated
  id: IsAuthenticated
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsAuthenticated
  nameWithType: NegotiateStream.IsAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsAuthenticated
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>認証が成功したかどうかを示す値</xref:System.Boolean>。"
  remarks: "クライアントの認証を呼び出して、<xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A></xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>。 呼び出してサーバーに認証、<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A></xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_10_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_10_1.cpp)]"
  syntax:
    content: public override bool IsAuthenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>認証成功した場合です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.IsAuthenticated*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsEncrypted
  id: IsEncrypted
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsEncrypted
  nameWithType: NegotiateStream.IsEncrypted
  fullName: System.Net.Security.NegotiateStream.IsEncrypted
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>を示す値かどうかこの<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>データの暗号化を使用します</xref:System.Boolean>。"
  remarks: "暗号化したデータのプライバシーの保護を利用します。つまり、ことが、データを転送中に、サード パーティによって解読できないことを確認するのに役立ちます。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_8_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_8_1.cpp)]"
  syntax:
    content: public override bool IsEncrypted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>データがネットワーク経由で送信される前に暗号化および復号化する場合に着いたときに、リモート エンドポイントです。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.IsEncrypted*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  id: IsMutuallyAuthenticated
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsMutuallyAuthenticated
  nameWithType: NegotiateStream.IsMutuallyAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>サーバーとクライアントの両方が認証されているかどうかを示す値</xref:System.Boolean>。"
  remarks: "相互認証は、クライアントが、サーバー認証用の資格情報を提供するときに、クライアントによって指定されます。 既定では、クライアントは、相互認証を要求します。       Negotiate プロトコルは、クライアントとサーバーでサポートされるセキュリティ プロトコルに応じて、NTLM または Kerberos のいずれかを選択します。 NTLM は、相互認証をサポートしていません。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_7_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_7_1.cpp)]"
  syntax:
    content: public override bool IsMutuallyAuthenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>サーバーが認証されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsServer
  id: IsServer
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsServer
  nameWithType: NegotiateStream.IsServer
  fullName: System.Net.Security.NegotiateStream.IsServer
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>この接続のローカル側が使用するかどうかを示す値<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>サーバーとして認証されました</xref:System.Boolean>。"
  remarks: "認証失敗または発生しなかった、このプロパティを返します`false`です。       サーバーで、認証に呼び出して、<xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A></xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_0_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_0_1.cpp)]"
  syntax:
    content: public override bool IsServer { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、ローカル エンドポイントは、認証された接続のサーバー側として正常に認証されましたそれ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.IsServer*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.IsSigned
  id: IsSigned
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: IsSigned
  nameWithType: NegotiateStream.IsSigned
  fullName: System.Net.Security.NegotiateStream.IsSigned
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得、<xref:System.Boolean>をこのストリームを使用して送信されるデータが署名されているかどうかを示す値</xref:System.Boolean>。"
  remarks: "データの整合性を保護することにデータの署名つまり、データが転送中に改ざんされているかどうかを決定する受信者と役に立ちます。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#1](~/add/codesnippet/csharp/p-system.net.security.ne_13_1.cs)]\n [!code-cpp[NclNegoSyncClient#1](~/add/codesnippet/cpp/p-system.net.security.ne_13_1.cpp)]"
  syntax:
    content: public override bool IsSigned { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>送信する前に、データが署名されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Net.Security.NegotiateStream.IsSigned*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Length
  id: Length
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Length
  nameWithType: NegotiateStream.Length
  fullName: System.Net.Security.NegotiateStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "基になるストリームの長さを取得します。"
  remarks: "このプロパティを呼び出すことによって返される値を返します、<xref:System.IO.Stream.Length%2A>基になるストリームのプロパティ</xref:System.IO.Stream.Length%2A>。 基になるストリームがシーク可能でない場合、このプロパティは例外をスロー通常します。 基になるストリームの実行時の型では、スローされる例外の実行時の型を決定します。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_9_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_9_1.cpp)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "A<xref:System.Int64>基になるストリームの長さを指定します</xref:System.Int64>。"
  overload: System.Net.Security.NegotiateStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "このプロパティの値を取得することはできません基になるストリームが、 <xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>です。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Position
  id: Position
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Position
  nameWithType: NegotiateStream.Position
  fullName: System.Net.Security.NegotiateStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得または基になるストリーム内の現在位置を設定します。"
  remarks: "このプロパティを呼び出すことによって返される値を返します、<xref:System.IO.Stream.Position%2A>基になるストリームのプロパティ</xref:System.IO.Stream.Position%2A>。 基になるストリームがシーク可能でない場合、このプロパティは例外をスロー通常します。 基になるストリームの実行時の型では、スローされる例外の実行時の型を決定します。"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A<xref:System.Int64>基になるストリーム内の現在位置を指定します</xref:System.Int64>。"
  overload: System.Net.Security.NegotiateStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Setting this property is not supported.  \n  \n \\- or -  \n  \n Getting the value of this property is not supported when the underlying stream is a <xref href=\"System.Net.Sockets.NetworkStream\"></xref>."
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "このストリームからデータを読み取り、指定した配列に格納します。"
  remarks: "メソッドは、最大数を読み取ります`count`現在からのバイト ストリームおよびそれらの格納で`buffer`始点`offset`です。       正常に認証が完了するまでは、このメソッドを呼び出すことはできません。 を認証するには、のいずれかを呼び出して、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>、または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       この操作を非同期的に実行するを使用して、<xref:System.Net.Security.NegotiateStream.BeginRead%2A>メソッド</xref:System.Net.Security.NegotiateStream.BeginRead%2A>。"
  example:
  - "The following code example demonstrates reading from a <xref:System.Net.Security.NegotiateStream>.  \n  \n [!code-cs[NclNegoSyncServer#1](~/add/codesnippet/csharp/e81792fe-7974-494d-8076-_1.cs)]\n [!code-cpp[NclNegoSyncServer#1](~/add/codesnippet/cpp/e81792fe-7974-494d-8076-_1.cpp)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>ストリームから読み取ったバイトを受け取る配列</xref:System.Byte>。"
    - id: offset
      type: System.Int32
      description: "A<xref:System.Int32>で&0; から始まる位置を含む`buffer`このストリームから読み取ったデータの格納を開始する位置</xref:System.Int32>。"
    - id: count
      type: System.Int32
      description: "A<xref:System.Int32>ストリームから読み取るバイトの最大数を含むします</xref:System.Int32>。"
    return:
      type: System.Int32
      description: "A<xref:System.Int32>基になるストリームから読み取ったバイト数を指定する値</xref:System.Int32>。 読み取られるデータがある場合は、0 を返します。"
  overload: System.Net.Security.NegotiateStream.Read*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "読み取り操作が失敗しました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が行われていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "読み取り操作が既に進行中です。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NegotiateStream.ReadTimeout
  fullName: System.Net.Security.NegotiateStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得または読み取り操作がブロックのデータ待機時間を設定します。"
  remarks: "このプロパティを呼び出すことによって返される値を返します、<xref:System.IO.Stream.ReadTimeout%2A>基になるストリームのプロパティ</xref:System.IO.Stream.ReadTimeout%2A>。 このプロパティを設定すると、<xref:System.IO.Stream.ReadTimeout%2A>基になるストリームの値が指定した値に設定します</xref:System.IO.Stream.ReadTimeout%2A>。       基になるストリームがある場合、 <xref:System.Net.Sockets.NetworkStream>、ReadTimeout (ミリ秒単位) に設定されている<xref:System.Threading.Timeout.Infinite>既定では操作がタイムアウトしないをしないで読み取れるようにします</xref:System.Threading.Timeout.Infinite></xref:System.Net.Sockets.NetworkStream>。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_12_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_12_1.cpp)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "A<xref:System.Int32>される読み取り操作が失敗するまでの経過時間を指定します</xref:System.Int32>。"
  overload: System.Net.Security.NegotiateStream.ReadTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.RemoteIdentity
  id: RemoteIdentity
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: RemoteIdentity
  nameWithType: NegotiateStream.RemoteIdentity
  fullName: System.Net.Security.NegotiateStream.RemoteIdentity
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "この認証されたストリームを共有するリモート側の id に関する情報を取得します。"
  remarks: "アクセスする場合、クライアントによって、このプロパティを返します、<xref:System.Security.Principal.GenericIdentity>サーバーと使用される認証プロトコルのサービス プリンシパル名 (SPN) を含むします</xref:System.Security.Principal.GenericIdentity>。 アクセスする場合、サーバーによって、このプロパティを返します、<xref:System.Security.Principal.WindowsIdentity>クライアントを記述する</xref:System.Security.Principal.WindowsIdentity>。 場合、<xref:System.Security.Principal.WindowsIdentity>が利用できない、クライアント情報が返されます<xref:System.Security.Principal.GenericIdentity>.</xref:System.Security.Principal.GenericIdentity>内のサーバーに</xref:System.Security.Principal.WindowsIdentity>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoAsyncServer#2](~/add/codesnippet/csharp/p-system.net.security.ne_1_1.cs)]\n [!code-cpp[NclNegoAsyncServer#2](~/add/codesnippet/cpp/p-system.net.security.ne_1_1.cpp)]"
  syntax:
    content: public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }
    return:
      type: System.Security.Principal.IIdentity
      description: "<xref:System.Security.Principal.IIdentity>リモート エンドポイントの id を表すオブジェクト</xref:System.Security.Principal.IIdentity>。"
  overload: System.Net.Security.NegotiateStream.RemoteIdentity*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が失敗したかが発生していません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NegotiateStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Security.NegotiateStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "<xref:System.NotSupportedException>。</xref:System.NotSupportedException>がスローされます。"
  remarks: "このメソッドを呼び出さないでください。 関数は、継承されますが、 <xref:System.Net.Security.NegotiateStream>。</xref:System.Net.Security.NegotiateStream>でサポートされていません"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "この値は無視されます。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "この値は無視されます。"
    return:
      type: System.Int64
      description: "<xref:System.NotSupportedException>。</xref:System.NotSupportedException>は常にスローします。"
  overload: System.Net.Security.NegotiateStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "シークはサポートされていない<xref href=&quot;System.Net.Security.NegotiateStream&quot;></xref>です。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NegotiateStream.SetLength(Int64)
  fullName: System.Net.Security.NegotiateStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "基になるストリームの長さを設定します。"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "<xref:System.Int64>ストリームの長さを指定する値</xref:System.Int64>。"
  overload: System.Net.Security.NegotiateStream.SetLength*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "指定した数を書き込む<xref:System.Byte>、指定されたバッファーとオフセットを使用して、基になるストリームにします</xref:System.Byte>。"
  remarks: "暗号化、署名、または暗号化および署名が有効になっている場合このメソッド バッファーからデータを読み取ります、暗号化、署名、または暗号化し署名、および基になるストリームを使用して送信します。 このメソッドを呼び出す場合は、セキュリティ サービスのない使用中では、データの暗号化や署名など、<xref:System.IO.Stream.Write%2A>基になるストリーム</xref:System.IO.Stream.Write%2A>。       このメソッドは、書き込み操作が完了するまでブロックします。 操作が完了するまでブロックを回避するのには、書き込みメソッドを使用します。       正常に認証が完了するまでは、このメソッドを呼び出すことはできません。 を認証するには、のいずれかを呼び出して、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>、 <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>、または<xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A>メソッド。</xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> </xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>       <xref:System.Net.Security.NegotiateStream>クラスが複数の同時書き込み操作をサポートしていません</xref:System.Net.Security.NegotiateStream>。 別の書き込み操作は、同じストリームで既に実行中に、書き込み操作を開始しようとする場合、<xref:System.NotSupportedException>例外がスローされます</xref:System.NotSupportedException>。"
  example:
  - "The following code example demonstrates writing to a <xref:System.Net.Security.NegotiateStream>.  \n  \n [!code-cs[NclNegoSyncClient#4](~/add/codesnippet/csharp/1536316b-fecf-4b4a-b33a-_1.cs)]\n [!code-cpp[NclNegoSyncClient#4](~/add/codesnippet/cpp/1536316b-fecf-4b4a-b33a-_1.cpp)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>をストリームに書き込まれたバイトを提供します</xref:System.Byte>。"
    - id: offset
      type: System.Int32
      description: "<xref:System.Int32>で&0; から始まる位置を含む`buffer`ストリームに書き込まれるバイトの読み取りを開始する位置</xref:System.Int32>。"
    - id: count
      type: System.Int32
      description: "A<xref:System.Int32>から読み取るバイト数を含んでいる`buffer`</xref:System.Int32>。"
  overload: System.Net.Security.NegotiateStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset is less than 0</code>.  \n  \n \\- or -  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n \\- or -  \n  \n <code>offset</code> plus count is greater than the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The write operation failed.  \n  \n \\- or -  \n  \n Encryption is in use, but the data could not be encrypted."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "実行中の書き込み操作が既に存在します。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "このオブジェクトが閉じられました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "認証が行われていません。"
  platform:
  - net462
- uid: System.Net.Security.NegotiateStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NegotiateStream.WriteTimeout
  fullName: System.Net.Security.NegotiateStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得または書き込み操作がブロックのデータ待機時間を設定します。"
  remarks: "このプロパティを呼び出すことによって返される値を返します、<xref:System.IO.Stream.WriteTimeout%2A>基になるストリームのプロパティ</xref:System.IO.Stream.WriteTimeout%2A>。 指定された値の設定、集合演算、<xref:System.IO.Stream.WriteTimeout%2A>基になるストリームの値</xref:System.IO.Stream.WriteTimeout%2A>。       基になるストリームがある場合、 <xref:System.Net.Sockets.NetworkStream>、WriteTimeout (ミリ秒単位) に設定されている<xref:System.Threading.Timeout.Infinite>既定では書き込み操作はタイムアウトしないようにします</xref:System.Threading.Timeout.Infinite></xref:System.Net.Sockets.NetworkStream>。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cs[NclNegoSyncClient#2](~/add/codesnippet/csharp/p-system.net.security.ne_11_1.cs)]\n [!code-cpp[NclNegoSyncClient#2](~/add/codesnippet/cpp/p-system.net.security.ne_11_1.cpp)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "A<xref:System.Int32>書き込み操作が失敗するまでの経過時間を指定します</xref:System.Int32>。"
  overload: System.Net.Security.NegotiateStream.WriteTimeout*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: System.Net.Security.AuthenticatedStream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.Authentication.AuthenticationException
  parent: System.Security.Authentication
  isExternal: false
  name: AuthenticationException
  nameWithType: AuthenticationException
  fullName: System.Security.Authentication.AuthenticationException
- uid: System.Security.Authentication.InvalidCredentialException
  parent: System.Security.Authentication
  isExternal: false
  name: InvalidCredentialException
  nameWithType: InvalidCredentialException
  fullName: System.Security.Authentication.InvalidCredentialException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: NegotiateStream(Stream)
  nameWithType: NegotiateStream.NegotiateStream(Stream)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream)
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: NegotiateStream(Stream,Boolean)
  nameWithType: NegotiateStream.NegotiateStream(Stream,Boolean)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(Stream,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient()
  nameWithType: NegotiateStream.AuthenticateAsClient()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient()
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String)
- uid: System.Net.NetworkCredential
  parent: System.Net
  isExternal: true
  name: NetworkCredential
  nameWithType: NetworkCredential
  fullName: System.Net.NetworkCredential
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String)
- uid: System.Security.Authentication.ExtendedProtection.ChannelBinding
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: true
  name: ChannelBinding
  nameWithType: ChannelBinding
  fullName: System.Security.Authentication.ExtendedProtection.ChannelBinding
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.ProtectionLevel
  parent: System.Net.Security
  isExternal: false
  name: ProtectionLevel
  nameWithType: ProtectionLevel
  fullName: System.Net.Security.ProtectionLevel
- uid: System.Security.Principal.TokenImpersonationLevel
  parent: System.Security.Principal
  isExternal: true
  name: TokenImpersonationLevel
  nameWithType: TokenImpersonationLevel
  fullName: System.Security.Principal.TokenImpersonationLevel
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync()
  nameWithType: NegotiateStream.AuthenticateAsClientAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync()
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer()
  nameWithType: NegotiateStream.AuthenticateAsServer()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer()
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(ExtendedProtectionPolicy)
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync()
  nameWithType: NegotiateStream.AuthenticateAsServerAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync()
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(ExtendedProtectionPolicy)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  nameWithType: NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential,ChannelBinding,String,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(ExtendedProtectionPolicy,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(NetworkCredential,ExtendedProtectionPolicy,ProtectionLevel,TokenImpersonationLevel,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.NegotiateStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Security.NegotiateStream.CanRead
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanRead
  nameWithType: NegotiateStream.CanRead
  fullName: System.Net.Security.NegotiateStream.CanRead
- uid: System.Net.Security.NegotiateStream.CanSeek
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanSeek
  nameWithType: NegotiateStream.CanSeek
  fullName: System.Net.Security.NegotiateStream.CanSeek
- uid: System.Net.Security.NegotiateStream.CanTimeout
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanTimeout
  nameWithType: NegotiateStream.CanTimeout
  fullName: System.Net.Security.NegotiateStream.CanTimeout
- uid: System.Net.Security.NegotiateStream.CanWrite
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanWrite
  nameWithType: NegotiateStream.CanWrite
  fullName: System.Net.Security.NegotiateStream.CanWrite
- uid: System.Net.Security.NegotiateStream.Dispose(System.Boolean)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NegotiateStream.Dispose(Boolean)
  fullName: System.Net.Security.NegotiateStream.Dispose(Boolean)
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsClient(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsClient(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsServer(IAsyncResult)
  nameWithType: NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndAuthenticateAsServer(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NegotiateStream.EndRead(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndRead(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NegotiateStream.EndWrite(IAsyncResult)
  fullName: System.Net.Security.NegotiateStream.EndWrite(IAsyncResult)
- uid: System.Net.Security.NegotiateStream.Flush
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Flush()
  nameWithType: NegotiateStream.Flush()
  fullName: System.Net.Security.NegotiateStream.Flush()
- uid: System.Net.Security.NegotiateStream.ImpersonationLevel
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ImpersonationLevel
  nameWithType: NegotiateStream.ImpersonationLevel
  fullName: System.Net.Security.NegotiateStream.ImpersonationLevel
- uid: System.Net.Security.NegotiateStream.IsAuthenticated
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsAuthenticated
  nameWithType: NegotiateStream.IsAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsAuthenticated
- uid: System.Net.Security.NegotiateStream.IsEncrypted
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsEncrypted
  nameWithType: NegotiateStream.IsEncrypted
  fullName: System.Net.Security.NegotiateStream.IsEncrypted
- uid: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsMutuallyAuthenticated
  nameWithType: NegotiateStream.IsMutuallyAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
- uid: System.Net.Security.NegotiateStream.IsServer
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsServer
  nameWithType: NegotiateStream.IsServer
  fullName: System.Net.Security.NegotiateStream.IsServer
- uid: System.Net.Security.NegotiateStream.IsSigned
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsSigned
  nameWithType: NegotiateStream.IsSigned
  fullName: System.Net.Security.NegotiateStream.IsSigned
- uid: System.Net.Security.NegotiateStream.Length
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Length
  nameWithType: NegotiateStream.Length
  fullName: System.Net.Security.NegotiateStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Security.NegotiateStream.Position
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Position
  nameWithType: NegotiateStream.Position
  fullName: System.Net.Security.NegotiateStream.Position
- uid: System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Security.NegotiateStream.ReadTimeout
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NegotiateStream.ReadTimeout
  fullName: System.Net.Security.NegotiateStream.ReadTimeout
- uid: System.Net.Security.NegotiateStream.RemoteIdentity
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: RemoteIdentity
  nameWithType: NegotiateStream.RemoteIdentity
  fullName: System.Net.Security.NegotiateStream.RemoteIdentity
- uid: System.Security.Principal.IIdentity
  parent: System.Security.Principal
  isExternal: true
  name: IIdentity
  nameWithType: IIdentity
  fullName: System.Security.Principal.IIdentity
- uid: System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NegotiateStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Security.NegotiateStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Security.NegotiateStream.SetLength(System.Int64)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NegotiateStream.SetLength(Int64)
  fullName: System.Net.Security.NegotiateStream.SetLength(Int64)
- uid: System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NegotiateStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Security.NegotiateStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Security.NegotiateStream.WriteTimeout
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NegotiateStream.WriteTimeout
  fullName: System.Net.Security.NegotiateStream.WriteTimeout
- uid: System.Net.Security.NegotiateStream.#ctor*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: NegotiateStream
  nameWithType: NegotiateStream.NegotiateStream
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClient*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClient
  nameWithType: NegotiateStream.AuthenticateAsClient
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsClientAsync
  nameWithType: NegotiateStream.AuthenticateAsClientAsync
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServer
  nameWithType: NegotiateStream.AuthenticateAsServer
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: AuthenticateAsServerAsync
  nameWithType: NegotiateStream.AuthenticateAsServerAsync
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsClient*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsClient
  nameWithType: NegotiateStream.BeginAuthenticateAsClient
- uid: System.Net.Security.NegotiateStream.BeginAuthenticateAsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginAuthenticateAsServer
  nameWithType: NegotiateStream.BeginAuthenticateAsServer
- uid: System.Net.Security.NegotiateStream.BeginRead*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginRead
  nameWithType: NegotiateStream.BeginRead
- uid: System.Net.Security.NegotiateStream.BeginWrite*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: BeginWrite
  nameWithType: NegotiateStream.BeginWrite
- uid: System.Net.Security.NegotiateStream.CanRead*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanRead
  nameWithType: NegotiateStream.CanRead
- uid: System.Net.Security.NegotiateStream.CanSeek*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanSeek
  nameWithType: NegotiateStream.CanSeek
- uid: System.Net.Security.NegotiateStream.CanTimeout*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanTimeout
  nameWithType: NegotiateStream.CanTimeout
- uid: System.Net.Security.NegotiateStream.CanWrite*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: CanWrite
  nameWithType: NegotiateStream.CanWrite
- uid: System.Net.Security.NegotiateStream.Dispose*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Dispose
  nameWithType: NegotiateStream.Dispose
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsClient*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsClient
  nameWithType: NegotiateStream.EndAuthenticateAsClient
- uid: System.Net.Security.NegotiateStream.EndAuthenticateAsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndAuthenticateAsServer
  nameWithType: NegotiateStream.EndAuthenticateAsServer
- uid: System.Net.Security.NegotiateStream.EndRead*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndRead
  nameWithType: NegotiateStream.EndRead
- uid: System.Net.Security.NegotiateStream.EndWrite*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: EndWrite
  nameWithType: NegotiateStream.EndWrite
- uid: System.Net.Security.NegotiateStream.Flush*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Flush
  nameWithType: NegotiateStream.Flush
- uid: System.Net.Security.NegotiateStream.ImpersonationLevel*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ImpersonationLevel
  nameWithType: NegotiateStream.ImpersonationLevel
- uid: System.Net.Security.NegotiateStream.IsAuthenticated*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsAuthenticated
  nameWithType: NegotiateStream.IsAuthenticated
- uid: System.Net.Security.NegotiateStream.IsEncrypted*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsEncrypted
  nameWithType: NegotiateStream.IsEncrypted
- uid: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsMutuallyAuthenticated
  nameWithType: NegotiateStream.IsMutuallyAuthenticated
- uid: System.Net.Security.NegotiateStream.IsServer*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsServer
  nameWithType: NegotiateStream.IsServer
- uid: System.Net.Security.NegotiateStream.IsSigned*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: IsSigned
  nameWithType: NegotiateStream.IsSigned
- uid: System.Net.Security.NegotiateStream.Length*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Length
  nameWithType: NegotiateStream.Length
- uid: System.Net.Security.NegotiateStream.Position*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Position
  nameWithType: NegotiateStream.Position
- uid: System.Net.Security.NegotiateStream.Read*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Read
  nameWithType: NegotiateStream.Read
- uid: System.Net.Security.NegotiateStream.ReadTimeout*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NegotiateStream.ReadTimeout
- uid: System.Net.Security.NegotiateStream.RemoteIdentity*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: RemoteIdentity
  nameWithType: NegotiateStream.RemoteIdentity
- uid: System.Net.Security.NegotiateStream.Seek*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Seek
  nameWithType: NegotiateStream.Seek
- uid: System.Net.Security.NegotiateStream.SetLength*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: SetLength
  nameWithType: NegotiateStream.SetLength
- uid: System.Net.Security.NegotiateStream.Write*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: Write
  nameWithType: NegotiateStream.Write
- uid: System.Net.Security.NegotiateStream.WriteTimeout*
  parent: System.Net.Security.NegotiateStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NegotiateStream.WriteTimeout
