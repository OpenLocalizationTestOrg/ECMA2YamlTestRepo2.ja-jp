### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "などのメソッドによって設定できるプロパティ、スタイル、データ バインディング、アニメーション、および継承を表します。"
  remarks: "DependencyProperty では、次の機能をサポートしている[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-スタイルのプロパティを設定できます。 詳細については、次を参照してください。[スタイルとテンプレート](~/add/includes/ajax-current-ext-md.md)です。      -プロパティは、データ バインディングによって設定できます。 データ バインディングの依存関係プロパティの詳細については、次を参照してください。[する方法: プロパティの&2; つのコントロールをバインド](~/add/includes/ajax-current-ext-md.md)です。      動的リソース参照では、プロパティを設定できます。 詳細については、次を参照してください。 [XAML リソース](~/add/includes/ajax-current-ext-md.md)です。      -プロパティは、要素ツリーの親要素からその値を自動的に継承できます。 詳細については、次を参照してください。[プロパティ値の継承](~/add/includes/ajax-current-ext-md.md)です。      -プロパティをアニメーション化することができます。 詳細については、次を参照してください。[アニメーションの概要](~/add/includes/ajax-current-ext-md.md)です。      -プロパティは、プロパティの前の値が変更され、プロパティの値を強制的に変換できる場合に報告できます。 詳細については、次を参照してください。[依存関係プロパティのコールバックと検証](~/add/includes/ajax-current-ext-md.md)です。      -プロパティ情報に報告[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]などかどうか、ビジュアル要素を再構成するには、レイアウト システムを要求プロパティの値を変更する必要があります。      -プロパティのサポートの受信、[!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)]です。  プロパティの編集など、**プロパティ**ウィンドウです。       依存関係プロパティの詳細については、次を参照してください。[依存関係プロパティの概要](~/add/includes/ajax-current-ext-md.md)です。 上記の機能をサポートするためにカスタム型のプロパティをする場合は、依存関係プロパティを作成する必要があります。  カスタム依存関係プロパティを作成する方法についてを参照してください。[依存関係プロパティをカスタム](~/add/includes/ajax-current-ext-md.md)です。       添付プロパティは、添付プロパティを定義する型情報を報告する任意のオブジェクトを可能にするプロパティです。 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]、任意の型から継承する<xref:System.Windows.DependencyObject>プロパティを定義する型から型を継承するかどうかに関係なく、添付プロパティを使用できます</xref:System.Windows.DependencyObject>。 添付プロパティは、の機能、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]言語です。  接続されているプロパティを設定する[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]を使用して、 *ownerType*.*propertyName*構文です。 添付プロパティの例は、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>プロパティ</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>。 すべてで使用できるプロパティを作成するかどうかは<xref:System.Windows.DependencyObject>型は、次に、添付プロパティを作成する必要があります</xref:System.Windows.DependencyObject>。 添付プロパティの場合、それらを作成する方法などの詳細についてを参照してください。[添付プロパティの概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a>## XAML 属性の使用```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> ## XAML 値`dependencyPropertyName`を指定する文字列、<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>の必要な依存関係プロパティ</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>。       これは、前に XML 名前空間プレフィックス プロパティが既定の XML 名前空間にない場合 (詳細については、「 [XAML 名前空間と WPF XAML のマッピングの Namespace](~/add/includes/ajax-current-ext-md.md))。      `ownerType`.`dependencyPropertyName`    ドット (.)、し<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>。</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>では、依存関係プロパティの所有者の種類を指定する文字列 `ownerType`XML 名前空間プレフィックスによっても前ことができます。 この使用法は遅延バインドのスタイルとテンプレート、ためにコンテキストを解析するため、依存関係プロパティの所有者を指定する必要がありますに特定の`TargetType`が未だ不明です。 詳細については、次を参照してください。[スタイルとテンプレート](../Topic/Styling%20and%20Templating.md)です。       `attachedPropertyOwnerType` *.* `attachedPropertyName`ドット (.)、添付プロパティの名前では、添付プロパティの所有者を指定する文字列。 `attachedPropertyOwnerType`XML 名前空間プレフィックスによっても前ことができます。"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "既に登録されている依存関係プロパティの所有者として別の型を追加します。"
  remarks: "このメソッドは、その特定の依存関係プロパティを最初に登録していない型に依存関係プロパティを認識するプロパティのシステムを使用します。       通常、AddOwner は既にマネージ クラスの継承によってその依存関係プロパティを公開しないクラスに依存関係プロパティを追加する使用 (クラスの継承、派生クラスによって継承されるラッパーのプロパティを原因となるをためは一般的なメンバー テーブルにアクセスできる依存関係プロパティ既に)。 AddOwner により、その依存関係プロパティを最初に登録していない型に依存関係プロパティを認識するプロパティ システムです。       メタデータを指定するのには、この署名することはできません。  このメソッドを使用すると、メタデータが、新しい自動的に生成<xref:System.Windows.DependencyProperty>とその所有者の型</xref:System.Windows.DependencyProperty>。 自動生成されたメタデータは、このプロパティが定義されている基本型のすべてからマージされたメタデータの結果を示します。 マージされたメタデータがない場合、使用可能な場合は、プロパティの既定のメタデータが使用されます。 使用して、プロパティが登録されている場合、<xref:System.Windows.DependencyProperty.RegisterAttached%2A>メソッド後の既定のメタデータと同じ場合は、作成するメタデータ<xref:System.Windows.DependencyProperty.RegisterAttached%2A>が呼び出されました</xref:System.Windows.DependencyProperty.RegisterAttached%2A></xref:System.Windows.DependencyProperty.RegisterAttached%2A>。 それ以外の場合、<xref:System.Windows.PropertyMetadata>でオブジェクトを作成、<xref:System.Windows.PropertyMetadata.DefaultValue%2A>プロパティがプロパティの型の既定値を他のすべてのプロパティの設定、<xref:System.Windows.PropertyMetadata>に設定されている`null`</xref:System.Windows.PropertyMetadata></xref:System.Windows.PropertyMetadata.DefaultValue%2A></xref:System.Windows.PropertyMetadata>。 使用して、<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>署名を指定した型に追加されると、依存関係プロパティのバージョンのメタデータを提供する場合</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>。       このメソッドの戻り値は通常、宣言して依存関係プロパティの識別子を格納することにより、依存関係プロパティを公開に使用されます。 識別子には、依存関係プロパティへのアクセスをプロパティ システムに呼び出したい[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]依存関係プロパティに対して特には存在する追加の所有者のクラスにします。 元の所有者と追加された所有者の両方に同じプロパティ名は、同様の機能を示すために使用する必要があります。 使用する必要があります、<xref:System.Windows.DependencyProperty>依存関係プロパティの識別子を定義し、宣言の AddOwner メソッドの戻り値[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]AddOwner を使用して型に追加される依存関係プロパティのプロパティのラッパー</xref:System.Windows.DependencyProperty> 。       内で宣言されている依存関係プロパティを作成するときに、前の推奨される AddOwner 手法が使用される[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]です。 たとえば、両方<xref:System.Windows.Controls.Border>と<xref:System.Windows.Controls.Control>定義、`BorderBrush`類似した機能の依存関係プロパティです</xref:System.Windows.Controls.Control></xref:System.Windows.Controls.Border>。 <xref:System.Windows.Controls.Control>定義、 `BorderBrush` AddOwner を呼び出すことによって、プロパティ システムにプロパティが元の所有者に基づく<xref:System.Windows.Controls.Border>とその登録<xref:System.Windows.Controls.Border.BorderBrushProperty>依存関係プロパティの識別子</xref:System.Windows.Controls.Border.BorderBrushProperty></xref:System.Windows.Controls.Border>。</xref:System.Windows.Controls.Control> AddOwner 返す値は、新しい静的なを確立するために使用し、<xref:System.Windows.DependencyProperty>フィールド (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 追加の所有者にそのプロパティの`BorderBrush`プロパティ ラッパーが宣言されても</xref:System.Windows.Controls.Control.BorderBrushProperty></xref:System.Windows.DependencyProperty>。"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "この依存関係プロパティの所有者として追加する型。"
    return:
      type: System.Windows.DependencyProperty
      description: "元への参照を<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>依存関係プロパティを識別する識別子。 この識別子として追加するクラスによって公開するように、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>フィールドです。"
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "既に登録されている依存関係プロパティの所有者として別の型を追加し、依存関係プロパティの依存関係プロパティのメタデータを提供するように、指定された所有者の型に存在します。"
  remarks: "このメソッドは、その特定の依存関係プロパティを最初に登録していない型に依存関係プロパティを認識するプロパティのシステムを使用します。       このメソッドの戻り値は、追加の所有者クラス上に存在するように特に宣言して、依存関係プロパティを公開に使用されます。 一般に、同様の機能を示すために、元の所有者と追加された所有者の両方に同じプロパティ名を使用してください。 同様に新しい識別子を公開することをお勧め[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A>を使用して型に追加される依存関係プロパティのプロパティのラッパー       <xref:System.Windows.DependencyProperty.AddOwner%2A>前の推奨される方法を作成するときに使用[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]内で宣言された[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</xref:System.Windows.DependencyProperty.AddOwner%2A>。 たとえば、両方<xref:System.Windows.Controls.Border>と<xref:System.Windows.Controls.Control>定義、`BorderBrush`類似した機能の依存関係プロパティです</xref:System.Windows.Controls.Control></xref:System.Windows.Controls.Border>。 <xref:System.Windows.Controls.Control>定義、`BorderBrush`プロパティを呼び出してプロパティのシステムを<xref:System.Windows.DependencyProperty.AddOwner%2A>元の所有者に<xref:System.Windows.Controls.Border>とその登録<xref:System.Windows.Controls.Border.BorderBrushProperty>依存関係プロパティの識別子です</xref:System.Windows.Controls.Border.BorderBrushProperty></xref:System.Windows.Controls.Border></xref:System.Windows.DependencyProperty.AddOwner%2A>。</xref:System.Windows.Controls.Control> <xref:System.Windows.DependencyProperty.AddOwner%2A>戻り値は、静的なを確立するために使用し、<xref:System.Windows.DependencyProperty>フィールド (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 追加の所有者にそのプロパティの`BorderBrush`プロパティ ラッパーが宣言されても</xref:System.Windows.Controls.Control.BorderBrushProperty></xref:System.Windows.DependencyProperty></xref:System.Windows.DependencyProperty.AddOwner%2A>。       <xref:System.Windows.DependencyObject.GetValue%2A>。</xref:System.Windows.DependencyObject.GetValue%2A>などの操作で追加された所有者の依存関係プロパティの識別子を使用する必要があります。 ただし、型または異なるメタデータを持つ所有者があるように追加されたクラスのインスタンスのいずれかに関係する型固有の操作を返すいなくても、期待どおりの結果、元 (いない追加の所有者の) <xref:System.Windows.DependencyObject.GetValue%2A>、または<xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A></xref:System.Windows.DependencyObject.GetValue%2A>などのメソッドの呼び出しで依存関係プロパティの識別子が指定されました。 メタデータ、追加された所有者、AddOwner をそれ自体を呼び出す、必ずしも所有者クラス識別子フィールドの追加によってのみ参照できます。 いずれにしても、同様に新しい識別子を公開することをお勧めは[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]の間に不一致を作成するように失敗したため AddOwner を使用して型に追加される依存関係プロパティのプロパティのラッパー、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]と[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]プロパティの表現。       提供されたメタデータは、基本の所有者に存在する依存関係プロパティのプロパティ メタデータに結合されます。 元の基本のメタデータで指定された特性が保持されます。 新しいメタデータに変更された特に特徴だけでは、基本のメタデータの特性を上書きします。 いくつかの特性など<xref:System.Windows.PropertyMetadata.DefaultValue%2A>、新しいメタデータに指定されている場合に置き換えられます</xref:System.Windows.PropertyMetadata.DefaultValue%2A>。 他のユーザーなど<xref:System.Windows.PropertyChangedCallback>、結合されます</xref:System.Windows.PropertyChangedCallback>。 最終的には、マージの動作によって異なりますので、ここで説明されている動作で使用される既存のプロパティのメタデータ クラス用に、上書きに使用されているプロパティのメタデータ型[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]依存関係プロパティです。 詳細については、「[依存関係プロパティのメタデータ](~/add/includes/ajax-current-ext-md.md)と[フレームワーク プロパティ メタデータ](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "この依存関係プロパティの所有者として追加する型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "指定した型に存在する場合は、依存関係プロパティを修飾するメタデータ。"
    return:
      type: System.Windows.DependencyProperty
      description: "元への参照を<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>依存関係プロパティを識別する識別子。 この識別子として追加するクラスによって公開するように、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>フィールドです。"
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティの既定のメタデータを取得します。"
  remarks: "既定のメタデータは、代替メタデータが指定されていない明示的な特定のオブジェクトまたは派生型のオブジェクトに提供されるプロパティのメタデータ<xref:System.Windows.DependencyProperty.Register%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>呼び出します</xref:System.Windows.DependencyProperty.OverrideMetadata%2A></xref:System.Windows.DependencyProperty.Register%2A>。       元の所有者では、最初にメタデータが適用されている場合<xref:System.Windows.DependencyProperty.Register%2A>を DefaultMetadata としてそのメタデータが返されます、依存関係プロパティを設定します</xref:System.Windows.DependencyProperty.Register%2A>。       元のメタデータが適用されない場合<xref:System.Windows.DependencyProperty.Register%2A>内から既定のメタデータを生成しを呼び出すと、<xref:System.Windows.DependencyProperty.Register%2A>呼び出し、この値は、DefaultMetadata として返されます</xref:System.Windows.DependencyProperty.Register%2A></xref:System.Windows.DependencyProperty.Register%2A>。       関連付けられている既定のメタデータを持つの主な目的、<xref:System.Windows.DependencyProperty>はいずれかでこのプロパティの既定値を指定する<xref:System.Windows.DependencyObject>または派生型です</xref:System.Windows.DependencyObject></xref:System.Windows.DependencyProperty>。       非添付プロパティは、このプロパティによって返されるメタデータの種類の派生型にキャストできません<xref:System.Windows.PropertyMetadata>プロパティが最初に登録されたメタデータの派生型を持つ場合でもを入力します</xref:System.Windows.PropertyMetadata>。 元のメタデータの可能性のある派生型を含む最初に登録されているメタデータを実行する場合に、呼び出す<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>パラメーターとして代わりに、入力元の登録を渡します</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>。       このプロパティによって返されるメタデータの型が元の指定された型を一致、添付プロパティの<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登録方法</xref:System.Windows.DependencyProperty.RegisterAttached%2A>。"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティの既定のメタデータ。"
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "このハッシュ コードを返します<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>です。"
  remarks: "プロパティのシステムが、独自の一意の識別子を使用して<xref:System.Windows.DependencyProperty.GlobalIndex%2A>、そのプロパティの値は GetHashCode によって返されます</xref:System.Windows.DependencyProperty.GlobalIndex%2A>。"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "ハッシュ コードをこの<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>です。"
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定した既存の型に存在する場合は、この依存関係プロパティのメタデータを返します。"
  remarks: "型は、必要なメタデータが原因のいずれかの元の登録から変化するために使用する種類またはオブジェクト参照を指定する<xref:System.Windows.DependencyProperty.AddOwner%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>型に存在する依存関係プロパティのメタデータを変更する呼び出し</xref:System.Windows.DependencyProperty.OverrideMetadata%2A></xref:System.Windows.DependencyProperty.AddOwner%2A>。"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "依存関係プロパティのメタデータを取得する対象の特定の型。"
    return:
      type: System.Windows.PropertyMetadata
      description: "プロパティ メタデータ オブジェクト。"
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したオブジェクト インスタンスに存在する場合は、この依存関係プロパティのメタデータを返します。"
  remarks: "型またはオブジェクト参照のいずれかが、指定するために必要な元の登録をいずれかが理由から、指定した依存関係プロパティのメタデータが異なるので<xref:System.Windows.DependencyProperty.AddOwner%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しを型に存在する場合、プロパティ メタデータを絞り込むことができます</xref:System.Windows.DependencyProperty.OverrideMetadata%2A></xref:System.Windows.DependencyProperty.AddOwner%2A>。       インスタンスに基づくプロパティのメタデータを要求するときに内部的にその型を評価できるようにインスタンスを渡しているに過ぎません。 依存関係プロパティのメタデータがインスタンスごとに異なるされません。任意の型のプロパティの組み合わせに対して整合性が常にします。"
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "依存関係プロパティの型固有バージョンからのメタデータが取得するための型をチェックする依存関係オブジェクト。"
    return:
      type: System.Windows.PropertyMetadata
      description: "プロパティ メタデータ オブジェクト。"
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定した型に存在する場合は、この依存関係プロパティのメタデータを返します。"
  remarks: "型またはオブジェクト参照のいずれかが、指定するために必要な元の登録をいずれかが理由から、指定した依存関係プロパティのメタデータが異なるので<xref:System.Windows.DependencyProperty.AddOwner%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しを型に存在する場合、プロパティ メタデータを絞り込むことができます</xref:System.Windows.DependencyProperty.OverrideMetadata%2A></xref:System.Windows.DependencyProperty.AddOwner%2A>。"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "依存関係プロパティのメタデータの取得元となる依存関係オブジェクトの種類を記録する特定のオブジェクト。"
    return:
      type: System.Windows.PropertyMetadata
      description: "プロパティ メタデータ オブジェクト。"
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティを一意に識別する内部で生成された値を取得します。"
  remarks: "この値は、整数、[!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]です。 一般に、このインデックスの値を使用して、必要はありませんし、インデックス テーブルにアクセスするすべての依存関係プロパティがありません。 依存関係プロパティは、識別子フィールドで代わりに参照する必要があります。       GlobalIndex は、0 から始まる配列インデックスとして、GlobalIndex を使用するデータ構造へのアクセス速度を内部的に使用されます。 ような使用法は、アプリケーションの設計者またはツールがあります。"
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "一意の数値識別子。"
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "元の依存関係プロパティの登録で指定されたプロパティの型に対してチェック済みとして指定された値がこの依存関係プロパティの型の許容されるかどうかを判断します。"
  remarks: "値`null`または参照型の依存関係プロパティの有効な種類、<xref:System.Nullable%601>依存関係プロパティを返す`true`このような場合</xref:System.Nullable%601>。 依存関係プロパティのどちらの参照がある場合も、 <xref:System.Nullable%601>IsValidType が返されますの種類、 `false` raise 例外ではなく、null 値の</xref:System.Nullable%601>。"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "確認する値。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、指定された値は、登録済みプロパティの型、または適切な派生型です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "基本型チェックを使用してプロパティの型指定された値が受け入れられるようにするかどうかを判断しも可能性がある、その型の値の許容範囲内にある場合。"
  remarks: "依存関係プロパティを通じてその型の値の許容の範囲を指定できます、<xref:System.Windows.ValidateValueCallback>は依存関係プロパティの登録で提供される</xref:System.Windows.ValidateValueCallback>。       このメソッドを呼び出す<xref:System.Windows.DependencyProperty.IsValidType%2A>内部的にします</xref:System.Windows.DependencyProperty.IsValidType%2A>。 対象の依存関係プロパティがあるない場合<xref:System.Windows.ValidateValueCallback>、 <xref:System.Windows.DependencyProperty.IsValidType%2A>。</xref:System.Windows.DependencyProperty.IsValidType%2A>を呼び出すことと実質的に同一では、このメソッドを呼び出す</xref:System.Windows.ValidateValueCallback> 依存関係プロパティが設定されている場合、 <xref:System.Windows.ValidateValueCallback>、場合<xref:System.Windows.DependencyProperty.IsValidType%2A>が返される`true`コールバックで実装されたとされる値が返されます</xref:System.Windows.DependencyProperty.IsValidType%2A></xref:System.Windows.ValidateValueCallback>。       Null 値は、参照型の依存関係プロパティのまたは有効な値、<xref:System.Nullable%601>依存関係プロパティは、返されます`true`このような場合</xref:System.Nullable%601>。 依存関係プロパティのどちらの参照がある場合も、<xref:System.Nullable%601>型、<xref:System.Windows.DependencyProperty.IsValidType%2A>戻ります`false`raise 例外ではなく、null 値の</xref:System.Windows.DependencyProperty.IsValidType%2A></xref:System.Nullable%601>。"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "確認する値。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>値が許容可能なは場合、適切な型または派生型であります。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティの名前を取得します。"
  remarks: "このプロパティで指定された名前を取得する、`name`依存関係プロパティの登録時にパラメーター。 この名前は変更できないとすることはできません`null`または空の文字列。 同じ所有者型に重複する名前登録では、許可されていません、重複を登録しようとしたときに例外がスローされます。      > [!IMPORTANT] > 依存関係プロパティの名前サフィックスの&quot;Property&quot;マイナスその依存関係プロパティの識別子の名前と一致する規則に従う必要があります。 詳細については、「[依存関係プロパティのカスタム](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "プロパティの名前です。"
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティの基本型から継承されたときに存在していたメタデータをオーバーライドする、指定した型のインスタンスに存在する場合は、この依存関係プロパティの代替メタデータを指定します。"
  remarks: "プロパティのシステムは、依存関係プロパティを使用する前に、依存関係プロパティのメタデータをオーバーライドする必要があります。 これは、特定のインスタンスは、依存関係プロパティを登録するクラスを使用して作成された時刻に相当します。 OverrideMetadata 呼び出しとしてそれ自体を提供する型の静的コンス トラクター内でのみ実行する必要があります、`forType`またはのようなインスタンス化でこのメソッドのパラメーターです。 所有者の型のインスタンスが存在した後、メタデータを変更するとしていますが、例外は発生しませんが、プロパティ システムに一貫性のない動作が発生します。       このメソッドを使用して特定の派生クラスのオーバーライドのメタデータが確立されると、同じ派生クラスでメタデータをオーバーライドしようとするとは、例外が発生します。       提供されたメタデータは、基本の所有者に存在する依存関係プロパティのプロパティ メタデータに結合されます。 元の基本のメタデータで指定された特性が保持されます。新しいメタデータに変更された特に特徴だけでは、基本のメタデータの特性を上書きします。 などのいくつかの特性<xref:System.Windows.PropertyMetadata.DefaultValue%2A>新しいメタデータに指定されている場合に置き換えられます</xref:System.Windows.PropertyMetadata.DefaultValue%2A>。 他のユーザーなど<xref:System.Windows.PropertyChangedCallback>、結合されます</xref:System.Windows.PropertyChangedCallback>。 最終的には、マージの動作によって異なりますので、ここで説明されている動作で使用される既存のプロパティのメタデータ クラス用に、上書きに使用されているプロパティのメタデータ型[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]依存関係プロパティです。 詳細については、「[依存関係プロパティのメタデータ](~/add/includes/ajax-current-ext-md.md)と[フレームワーク プロパティ メタデータ](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "この依存関係プロパティが継承された型と、指定した代替メタデータが適用されます。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "オーバーライドする型の依存関係プロパティに適用するメタデータ。"
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "読み取り専用の依存関係プロパティのメタデータをオーバーライドしようとしました (操作を実行することはできませんこの署名を使用して)。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定した型に存在する場合、依存関係プロパティのメタデータが確立既にされました。"
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "初期の依存関係プロパティの登録で指定されたメタデータをオーバーライドする、指定した型のインスタンスに存在するときに、代替の読み取り専用の依存関係プロパティのメタデータを提供します。 渡す必要があります、 <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref>の例外の発生を防ぐために読み取り専用の依存関係プロパティです。"
  remarks: "この署名が読み取り専用の依存関係プロパティの識別子の基になる実装を提供 (<xref:System.Windows.DependencyPropertyKey>) メソッド</xref:System.Windows.DependencyPropertyKey>。 読み取り/書き込みの依存関係プロパティのメタデータをオーバーライドする場合は、 <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>を使用します。       プロパティのシステムは、依存関係プロパティを使用する前に、依存関係プロパティのメタデータをオーバーライドする必要があります。 これは、依存関係プロパティを登録するクラスの特定のオブジェクトが作成された時間に相当します。 呼び出す<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>としてそれ自体を提供する型の静的コンス トラクター内でのみ実行する必要があります、`forType`またはのようなインスタンス化でこのメソッドのパラメーターです</xref:System.Windows.DependencyProperty.OverrideMetadata%2A>。 所有者の型のインスタンスが存在した後、メタデータを変更するとしていますが、例外は発生しませんが、プロパティ システムに一貫性のない動作が発生します。       このメソッドを使用して特定の派生クラスのオーバーライドのメタデータが確立されると、同じ派生クラスでメタデータをオーバーライドしようとするとは、例外が発生します。       提供されたメタデータは、基本の所有者に存在する依存関係プロパティのプロパティ メタデータに結合されます。 元の基本のメタデータで指定された特性が保持されます。新しいメタデータに変更された特に特徴だけでは、基本のメタデータの特性を上書きします。 などのいくつかの特性<xref:System.Windows.PropertyMetadata.DefaultValue%2A>新しいメタデータに指定されている場合に置き換えられます</xref:System.Windows.PropertyMetadata.DefaultValue%2A>。 他のユーザーなど<xref:System.Windows.PropertyChangedCallback>、結合されます</xref:System.Windows.PropertyChangedCallback>。 マージの動作は、上書きに使用されているプロパティのメタデータの型によって異なります。 詳細については、「[依存関係プロパティのメタデータ](~/add/includes/ajax-current-ext-md.md)と[フレームワーク プロパティ メタデータ](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "この依存関係プロパティが継承された型と、指定した代替メタデータが適用されます。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "オーバーライドする型の依存関係プロパティに適用するメタデータ。"
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "読み取り専用の依存関係プロパティのアクセス キー。"
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティ システムに登録された、プロパティ、または自身をプロパティの所有者として追加されるオブジェクトの種類を取得します。"
  remarks: "この値は、プロパティの登録時に指定されました。 所有者が型にするか元登録の場合、<xref:System.Windows.DependencyProperty>識別子から生成された、<xref:System.Windows.DependencyProperty.Register%2A>呼び出し、または自身の場合、所有者として追加する型、<xref:System.Windows.DependencyProperty>識別子から生成された、<xref:System.Windows.DependencyProperty.AddOwner%2A>呼び出します</xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.DependencyProperty></xref:System.Windows.DependencyProperty.Register%2A></xref:System.Windows.DependencyProperty>。       指定されたいずれかで OwnerType<xref:System.Windows.DependencyProperty>は、変更不可とすることはできません`null`有効<xref:System.Windows.DependencyProperty></xref:System.Windows.DependencyProperty></xref:System.Windows.DependencyProperty>。"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "プロパティを登録するか、または自身をプロパティの所有者として追加するオブジェクトの型。"
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティの値で使用されている型を取得します。"
  remarks: "このプロパティを元のプロパティの登録によって宣言されたプロパティの値の型を報告する、`propertyType`パラメーター。 ような<xref:System.Windows.DependencyProperty.Name%2A>、登録後は、依存関係プロパティのプロパティの型は変更できません</xref:System.Windows.DependencyProperty.Name%2A>。"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "<xref:System.Type>のプロパティの値</xref:System.Type>。"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティが、これで識別されるかどうかを示す値を取得<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>インスタンスが読み取り専用の依存関係プロパティです。"
  remarks: "呼び出してプロパティ システム内で読み取り専用の依存関係プロパティが登録されている、<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>メソッドはなく、<xref:System.Windows.DependencyProperty.Register%2A>メソッド</xref:System.Windows.DependencyProperty.Register%2A></xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>。 添付プロパティを読み取り専用として登録することもできます。<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>を参照してください。       読み取り専用の依存関係プロパティを必要とする<xref:System.Windows.DependencyPropertyKey>識別子ではなく、<xref:System.Windows.DependencyProperty>メタデータ オーバーライドまたは値の設定などのメタデータの操作を実行する識別子です</xref:System.Windows.DependencyProperty></xref:System.Windows.DependencyPropertyKey>。 コレクションを取得した場合は<xref:System.Windows.DependencyProperty>識別子を呼び出すことによって<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>別または[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]識別子を公開する、呼び出しを試みる前に読み取り専用値をチェック<xref:System.Windows.DependencyObject.SetValue%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、入力パラメーターとして、その依存関係プロパティの識別子を使用して、識別子を表す依存関係プロパティが読み取り専用ではないことを確認する</xref:System.Windows.DependencyProperty.OverrideMetadata%2A></xref:System.Windows.DependencyObject.SetValue%2A></xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A></xref:System.Windows.DependencyProperty>。 読み取り専用の値が場合`true`、依存関係プロパティをへの参照を取得する方法をプログラムではありません、<xref:System.Windows.DependencyPropertyKey>メタデータからまたはその依存関係プロパティの識別子、<xref:System.Windows.DependencyProperty>識別子識別子を、呼び出すために、静的フィールドとして使用する必要があります<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>に対して読み取り専用の依存関係プロパティ。</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> 。       カスタム依存関係プロパティを作成、読み取り専用として登録するの get アクセサーだけを定義する必要があります、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]ラッパー プロパティです。 それ以外の場合、クラスは、バックアップの依存関係プロパティへのアクセスと比較してプロパティのラッパーの混乱を招くオブジェクト モデルがあります。 詳細については、「[依存関係プロパティのカスタム](~/add/includes/ajax-current-ext-md.md)または[読み取り専用の依存関係プロパティ](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>依存関係プロパティが読み取り専用の場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティ名、プロパティの型、所有者の種類と依存関係プロパティを登録します。"
  remarks: "依存関係プロパティの登録の詳細については、 <xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>を参照してください。"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。 名前は、所有者型の登録名前空間内で一意である必要があります。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    return:
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子の値を設定するために使用する必要があります、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>クラスのフィールドです。 プログラムでその値を設定またはメタデータの取得などの操作の後で、依存関係プロパティを参照するその識別子を使用しています。"
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティ名、プロパティの型、所有者型、およびプロパティのメタデータを依存関係プロパティを登録します。"
  remarks: "依存関係プロパティの登録の詳細については、 <xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>を参照してください。"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。"
    return:
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子の値を設定するために使用する必要があります、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>クラスのフィールドです。 プログラムでその値を設定またはメタデータの取得などの操作の後で、依存関係プロパティを参照するその識別子を使用しています。"
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティ名、プロパティの型、所有者型、プロパティ メタデータ、およびプロパティの値検証コールバックを依存関係プロパティを登録します。"
  remarks: "依存関係プロパティの登録の詳細については、 <xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>を参照してください。"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "通常の型検証に加えて、依存関係プロパティの値のカスタム検証を実行する必要があるコールバックへの参照。"
    return:
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子の値を設定するために使用する必要があります、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>クラスのフィールドです。 プログラムでその値を設定またはメタデータの取得などの操作の後で、依存関係プロパティを参照するその識別子を使用しています。"
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティ名、プロパティの型、所有者型との添付プロパティを登録します。"
  remarks: "添付プロパティによって定義されたプロパティの概念は、[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]です。 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]依存関係プロパティとしてアタッチされるプロパティを実装します。 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]添付プロパティは、依存関係プロパティ、レポート レイアウトの特性などの操作で、[全般] プロパティのシステムで使用できるメタデータが適用されることができます。 詳細については、次を参照してください。[添付プロパティの概要](~/add/includes/ajax-current-ext-md.md)です。       依存関係プロパティの登録の詳細については、 <xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>を参照してください。"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    return:
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子の値を設定するために使用する必要があります、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>クラスのフィールドです。 プログラムでその値を設定またはメタデータの取得などの操作の後で、依存関係プロパティを参照するその識別子を使用しています。"
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティ名、プロパティの型、所有者型、およびプロパティのメタデータを添付プロパティを登録します。"
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。 これには、既定値やその他の特性を含めることができます。"
    return:
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子の値を設定するために使用する必要があります、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>クラスのフィールドです。 プログラムでその値を設定またはメタデータの取得などの操作の後で、依存関係プロパティを参照するその識別子を使用しています。"
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティの型、所有者型、プロパティ メタデータ、およびプロパティの値検証コールバックを添付プロパティを登録します。"
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。 これには、既定値やその他の特性を含めることができます。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "通常の型検証に加えて、依存関係プロパティの値のカスタム検証を実行する必要があるコールバックへの参照。"
    return:
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子の値を設定するために使用する必要があります、 <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref>クラスのフィールドです。 プログラムでその値を設定またはメタデータの取得などの操作の後で、依存関係プロパティを参照するその識別子を使用しています。"
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティの型、所有者型、およびプロパティ メタデータを読み取り専用の添付プロパティを登録します。"
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "依存関係プロパティのキーを後で依存関係プロパティの参照を使用して、クラス内の静的な読み取り専用フィールドの値を設定するために使用する必要があります。"
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを読み取り専用の添付プロパティを登録します。"
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "通常の型検証に加えて、依存関係プロパティの値のカスタム検証を実行する必要がありますユーザー作成のコールバックへの参照。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "依存関係プロパティのキーを依存関係プロパティの参照を使用して、クラス内の静的な読み取り専用フィールドの値を設定するために使用する必要があります。"
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティの型、所有者型、プロパティのメタデータと、読み取り専用の依存関係プロパティを登録します。"
  remarks: "このメソッドが戻る型<xref:System.Windows.DependencyPropertyKey>であるのに対し<xref:System.Windows.DependencyProperty.RegisterAttached%2A><xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>型を返します</xref:System.Windows.DependencyProperty.RegisterAttached%2A></xref:System.Windows.DependencyPropertyKey> 通常、読み取り専用プロパティを表すキーに対して行われていない、パブリック<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>を呼び出すことによって、依存関係プロパティの値を設定するキーを使用できるため クラスのデザインは、要件に影響するが、アクセス権と任意の可視性を制限する、一般にお勧め<xref:System.Windows.DependencyPropertyKey>クラスまたはアプリケーション ロジックの一部としてその依存関係プロパティを設定するために必要なコードの部分のみにします</xref:System.Windows.DependencyPropertyKey>。 値を公開することにより、読み取り専用の依存関係プロパティを依存関係プロパティの識別子を公開することも推奨<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>として、`public static readonly`クラスのフィールド</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       読み取り専用の依存関係プロパティは、非常に典型的なシナリオ両方、既存の[!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)]およびカスタマイズのシナリオのための他の[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]場合でも、そのプロパティはありませんを設定する呼び出し元が、機能が依存関係プロパティを必要と可能性があります。 基づくなどの依存関係プロパティを取得する他のプロパティ システム操作の基礎として読み取り専用の依存関係プロパティの値を使用する、<xref:System.Windows.Trigger>スタイルで依存関係プロパティ</xref:System.Windows.Trigger>。       依存関係プロパティの登録の詳細については、 <xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>を参照してください。"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "依存関係プロパティのキーを依存関係プロパティの参照を使用して、クラス内の静的な読み取り専用フィールドの値を設定するために使用する必要があります。"
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指定したプロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを読み取り専用の依存関係プロパティを登録します。"
  remarks: "このメソッドが戻る型<xref:System.Windows.DependencyPropertyKey>であるのに対し<xref:System.Windows.DependencyProperty.RegisterAttached%2A><xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>型を返します</xref:System.Windows.DependencyProperty.RegisterAttached%2A></xref:System.Windows.DependencyPropertyKey> 通常、読み取り専用プロパティを表すキーに対して行われていない、パブリック<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>を呼び出すことによって、依存関係プロパティの値を設定するキーを使用できるため クラスのデザインは、要件に影響するが、アクセス権と任意の可視性を制限する、一般にお勧め<xref:System.Windows.DependencyPropertyKey>クラスまたはアプリケーション ロジックの一部としてその依存関係プロパティを設定するために必要なコードの部分のみにします</xref:System.Windows.DependencyPropertyKey>。 値を公開することにより、読み取り専用の依存関係プロパティを依存関係プロパティの識別子を公開することも推奨<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>として、`public static readonly`クラスのフィールド</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       読み取り専用の依存関係プロパティは、非常に典型的なシナリオです。 基づくなどの依存関係プロパティを取得する他のプロパティ システム操作の基礎として読み取り専用の依存関係プロパティの値を使用する、<xref:System.Windows.Trigger>スタイルで依存関係プロパティ</xref:System.Windows.Trigger>。       依存関係プロパティの登録の詳細については、 <xref:System.Windows.DependencyProperty>。</xref:System.Windows.DependencyProperty>を参照してください。       読み取り専用の依存関係プロパティの検証を重要性が低いことがあります。 キーの指定した非パブリックなアクセス レベルは、任意の無効な入力の可能性を軽減します。"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "登録する依存関係プロパティの名前。"
    - id: propertyType
      type: System.Type
      description: "プロパティの型。"
    - id: ownerType
      type: System.Type
      description: "依存関係プロパティを登録する所有者型。"
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "依存関係プロパティのプロパティ メタデータ。"
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "通常の型検証に加えて、依存関係プロパティの値のカスタム検証を実行する必要がありますユーザー作成のコールバックへの参照。"
    return:
      type: System.Windows.DependencyPropertyKey
      description: "依存関係プロパティのキーを後で依存関係プロパティの参照を使用して、クラス内の静的な読み取り専用フィールドの値を設定するために使用する必要があります。"
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティの文字列表現を返します。"
  remarks: "この実装を返します、<xref:System.Windows.DependencyProperty.Name%2A>プロパティの値</xref:System.Windows.DependencyProperty.Name%2A>。"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "依存関係プロパティの文字列形式。"
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "によって使用される静的な値を指定します、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]プロパティ システムなく<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>プロパティが存在する場合しますが、プロパティ システムによって設定された値がないことを示すことです。"
  remarks: "UnsetValue シナリオを使用するための sentinel 値は、ここで、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]プロパティ システムでは、要求を決定することができません<xref:System.Windows.DependencyProperty>値</xref:System.Windows.DependencyProperty>。 UnsetValue が使用されるのではなく`null`ので、 `null` 、有効なプロパティの値だけでなく、有効な可能性があります (および頻繁に使用される) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>。</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>外 UnsetValue が返されることはありません。 呼び出すと<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>で依存関係プロパティの<xref:System.Windows.DependencyObject>インスタンスを次のいずれかに該当: - 依存関係プロパティのメタデータで確立されている既定値があり、その値が返されます</xref:System.Windows.DependencyObject></xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>。 この値は<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>かられることもあります。      その他のいくつかの値をプロパティ システムによって確立され、既定値は、関連性がなくなった。 詳細については、「[依存関係プロパティ値の優先順位](~/add/includes/ajax-current-ext-md.md)です。       設定、 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>UnsetValue の具体的には許可されていない</xref:System.Windows.PropertyMetadata.DefaultValue%2A>。       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>要求されたプロパティはローカルに設定されていない場合は、UnsetValue を返します。</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue <xref:System.Windows.CoerceValueCallback>。</xref:System.Windows.CoerceValueCallback>の戻り値として使用する場合の特別な意味を持つ 詳細については、「[依存関係プロパティのコールバックと検証](~/add/includes/ajax-current-ext-md.md)です。       データベースにバインドする場合は、UnsetValue が等価ではないことを注意してください<xref:System.DBNull.Value>、方法と同様の<xref:System.DBNull.Value>null の場合は true と等価ではありません</xref:System.DBNull.Value></xref:System.DBNull.Value>。"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "依存関係プロパティの値検証コールバックを取得します。"
  remarks: "このプロパティが格納されます`null`に登録されている検証コールバックいない依存関係プロパティです。       コールバックは、静的な意味で動作する必要があります値を検証します検証を使用して適用、<xref:System.Windows.ValidateValueCallback>指定された値が、特定のインスタンスに対して有効かどうかを判断できません。</xref:System.Windows.ValidateValueCallback> 。 コールバックは、依存関係プロパティを所有するすべてのオブジェクトが必要がありますまたは有効なものとして指定された値を許容しないようにするかどうかにのみを確認できます。 特定のインスタンスを使用するには、その他の依存関係プロパティの値を知ることに依存する検証を実行する必要がある場合、<xref:System.Windows.CoerceValueCallback>代わりにします</xref:System.Windows.CoerceValueCallback>。 <xref:System.Windows.CoerceValueCallback>依存関係プロパティの識別子の直下にあるではなく、依存関係プロパティのメタデータの一部として登録されています</xref:System.Windows.CoerceValueCallback>。 詳細については、「[依存関係プロパティのコールバックと検証](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "この依存関係プロパティの値検証コールバック、 <code> validateValueCallback </code>元の依存関係プロパティの登録のパラメーターです。"
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
