### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "Windows イベント ログとの対話を提供します。"
  remarks: "イベント ログでは、アクセスしたり、ソフトウェアまたはハードウェアの重要なイベントに関する情報を記録する Windows イベント ログをカスタマイズできます。 イベント ログを使用すると、する既存のログから読み取られた、ログにエントリを書き込むを作成またはイベント ソースを削除して、ログを削除およびログ エントリに対応します。 イベント ソースを作成するときに、新しいログを作成することもできます。      > [!IMPORTANT] > この型は、<xref:System.IDisposable>インターフェイス</xref:System.IDisposable>。 型を使用してが完了したらを直接的または間接的にその破棄する必要があります。 型の直接 dispose を呼び出す、<xref:System.IDisposable.Dispose%2A>メソッドで、 `try` / `catch`ブロック</xref:System.IDisposable.Dispose%2A>。 など、使用言語構成要素に直接ことのない dispose `using` (C# の場合) または`Using`(Visual Basic で)。 詳細についてを参照してください&quot;を使用して、オブジェクトを実装する IDisposable&quot;、<xref:System.IDisposable>インターフェイスに関するトピック</xref:System.IDisposable>。       個々 のイベント ログとそのレジストリ エントリへのアクセスを提供するだけでなく、EventLog クラスではすべてのイベント ログのコレクションにアクセスできます。 使用することができます、`static`ログを削除するイベント ログのメンバーがログの一覧を取得、作成またはソースを削除する、またはコンピューターが既に特定のソースを含むかどうかを判断します。       次の&3; つの既定のイベント ログがある: アプリケーション、システム、およびセキュリティ。 セキュリティ ログは、読み取り専用です。 他のアプリケーションやサービスをインストールすると、Active Directory などには、追加のイベント ログがある場合があります。       セキュリティに関する考慮事項がある、EventLog クラスを使用する場合。 イベント ログが必要です<xref:System.Diagnostics.EventLogPermission>、.NET Framework 2.0 以降で、特定のアクションまたは .NET Framework 1.0 および 1.1 で完全な信頼のアクセス許可</xref:System.Diagnostics.EventLogPermission>。 お勧め<xref:System.Diagnostics.EventLogPermission>を部分的に信頼されたコードに付与できません</xref:System.Diagnostics.EventLogPermission>。  任意のイベント ログ オブジェクトを渡す必要がありますしないなど<xref:System.Diagnostics.EventLogEntryCollection>と<xref:System.Diagnostics.EventLogEntry>信頼度の低いコードへのオブジェクト</xref:System.Diagnostics.EventLogEntry></xref:System.Diagnostics.EventLogEntryCollection>。 たとえば、EventLog オブジェクトを作成する、エントリを書き込み、およびイベント ログを渡す、イベント ログを読み書きする機能は、名前別のアプリケーション イベント ログ メッセージを発行するなどのアクションを実行するコードを許可しているので、オブジェクトを部分的に信頼されたコードにはセキュリティの問題では、作成できます。       Windows Vista 以降で、ユーザー アカウント制御 (UAC) は、ユーザーの資格情報を決定します。 組み込みの Administrators グループのメンバーの場合は、2 つのランタイム アクセス トークンが割り当てられて: 標準ユーザー アクセス トークンおよび管理者アクセス トークン。 既定では、標準ユーザー ロールにしています。 セキュリティ ログにアクセスするコードを実行するには、最初に、資格情報を標準ユーザーから管理者に昇格させる必要があります。 これを行うアプリケーションのショートカット メニューを開き、アプリケーションを起動するときに (マウスを使用している場合を右クリックし、アプリケーションのアイコン) を管理者として実行することを示すとします。       イベント ログを使用すると、サーバーのイベント ビューアーで表示できるカスタムのイベント ログを作成します。 使用して、<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>イベント ビューアーで、イベント ログのローカライズされた名前を表示するメソッド</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>。 使用して、<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>最大ログ サイズに達したときに、イベント ログの動作を構成する方法</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>。       イベント ログから読み取り、ログの名前を指定します (<xref:System.Diagnostics.EventLog.Log%2A>プロパティ) とサーバー コンピューターの名前 (<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ</xref:System.Diagnostics.EventLog.MachineName%2A>イベント ログの</xref:System.Diagnostics.EventLog.Log%2A> サーバーのコンピューター名、ローカル コンピューターを指定しない場合は、&quot;です。&quot;、と見なされます。 イベント ソースを指定する必要はありません (<xref:System.Diagnostics.EventLog.Source%2A>プロパティ)、ソースがログに書き込むためにのみ必要であるためです</xref:System.Diagnostics.EventLog.Source%2A>。 <xref:System.Diagnostics.EventLog.Entries%2A>プロパティはエントリのイベント ログの一覧が設定されます</xref:System.Diagnostics.EventLog.Entries%2A>。       イベント ログに書き込み、指定するか、イベント ソースの作成 (<xref:System.Diagnostics.EventLog.Source%2A>プロパティ).</xref:System.Diagnostics.EventLog.Source%2A> コンピューターを新しいイベント ソースを作成するには、管理者の資格情報が必要です。 イベント ソースは、有効なエントリのソースとしてイベント ログで、アプリケーションを登録します。 一度に&1; つしかログに書き込むには、イベント ソースを使用できます。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、任意のランダムな文字列を指定できますが、名前は、コンピューター上の他のソースから個別である必要があります</xref:System.Diagnostics.EventLog.Source%2A>。 イベント ソースは、通常、アプリケーションまたは別の識別文字列の名前です。 複製を作成しようとしています<xref:System.Diagnostics.EventLog.Source%2A>値は、例外をスローします。</xref:System.Diagnostics.EventLog.Source%2A> 。 ただし、単一のイベント ログは、複数のソースで関連付けることができます。       イベント ログのインスタンスに関連付けられているイベント ログのイベント ソースが存在しない場合、新しいイベント ソースが作成されます。 イベント ソース以降および Windows Vista または Windows Server 2003 を作成するには、管理者の資格情報が必要です。       この要件は、セキュリティ ログを含む、すべてのイベント ログを検索して、イベント ソースが一意であるかどうかを確認する必要があるためにです。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます</xref:System.Security.SecurityException>。      > [!IMPORTANT] > を作成またはイベント ソースを削除する名前付きミュー テックスを使用して、基になるコードを同期する必要があります。 高い特権を持つアプリケーションは、名前付きミュー テックスをロックする場合、に、ロックが解放されるまでの応答を停止するアプリケーションを作成またはイベント ソースを削除しようとしているが発生します。 この問題を防ぐため、決して付与<xref:System.Security.Permissions.SecurityPermissionFlag>信頼されていないコードにアクセス許可</xref:System.Security.Permissions.SecurityPermissionFlag>。 さらに、<xref:System.Security.Permissions.SecurityPermissionFlag>権限は、可能性のあるにより、他のアクセス許可を省略して、信頼性の高いコードにのみ付与する必要があります</xref:System.Security.Permissions.SecurityPermissionFlag>。       アプリケーションとサービスは、アプリケーション ログまたはカスタム ログを記述する必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。 <xref:System.Diagnostics.EventLog.Log%2A>プロパティ、イベント ログの既定値は、アプリケーション ログ</xref:System.Diagnostics.EventLog.Log%2A>を明示的に設定されていない場合      > [!NOTE] >、登録済みのソースとして記述からアプリケーションを保護するものはありません。  アプリケーションが与えられる場合<xref:System.Diagnostics.EventLogPermissionAccess>権限、コンピューターに登録されている任意の有効なソースのイベントは書き込み可能です</xref:System.Diagnostics.EventLogPermissionAccess>。       使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>および<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込むためのメソッド</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.WriteEvent%2A> イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。       アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムは、イベント ソースの一覧を更新していないしようとすると、新しいソースとイベントを書き込む、書き込み操作は失敗します。 使用して、新しいソースを構成することができます、<xref:System.Diagnostics.EventLogInstaller>オブジェクトまたは<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 コンピューターを新しいイベント ソースを作成するには、管理者の資格情報が必要です。       各ソースは一度に&1; つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のイベント ログに書き込むに複数のソースを使用することができます。 たとえば、アプリケーションでは、異なるイベント ログまたは別のリソース ファイル用に構成された複数のソースが必要です。 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。       イベント ソースは、イベント カテゴリおよびメッセージ文字列のローカライズされたリソースを登録できます。 アプリケーションは、実際の文字列値を指定する代わりにリソース識別子を使用して、イベント ログ エントリを書き込むことができます。 参照してください、<xref:System.Diagnostics.EventLogInstaller>と<xref:System.Diagnostics.EventSourceCreationData>の詳細については、リソース ファイルを使用するソースを構成するためのクラス</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>。       アプリケーションがイベント ログに直接文字列値を書き込む場合がありません、リソースに、ソース ファイルのプロパティを設定します。 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。       イベントを書き込む場合は、メッセージ文字列またはメッセージ文字列のリソース識別子を少なくとも指定する必要があります。 その他のイベント プロパティはオプションです。 省略可能なイベントの設定の例については、次のとおりです: に設定することができます、<xref:System.Diagnostics.EventLogEntryType>エントリのイベント ビューアーを表示するアイコンを指定する</xref:System.Diagnostics.EventLogEntryType>。      イベントのカテゴリの識別子は、アプリケーションがイベントをフィルタ リングのカテゴリを使用する場合-を指定できます。      特定のイベントに追加情報を関連付ける場合、バイナリ データをイベント エントリ-アタッチできます。      > [!IMPORTANT] > イベント ログがディスク領域、プロセッサ時間、およびその他のシステム リソースを消費します。 重要な情報のみをログに重要です。 で、エラーのパスでは、イベント ログの呼び出しを配置するではなく、主要なコード パスのため、しないパフォーマンスに悪影響をお勧めします。       イベント ログのインスタンスの初期プロパティ値の一覧は、次を参照してください、<xref:System.Diagnostics.EventLog.%23ctor%2A>コンス トラクター。</xref:System.Diagnostics.EventLog.%23ctor%2A> 。"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>クラスです。 ログと、インスタンスは関連付けません。"
  remarks: "呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定して、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>インスタンス</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>。 のみを読み込む場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからまたはを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.Entries%2A>。      > [!NOTE] > を指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.MachineName%2A> 。       次の表は、 <xref:System.Diagnostics.EventLog>。</xref:System.Diagnostics.EventLog>のインスタンスの初期プロパティ値を示しています。      |プロパティ |初期値 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 (&quot;&quot;). | |<xref:System.Diagnostics.EventLog.Log%2A>|空の文字列 (&quot;&quot;). | |<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカル コンピューター (&quot;です&quot;)。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A> 。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>クラスです。 ローカル コンピューター上のログのインスタンスに関連付けます。"
  remarks: "このオーバー ロードの設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`パラメーター</xref:System.Diagnostics.EventLog.Log%2A> 。 呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定して、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>インスタンス</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>。 のみを読み込む場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからまたはを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.Entries%2A>。      > [!NOTE] > を指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.MachineName%2A> 。 このコンス トラクターのオーバー ロードを指定します、<xref:System.Diagnostics.EventLog.Log%2A>プロパティが変更できますを読み取る前に、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティ</xref:System.Diagnostics.EventLog.Entries%2A></xref:System.Diagnostics.EventLog.Log%2A>。       ソースを指定する場合、<xref:System.Diagnostics.EventLog.Source%2A>プロパティは、他のソース コンピューターで、後続の呼び出しから一意<xref:System.Diagnostics.EventLog.WriteEntry%2A>が既に存在しない場合は、指定された名前、ログを作成します</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>。       次の表は、 <xref:System.Diagnostics.EventLog>。</xref:System.Diagnostics.EventLog>のインスタンスの初期プロパティ値を示しています。      |プロパティ |初期値 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 (&quot;&quot;). | |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`パラメーターです |。  |<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカル コンピューター (&quot;です&quot;)。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A> 。"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "ローカル コンピューター上のログの名前。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "ログ名は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "ログの名前が正しくありません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>クラスです。 指定したコンピューター上のログにインスタンスを関連付けます。"
  remarks: "このオーバー ロードの設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`パラメーターおよび<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを`machineName`パラメーター</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 。 <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog>。</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を指定する</xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出す前に のみを読み込む場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからまたはを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.Entries%2A>。      > [!NOTE] > コンス トラクターは、のこのオーバー ロードを指定します、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティも、することができますいずれかを変更を読み取る前に、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティ</xref:System.Diagnostics.EventLog.Entries%2A></xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>。       次の表は、 <xref:System.Diagnostics.EventLog>。</xref:System.Diagnostics.EventLog>のインスタンスの初期プロパティ値を示しています。      |プロパティ |初期値 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 (&quot;&quot;). | |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`パラメーターです |。  |<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`パラメーターです |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A> 。"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "指定したコンピューター上のログの名前です。"
    - id: machineName
      type: System.String
      description: "ログが存在するコンピューター。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "ログ名は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "ログの名前が正しくありません。       または、コンピューター名は無効です。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>クラスです。 指定したコンピューター上のログにインスタンスを関連付けますとを作成または指定されたソースが割り当てられます、 <xref href=&quot;System.Diagnostics.EventLog&quot;></xref>です。"
  remarks: "このコンス トラクターを設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`、パラメーター、<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを`machineName`パラメーター、および<xref:System.Diagnostics.EventLog.Source%2A>プロパティを`source`パラメーター</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、イベント ログに書き込む際に必要</xref:System.Diagnostics.EventLog.Source%2A> ただし、イベント ログ、のみからの読み取りのみ行う場合、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>である限り、サーバー上のイベント ログでは、既に関連付けられているソースを持つ) のプロパティが必要です</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>。 イベント ログから読み取るだけの場合は、コンス トラクターの他のオーバー ロードがありますで十分です。       次の表は、 <xref:System.Diagnostics.EventLog>。</xref:System.Diagnostics.EventLog>のインスタンスの初期プロパティ値を示しています。      |プロパティ |初期値 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|`source`パラメーターです |。  |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`パラメーターです |。  |<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`パラメーターです |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A> 。"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "指定したコンピューター上のログの名前"
    - id: machineName
      type: System.String
      description: "ログが存在するコンピューター。"
    - id: source
      type: System.String
      description: "イベント ログ エントリのソース。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "ログ名は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "ログの名前が正しくありません。       または、コンピューター名は無効です。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初期化を開始、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>フォームまたは別のコンポーネントで使用します。 初期化は実行時に発生します。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントを使用するコンポーネントの初期化を開始します。 <xref:System.Diagnostics.EventLog.EndInit%2A>メソッドが初期化を終了します</xref:System.Diagnostics.EventLog.EndInit%2A>。 BeginInit を使用して<xref:System.Diagnostics.EventLog.EndInit%2A>メソッドのコントロールが完全に初期化される前に使用を禁止します</xref:System.Diagnostics.EventLog.EndInit%2A>。"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>既に初期化されています。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログからすべてのエントリを削除します。"
  remarks: "イベント ログには、格納できるエントリの数を決定する最大サイズが設定されます。 イベント ログがいっぱいに、新しいイベント情報の記録を停止または、以前のエントリを上書きする開始します。 イベントの記録を停止する場合は、既存のエントリのログを消去し、イベントの記録をもう一度開始することを許可するこのメソッドを使用できます。 ログのイベント ログ エントリの消去が存在するコンピューターに対する管理者権限が必要です。       オフ、イベント ログを閉じ、新しいを取得しますが、ハンドルを読み書きイベント ハンドルを解放およびイベント ログが再度開かれます。 既存のイベントと共にメソッドの呼び出し後に受信したイベントはオフにします。"
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "イベント ログは消去されませんでした。       または、ログを開くことができません。 Windows エラー コードは使用できません。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "値が指定されていない、<xref:System.Diagnostics.EventLog.Log*>プロパティ</xref:System.Diagnostics.EventLog.Log*>。 ログ名は空の文字列ではないことを確認してください。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ログは存在しません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログと、リリース読み取りし、書き込みハンドルを閉じます。"
  remarks: "Close メソッドが呼び出されますによって保護された<xref:System.ComponentModel.Component.Dispose%2A>メソッド</xref:System.ComponentModel.Component.Dispose%2A>。 <xref:System.ComponentModel.Component.Dispose%2A>。</xref:System.ComponentModel.Component.Dispose%2A>を呼び出す前に Close を呼び出す必要はありません。"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "イベント ログの読み取りハンドルまたは書き込みハンドルが正常に解放されませんでした。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ローカライズされたイベントを書き込むための有効なイベント ソースを確立メッセージ、イベント ソースと対応するイベント ログで指定された構成プロパティを使用します。"
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "イベント ソースと対象のイベント ログの構成プロパティ。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ローカル コンピューターのログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 このメソッドは、ローカル コンピューターに新しいカスタム ログを作成することができますも。"
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "ローカル コンピューター上で、アプリケーションが登録されているソースの名前。"
    - id: logName
      type: System.String
      description: "ログの名前に、ソースのエントリが書き込まれます。 使用可能な値には、アプリケーション、システム、またはカスタム イベント ログが含まれます。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ローカル コンピューターのイベント ログのレジストリ キーを開けませんでした。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定したコンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 このメソッドは、指定したコンピューター上の新しいカスタム ログの作成にも使用できます。"
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューターにアプリケーションを登録するときのソース。"
    - id: logName
      type: System.String
      description: "ログの名前に、ソースのエントリが書き込まれます。 使用可能な値には、アプリケーション、システム、またはカスタム イベント ログが含まれます。 値を指定しない場合`logName`アプリケーションへの既定値です。"
    - id: machineName
      type: System.String
      description: "このイベント ソースを登録するコンピューターの名前または&quot;です。&quot;ローカル コンピューター用です。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ローカル コンピューターからイベント ログを削除します。"
  remarks: "削除するログが、ローカル コンピューター上にある場合は、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。       Delete で削除によって指定されたログ`logName`ローカル コンピューターからです。 ログに登録されているソースのみを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>。</xref:System.Diagnostics.EventLog.Clear%2A> 削除と<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 新しいインスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します</xref:System.Diagnostics.EventLog>。       Delete メソッドは、まず、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 その後の時点のログを再作成する場合、再利用する場合は、もう一度、イベント ソースを登録する必要があります。 イベント ソースを登録しないでログ名を指定せず、他のユーザーがイベント ソースに書き込む場合は、イベント ソースは、アプリケーション イベント ログに作成されます。 そのため、削除および再作成するログにエントリを書き込むことであったアプリケーションは、アプリケーション ログに書き込む代わりに、今すぐイベント ソースを含んでいるためです。      > [!NOTE] > 困難なプロセス、イベント ログを再作成することができます。 システムで作成されたイベント ログのアプリケーション ログなどのいずれかを削除しないでください。       Delete を呼び出すことによって、ログを自動的に削除すると、そのログに登録されているソースが削除されます。 これにより、そのログ機能を使用して他のアプリケーション。"
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '削除するログの名前。 使用可能な値が含まれます。 アプリケーション、セキュリティ、システム、およびコンピューター上の任意のカスタム イベント ログです。'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>空の文字列 (&quot;&quot;) または<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "イベント ログは消去されませんでした。       または、ログを開くことができません。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定したコンピューターからイベント ログを削除します。"
  remarks: "リモート コンピューターを削除するログがある場合は、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。       <xref:System.Diagnostics.EventLog.Delete%2A>指定されたログを削除`logName`で指定されたコンピューターから`machineName`です。</xref:System.Diagnostics.EventLog.Delete%2A> ログに登録されているソースのみを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>。</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>および<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。</xref:System.Diagnostics.EventLog.Delete%2A> インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します</xref:System.Diagnostics.EventLog>。       このメソッドは、まず、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 その後の時点のログを再作成する場合、再利用する場合は、もう一度、イベント ソースを登録する必要があります。 イベント ソースを登録しないでログ名を指定せず、他のユーザーがイベント ソースに書き込む場合は、イベント ソースは、アプリケーション イベント ログに作成されます。 そのため、削除および再作成するログにエントリを書き込むことであったアプリケーションは、アプリケーション ログに書き込む代わりに、今すぐイベント ソースを含んでいるためです。      > [!NOTE] > 困難なプロセス、イベント ログを再作成することができます。 システムで作成されたイベント ログのアプリケーション ログなどのいずれかを削除しないでください。       <xref:System.Diagnostics.EventLog.Delete%2A>そのログに登録されているソースを自動的に削除</xref:System.Diagnostics.EventLog.Delete%2A>を呼び出すことによって、ログを削除します。 これにより、そのログ機能を使用して他のアプリケーション。"
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '削除するログの名前。 使用可能な値が含まれます。 アプリケーション、セキュリティ、システム、および指定したコンピューター上の任意のカスタム イベント ログです。'
    - id: machineName
      type: System.String
      description: "ログを削除するコンピューターの名前または&quot;.&quot;ローカル コンピューター用です。"
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "イベント ログは消去されませんでした。       または、ログを開くことができません。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ローカル コンピューターのイベント ログからイベント ソースの登録を削除します。"
  remarks: "登録を削除するには、このメソッドを使用して、 <xref:System.Diagnostics.EventLog.Source%2A>、ローカル コンピューターから</xref:System.Diagnostics.EventLog.Source%2A>。 DeleteEventSource では、ローカル コンピューター上のレジストリにアクセスし、有効なイベントのソースとして、アプリケーションの登録を解除します。       そのログにエントリを書き込むことが不要になった場合は、有効なイベントのソースとして、コンポーネントを削除できます。 たとえば、これを行いますコンポーネントを別の&1; つのログに変更する必要がある場合。 ソースは、一度に&1; つのログしか登録できないことができます、ため、ログを変更する必要があります、現在の登録を削除します。       DeleteEventSource では、ログに登録されているソースのみを削除します。 自体は、ログを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Delete%2A>。</xref:System.Diagnostics.EventLog.Delete%2A> ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>。</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>DeleteEventSource は`static`メソッド、クラス自体を呼び出すことができるようにします。</xref:System.Diagnostics.EventLog.Delete%2A> インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します</xref:System.Diagnostics.EventLog>。       <xref:System.Diagnostics.EventLog.Delete%2A>そのログに登録されているソースを自動的に削除</xref:System.Diagnostics.EventLog.Delete%2A>を呼び出すことによって、ログを削除します。 これにより、そのログ機能を使用して他のアプリケーション。      > [!NOTE] > ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。"
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "イベント ログ システムにアプリケーションを登録する名前です。"
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定したコンピューターから、アプリケーションのイベント ソース登録を削除します。"
  remarks: "登録を削除するこのオーバー ロードを使用して、 <xref:System.Diagnostics.EventLog.Source%2A>、リモート コンピューターから</xref:System.Diagnostics.EventLog.Source%2A>。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>指定されたコンピューターのレジストリにアクセスする`machineName`し有効なイベントのソースとして、アプリケーションの登録を削除します。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       そのログにエントリを書き込むことが不要になった場合は、有効なイベントのソースとして、コンポーネントを削除できます。 たとえば、これを行いますコンポーネントを別の&1; つのログに変更する必要がある場合。 ソースは、一度に&1; つのログしか登録できないことができます、ため、ログを変更する必要があります、現在の登録を削除します。       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>ログに登録されているソースのみを削除します。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 自体は、ログを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Delete%2A>。</xref:System.Diagnostics.EventLog.Delete%2A> ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>。</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>および<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。</xref:System.Diagnostics.EventLog.Delete%2A> インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します</xref:System.Diagnostics.EventLog>。       <xref:System.Diagnostics.EventLog.Delete%2A>そのログに登録されているソースを自動的に削除</xref:System.Diagnostics.EventLog.Delete%2A>を呼び出すことによって、ログを削除します。 これにより、そのログ機能を使用して他のアプリケーション。      > [!NOTE] > ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。"
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "イベント ログ システムにアプリケーションを登録する名前です。"
    - id: machineName
      type: System.String
      description: "登録を削除するコンピューターの名前または&quot;.&quot;ローカル コンピューター用です。"
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>削除できません、親のレジストリ キーのレジストリに<code>source</code>同じ名前のサブキーが含まれていません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "によって使用されるアンマネージ リソースを解放、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>、マネージ リソースも解放します。"
  remarks: "このメソッドは、パブリック`Dispose()`メソッドおよび<xref:System.Object.Finalize%2A>メソッド</xref:System.Object.Finalize%2A>。 `Dispose()`プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A>呼び出す`Dispose`で`disposing`&quot;éý&quot;`false`です。</xref:System.Object.Finalize%2A>       ときに、`disposing`パラメーターが true の場合、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放しますこの<xref:System.Diagnostics.EventLog>参照。</xref:System.Diagnostics.EventLog> 。 このメソッドを呼び出して、`Dispose()`参照される各オブジェクトのメソッドです。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マネージ コードとアンマネージ リソースを解放するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>アンマネージ リソースだけを解放します。"
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または設定を示す値かどうか、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>受信<xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;></xref>イベント通知します。"
  remarks: "EnableRaisingEvents プロパティを決定するかどうか<xref:System.Diagnostics.EventLog>のエントリがログに書き込まれるときにイベントを発生させます</xref:System.Diagnostics.EventLog> このプロパティが`true`、コンポーネントを受信する、<xref:System.Diagnostics.EventLog.EntryWritten>イベントで指定されているログにエントリが記述されたときに通知を受け取ります、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ。</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> 。 EnableRaisingEvents 場合`false`イベントは発生しません。      > [!NOTE] >、ローカル コンピューター上のエントリが書き込まれるときにのみ、イベント通知を受け取ることができます。 リモート コンピューターに書き込まれたエントリに対する通知を受け取ることはできません。"
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>エントリがログに書き込まれる、それ以外の場合に通知を受け取る<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログは、リモート コンピューターでです。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初期化を終了、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>フォームまたは別のコンポーネントを使用します。 初期化は実行時に発生します。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントを使用するコンポーネントの初期化を終了します。 <xref:System.Diagnostics.EventLog.BeginInit%2A>メソッドは、初期化を開始します</xref:System.Diagnostics.EventLog.BeginInit%2A>。 使用して、 <xref:System.Diagnostics.EventLog.BeginInit%2A>EndInit メソッド使用されないように、コントロールが完全に初期化される前に、</xref:System.Diagnostics.EventLog.BeginInit%2A> 。"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログの内容を取得します。"
  remarks: "イベント ログから読み取るときに、エントリのメンバーを使用します。       プロパティが読み取り専用は、エントリを変更またはエントリを使用してログに書き込むことはできません。 代わりに、指定、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すと<xref:System.Diagnostics.EventLog.WriteEntry%2A>新しいログ エントリを書き込めません</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>。 イベント ログ内のエントリの数をカウントするエントリを使用して&1; つずつ表示<xref:System.Diagnostics.EventLogEntry>コレクション内で</xref:System.Diagnostics.EventLogEntry>。 使用して、インデックス付き<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>など特定のエントリに関する情報を取得するメンバー <xref:System.Diagnostics.EventLogEntry.Message%2A>、 <xref:System.Diagnostics.EventLogEntry.Category%2A>、 <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>、または<xref:System.Diagnostics.EventLogEntry.EntryType%2A>.</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       <xref:System.Diagnostics.EventLog.Source%2A>ログからのみ読み取るときに</xref:System.Diagnostics.EventLog.Source%2A>指定する必要はありません。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名および<xref:System.Diagnostics.EventLog.MachineName%2A>(サーバーのコンピューター名) のプロパティを<xref:System.Diagnostics.EventLog>インスタンス</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>。 どちらの場合は、エントリのイベント ログの一覧にエントリ メンバーが自動的に設定されます。 個々 のエントリを読み込むには、この一覧にアイテムを適切なインデックスを選択します。       ログ エントリの読み取りと書き込みの重要な違いは、読み取りメソッドを明示的に呼び出す必要はありません。 後に、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>指定すると、エントリ プロパティが自動的に設定されます</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>。 の値、<xref:System.Diagnostics.EventLog.Log%2A>または<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティをプロパティには、それを読み取り、次回が再作成されないエントリ</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>を変更する場合      > [!NOTE] > <xref:System.Diagnostics.EventLog.MachineName%2A>、ログに接続しているかどうか</xref:System.Diagnostics.EventLog.MachineName%2A>を指定する必要はありません 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカルのコンピューターでは、&quot;です&quot;、と見なされます。</xref:System.Diagnostics.EventLog.MachineName%2A> 。"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "<xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref>イベント ログにエントリを保持します。 各エントリのインスタンスに関連付け、 <xref href=&quot;System.Diagnostics.EventLogEntry&quot;> </xref>クラスです。"
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ローカル コンピューター上のイベント ログにエントリが書き込まれるときに発生します。"
  remarks: "設定する必要があります、イベント通知を受信する<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>に`true`</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>。 イベント通知を受信できるは、ローカル コンピューター上のエントリが書き込まれる時点のみです。 リモート コンピューターに書き込まれたエントリに対する通知を受け取ることはできません。       EntryWritten デリゲートを作成するときに、イベントを処理するメソッドを特定します。 イベントをイベント ハンドラーに関連付けるには、イベントに、デリゲートのインスタンスを追加します。 デリゲートを削除するまで、イベントが発生するたびに、イベント ハンドラーが呼び出されます。 デリゲートでイベントを処理の詳細については、次を参照してください。[イベント](~/add/includes/ajax-current-ext-md.md)です。       システムに応答<xref:System.Diagnostics.EventLog.WriteEntry%2A>最後の書き込みイベントには、少なくとも&6; 秒前が発生した場合にのみです</xref:System.Diagnostics.EventLog.WriteEntry%2A>。 これは意味が&6; 秒間隔に含まれる&1; つの EntryWritten イベント通知を受け取るだけ場合でも、1 つ以上のイベント ログの変更が発生します。 呼び出しの間の十分に長いスリープ間隔 (約 10 秒) を挿入する場合<xref:System.Diagnostics.EventLog.WriteEntry%2A>、イベントを見逃す可能性が少なくします</xref:System.Diagnostics.EventLog.WriteEntry%2A>。 ただし、書き込みイベントが頻繁に発生した場合に、まで、次回イベント通知を受け取るされません可能性があります。 通常、受信されなかったイベント通知は失われませんが、遅延します。"
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ログが、ローカル コンピューター上に存在するかどうかを判断します。"
  remarks: "このメソッドを使用して、ログが、ローカル コンピューター上に存在するかどうかを確認します。 ソースが、ローカル コンピューター上に存在するかどうかを判断する場合は、使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A>       このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 ローカル コンピューター上クエリを返しますそれ以外の場合、`false`です。       同じコンピューターに、新しいログ、既存のログの名前を付けることはできません、新しいログを作成する前にこのメソッドを使用して、かどうかを指定した`logName`ローカル コンピューターに既に存在します。 `logName`パラメーターが、大文字小文字を区別することはありません。       存在するが、`static`メソッド、クラス自体を呼び出すことができます。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>Exists を呼び出す</xref:System.Diagnostics.EventLog>。"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '検索するログの名前。 使用可能な値が含まれます。 アプリケーション、セキュリティ、システム、他のアプリケーション固有のログ (などに関連付けられている Active Directory)、またはコンピューター上の任意のカスタム ログです。'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ローカル コンピューターに、ログが存在する場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "LogName <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>か、値が空です。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定したコンピューター上にログが存在するかどうかを判断します。"
  remarks: "このメソッドを使用して、リモート コンピューター上のログが存在するかどうかを確認します。 リモート コンピューターで、ソースが存在するかどうかを判断する場合は、使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A>       このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 指定したコンピューター上クエリを返しますそれ以外の場合、`false`です。       同じコンピューターに、新しいログ、既存のログの名前を付けることはできませんは、新しいログを作成する前にこのメソッドを&1; つを使用して、指定した`logName`で指定されたサーバーに既に存在する、`machineName`パラメーター。 `logName`と`machineName`パラメーターは大文字と小文字が区別されません。       <xref:System.Diagnostics.EventLog.Exists%2A>`static`メソッド、クラス自体を呼び出すことができます。</xref:System.Diagnostics.EventLog.Exists%2A> <xref:System.Diagnostics.EventLog>呼び出す<xref:System.Diagnostics.EventLog.Exists%2A>。</xref:System.Diagnostics.EventLog.Exists%2A></xref:System.Diagnostics.EventLog>の新しいインスタンスを作成する必要はありません。"
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '検索対象のログです。 使用可能な値が含まれます。 アプリケーション、セキュリティ、システム、他のアプリケーション固有のログ (などに関連付けられている Active Directory)、またはコンピューター上の任意のカスタム ログです。'
    - id: machineName
      type: System.String
      description: "ログの検索対象のコンピューターの名前または&quot;です。&quot;ローカル コンピューターのです。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>指定したコンピューター上にログが存在する場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>パラメーターは、形式が無効です。 検索しているコンピューターを適切な構文を使用していることを確認してください。       - または -、 <code> logName </code>は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>か、値が空です。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ローカル コンピューター上のすべてのイベント ログを検索しの配列を作成<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>リストを格納するオブジェクト。"
  remarks: "配列<xref:System.Diagnostics.EventLog>GetEventLogs への呼び出しが行われたときに、オブジェクトは、ローカル コンピューター上のすべてのイベント ログのスナップショット</xref:System.Diagnostics.EventLog>。 リアルタイムのログの作成または削除は反映されませんように動的なコレクションはありません。 読み取り/書き込みを行う前に、配列内のログが存在することを確認する必要があります。 配列には通常、少なくとも&3; つのログが含まれています。 アプリケーション、システム、およびセキュリティ。 ローカル コンピューター上のカスタム ログを作成した場合も、配列に表示されます。       イベント ログの一覧を取得するには、適切なレジストリ権限が必要です。 これらの権限は<xref:System.Diagnostics.EventLog.Exists%2A><xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog.Exists%2A>の呼び出しに必要なものと同じ"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "型の配列<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>ローカル コンピューター上のログを表すです。"
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "レジストリへの読み取りアクセス権がありません。       または、コンピューターのイベント ログ サービスはありません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定したコンピューター上のすべてのイベント ログを検索しの配列を作成<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>リストを格納するオブジェクト。"
  remarks: "配列<xref:System.Diagnostics.EventLog>オブジェクトで指定したコンピューター上のすべてのイベント ログのスナップショット、`machineName`パラメーターとへの呼び出し<xref:System.Diagnostics.EventLog.GetEventLogs%2A>が行われます</xref:System.Diagnostics.EventLog.GetEventLogs%2A></xref:System.Diagnostics.EventLog>。 リアルタイムのログの作成または削除は反映されませんように動的なコレクションはありません。 読み取り/書き込みを行う前に、配列内のログが存在することを確認する必要があります。 配列には通常、少なくとも&3; つのログが含まれています。 アプリケーション、システム、およびセキュリティ。 指定したコンピューター上のカスタム ログを作成した場合も、配列に表示されます。       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>`static`メソッドを呼び出すことができますので、<xref:System.Diagnostics.EventLog>クラス自体</xref:System.Diagnostics.EventLog>。</xref:System.Diagnostics.EventLog.GetEventLogs%2A> インスタンスを作成する必要はありません、<xref:System.Diagnostics.EventLog>メソッドへの呼び出しを作成するオブジェクト</xref:System.Diagnostics.EventLog>。       イベント ログの一覧を取得するには、適切なレジストリ権限が必要です。 これらの権限は<xref:System.Diagnostics.EventLog.Exists%2A><xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog.Exists%2A>の呼び出しに必要なものと同じ"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "イベント ログを検索するコンピューター。"
    return:
      type: System.Diagnostics.EventLog[]
      description: "型の配列<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>指定したコンピューター上のログを表すです。"
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>パラメーターは、コンピューター名は無効です。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "レジストリへの読み取りアクセス権がありません。       または、コンピューターのイベント ログ サービスはありません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得またはからの読み取りまたは書き込みするログの名前を設定します。"
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "ログの名前。 アプリケーション、システム、セキュリティ、またはカスタム ログ名を指定できます。 既定値は空の文字列 (&quot;&quot;) です。"
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログの表示名を取得します。"
  remarks: "> [!NOTE]> Windows Vista 以降で、ユーザーには、セキュリティ ログにアクセスする権限がありません。 Windows Vista を実行しているか、ユーザーは、後で表示されます、<xref:System.Security.SecurityException>セキュリティ ログ内のイベントの表示名にアクセスしようとする</xref:System.Security.SecurityException>場合   >> Windows Vista 以降で、ユーザー アカウント制御 (UAC) は、ユーザーの特権を決定します。 組み込みの Administrators グループのメンバーの場合は、2 つのランタイム アクセス トークンが割り当てられて: 標準ユーザー アクセス トークンおよび管理者アクセス トークン。 既定では、標準ユーザー ロールにしています。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 アプリケーション アイコンを右クリックし、管理者として実行することを示すアプリケーションを起動するときに、これを行うことができます。"
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "システムのイベント ビューアーでイベント ログを表す名前です。"
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定した<xref:System.Diagnostics.EventLog.Log*>このコンピューターのレジストリに存在しません</xref:System.Diagnostics.EventLog.Log*>。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定したソースが登録されているログの名前を取得します。"
  remarks: "イベント ソースは、イベントをログに記録新機能を示します。 通常は、アプリケーションの名前か、アプリケーションのサブコンポーネントの名前、アプリケーションが大きい場合。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。       時に、1 つのログに書き込むだけことができます、新しい変換元を作成するときに、システムでは、イベント ログとアプリケーションを有効なエントリのソースとして登録します。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、任意の文字列を指定できますが、他のソース コンピューター上で、名前は使用できません</xref:System.Diagnostics.EventLog.Source%2A>。 作成、複製された<xref:System.Diagnostics.EventLog.Source%2A>値は、例外をスローします</xref:System.Diagnostics.EventLog.Source%2A>。 ただし、単一のイベント ログには、多くの異なるソースが書き込みを持つことができます。"
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "イベント ソースの名前です。"
    - id: machineName
      type: System.String
      description: "検索するには、対象のコンピューターの名前または&quot;です。&quot;ローカル コンピューターのです。"
    return:
      type: System.String
      description: "レジストリで指定したソースに関連付けられているログの名前。"
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または設定の読み取りまたはイベントの書き込みをするコンピューターの名前。"
  remarks: "イベント ログに記述する場合<xref:System.Diagnostics.EventLog.Source%2A>、イベント ログ オブジェクトを特定のログに接続するために</xref:System.Diagnostics.EventLog.Source%2A>関連付ける必要があります。 <xref:System.Diagnostics.EventLog.Source%2A>のみをログから読み取るときにプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を指定する必要はありません。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名、および MachineName (サーバーのコンピューター名).</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 指定する必要はありません、MachineName、ログに接続している場合。 MachineName、ローカル コンピューターが指定されていない場合 (&quot;です。&quot;) と見なされます。       ソースは、一度に&1; つのログしか登録できません。 場合、<xref:System.Diagnostics.EventLog.Source%2A>のインスタンスのプロパティが設定された<xref:System.Diagnostics.EventLog>、そのため、MachineName プロパティを変更することはできません<xref:System.Diagnostics.EventLog>の値を変更することがなく<xref:System.Diagnostics.EventLog.Source%2A>呼び出しまたは<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>最初</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Source%2A></xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A>。 MachineName プロパティを変更する場合、<xref:System.Diagnostics.EventLog>すべてのハンドルを閉じ、ログと、新しいコンピューター上のソースに再度アタッチします</xref:System.Diagnostics.EventLog>。       MachineName 値は、空の文字列にすることはできません。 ローカル コンピューターに既定でそれが明示的に設定されていない場合 (&quot;です。&quot;) です。"
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "イベント ログが存在するサーバーの名前。 既定値は、ローカル コンピューター (&quot;です。&quot;) です。"
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "コンピューター名が正しくありません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得またはイベント ログの最大サイズをキロバイト単位で設定します。"
  remarks: "MaximumKilobytes プロパティでは、イベント ログ ファイルのサイズ制限を表します。 イベント ログが、構成された、サイズ制限に達したとき<xref:System.Diagnostics.EventLog.OverflowAction%2A>値は、新しいエントリを破棄するかどうかや、新しいエントリが古いエントリを上書きするかどうかを決定します</xref:System.Diagnostics.EventLog.OverflowAction%2A>。      > [!NOTE] > このプロパティは、このインスタンスで表されるイベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに対して登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "イベント ログの最大サイズ。 既定値は、512 キロバイト単位の最大ファイル サイズを示す 512 です。"
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定した値は、64、4194240、または 64 の倍数されませんよりも大きいか小さいです。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログにエントリを保持する日数を取得します。"
  remarks: "MinimumRetentionDays プロパティを使用して、イベント ログの現在の設定を調べます。 使用して<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>イベント ログ内の各エントリを保持する日数の最小数を変更します</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>。       MinimumRetentionDays 値は、イベント ログのオーバーフロー動作によって異なります。 場合、<xref:System.Diagnostics.OverflowAction>イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction>、MinimumRetentionDays 値は 0 です</xref:System.Diagnostics.OverflowAction></xref:System.Diagnostics.OverflowAction>。 場合、<xref:System.Diagnostics.OverflowAction>イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction>、MinimumRetentionDays 値は-1</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> 。 場合、<xref:System.Diagnostics.OverflowAction>イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction>、MinimumRetentionDays 値は、0 より大きい値であり、イベント ログがいっぱいの場合は、イベント ログ エントリを保持する日数を表す</xref:System.Diagnostics.OverflowAction></xref:System.Diagnostics.OverflowAction>。       オーバーフロー動作は、イベント ログがサイズ制限に達したときにのみ発生します。 ときに、<xref:System.Diagnostics.EventLog>がその<xref:System.Diagnostics.EventLog.OverflowAction%2A>&quot;éý&quot; <xref:System.Diagnostics.OverflowAction>、し、イベント ログがその最大サイズに達すると、新しいエントリは&31; 歳以上が、MinimumRetentionDays 期間を超えるエントリを置き換えることができるかどうかにのみ書き込まれます</xref:System.Diagnostics.OverflowAction></xref:System.Diagnostics.EventLog.OverflowAction%2A></xref:System.Diagnostics.EventLog>。 最低限の期間のイベント エントリの保持は、イベント ログを定期的にアーカイブする場合に適しています。 それ以外の場合、イベント ログが、上限に達するときに、新しいエントリを損失する可能性があります。 新しいイベント情報の損失を回避するのには、特定のイベント ログのアーカイブ スケジュールに基づいてイベントの最小保有日数を設定します。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "イベント ログにエントリを保持する日数。 既定値は 7 です。"
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログが最大ファイル サイズに達したときに、新しいエントリを書き込むために構成された動作を変更します。"
  remarks: "イベント ログのオーバーフロー動作では、新しいエントリが最大ファイル サイズに達したログに書き込まれるときの動作を指定します。      > [!NOTE] > オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ有効になります。 オーバーフロー動作は、新しいエントリの追加のイベント ログ エントリに対応できるログに書き込むには影響しません。       ModifyOverflowPolicy メソッドは、イベント ログのオーバーフロー動作を構成します。 <xref:System.Diagnostics.EventLog>インスタンス。</xref:System.Diagnostics.EventLog> 指定されたイベント ログに対してこのメソッドを呼び出した後、 <xref:System.Diagnostics.EventLog.Log%2A>、プロパティ、<xref:System.Diagnostics.EventLog.OverflowAction%2A>と<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>プロパティの値は、新しく構成されたオーバーフロー動作を反映します</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A></xref:System.Diagnostics.EventLog.OverflowAction%2A></xref:System.Diagnostics.EventLog.Log%2A>。      > [!NOTE] > このプロパティは、このインスタンスで表されるイベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに対して登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。       設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction>を新しいエントリが最も古いエントリを上書きすることを示すときに、<xref:System.Diagnostics.EventLog>最大サイズに達した</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.OverflowAction>。 場合、`action`にパラメーターが設定されている<xref:System.Diagnostics.OverflowAction>、`retentionDays`パラメーター値は無視されます</xref:System.Diagnostics.OverflowAction>。       設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction>を新しいエントリごとに、古いエントリが上書きされることを示すときに、<xref:System.Diagnostics.EventLog>最大サイズに達した</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.OverflowAction>。 使用して、ログのイベントを保持する日数を指定、`retentionDays`パラメーター。 保有期間の範囲内のイベントは、新しいエントリでは上書きされません。       設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction>ログの最大サイズに達したときに、新しいイベントを破棄します</xref:System.Diagnostics.OverflowAction>。 場合、`action`にパラメーターが設定されている<xref:System.Diagnostics.OverflowAction>、`retentionDays`パラメーター値は無視されます</xref:System.Diagnostics.OverflowAction>。      > [!CAUTION] > オーバーフロー ポリシーを設定<xref:System.Diagnostics.OverflowAction>イベント ログがいっぱいになったときに、新しいエントリを破棄するように指定します</xref:System.Diagnostics.OverflowAction>。 この設定を使用する場合は、イベント ログが定期的にアーカイブし、その最大サイズの制限に達しないようにを確認します。"
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "新しいエントリをイベント ログに書き込むためのオーバーフロー動作。"
    - id: retentionDays
      type: System.Int32
      description: "それぞれのイベント ログ エントリが保持される日数の最小数。 場合にのみ、このパラメーターは使用`action`に設定されている<xref href=&quot;System.Diagnostics.OverflowAction&quot;></xref>です。"
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>有効ではありません<xref:System.Diagnostics.EventLog.OverflowAction*>値。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>1 よりか 365 よりも大きいです。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログがログの最大ファイル サイズに達したときに、新しいエントリを格納するために構成された動作を取得します。"
  remarks: "イベント ログ サイズが大きくなったりに新しいイベントが書き込まれるとします。 各イベント ログが構成されているサイズの上限です。<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>プロパティは、イベント ログ ファイルのサイズの許可されているキロバイト単位の最大数を定義します</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>。       OverflowAction プロパティの値を使用して、その最大サイズでは、イベント ログに対して構成されているオーバーフロー動作を検査します。 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>イベント ログのオーバーフロー動作を変更するメソッド</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>を使用して      > [!NOTE] > オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ有効になります。 オーバーフロー動作は、新しいエントリの追加のイベント ログ エントリに対応できるログに書き込むには影響しません。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>イベント ログが最大ログ サイズに達したときに、新しいエントリを格納するために構成された動作を指定する値。 既定値は<xref href=&quot;System.Diagnostics.OverflowAction&quot;></xref>です。"
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "サーバーのイベント ビューアーに表示されているイベント ログのローカライズされた名前を指定します。"
  remarks: "RegisterDisplayName を使用して、登録し、カスタム イベント ログのイベント ビューアーのローカライズされた名前を表示します。       指定したリソース識別子は、リソース ファイルで定義されているローカライズされた文字列に対応する必要があります。 イベント ビューアーには、ローカライズされた文字列と現在のカルチャ設定を使用して、カスタム イベント ログ名が表示されます。 たとえば、リソース ファイルに複数の異なるカルチャのローカライズされた複数のイベント ログ名を定義できます。 イベント ビューアーには、現在のユーザーのカルチャ設定に対応するローカライズされた文字列が表示されます。       イベント ビューアーは、リソース ファイルからローカライズされた文字列を読み込めなかった場合、またはイベント ログの表示名が登録されていない場合は、イベント ビューアーに表示されます<xref:System.Diagnostics.EventLog.Log%2A>。</xref:System.Diagnostics.EventLog.Log%2A>で定義されているイベント ログ名      > [!NOTE] > 定義済みのイベント ログの表示名を登録する必要はありません。 オペレーティング システムでは、アプリケーション、システム、およびセキュリティ イベント ログのローカライズされた表示名を登録します。"
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "ローカライズされたリソース ファイルの完全指定パス。"
    - id: resourceId
      type: System.Int64
      description: "リソース ファイル内のローカライズされた文字列のインデックスを作成するリソースの識別子。"
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または設定ソースの名前を登録し、イベント ログに書き込むときに使用します。"
  remarks: "イベント ソースは、イベントをログに記録新機能を示します。 通常は、アプリケーションの名前か、アプリケーションのサブコンポーネントの名前、アプリケーションが大きい場合。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。       のみ、イベント ログに書き込みを行う場合は、イベント ソースを指定する必要があります。 イベント ログにエントリを書き込む前に有効なイベントのソースとして、イベント ログにイベント ソースを登録する必要があります。 ログ エントリを記述するときに、システムは、エントリを配置するのにための適切なログを検索するのにソース プロパティを使用します。 ソース、または<xref:System.Diagnostics.EventLog.Log%2A><xref:System.Diagnostics.EventLog.MachineName%2A>。</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>を指定できますか、イベント ログを読み取る場合      > [!NOTE] > を指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ローカル コンピューター上のログに接続しているかどうか</xref:System.Diagnostics.EventLog.MachineName%2A>。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.MachineName%2A> 。       使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>し<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込む</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.WriteEvent%2A> イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。       アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログ用に新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。       ソースがローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは一度に&1; つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のイベント ログに書き込むに複数のソースを使用することができます。 たとえば、アプリケーションでは、異なるイベント ログまたは別のリソース ファイル用に構成された複数のソースが必要です。       元の値を変更する場合、<xref:System.Diagnostics.EventLog>に登録されているが閉じられ、すべてのイベント ハンドルを解放します</xref:System.Diagnostics.EventLog>。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。       既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。      > [!NOTE] > ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするためにコンピューターを再起動する必要があります。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "エントリのソースとしてイベント ログに登録されている名前です。 既定値は空の文字列 (&quot;&quot;) です。"
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "ソース名は文字で 254 文字より長いレジストリ キーのパスになります。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ソースがローカル コンピューターに登録されているかどうかを判断します。"
  remarks: "このメソッドを使用すると、イベント ソースがローカル コンピューター上に存在するかどうかを確認します。 ログが、ローカル コンピューター上に存在するかどうかを判断する場合は、使用<xref:System.Diagnostics.EventLog.Exists%2A>。</xref:System.Diagnostics.EventLog.Exists%2A>       このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 ローカル コンピューター上それ以外の場合、<xref:System.Security.SecurityException>がスローされます</xref:System.Security.SecurityException>。      > [!NOTE] > イベント ソース以降および Windows Vista または Windows Server 2003 を検索するには管理者特権が必要です。   >> ため、この要件では、セキュリティを含む、すべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます</xref:System.Security.SecurityException>。   >> Windows Vista 以降で、ユーザー アカウント制御 (UAC) がユーザーの権限を決定します。 組み込みの Administrators グループのメンバーの場合は、2 つのランタイム アクセス トークンが割り当てられて: 標準ユーザー アクセス トークンおよび管理者アクセス トークン。 既定では、標準ユーザー ロールにしています。 パフォーマンス カウンターにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 アプリケーション アイコンを右クリックし、管理者として実行することを示すアプリケーションを起動するときに、これを行うことができます。      > [!NOTE] > の下で実行するサービス、<xref:System.ServiceProcess.ServiceAccount>アカウントには、このメソッドの実行に必要な権限はありません</xref:System.ServiceProcess.ServiceAccount>。 解決のイベント ソースが存在するかどうかを確認するには、 <xref:System.ServiceProcess.ServiceInstaller>、それが存在しない場合、インストーラーのソースを作成するとします</xref:System.ServiceProcess.ServiceInstaller>。       新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ために、試行する前にこのメソッドを使用して、呼び出す<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ことを確認する、ソースで指定された名前を持つ`source`ローカル コンピューターに既に存在しません</xref:System.Diagnostics.EventLog.CreateEventSource%2A>。 `source`パラメーターは、大文字小文字を区別することはありません。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "イベント ソースの名前です。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>イベント ソースがローカル コンピューターに登録されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>見つからないとしましたが、一部またはすべてのイベント ログを検索できませんでした。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ソースが指定されたコンピューターに登録されているかどうかを判断します。"
  remarks: "指定されたコンピューターのイベント ソースが存在するかどうかを確認するには、このメソッドを使用して、`machineName`パラメーター。 指定したコンピューター上のログが存在するかどうかを判断する場合は、使用<xref:System.Diagnostics.EventLog.Exists%2A>。</xref:System.Diagnostics.EventLog.Exists%2A>       このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 特定のサーバー上それ以外の場合、<xref:System.Security.SecurityException>がスローされます</xref:System.Security.SecurityException>。      > [!NOTE] > イベント ソース以降および Windows Vista または Windows Server 2003 を検索するには管理者特権が必要です。   >> ため、この要件では、セキュリティを含む、すべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます</xref:System.Security.SecurityException>。   >> Windows Vista 以降で、ユーザー アカウント制御 (UAC) がユーザーの権限を決定します。 組み込みの Administrators グループのメンバーの場合は、2 つのランタイム アクセス トークンが割り当てられて: 標準ユーザー アクセス トークンおよび管理者アクセス トークン。 既定では、標準ユーザー ロールにしています。 パフォーマンス カウンターにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 アプリケーション アイコンを右クリックし、管理者として実行することを示すアプリケーションを起動するときに、これを行うことができます。      > [!NOTE] > の下で実行するサービス、<xref:System.ServiceProcess.ServiceAccount>アカウントには、このメソッドの実行に必要な権限はありません</xref:System.ServiceProcess.ServiceAccount>。 解決のイベント ソースが存在するかどうかを確認するには、 <xref:System.ServiceProcess.ServiceInstaller>、それが存在しない場合、インストーラーのソースを作成するとします</xref:System.ServiceProcess.ServiceInstaller>。       新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ために、試行する前にこのメソッドを使用して、呼び出す<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ことを確認する、ソースで指定された名前を持つ`source`コンピューターに既に存在しません</xref:System.Diagnostics.EventLog.CreateEventSource%2A>。 `source`と`machineName`パラメーターは大文字と小文字が区別されません。       <xref:System.Diagnostics.EventLog.SourceExists%2A>`static`メソッド、クラス自体を呼び出すことができます。</xref:System.Diagnostics.EventLog.SourceExists%2A> <xref:System.Diagnostics.EventLog>呼び出す<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog>のインスタンスを作成する必要はありません。"
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "イベント ソースの名前です。"
    - id: machineName
      type: System.String
      description: "名前、検索対象のコンピューターまたは&quot;です。&quot;ローカル コンピューターのです。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>イベント ソースが指定したコンピューターに登録されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>無効なコンピューター名です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>見つからないとしましたが、一部またはすべてのイベント ログを検索できませんでした。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または設定の結果として発行されるイベント ハンドラー呼び出しをマーシャ リングに使用するオブジェクト、 <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>エントリ書き込みイベント。"
  remarks: "SynchronizingObject がある場合`null`、処理するメソッド、<xref:System.Diagnostics.EventLog.EntryWritten>イベントがシステムのスレッド プールのスレッドで呼び出されます</xref:System.Diagnostics.EventLog.EntryWritten>。 システム スレッド プールの詳細については、 <xref:System.Threading.ThreadPool>。</xref:System.Threading.ThreadPool>を参照してください。       ときに、<xref:System.Diagnostics.EventLog.EntryWritten>システム スレッド プールを介したコンポーネントにアクセスする、ボタンなどのコンポーネントが動作しない、または例外が発生する可能性があります visual Windows フォームでイベントが処理されます</xref:System.Diagnostics.EventLog.EntryWritten>。 これを回避する SynchronizingObject を処理するメソッドを、Windows フォームのコンポーネントに設定して、<xref:System.Diagnostics.EventLog.EntryWritten>コンポーネントが作成されたスレッドと同じスレッドで呼び出されるイベント</xref:System.Diagnostics.EventLog.EntryWritten>。       場合、<xref:System.Diagnostics.EventLog>内で使用する[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]、Windows フォーム デザイナーで SynchronizingObject 自動的に設定を含む、<xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog>コントロールに</xref:System.Diagnostics.EventLog> 配置する場合など、 <xref:System.Diagnostics.EventLog>Form1 のデザイナー上 (から継承される<xref:System.Windows.Forms.Form>) の SynchronizingObject プロパティ<xref:System.Diagnostics.EventLog>Form1 のインスタンスに設定されている</xref:System.Diagnostics.EventLog></xref:System.Windows.Forms.Form></xref:System.Diagnostics.EventLog>。"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>の結果として発行されるイベント ハンドラー呼び出しをマーシャ リングするために使用する<xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;></xref>イベント ログのイベントです。"
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログに指定したメッセージ テキストと、情報の種類エントリを書き込みます。"
  remarks: "このメソッドを使用してこれに関連付けられているイベント ログに情報のエントリを書き込む<xref:System.Diagnostics.EventLog>インスタンス</xref:System.Diagnostics.EventLog>。 その他の<xref:System.Diagnostics.EventLogEntryType><xref:System.Diagnostics.EventLog.WriteEntry%2A>。</xref:System.Diagnostics.EventLog.WriteEntry%2A>の異なるオーバー ロードを使用して、</xref:System.Diagnostics.EventLogEntryType>指定する場合      > [!NOTE] >、 `message` % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。       <xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog>ログにエントリを記述する前に、コンポーネント</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を設定する必要があります。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。       アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A>。      > [!NOTE] > を指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> 。       かどうか、システムは、登録<xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog.WriteEntry%2A>し<xref:System.Diagnostics.EventLog.Log%2A><xref:System.Diagnostics.EventLog>インスタンス、ログの既定値は、アプリケーション ログ</xref:System.Diagnostics.EventLog>のプロパティが設定されていない</xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出すことによって</xref:System.Diagnostics.EventLog.Source%2A>必要があります      > [!NOTE] > <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>の登録処理中に発生したエラーによって生成される多くの上に示した例外       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログにエラー、警告、情報、監査正常終了、または監査エラー エントリと共に指定したメッセージ テキストを書き込みます。"
  remarks: "このメソッドを使用して、指定した<xref:System.Diagnostics.EventLogEntryType>イベント ログに</xref:System.Diagnostics.EventLogEntryType>エントリの書き込み `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。      > [!NOTE] >、 `message` % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。       <xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog>ログにエントリを記述する前に、コンポーネント</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を設定する必要があります。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。       アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A>。      > [!NOTE] > を指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> 。       かどうか、システムは、登録<xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog.WriteEntry%2A>し<xref:System.Diagnostics.EventLog.Log%2A><xref:System.Diagnostics.EventLog>インスタンス、ログの既定値は、アプリケーション ログ</xref:System.Diagnostics.EventLog>のプロパティが設定されていない</xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出すことによって</xref:System.Diagnostics.EventLog.Source%2A>必要があります      > [!NOTE] > 上に示した多くの例外が<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>の登録処理中に発生したエラーによって生成されます       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。"
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定した登録イベント ソースを使用して、イベント ログに特定のメッセージ テキストと共に情報型エントリを書き込みます。"
  remarks: "このメソッドを使用して、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログが information のエントリを書き込みます。 その他の<xref:System.Diagnostics.EventLogEntryType><xref:System.Diagnostics.EventLog.WriteEntry%2A>。</xref:System.Diagnostics.EventLog.WriteEntry%2A>の異なるオーバー ロードを使用して、</xref:System.Diagnostics.EventLogEntryType>指定する場合       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。   >>、`message`文字列は % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューターにアプリケーションを登録するときのソース。"
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログを指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にエントリを書き込みます。"
  remarks: "このメソッドを使用して、アプリケーション定義のエントリの書き込みを`eventID`イベント ログにします。 `eventID`ソースと共に、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントとそれらに対応する説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。      > [!NOTE] >、 `message` % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。       イベントの識別子だけでなく<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント</xref:System.Diagnostics.EventLogEntryType>を指定できます。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。       <xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog>ログにエントリを記述する前に、コンポーネント</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を設定する必要があります。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。       アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A>。      > [!NOTE] > を指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> 。       かどうか、システムは、登録<xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog.WriteEntry%2A>し<xref:System.Diagnostics.EventLog.Log%2A><xref:System.Diagnostics.EventLog>インスタンス、ログの既定値は、アプリケーション ログ</xref:System.Diagnostics.EventLog>のプロパティが設定されていない</xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出すことによって</xref:System.Diagnostics.EventLog.Source%2A>必要があります      > [!NOTE] > 上に示した多くの例外が<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>の登録処理中に発生したエラーによって生成されます       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
    - id: eventID
      type: System.Int32
      description: "イベントのアプリケーション固有の識別子です。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定した登録イベント ソースを使用して、イベント ログにエラー、警告、情報、監査正常終了、または監査エラー エントリと共に指定したメッセージ テキストを書き込みます。"
  remarks: "このメソッドを使用して、指定した<xref:System.Diagnostics.EventLogEntryType>イベント ログに、適切なログのイベント ソースとして既に登録されているソースの使用</xref:System.Diagnostics.EventLogEntryType>のエントリの書き込み `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。      > [!NOTE] >、 `message` % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。"
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューターにアプリケーションを登録するときのソース。"
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログに、指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリを書き込みます。"
  remarks: "このメソッドを使用して、アプリケーション定義のエントリの書き込みを`category`イベント ログにします。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリをローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。      > [!NOTE] >、`category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。      > [!NOTE] >、 `message` % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。       イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルを構成します。       カテゴリには、だけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントとそれらに対応する説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。       最後<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベントを</xref:System.Diagnostics.EventLogEntryType>指定できます。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。       <xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog>ログにエントリを記述する前に、コンポーネント</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を設定する必要があります。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。       アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A>。      > [!NOTE] > を指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> 。       かどうか、システムは、登録<xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog.WriteEntry%2A>し<xref:System.Diagnostics.EventLog.Log%2A><xref:System.Diagnostics.EventLog>インスタンス、ログの既定値は、アプリケーション ログ</xref:System.Diagnostics.EventLog>のプロパティが設定されていない</xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出すことによって</xref:System.Diagnostics.EventLog.Source%2A>必要があります      > [!NOTE] > 上に示した多くの例外が<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>の登録処理中に発生したエラーによって生成されます       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
    - id: eventID
      type: System.Int32
      description: "イベントのアプリケーション固有の識別子です。"
    - id: category
      type: System.Int16
      description: "メッセージに関連付けられているアプリケーション固有のサブカテゴリ。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定した登録イベント ソースを使用して、イベント ログを指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にエントリを書き込みます。"
  remarks: "このメソッドを使用して、アプリケーション定義のエントリの書き込みを`eventID`をイベント ログ ソースを既に使用して、適切なログのイベント ソースとして登録されています。 `eventID`ソースとイベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントとそれらに対応する説明文字列を定義できます。 イベント ビューアーは、失敗の原因を理解し、実行するアクションを提案するユーザーを支援するユーザーにこれらの文字列を表示します。      > [!NOTE] >、 `message` % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。       イベントの識別子<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定できますが<xref:System.Diagnostics.EventLogEntryType>、イベント ログに書き込まれるイベント</xref:System.Diagnostics.EventLogEntryType></xref:System.Diagnostics.EventLog.WriteEntry%2A>のこのオーバー ロードだけでなく `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。"
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューターにアプリケーションを登録するときのソース。"
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
    - id: eventID
      type: System.Int32
      description: "イベントのアプリケーション固有の識別子です。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "イベント ログに、指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリを書き込みますをメッセージにバイナリ データを追加します。"
  remarks: "このオーバー ロードを使用して、イベント ログにイベント固有のアプリケーションで定義されたデータを書き込みます。 イベント ビューアーがこのデータを解釈しません16 進数およびテキストを組み合わせた形式でのみ、生データを表示します。 他の問題のデバッグ役に立つことを確認する場合にだけなので、慎重、イベントに固有のデータを使用します。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはログ ファイルをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。       バイナリ データに加え、アプリケーション定義のカテゴリおよびアプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリをローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。      > [!NOTE] >、 `message` % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。      > [!NOTE] >、`category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。       イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルを構成します。       イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントとそれらに対応する説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。       最後<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベントを</xref:System.Diagnostics.EventLogEntryType>指定できます。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。       <xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog>ログにエントリを記述する前に、コンポーネント</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を設定する必要があります。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。       アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.Source%2A>。      > [!NOTE] > を指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> 。       かどうか、システムは、登録<xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog.WriteEntry%2A>し<xref:System.Diagnostics.EventLog.Log%2A><xref:System.Diagnostics.EventLog>インスタンス、ログの既定値は、アプリケーション ログ</xref:System.Diagnostics.EventLog>のプロパティが設定されていない</xref:System.Diagnostics.EventLog.Log%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A>を呼び出すことによって</xref:System.Diagnostics.EventLog.Source%2A>必要があります      > [!NOTE] > 上に示した多くの例外が<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>の登録処理中に発生したエラーによって生成されます       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。"
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
    - id: eventID
      type: System.Int32
      description: "イベントのアプリケーション固有の識別子です。"
    - id: category
      type: System.Int16
      description: "メッセージに関連付けられているアプリケーション固有のサブカテゴリ。"
    - id: rawData
      type: System.Byte[]
      description: "エントリに関連付けられているバイナリ データを保持するバイト配列。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定した登録イベント ソースを使用して、イベント ログを指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリを書き込みます。 <code> category </code>イベント ビューアー ログでイベントをフィルター処理で使用できます。"
  remarks: "このメソッドを使用して、アプリケーション定義のエントリの書き込みを`category`イベント ログに適切なログのイベント ソースとして既に登録されているソースを使用します。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリをローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。      > [!NOTE] >、`category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。       イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルを構成します。       カテゴリには、だけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントとそれらに対応する説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。       最後<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベントを</xref:System.Diagnostics.EventLogEntryType>指定できます。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。   >>、`message`文字列は % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューターにアプリケーションを登録するときのソース。"
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
    - id: eventID
      type: System.Int32
      description: "イベントのアプリケーション固有の識別子です。"
    - id: category
      type: System.Int16
      description: "メッセージに関連付けられているアプリケーション固有のサブカテゴリ。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(指定した登録イベント ソースを使用して)、イベント ログに、指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリを書き込みますをメッセージにバイナリ データを追加します。"
  remarks: "このメソッドを使用して、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログにイベント固有のアプリケーションで定義されたデータを書き込みます。 イベント ビューアーがこのデータを解釈しません16 進数およびテキストを組み合わせた形式でのみ、生データを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみが含まれます。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはログ ファイルをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。       バイナリ データに加え、アプリケーション定義のカテゴリおよびアプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリをローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。      > [!NOTE] >、`category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、– 10 は、65,526、– 1 65,535 として表示されます。       イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラス</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルを構成します。       イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントとそれらに対応する説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。       最後<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベントを</xref:System.Diagnostics.EventLogEntryType>指定できます。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みますローカライズ可能なメッセージ リソース ファイルは使用されません。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます</xref:System.Diagnostics.EventLog.WriteEvent%2A>。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > 場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。   >>、`message`文字列は % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューターにアプリケーションを登録するときのソース。"
    - id: message
      type: System.String
      description: "イベント ログに書き込む文字列。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "1 つ、 <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>値。"
    - id: eventID
      type: System.Int32
      description: "イベントのアプリケーション固有の識別子です。"
    - id: category
      type: System.Int16
      description: "メッセージに関連付けられているアプリケーション固有のサブカテゴリ。"
    - id: rawData
      type: System.Byte[]
      description: "エントリに関連付けられているバイナリ データを保持するバイト配列。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>有効ではありません<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>です。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "ローカライズされたエントリをイベント ログに書き込みます。"
  remarks: "このメソッドを使用して、イベント ログにローカライズされたエントリを書き込みます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソースの識別子を使用して、 <xref:System.Diagnostics.EventLog.Source%2A>。</xref:System.Diagnostics.EventLog.Source%2A>のローカライズされたリソース ファイルから対応する文字列を表示 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。       入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します</xref:System.Diagnostics.EventInstance.InstanceId%2A>。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力</xref:System.Diagnostics.EventInstance.EntryType%2A></xref:System.Diagnostics.EventInstance.CategoryId%2A>。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.WriteEvent%2A>。</xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前にコンポーネント</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を設定する必要があります。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>アプリケーション イベント ログに直接文字列値を書き込む場合、メソッド</xref:System.Diagnostics.EventLog.WriteEntry%2A>の使用します。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > の値のリモート コンピューターにエントリを書き込むかどうか、`message`文字列できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。 また、`message`文字列は % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。"
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>ローカライズされたイベント ログ エントリを表すインスタンス。"
    - id: values
      type: System.Object[]
      description: "イベント ログ エントリのメッセージ テキストにマージする文字列の配列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定したイベント データ、メッセージ置換文字列、および関連付けられているバイナリ データと共にイベント ログ エントリを書き込みます。"
  remarks: "このメソッドを使用して、イベント ログにイベント固有のデータを追加したローカライズされたエントリを書き込みます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソースの識別子を使用して、 <xref:System.Diagnostics.EventLog.Source%2A>。</xref:System.Diagnostics.EventLog.Source%2A>のローカライズされたリソース ファイルから対応する文字列を表示 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。       入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します</xref:System.Diagnostics.EventInstance.InstanceId%2A>。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力</xref:System.Diagnostics.EventInstance.EntryType%2A></xref:System.Diagnostics.EventInstance.CategoryId%2A>。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。       イベントの詳細情報を入力する必要があるときにイベントをバイナリ データを指定します。 たとえば、使用して、`data`パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーは、関連付けられたイベント データを解釈できません。16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみが含まれます。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはイベント ログをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。       <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.WriteEvent%2A>。</xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前にコンポーネント</xref:System.Diagnostics.EventLog>のプロパティ</xref:System.Diagnostics.EventLog.Source%2A>を設定する必要があります。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。      > [!NOTE] > を指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.WriteEvent%2A>、ローカル コンピューター (&quot;です&quot;) と見なされます。</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> 。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>アプリケーション イベント ログに直接文字列値を書き込む場合、メソッド</xref:System.Diagnostics.EventLog.WriteEntry%2A>の使用します。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。      > [!NOTE] > の値のリモート コンピューターにエントリを書き込むかどうか、`message`文字列できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。 また、`message`文字列は % を含めることはできません*n*ここで、 *n*整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。"
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>ローカライズされたイベント ログ エントリを表すインスタンス。"
    - id: data
      type: System.Byte[]
      description: "エントリに関連付けられているバイナリ データを保持するバイト配列。"
    - id: values
      type: System.Object[]
      description: "イベント ログ エントリのメッセージ テキストにマージする文字列の配列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "データとメッセージ置換文字列を指定した登録イベント ソースを使用して、指定したイベントのイベント ログ エントリを書き込みます。"
  remarks: "このメソッドを使用して、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログにローカライズされたエントリを書き込みます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソースの識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。       入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します</xref:System.Diagnostics.EventInstance.InstanceId%2A>。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力</xref:System.Diagnostics.EventInstance.EntryType%2A></xref:System.Diagnostics.EventInstance.CategoryId%2A>。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。       <xref:System.Diagnostics.EventLog.WriteEvent%2A>。</xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前に、イベント ログの指定したソースを登録する必要があります。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>アプリケーション イベント ログに直接文字列値を書き込む場合、メソッド</xref:System.Diagnostics.EventLog.WriteEntry%2A>の使用します。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューター上のアプリケーションに登録されたイベント ソースの名前。"
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>ローカライズされたイベント ログ エントリを表すインスタンス。"
    - id: values
      type: System.Object[]
      description: "イベント ログ エントリのメッセージ テキストにマージする文字列の配列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "登録イベント ソースを指定して、ログ エントリを指定したイベント データ、メッセージ置換文字列、および関連付けられているバイナリ データは、イベントを書き込みます。"
  remarks: "このメソッドを使用して、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログにイベント固有のデータを追加したローカライズされたエントリを書き込みます。 文字列値ではなく、リソース識別子では、イベントのプロパティを指定します。 イベント ビューアーでは、リソースの識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。       入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します</xref:System.Diagnostics.EventInstance.InstanceId%2A>。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力</xref:System.Diagnostics.EventInstance.EntryType%2A></xref:System.Diagnostics.EventInstance.CategoryId%2A>。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。       イベントの詳細情報を入力する必要があるときにイベントをバイナリ データを指定します。 たとえば、使用して、`data`パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーは、関連付けられたイベント データを解釈できません。16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみが含まれます。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはイベント ログをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。       <xref:System.Diagnostics.EventLog.WriteEvent%2A>。</xref:System.Diagnostics.EventLog.WriteEvent%2A>を使用する前に、イベント ログの指定したソースを登録する必要があります。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。       作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッド</xref:System.Diagnostics.EventLog.CreateEventSource%2A></xref:System.Diagnostics.EventLogInstaller>。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。       ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>アプリケーション イベント ログに直接文字列値を書き込む場合、メソッド</xref:System.Diagnostics.EventLog.WriteEntry%2A>の使用します。       アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを&1; つのソースを構成し、<xref:System.Diagnostics.EventLog.WriteEvent%2A>イベント ログへのリソース識別子を使用してエントリを書き込むメソッド</xref:System.Diagnostics.EventLog.WriteEvent%2A>では、そのソースを使用 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます</xref:System.Diagnostics.EventLog.WriteEntry%2A>。"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "指定したコンピューター上のアプリケーションに登録されたイベント ソースの名前。"
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>ローカライズされたイベント ログ エントリを表すインスタンス。"
    - id: data
      type: System.Byte[]
      description: "エントリに関連付けられているバイナリ データを保持するバイト配列。"
    - id: values
      type: System.Object[]
      description: "イベント ログ エントリのメッセージ テキストにマージする文字列の配列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "イベント ログのレジストリ キーを開けませんでした。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "オペレーティング システムでは、イベントのエントリをイベント ログに書き込むときにエラーが報告されました。 Windows エラー コードは使用できません。"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
