### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "提供、<xref:System.IO.Stream>ファイルの場合、同期および非同期の両方をサポートする読み取りおよび書き込み操作です</xref:System.IO.Stream>。       この型の .NET Framework ソース コードを参照するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)です。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>指定下読み取り/書き込みアクセス許可を持つ、指定したファイル ハンドルのクラスです。"
  remarks: "ときに<xref:System.IO.Stream.Close%2A>が呼び出されると、またはハンドルが閉じられ、ファイルのハンドル数は減少します</xref:System.IO.Stream.Close%2A>。       `FileStream`ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、または中にシーク、`FileStream`も保持しているハンドルは、データの破損、可能性があります。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のすべてのメソッドは呼び出しません`Close`が完了したらこのハンドルを使用します</xref:System.IO.FileStream.Flush%2A>。      > [!CAUTION] > 文字のセットをコンパイル時に特定のカルチャ設定を同じ文字を別のカルチャ設定を取得する文字、解釈されないことし、例外をスローする可能性があります。       `FileShare.Read`これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター</xref:System.IO.FileStream> 。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "ファイルのファイル ハンドルを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "設定する定数、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>フィールドではなく<xref href=&quot;System.IO.FileAccess&quot;></xref>です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディスク エラーなど、I/O エラーが発生しました。       または、ストリームが閉じられました。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求された場合など、指定したファイル ハンドル用のオペレーティング システムによって許可されていない<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>読み取り専用アクセスのファイル ハンドルを設定します。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>指定下読み取り/書き込みアクセス許可を持つ、指定したファイル ハンドルのクラスです。"
  remarks: "ときに<xref:System.IO.Stream.Close%2A>が呼び出されると、またはハンドルが閉じられ、ファイルのハンドル数は減少します</xref:System.IO.Stream.Close%2A>。       `FileStream`ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、または中にシーク、`FileStream`も保持しているハンドルは、データの破損、可能性があります。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のすべてのメソッドは呼び出しません`Close`が完了したらこのハンドルを使用します</xref:System.IO.FileStream.Flush%2A>。      > [!CAUTION] > 文字のセットをコンパイル時に特定のカルチャ設定を同じ文字を別のカルチャ設定を取得する文字、解釈されないことし、例外をスローする可能性があります。       `FileShare.Read`これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター</xref:System.IO.FileStream> 。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "ファイルのファイル ハンドルを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "設定する定数、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>フィールドではなく<xref href=&quot;System.IO.FileAccess&quot;></xref>です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディスク エラーなど、I/O エラーが発生しました。       または、ストリームが閉じられました。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求された場合など、指定したファイル ハンドル用のオペレーティング システムによって許可されていない<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>読み取り専用アクセスのファイル ハンドルを設定します。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>パスと作成モードを指定しています。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       または、ストリームが閉じられました。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定したパス、ファイル名、またはその両方は、システム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>無効な値が含まれています。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>クラスの指定下読み取り/書き込み権限を持つ、指定したファイル ハンドル用およびバッファー サイズ。"
  remarks: "`FileStream`ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、または中にシーク、`FileStream`も保持しているハンドルは、データの破損、可能性があります。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のすべてのメソッドは呼び出しません`Close`が完了したらこのハンドルを使用します</xref:System.IO.FileStream.Flush%2A>。 または、読み書き可能なハンドルにこの関数を呼び出す前に`FileStream`コンス トラクターです。       `FileShare.Read`これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター</xref:System.IO.FileStream> 。      > [!CAUTION] > 文字のセットをコンパイル時に特定のカルチャ設定を同じ文字を別のカルチャ設定を取得する文字、解釈されないことし、例外をスローする可能性があります。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "ファイルのファイル ハンドルを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref>設定する定数、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code>パラメーターが無効なハンドル。       - または -、 <code> handle </code>パラメーターが同期ハンドルであり、非同期的に使用されました。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code>パラメーターが負の値。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディスク エラーなど、I/O エラーが発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求された場合など、指定したファイル ハンドル用のオペレーティング システムによって許可されていない<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>読み取り専用アクセスのファイル ハンドルを設定します。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>指定下読み取り/書き込みアクセス許可を持つ、指定したファイル ハンドル用クラスと<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>インスタンスの所有権です。"
  remarks: "`FileStream`オブジェクトには、ファイルに指定されたアクセスが与えられます。 ハンドルの所有権がなりますとして指定します。 このプロセスへの呼び出し、ハンドルを所有している場合、<xref:System.IO.Stream.Close%2A>メソッドは、ハンドルを終了しても、ファイルのハンドル数は減少します</xref:System.IO.Stream.Close%2A>。 `FileStream`オブジェクトが 4096 バイトまでの既定のバッファー サイズを指定します。       `FileStream`ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、または中にシーク、`FileStream`も保持しているハンドルは、データの破損、可能性があります。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のメソッドは呼び出しません`Close`が完了したら、ハンドルを使用します</xref:System.IO.FileStream.Flush%2A>。       `FileShare.Read`これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター</xref:System.IO.FileStream> 。      > [!CAUTION] > 文字のセットをコンパイル時に特定のカルチャ設定を同じ文字を別のカルチャ設定を取得する文字、解釈されないことし、例外をスローする可能性があります。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "ファイルのファイル ハンドルを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "設定する定数、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ファイル ハンドルを所有するこれ場合<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>インスタンス。 それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>フィールドではなく<xref href=&quot;System.IO.FileAccess&quot;></xref>です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディスク エラーなど、I/O エラーが発生しました。       または、ストリームが閉じられました。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求された場合など、指定したファイル ハンドル用のオペレーティング システムによって許可されていない<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>読み取り専用アクセスのファイル ハンドルを設定します。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>クラスの指定したパス、作成モード、および読み取り/書き込みアクセス許可。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
    - id: access
      type: System.IO.FileAccess
      description: "ファイルにアクセスできる方法を決定する定数、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 によって返される値も指定、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>場合`path`ディスク ファイルを指定します。</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求に指定されたオペレーティング システムによって許可されていない<code> path </code>、ときなど<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>ファイルまたはディレクトリが読み取り専用アクセスの設定とします。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定したパス、ファイル名、またはその両方は、システム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>無効な値が含まれています。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>指定下読み取り/書き込みアクセス許可、バッファー サイズ、および同期状態または非同期状態で、指定したファイル ハンドルのクラスです。"
  remarks: "設定する、`isAsync`パラメーターを`true`を非同期的にファイル ハンドルを開きます。 パラメーターの場合は`true`ストリームがファイルの操作を非同期的に実行する重複 I/O を使用します。 ただし、パラメーターは、する必要はありません`true`を呼び出して、 <xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、または<xref:System.IO.Stream.CopyToAsync%2A>メソッド</xref:System.IO.Stream.CopyToAsync%2A></xref:System.IO.FileStream.WriteAsync%2A></xref:System.IO.FileStream.ReadAsync%2A>。 ときに、`isAsync`パラメーターは`false`および書き込み操作を非同期の読み込みを呼び出すと、引き続き、UI スレッドはブロックされませんが、実際の I/O 操作が同期的に実行します。       `FileStream`ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、または中にシーク、`FileStream`も保持しているハンドルは、データの破損、可能性があります。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のすべてのメソッドは呼び出しません`Close`が完了したらこのハンドルを使用します</xref:System.IO.FileStream.Flush%2A>。 または、読み書き可能なハンドルにこの関数を呼び出す前に`FileStream`コンス トラクターです。       `FileShare.Read`これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター</xref:System.IO.FileStream> 。      > [!CAUTION] > 文字のセットをコンパイル時に特定のカルチャ設定を同じ文字を別のカルチャ設定を取得する文字、解釈されないことし、例外をスローする可能性があります。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "ファイルがこのファイルのハンドル<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "設定する定数、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ハンドルが非同期的に開かれた場合 (つまり、重複 I/O モード用) です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code>パラメーターが無効なハンドル。       - または -、 <code> handle </code>パラメーターが同期ハンドルであり、非同期的に使用されました。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code>パラメーターが負の値。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディスク エラーなど、I/O エラーが発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求された場合など、指定したファイル ハンドル用のオペレーティング システムによって許可されていない<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>読み取り専用アクセスのファイル ハンドルを設定します。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref> 、指定下読み取り/書き込み権限を持つ、指定したファイル ハンドル用クラス<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>インスタンスの所有権、およびバッファー サイズ。"
  remarks: "`FileStream`オブジェクトには、ファイルに指定されたアクセスが与えられます。 ハンドルの所有権がなりますとして指定します。 この場合`FileStream`への呼び出し、ハンドルを所有している、<xref:System.IO.Stream.Close%2A>メソッドは、ハンドルを終了しても</xref:System.IO.Stream.Close%2A>。 具体的には、ファイルのハンドル数は減少します。 `FileStream`オブジェクトが指定したバッファー サイズを指定します。       `FileStream`ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、または中にシーク、`FileStream`も保持しているハンドルは、データの破損、可能性があります。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のすべてのメソッドは呼び出しません`Close`が完了したらこのハンドルを使用します</xref:System.IO.FileStream.Flush%2A>。 または、読み書き可能なハンドルにこの関数を呼び出す前に`FileStream`コンス トラクターです。       `FileShare.Read`これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター</xref:System.IO.FileStream> 。      > [!CAUTION] > 文字のセットをコンパイル時に特定のカルチャ設定を同じ文字を別のカルチャ設定を取得する文字、解釈されないことし、例外をスローする可能性があります。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "ファイルがこのファイルのハンドル<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "設定する定数、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ファイル ハンドルを所有するこれ場合<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>インスタンス。 それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>負の値。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディスク エラーなど、I/O エラーが発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求された場合など、指定したファイル ハンドル用のオペレーティング システムによって許可されていない<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>読み取り専用アクセスのファイル ハンドルを設定します。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>指定したパス、作成モード、読み取り/書き込みアクセス許可、および共有アクセス許可を持つクラス。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
    - id: access
      type: System.IO.FileAccess
      description: "ファイルにアクセスできる方法を決定する定数、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 によって返される値も指定、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>場合`path`ディスク ファイルを指定します。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "プロセスによるファイルの共有方法を決定する定数。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       - または - Windows 98 または Windows 98 Second Edition、システムが実行されていると<code> share </code> éý &quot; è <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;></xref>です。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求に指定されたオペレーティング システムによって許可されていない<code> path </code>、ときなど<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>ファイルまたはディレクトリが読み取り専用アクセスの設定とします。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定したパス、ファイル名、またはその両方は、システム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>無効な値が含まれています。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref> 、指定下読み取り/書き込み権限を持つ、指定したファイル ハンドル用クラス<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>インスタンスの所有権、バッファー サイズ、および同期状態または非同期状態です。"
  remarks: "`FileStream`オブジェクトには、ファイルに指定されたアクセスが与えられます。 ハンドルの所有権がなりますとして指定します。 この場合`FileStream`への呼び出し、ハンドルを所有している、<xref:System.IO.Stream.Close%2A>メソッドは、ハンドルを終了しても</xref:System.IO.Stream.Close%2A>。 具体的には、ファイルのハンドル数は減少します。 `FileStream`オブジェクトが指定したバッファー サイズを指定します。       `FileStream`ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、または中にシーク、`FileStream`も保持しているハンドルは、データの破損、可能性があります。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のすべてのメソッドは呼び出しません`Close`が完了したらこのハンドルを使用します</xref:System.IO.FileStream.Flush%2A>。 または、読み書き可能なハンドルにこの関数を呼び出す前に`FileStream`コンス トラクターです。       `FileShare.Read`これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター</xref:System.IO.FileStream> 。      > [!CAUTION] > 文字のセットをコンパイル時に特定のカルチャ設定を同じ文字を別のカルチャ設定を取得する文字、解釈されないことし、例外をスローする可能性があります。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "ファイルがこのファイルのハンドル<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: access
      type: System.IO.FileAccess
      description: "設定する定数、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ファイル ハンドルを所有するこれ場合<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>インスタンス。 それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ハンドルが非同期的に開かれた場合 (つまり、重複 I/O モード用) です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>より小さい<xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;></xref>以上<xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;></xref>または<code>bufferSize</code>が 0 未満です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "ハンドルが正しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディスク エラーなど、I/O エラーが発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求された場合など、指定したファイル ハンドル用のオペレーティング システムによって許可されていない<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>読み取り専用アクセスのファイル ハンドルを設定します。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>クラスの指定したパス、作成モード、読み取り/書き込みと共有アクセス許可、およびバッファー サイズ。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
    - id: access
      type: System.IO.FileAccess
      description: "ファイルにアクセスできる方法を決定する定数、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 によって返される値も指定、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>場合`path`ディスク ファイルを指定します。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "プロセスによるファイルの共有方法を決定する定数。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>負の値またはゼロです。       - または - <code>mode</code>、 <code>access</code>、または<code>share</code>無効な値を格納します。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       - または - Windows 98 または Windows 98 Second Edition、システムが実行されていると<code> share </code> éý &quot; è <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;></xref>です。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求に指定されたオペレーティング システムによって許可されていない<code> path </code>、ときなど<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>ファイルまたはディレクトリが読み取り専用アクセスの設定とします。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定したパス、ファイル名、またはその両方は、システム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>指定されたパス、作成モード、読み取り/書き込みを持つクラスし、共有アクセス許可、バッファーのサイズ、および同期状態または非同期状態です。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
    - id: access
      type: System.IO.FileAccess
      description: "ファイルにアクセスできる方法を決定する定数、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 によって返される値も指定、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>場合`path`ディスク ファイルを指定します。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "プロセスによるファイルの共有方法を決定する定数。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは、4096 です."
    - id: useAsync
      type: System.Boolean
      description: "非同期 I/O または同期 I/O を使用するかどうかを指定します。 ただし、基になるオペレーティング システムが非同期の I/O をサポートしていませんことを指定するため<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>、プラットフォームによって、ハンドルを同期的に開かれる可能性があります。 非同期的に開かれたときに、 <> </> *> と<> *> 少量の読み取りまたは書き込みより低くなる可能性がありますメソッドが大量の読み取りまたは書き込みのパフォーマンスが向上ことができます。 アプリケーションが非同期 I/O を活用するために設計されている場合は、設定、`useAsync`パラメーターを<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。 非同期 I/O を正しく使用することができますを高速化によって、アプリケーションほどによってパフォーマンスが低下する非同期 I/O 用にアプリケーションを再設計せず使用しますが、10 倍ほど 10 倍にします。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>負の値またはゼロです。       - または - <code>mode</code>、 <code>access</code>、または<code>share</code>無効な値を格納します。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       - または - Windows 98 または Windows 98 Second Edition、システムが実行されていると<code> share </code> éý &quot; è <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;></xref>です。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求に指定されたオペレーティング システムによって許可されていない<code> path </code>、ときなど<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>ファイルまたはディレクトリが読み取り専用アクセスの設定とします。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定したパス、ファイル名、またはその両方は、システム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>クラスは、指定したパス、作成モード、読み取り/書き込みと共有アクセス許可、アクセス、同じファイルでは、バッファー サイズ、および追加のファイル オプションを他の Filestream が保有できます。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
    - id: access
      type: System.IO.FileAccess
      description: "ファイルにアクセスできる方法を決定する定数、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 によって返される値も指定、 <> </> *> と<> *> のプロパティ、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>オブジェクト。 <xref:System.IO.FileStream.CanSeek*><xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>場合`path`ディスク ファイルを指定します。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "プロセスによるファイルの共有方法を決定する定数。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
    - id: options
      type: System.IO.FileOptions
      description: "追加のファイル オプションを指定する値。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>負の値またはゼロです。       - または - <code>mode</code>、 <code>access</code>、または<code>share</code>無効な値を格納します。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求に指定されたオペレーティング システムによって許可されていない<code> path </code>、ときなど<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>ファイルまたはディレクトリが読み取り専用アクセスの設定とします。       - または - <xref href=&quot;System.IO.FileOptions&quot;> </xref>が指定されて<code> options</code>が現在のプラットフォームでは、ファイルの暗号化はサポートされていません。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定したパス、ファイル名、またはその両方は、システム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>指定したパス、作成モード、アクセス権および共有アクセス許可、バッファー サイズ、および追加のファイル オプションを持つクラス。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref href=&quot;System.IO.FileStream&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "ファイルのアクセスおよび監査規則を作成するときに使用するアクセス権を決定する定数。"
    - id: share
      type: System.IO.FileShare
      description: "プロセスによるファイルの共有方法を決定する定数。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
    - id: options
      type: System.IO.FileOptions
      description: "追加のファイル オプションを指定する定数。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>負の値またはゼロです。       - または - <code>mode</code>、 <code>access</code>、または<code>share</code>無効な値を格納します。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "現在のオペレーティング システムが Windows NT 以降です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求に指定されたオペレーティング システムによって許可されていない<code> path </code>、ときなど<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>ファイルまたはディレクトリが読み取り専用アクセスの設定とします。       - または - <xref href=&quot;System.IO.FileOptions&quot;> </xref>が指定されて<code> options</code>が現在のプラットフォームでは、ファイルの暗号化はサポートされていません。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定した<code> path</code>ファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.FileStream&quot;> </xref>クラスの指定したパス、作成モード、アクセス権、共有アクセス許可、バッファー サイズ、追加のファイル オプション、アクセス制御と監査セキュリティ。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "ファイルの相対パスまたは絶対パスを現在<xref href=&quot;System.IO.FileStream&quot;></xref>オブジェクトによってカプセル化します。"
    - id: mode
      type: System.IO.FileMode
      description: "開くか、ファイルを作成する方法を決定する定数。"
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "ファイルのアクセスおよび監査規則を作成するときに使用するアクセス権を決定する定数。"
    - id: share
      type: System.IO.FileShare
      description: "プロセスによるファイルの共有方法を決定する定数。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>バッファー サイズを示す 0 より大きい値です</xref:System.Int32>。 既定のバッファー サイズは 4096 です。"
    - id: options
      type: System.IO.FileOptions
      description: "追加のファイル オプションを指定する定数。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "アクセス制御を決定する定数およびファイルのセキュリティを監査します。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;)、空白しか含んでいない、または&1; つまたは複数の無効な文字が含まれています。       - または -<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、NTFS 環境などです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>などの非ファイル デバイスを参照&quot;con:&quot;、&quot;com1:&quot;、&quot;lpt&1;:&quot;、非 NTFS 環境などです。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>負の値またはゼロです。       - または - <code>mode</code>、 <code>access</code>、または<code>share</code>無効な値を格納します。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "場合など、ファイルが見つからない<code> mode </code>は<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;></xref>とで指定されたファイル<code> path </code>存在しません。 これらのモードでファイルが存在する必要があります。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定するなど、I/O エラー <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref>によって指定されたファイル<code> path </code>既に存在する場合が発生しました。       または、ストリームが閉じられました。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定のパスがマップされていないドライブにあるなど、有効ではありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求に指定されたオペレーティング システムによって許可されていない<code> path </code>、ときなど<code> access </code>は<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>ファイルまたはディレクトリが読み取り専用アクセスの設定とします。       - または - <xref href=&quot;System.IO.FileOptions&quot;> </xref>が指定されて<code> options</code>が現在のプラットフォームでは、ファイルの暗号化はサポートされていません。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定した<code> path</code>ファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満である必要があり、ファイル名は 260 文字未満にする必要があります。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "現在のオペレーティング システムが Windows NT 以降です。"
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "非同期の読み取り操作を開始します。 (使用を検討して<xref:System.IO.FileStream.ReadAsync*>代わりにします「解説」セクションを参照してください。)</xref:System.IO.FileStream.ReadAsync*> 。"
  remarks: ".NET Framework 4 以前のバージョンは BeginRead などのメソッドを使用する必要があると<xref:System.IO.FileStream.EndRead%2A>ファイルの非同期操作を実装する</xref:System.IO.FileStream.EndRead%2A>。 これらのメソッドでは使用できます、[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]レガシ コードをサポートするただし、新しい非同期メソッドなど<xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、 <xref:System.IO.Stream.CopyToAsync%2A>、および<xref:System.IO.FileStream.FlushAsync%2A>、ヘルプ ファイルの非同期操作をより簡単に実装する</xref:System.IO.FileStream.FlushAsync%2A></xref:System.IO.Stream.CopyToAsync%2A></xref:System.IO.FileStream.WriteAsync%2A></xref:System.IO.FileStream.ReadAsync%2A>。       <xref:System.IO.FileStream.EndRead%2A>BeginRead を呼び出すたびに対して&1; 回だけ呼び出すこと必要があります。</xref:System.IO.FileStream.EndRead%2A> 別の読み取りを開始する前に読み取りプロセスを終了に失敗すると、デッドロックなど、望ましくない動作可能性があります。       <xref:System.IO.FileStream>操作の&2; つの異なるモードを提供します。 I/O 同期と非同期 I/O です。</xref:System.IO.FileStream> いずれかを使用できますが、基になるオペレーティング システムのリソースは、これらのモードの&1; つのみで、アクセスを許可する場合があります。 既定では、<xref:System.IO.FileStream>オペレーティング システム ハンドルを同期的が開きます</xref:System.IO.FileStream>。 Windows では、非同期メソッドの速度が低下します。 非同期メソッドを使用している場合を使用して、<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>コンス トラクター</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 。      > [!NOTE] > を使用して、 <xref:System.IO.FileStream.CanRead%2A>、現在のインスタンスが読み取りをサポートするかどうかを決定するプロパティ</xref:System.IO.FileStream.CanRead%2A>。 詳細については、 <xref:System.IO.Stream.CanRead%2A>。</xref:System.IO.Stream.CanRead%2A>を参照してください。       ストリームが閉じているか、無効な引数を渡す場合の例外が直ちにスローされます BeginRead からです。 IO 要求中にディスク障害など、非同期読み取り要求中に発生したエラーは、スレッド プールのスレッドで発生し、 <xref:System.IO.FileStream.EndRead%2A>。</xref:System.IO.FileStream.EndRead%2A>への呼び出しに可視になります。       <xref:System.IO.Stream.EndRead%2A>これで呼び出されなければなりません<xref:System.IAsyncResult>読み取られたバイト数を確認する</xref:System.IAsyncResult>。</xref:System.IO.Stream.EndRead%2A>       複数の非同期要求は、不定の要求の完了の順序をレンダリングします。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "データを読み取るバッファー。"
    - id: offset
      type: System.Int32
      description: "内のバイト オフセット`array`読み取りを開始する位置。"
    - id: numBytes
      type: System.Int32
      description: "読み取るバイトの最大数。"
    - id: userCallback
      type: System.AsyncCallback
      description: "非同期の読み取り操作時に呼び出されるメソッドが完了するとします。"
    - id: stateObject
      type: System.Object
      description: "この特定の非同期読み取り要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "非同期の読み取りを参照するオブジェクト。"
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "配列の長さマイナス<code> offset </code>はより小さい<code> numBytes</code>です。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>または<code>numBytes</code>が負の値。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "非同期の読み取りがファイルの終わりを超えて試行されました。"
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "非同期の書き込み操作を開始します。 (使用を検討して<xref:System.IO.FileStream.WriteAsync*>代わりにします「解説」セクションを参照してください。)</xref:System.IO.FileStream.WriteAsync*> 。"
  remarks: ".NET Framework 4 以前のバージョンは BeginWrite などのメソッドを使用する必要があると<xref:System.IO.FileStream.EndWrite%2A>ファイルの非同期操作を実装する</xref:System.IO.FileStream.EndWrite%2A>。 これらのメソッドでは使用できます、[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]レガシ コードをサポートするただし、新しい非同期メソッドなど<xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、 <xref:System.IO.Stream.CopyToAsync%2A>、および<xref:System.IO.FileStream.FlushAsync%2A>、ヘルプ ファイルの非同期操作をより簡単に実装する</xref:System.IO.FileStream.FlushAsync%2A></xref:System.IO.Stream.CopyToAsync%2A></xref:System.IO.FileStream.WriteAsync%2A></xref:System.IO.FileStream.ReadAsync%2A>。       <xref:System.IO.FileStream.EndWrite%2A>1 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>を渡した</xref:System.IAsyncResult>。</xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>I/O 操作が完了するまでブロックされます。</xref:System.IO.FileStream.EndWrite%2A>       このメソッドは<xref:System.IO.Stream.BeginWrite%2A>。</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>操作の&2; つの異なるモードを提供します。 I/O 同期と非同期 I/O です。</xref:System.IO.FileStream> いずれかを使用できますが、基になるオペレーティング システムのリソースは、これらのモードの&1; つのみで、アクセスを許可する場合があります。 既定では、<xref:System.IO.FileStream>オペレーティング システム ハンドルを同期的が開きます</xref:System.IO.FileStream>。 Windows では、非同期メソッドの速度が低下します。 非同期メソッドを使用している場合を使用して、<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>コンス トラクター</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 。       ストリームが閉じているか、無効な引数を渡す場合の例外が直ちにスローされます BeginWrite からです。 IO 要求中にディスク障害など、非同期書き込み要求中に発生したエラーは、スレッド プールのスレッドで発生し、 <xref:System.IO.FileStream.EndWrite%2A>。</xref:System.IO.FileStream.EndWrite%2A>への呼び出しに可視になります。       複数の非同期要求は、不定の要求の完了の順序をレンダリングします。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "現在のストリームに書き込むデータを保持するバッファー。"
    - id: offset
      type: System.Int32
      description: "内の&0; から始まるバイト オフセット`array`現在のストリームにバイトのコピーを開始する位置。"
    - id: numBytes
      type: System.Int32
      description: "書き込むバイトの最大数。"
    - id: userCallback
      type: System.AsyncCallback
      description: "非同期の書き込み操作が完了したときに呼び出されるメソッド。"
    - id: stateObject
      type: System.Object
      description: "この特定の非同期書き込み要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "非同期の書き込みを参照するオブジェクト。"
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>引いた長さ<code>offset</code>はより小さい<code>numBytes</code>です。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>または<code>numBytes</code>が負の値。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームは書き込みをサポートしていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O エラーが発生しました。"
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "現在のストリームが読み取りをサポートするかどうかを示す値を取得します。"
  remarks: "派生したクラス場合<xref:System.IO.Stream>読み取りをサポートしませんへの呼び出し、 <xref:System.IO.FileStream.Read%2A>、 <xref:System.IO.FileStream.ReadByte%2A>、<xref:System.IO.FileStream.BeginRead%2A>メソッドはスロー <xref:System.NotSupportedException>.</xref:System.NotSupportedException></xref:System.IO.FileStream.BeginRead%2A>と</xref:System.IO.FileStream.ReadByte%2A></xref:System.IO.FileStream.Read%2A></xref:System.IO.Stream>       ストリームが閉じられたかどうか、このプロパティを返します`false`です。"
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ストリームが読み取りをサポートしている場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>ストリームが閉じているか書き込み専用アクセスで開かれた場合。"
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "現在のストリームがシークをサポートしているかどうかを示す値を取得します。"
  remarks: "派生したクラス場合<xref:System.IO.Stream>への呼び出しをシークをサポートしていない<xref:System.IO.FileStream.Length%2A>、 <xref:System.IO.FileStream.SetLength%2A>、 <xref:System.IO.FileStream.Position%2A>、 <xref:System.IO.FileStream.Seek%2A> <xref:System.NotSupportedException>.</xref:System.NotSupportedException>をスロー</xref:System.IO.FileStream.Seek%2A>および</xref:System.IO.FileStream.Position%2A></xref:System.IO.FileStream.SetLength%2A></xref:System.IO.FileStream.Length%2A></xref:System.IO.Stream>       ストリームが閉じられたかどうか、このプロパティを返します`false`です。"
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ストリームがシークをサポートしている場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>ストリームが閉じている場合、または場合、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>コンソールにパイプ出力などのオペレーティング システム ハンドルから構築されています。"
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "現在のストリームが書き込みをサポートするかどうかを示す値を取得します。"
  remarks: "派生したクラス場合<xref:System.IO.Stream>への呼び出しの書き込みをサポートしていません<xref:System.IO.FileStream.SetLength%2A>、 <xref:System.IO.FileStream.Write%2A>、 <xref:System.IO.FileStream.BeginWrite%2A>、 <xref:System.IO.FileStream.WriteByte%2A> <xref:System.NotSupportedException>.</xref:System.NotSupportedException>をスロー</xref:System.IO.FileStream.WriteByte%2A>または</xref:System.IO.FileStream.BeginWrite%2A></xref:System.IO.FileStream.Write%2A></xref:System.IO.FileStream.SetLength%2A></xref:System.IO.Stream>       ストリームが閉じられたかどうか、このプロパティを返します`false`です。"
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ストリームが書き込みをサポートしている場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>ストリームが閉じているか、読み取り専用アクセスで開かれた場合。"
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "によって使用されるアンマネージ リソースを解放、 <xref href=&quot;System.IO.FileStream&quot;> </xref>し、必要に応じてマネージ リソースを解放します。"
  remarks: "このメソッドは、パブリック<xref:System.ComponentModel.Component.Dispose%2A>メソッドおよび<xref:System.Object.Finalize%2A>メソッド</xref:System.Object.Finalize%2A></xref:System.ComponentModel.Component.Dispose%2A>。 <xref:System.ComponentModel.Component.Dispose%2A>保護された Dispose メソッドを呼び出し、`disposing`パラメーターに設定`true`です。</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>Dispose を呼び出す`disposing`&quot;éý&quot;`false`です。</xref:System.Object.Finalize%2A>       ときに、`disposing`パラメーターは`true`、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放しますこの<xref:System.IO.FileStream>参照。</xref:System.IO.FileStream> 。 このメソッドを呼び出して、<xref:System.ComponentModel.Component.Dispose%2A>参照される各オブジェクトのメソッド</xref:System.ComponentModel.Component.Dispose%2A>。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マネージ コードとアンマネージ リソースを解放するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>アンマネージ リソースだけを解放します。"
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "保留中の非同期読み取り操作を完了するまで待機します。 (使用を検討して<xref:System.IO.FileStream.ReadAsync*>代わりにします「解説」セクションを参照してください。)</xref:System.IO.FileStream.ReadAsync*> 。"
  remarks: ".NET Framework 4 以前のバージョンはなどのメソッドを使用する必要がある<xref:System.IO.FileStream.BeginRead%2A>と非同期のファイル操作を実装する EndRead</xref:System.IO.FileStream.BeginRead%2A> 。 これらのメソッドでは使用できます、[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]レガシ コードをサポートするただし、新しい非同期メソッドなど<xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、 <xref:System.IO.Stream.CopyToAsync%2A>、および<xref:System.IO.FileStream.FlushAsync%2A>、ヘルプ ファイルの非同期操作をより簡単に実装する</xref:System.IO.FileStream.FlushAsync%2A></xref:System.IO.Stream.CopyToAsync%2A></xref:System.IO.FileStream.WriteAsync%2A></xref:System.IO.FileStream.ReadAsync%2A>。       EndRead は<xref:System.IO.FileStream.BeginRead%2A>。</xref:System.IO.FileStream.BeginRead%2A>呼び出しごとに正確に呼び出す必要があります。 別の読み取りを開始する前に読み取りプロセスを終了に失敗すると、デッドロックなど、望ましくない動作可能性があります。       このメソッドは<xref:System.IO.Stream.EndRead%2A>。</xref:System.IO.Stream.EndRead%2A>       EndRead は、すべて<xref:System.IAsyncResult><xref:System.IO.FileStream.BeginRead%2A>。</xref:System.IO.FileStream.BeginRead%2A></xref:System.IAsyncResult>で呼び出すことができます。 EndRead を呼び出すことがわかりますストリームから読み取られたバイト数。 EndRead は、I/O 操作が完了するまでブロックされます。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "待機する保留中の非同期要求への参照。"
    return:
      type: System.Int32
      description: "0 ~ 要求したバイト数の間のストリームから読み取られたバイト数。 ストリームが返されるだけストリームの末尾では 0、それ以外の場合は、ブロックには、少なくとも 1 バイトが読み込み可能になるまでです。"
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "この<xref:System.IAsyncResult>オブジェクトは、<xref:System.IO.FileStream.BeginRead*>このクラスで</xref:System.IO.FileStream.BeginRead*>呼び出すことにより作成されていません</xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndRead は複数回呼び出されます。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ストリームが閉じているか、内部エラーが発生しました。"
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "I/O 操作が完了するまでは、非同期の書き込み操作とブロックを終了します。 (使用を検討して<xref:System.IO.FileStream.WriteAsync*>代わりにします「解説」セクションを参照してください。)</xref:System.IO.FileStream.WriteAsync*> 。"
  remarks: ".NET Framework 4 以前のバージョンはなどのメソッドを使用する必要がある<xref:System.IO.FileStream.BeginWrite%2A>と非同期のファイル操作を実装する EndWrite</xref:System.IO.FileStream.BeginWrite%2A> 。 これらのメソッドでは使用できます、[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]レガシ コードをサポートするただし、新しい非同期メソッドなど<xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、 <xref:System.IO.Stream.CopyToAsync%2A>、および<xref:System.IO.FileStream.FlushAsync%2A>、ヘルプ ファイルの非同期操作をより簡単に実装する</xref:System.IO.FileStream.FlushAsync%2A></xref:System.IO.Stream.CopyToAsync%2A></xref:System.IO.FileStream.WriteAsync%2A></xref:System.IO.FileStream.ReadAsync%2A>。       このメソッドは<xref:System.IO.Stream.EndWrite%2A>。</xref:System.IO.Stream.EndWrite%2A>       EndWrite はすべて<xref:System.IAsyncResult><xref:System.IO.FileStream.BeginWrite%2A>。</xref:System.IO.FileStream.BeginWrite%2A></xref:System.IAsyncResult>で&1; 回だけ呼び出す必要があります。 EndWrite は、I/O 操作が完了するまでブロックされます。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "保留中の非同期 I/O 要求。"
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "この<xref:System.IAsyncResult>オブジェクトは、<xref:System.IO.Stream.BeginWrite*>このクラスで</xref:System.IO.Stream.BeginWrite*>呼び出すことにより作成されていません</xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite は複数回呼び出されます。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ストリームが閉じているか、内部エラーが発生しました。"
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "リソースが解放され、ガベージ コレクターがクリアするときに他のクリーンアップ操作が実行されることにより、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>です。"
  remarks: "ガベージ コレクター`Finalize`現在のオブジェクトが完了する準備ができています。 `Finalize`閉じる、`FileStream`です。"
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "このストリームのバッファーをクリアし、ファイルに書き込まれるバッファー内のデータ。"
  remarks: "このメソッドは<xref:System.IO.Stream.Flush%2A?displayProperty=fullName>。</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       Flush メソッドを呼び出すときに、オペレーティング システム I/O バッファーがフラッシュもされます。       明示的にフラッシュの呼び出しやオブジェクトの破棄しない限り、ストリームのエンコーダーはフラッシュされません。 設定<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>に`true`に、ストリーム バッファーからデータがフラッシュされますが、エンコーダーの状態はフラッシュされないことを意味します</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>。 これにより、次の文字のブロックを正常にエンコードできるように (一部の文字) の状態を保持するエンコーダー。 このシナリオでは、UTF8、UTF7、特定の文字をエンコードするため、エンコーダーは、隣接する文字または文字列を受信した後に影響します。       フラッシュが次の&2; つの関数を実行して、バッファーは、読み取りまたは書き込みのいずれかを使用できる、ため: - 以前バッファーに書き込まれたすべてのデータがファイルにコピーし、エンコーダー状態を除く、バッファーをクリアします。      If<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>は`true`とデータが以前の読み取りにバッファーをファイルからコピー、ファイル内の現在位置が、バッファー内の未読のバイト数だけデクリメントします</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>。 バッファーをクリアし、します。       使用して、<xref:System.IO.FileStream.Flush%28System.Boolean%29>バッファリングされたすべてのデータの中間ファイル バッファーのことを確認するときのメソッドのオーバー ロードが記述されたディスクにします</xref:System.IO.FileStream.Flush%28System.Boolean%29>。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "このストリームのバッファーをクリアし、ファイルに書き込まれるバッファー内のデータし、もすべての中間ファイル バッファーをクリアします。"
  remarks: "バッファリングされたすべてのデータの中間ファイル バッファーのことを確認する場合は、このオーバー ロードが書き込まれます使用してディスクにします。       Flush メソッドを呼び出すときに、オペレーティング システム I/O バッファーがフラッシュもされます。"
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>すべての中間ファイル バッファーをフラッシュするにはそれ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "このストリームのすべてのバッファーをクリアに非同期的に、基になるデバイスに書き込まれるバッファー内のデータ、およびキャンセル要求を監視します。"
  remarks: "FlushAsync メソッドを呼び出すときに、オペレーティング システム I/O バッファーがフラッシュもされます。       返されるタスクに含まれる完了前に、操作が取り消された場合、<xref:System.Threading.Tasks.TaskStatus>値を<xref:System.Threading.Tasks.Task.Status%2A>プロパティ</xref:System.Threading.Tasks.Task.Status%2A></xref:System.Threading.Tasks.TaskStatus>。 返されるタスクに含まれるファイルへのハンドルが破棄されている場合、<xref:System.ObjectDisposedException>での例外、<xref:System.Threading.Tasks.Task.Exception%2A>プロパティ</xref:System.Threading.Tasks.Task.Exception%2A></xref:System.ObjectDisposedException>。"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "キャンセル要求を監視するトークンです。"
    return:
      type: System.Threading.Tasks.Task
      description: "非同期のフラッシュ操作を表すタスク。"
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは破棄されました。"
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得、 <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref>現在によって記述されるファイルのアクセス制御リスト (ACL) エントリをカプセル化するオブジェクト<xref href=&quot;System.IO.FileStream&quot;></xref>オブジェクト。"
  remarks: "中に、<xref:System.IO.FileStream>使用を検討して、既存のファイルのアクセス制御リスト (ACL) エントリを取得することができますを使用するクラスと GetAccessControl<xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>ので、メソッドは使いやすくします</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName></xref:System.IO.FileStream>。       ファイルの ACL エントリを取得するのにには、GetAccessControl メソッドを使用します。       ACL は、個人やグループがある、または権限がない、指定されたファイルの特定のアクションをについて説明します。 詳細については、次を参照してください。[する方法: アクセス制御リスト エントリを追加または](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "現在の記述されるファイルのアクセス制御の設定をカプセル化するオブジェクト<xref href=&quot;System.IO.FileStream&quot;></xref>オブジェクト。"
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ファイルは閉じられます。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイルを開くときに I/O エラーが発生しました。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "ファイルが見つかりませんでした。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "この操作は現在のプラットフォームでサポートされていません。       または、呼び出し元に必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ファイルのオペレーティング システム ファイル ハンドルを取得する現在<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクトによってカプセル化します。"
  remarks: "このプロパティは、オペレーティング システムに用意されているシステムの呼び出しで使用するためのオペレーティング システム ハンドル (など`ReadFile`Windows 上)。 など、ファイル記述子を期待する C ライブラリ関数では動作しません`fread`です。       オペレーティング システム ハンドルが開かれた同期または非同期で、に応じて`FileStream`コンス トラクターが呼び出されました。 使用して、<xref:System.IO.FileStream.IsAsync%2A>プロパティをこのハンドルが非同期的に開かれたかどうかを検出します</xref:System.IO.FileStream.IsAsync%2A>。 Win32 では、つまり、重複 I/O 用、ハンドルが開かれた、異なるパラメーターを必要と`ReadFile`と`WriteFile`です。      > [!CAUTION] > 場合に、データの破損が発生する可能性があります、`FileStream`が作成されると、そのハンドルが渡される、なんらかの操作が、ハンドルのファイル ポインターを移動し、`FileStream`もう一度使用されます。 複数のスレッドは、同時に同じファイルに書き込めません安全と`FileStream`コードをバッファー処理には、行うことは想定しています。 `FileStream`スローする可能性、<xref:System.IO.IOException>場合`FileStream`他のプロセスがファイル ポインターを移動したことを検出します</xref:System.IO.IOException>。 これを回避するには、書き込みませんすべてのデータ ファイルの一部にする`FileStream`がバッファーに格納したとしたときにメソッドが呼び出された最後の場所にファイル ポインターを復元`FileStream`です。"
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "これによってカプセル化されるファイルのオペレーティング システム ファイル ハンドル<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>オブジェクト、または-1 の場合、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>が閉じられました。"
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "示す値を取得するかどうか、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>が非同期的または同期的に開かれました。"
  remarks: "`IsAsync`プロパティを検出するかどうか、`FileStream`ハンドルが開かれた非同期的に、使用するようコードを有効にすると、<xref:System.IO.FileStream.Handle%2A>プロパティ正しく</xref:System.IO.FileStream.Handle%2A>。 Win32 では、 `IsAsync` true を示し、ハンドル重複 I/O 用に開かれたために異なるパラメーターを必要とされている`ReadFile`と`WriteFile`です。       インスタンスを作成するときに、この値を指定する、<xref:System.IO.FileStream>クラスを持つコンス トラクターを使用して、 `isAsync`、 `useAsync`、または`options`パラメーター</xref:System.IO.FileStream> 。 このプロパティが`true`ストリームがファイルの操作を非同期的に実行する重複 I/O を使用します。 ただし、IsAsync プロパティは、する必要はありません`true`を呼び出して、 <xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、または<xref:System.IO.Stream.CopyToAsync%2A>メソッド</xref:System.IO.Stream.CopyToAsync%2A></xref:System.IO.FileStream.WriteAsync%2A></xref:System.IO.FileStream.ReadAsync%2A>。 IsAsync プロパティが`false`および書き込み操作を非同期の読み込みを呼び出すと、引き続き、UI スレッドはブロックされませんが、実際の I/O 操作が同期的に実行します。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>が非同期的に以外の場合、開かれた<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリームのバイトの長さを取得します。"
  remarks: "一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "バイト単位のストリームの長さを表す long 値。"
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>このストリームは<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "閉じられているファイルなど、I/O エラーが発生しました。"
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "他のプロセスからの読み取りまたは書き込み禁止、 <xref href=&quot;System.IO.FileStream&quot;></xref>です。"
  remarks: "ファイル ストリームの範囲をロックすると、ファイル ストリームの範囲にロックのプロセスの排他アクセスのスレッドが与えられます。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "ロックする範囲の先頭。 このパラメーターの値は、0 (ゼロ) 以上にする必要があります。"
    - id: length
      type: System.Int64
      description: "ロックする範囲。"
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>または<code>length</code>が負の値。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ファイルは閉じられます。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "別のプロセスが、ファイルの一部をロックしているために、プロセスは、ファイルにアクセスできません。"
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "名前を取得、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>コンス トラクターに渡されました。"
  remarks: "一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "示す文字列の名前、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得またはこのストリームの現在の位置を設定します。"
  remarks: "ストリームの長さを超えた位置にシークはサポートされています。  シークすると、ファイルの長さを超えて、ファイルのサイズが大きくなります。  Microsoft Windows NT 以降では、ファイルの末尾に追加されたデータすべてが&0; に設定します。  Microsoft Windows 98 またはそれ以前は、ファイルの末尾に追加されたデータすべてがデータは既に削除は 0 に設定されていません。 Windows 98 またはそれ以前のストリームの末尾を越える大きな値に、ストリームの位置を設定すると、例外が発生する可能性があります。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "このストリームの現在位置。"
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームはシークをサポートしていません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "位置を負の値に設定しようとしています。"
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "これをサポートしないストリームの末尾を越えたシークしようとしました。"
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリームからバイトのブロックを読み取り、特定のバッファーにデータを書き込みます。"
  remarks: "このメソッドは<xref:System.IO.Stream.Read%2A>。</xref:System.IO.Stream.Read%2A>       `offset`パラメーターはバイトのオフセット`array`(バッファーのインデックス) 読み取りを開始する位置を示す、`count`パラメーターは、このストリームから読み取られるバイトの最大数を示します。 ストリームの末尾に達した場合は、実際の数バイトを読み取り、または&0; を返されるです。 読み取り操作が成功した場合、ストリームの現在の位置は読み取られたバイト数で進められます。 例外が発生する場合は、ストリームの現在の位置は変更されません。       Read メソッドでは、ストリームの末尾に到達した場合にのみゼロを返します。 それ以外の場合、読み取り常に少なくとも&1; バイトのストリームから読み取りを返す前にします。 読み取りを呼び出すとストリームから使用可能なデータがない場合、メソッドは、少なくとも&1; バイトのデータを返すことができるまでにブロックされます。 実装は、ストリームの末尾に達していない場合でも、要求されたより少ないバイト数を返すことです。       使用して<xref:System.IO.BinaryReader>プリミティブ データ型を読み取るためです</xref:System.IO.BinaryReader>。       読み取り操作を実行するスレッドを中断しません。 アプリケーションは正常に実行するスレッドはブロック解除後に見えますが、中断は、アプリケーションのパフォーマンスと信頼性を減らすことができます。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "このメソッドが戻るときまでの値が指定したバイト配列が含まれています。`offset`と (`offset`  +  `count` - 1`)` 、現在のソースから読み取ったバイトにより置き換えられます。"
    - id: offset
      type: System.Int32
      description: "内のバイト オフセット`array`れる読み取りのバイトを配置します。"
    - id: count
      type: System.Int32
      description: "読み取るバイトの最大数。"
    return:
      type: System.Int32
      description: "バッファーに読み取られた合計バイト数。 要求したかどうかは、そのバイト数が現在使用できるか、ストリームの末尾に達する場合は&0; をバイト数よりも少ない可能性があります。"
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>または<code>count</code>が負の値。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームは読み取りをサポートしていません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O エラーが発生しました。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>および<code>count</code>で無効な範囲を記述<code>array</code>です。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "メソッドは、ストリームが閉じられた後に呼び出されました。"
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "現在のストリームからバイト シーケンスを非同期に読み取ります、読み取られたバイト数だけストリーム内の位置を進めますキャンセル要求を監視します。"
  remarks: "ReadAsync メソッドでは、メイン スレッドをブロックすることがなくリソースを消費するファイルの操作を実行することができます。 このパフォーマンスに関する考慮事項は、特に重要な[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]アプリまたは[!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)]アプリで、時間のかかるストリーム操作が UI スレッドをブロックされ、アプリが動作するいないと表示されます。 非同期メソッドと組み合わせてで使用される、`async`と`await`Visual Basic および c# のキーワードです。       使用して、 <xref:System.IO.FileStream.CanRead%2A>、現在のインスタンスが読み取りをサポートするかどうかを決定するプロパティ</xref:System.IO.FileStream.CanRead%2A>。       返されるタスクに含まれる完了前に、操作が取り消された場合、<xref:System.Threading.Tasks.TaskStatus>値を<xref:System.Threading.Tasks.Task.Status%2A>プロパティ</xref:System.Threading.Tasks.Task.Status%2A></xref:System.Threading.Tasks.TaskStatus>。 返されるタスクに含まれるファイルへのハンドルが破棄されている場合、<xref:System.ObjectDisposedException>での例外、<xref:System.Threading.Tasks.Task.Exception%2A>プロパティ</xref:System.Threading.Tasks.Task.Exception%2A></xref:System.ObjectDisposedException>。"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "データを書き込むバッファー。"
    - id: offset
      type: System.Int32
      description: "内のバイト オフセット`buffer`ストリームからデータを書き込む開始位置を示すです。"
    - id: count
      type: System.Int32
      description: "読み取るバイトの最大数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "キャンセル要求を監視するトークンです。"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "読み取り操作を表す、非同期タスク。 値、 <code> TResult </code>パラメーターには、バッファーに読み取られたバイトの合計数が含まれています。 結果の値は、現在使用できるバイト数が要求した数より小さいか、ストリームの末尾に達している場合 0 (ゼロ) であることを要求したバイト数より小さくできます。"
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>または<code>count</code>が負の値。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "合計<code> offset </code>と<code> count </code>バッファー長を超えています。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームは読み取りをサポートしていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは破棄されました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ストリームは、前の読み取り操作で使用するには現在します。"
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ファイルからバイトを読み取り、読み取り位置を&1; バイト進めます。"
  remarks: "このメソッドは<xref:System.IO.Stream.ReadByte%2A>。</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > を使用して、 <xref:System.IO.FileStream.CanRead%2A>、現在のインスタンスが読み取りをサポートするかどうかを決定するプロパティ</xref:System.IO.FileStream.CanRead%2A>。 詳細については、 <xref:System.IO.Stream.CanRead%2A>。</xref:System.IO.Stream.CanRead%2A>を参照してください。"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "キャストしたバイト、 <xref:System.Int32>、ストリームの末尾に達している場合は-1</xref:System.Int32> 。"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "現在のストリームは読み取りをサポートしていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "現在のストリームは閉じられます。"
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得、 <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref>ファイルのオペレーティング システム ファイル ハンドルを表すオブジェクトを現在<xref href=&quot;System.IO.FileStream&quot;></xref>オブジェクトによってカプセル化します。"
  remarks: "SafeFileHandle プロパティは自動的に、ストリームをフラッシュし、現在のストリームの位置を 0 に設定します。  これにより、移動するファイルまたはこのプロパティによって返される SafeFileHandle を使用して別のストリームをリセットするストリームの位置。"
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "ファイルのオペレーティング システム ファイル ハンドルを表すオブジェクトを現在<xref href=&quot;System.IO.FileStream&quot;></xref>オブジェクトによってカプセル化します。"
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "このストリームの現在の位置を指定した値に設定します。"
  remarks: "このメソッドは<xref:System.IO.Stream.Seek%2A?displayProperty=fullName>。</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > を使用して、 <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>、現在のインスタンスがシークをサポートするかどうかを決定するプロパティ</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>。 詳細については、 <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>。</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>を参照してください。       ストリームの長さを超えた位置をシークできます。 シークすると、ファイルの長さを超えて、ファイルのサイズが大きくなります。 Windows NT とそれ以降のバージョンでは、ファイルの末尾に追加されたデータは、0 に設定されます。 Windows 98 またはそれ以前のバージョンでは、ファイルの末尾に追加されたデータが設定されていないデータは既に削除は 0 にします。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "に対する相対ポイント`origin`シークの開始位置を示すです。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "参照ポイントとして先頭、末尾、または現在位置を示す`offset`、 <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>型の値を使用します。"
    return:
      type: System.Int64
      description: "ストリームの新しい位置。"
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O エラーが発生しました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームが場合など、シークをサポートしていない、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>パイプまたはコンソール出力から構成されます。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "シークがストリームの先頭の前に試行されます。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "メソッドは、ストリームが閉じられた後に呼び出されました。"
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "示すアクセス制御リスト (ACL) エントリを適用する<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>オブジェクトが現在の説明されているファイルに<xref href=&quot;System.IO.FileStream&quot;></xref>オブジェクト。"
  remarks: "中に、<xref:System.IO.FileStream>クラスと SetAccessControl 既存のファイルで使用できる、使用を検討して、<xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>メソッドが簡単に使用します</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName></xref:System.IO.FileStream>。       SetAccessControl メソッドは、継承されない ACL リストを表すファイルへのアクセス制御リスト (ACL) エントリを適用します。      > [!CAUTION] >、ACL に指定された、`fileSecurity`パラメーターは、ファイルの既存の ACL を置き換えます。 新しいユーザーのアクセス許可を追加するには、使用、<xref:System.IO.FileStream.GetAccessControl%2A>され、既存の ACL を取得して、変更、適用することを SetAccessControl を使用するメソッドが、ファイルをバックアップします</xref:System.IO.FileStream.GetAccessControl%2A>。       ACL は、個人やグループがある、または権限がない、指定されたファイルの特定のアクションをについて説明します。 詳細については、次を参照してください。[する方法: アクセス制御リスト エントリを追加または](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "現在のファイルに適用する ACL エントリを記述するオブジェクト。"
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ファイルは閉じられます。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "ファイルが見つからないか、変更します。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "現在のプロセスには、ファイルを開くアクセスはありません。"
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "このストリームの長さを指定した値に設定します。"
  remarks: "このメソッドは<xref:System.IO.Stream.SetLength%2A>。</xref:System.IO.Stream.SetLength%2A>       指定した値が、ストリームの現在の長さより小さい場合は、ストリームは切り捨てられます。 このシナリオでは、現在の位置が、新しい長さより大きい場合、現在の位置がストリームの最後のバイトまで移動します。 指定した値が、ストリームの現在の長さより大きい場合は、ストリームが展開され、現在の位置は変わりません。 ストリームが展開されている場合、古いクライアント シークレットと新しい長さの間のストリームの内容は未定義です。       ストリームは書き込みとシークの両方をサポートする必要があります`SetLength`動作をします。      > [!NOTE] > 使用、<xref:System.IO.FileStream.CanWrite%2A>プロパティを現在のインスタンスがドキュメントの作成をサポートするかどうかを確認し、<xref:System.IO.FileStream.CanSeek%2A>シークがサポートされているかどうかを決定するプロパティ</xref:System.IO.FileStream.CanSeek%2A></xref:System.IO.FileStream.CanWrite%2A>。 詳細については、「 <xref:System.IO.Stream.CanWrite%2A> <xref:System.IO.Stream.CanSeek%2A>。</xref:System.IO.Stream.CanSeek%2A></xref:System.IO.Stream.CanWrite%2A>の使用」を参照していますください。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "ストリームの新しい長さ。"
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O エラーが発生しました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームは書き込みとシークの両方をサポートしていません。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "設定しようと、 <code> value </code>パラメーターを 0 未満です。"
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "以前にロックされたファイルの全部または一部を他のプロセスによるアクセスを許可します。"
  remarks: "一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "ロックを解除する範囲の先頭。"
    - id: length
      type: System.Int64
      description: "ロックする範囲。"
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>または<code>length</code>が負の値。"
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ファイル ストリームにバイトのブロックを書き込みます。"
  remarks: "このメソッドは<xref:System.IO.Stream.Write%2A>。</xref:System.IO.Stream.Write%2A>       `offset`パラメーターはバイトのオフセット`array`(バッファーのインデックス) コピーを開始する位置を示す、`count`パラメーターは、ストリームに書き込まれるバイト数。 書き込み操作が成功した場合、ストリームの現在の位置は書き込まれたバイト数で進められます。 例外が発生する場合は、ストリームの現在の位置は変更されません。      > [!NOTE] > を使用して、 <xref:System.IO.FileStream.CanWrite%2A>、現在のインスタンスが書き込みをサポートするかどうかを決定するプロパティ</xref:System.IO.FileStream.CanWrite%2A>。 詳細については、 <xref:System.IO.Stream.CanWrite%2A>。</xref:System.IO.Stream.CanWrite%2A>を参照してください。       書き込み操作を実行するスレッドを中断しません。 アプリケーションは正常に実行するスレッドはブロック解除後に見えますが、中断は、アプリケーションのパフォーマンスと信頼性を減らすことができます。       一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "ストリームに書き込むデータを保持するバッファー。"
    - id: offset
      type: System.Int32
      description: "内の&0; から始まるバイト オフセット`array`ストリームにバイトのコピー開始位置を示すです。"
    - id: count
      type: System.Int32
      description: "書き込むバイトの最大数。"
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>および<code>count</code>で無効な範囲を記述<code>array</code>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>または<code>count</code>が負の値。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "現在のストリームのインスタンスは、書き込みをサポートしません。"
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "非同期的に現在のストリームにバイトのシーケンスを書き込み、書き込んだバイト数だけストリーム内の現在位置を進めます、キャンセル要求を監視します。"
  remarks: "WriteAsync メソッドでは、メイン スレッドをブロックすることがなくリソースを消費するファイルの操作を実行することができます。 このパフォーマンスに関する考慮事項は、特に重要な[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]アプリまたは[!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)]アプリで、時間のかかるストリーム操作が UI スレッドをブロックされ、アプリが動作するいないと表示されます。 非同期メソッドと組み合わせてで使用される、`async`と`await`Visual Basic および c# のキーワードです。       使用して、 <xref:System.IO.FileStream.CanWrite%2A>、現在のインスタンスが読み取りをサポートするかどうかを決定するプロパティ</xref:System.IO.FileStream.CanWrite%2A>。       返されるタスクに含まれる完了前に、操作が取り消された場合、<xref:System.Threading.Tasks.TaskStatus>値を<xref:System.Threading.Tasks.Task.Status%2A>プロパティ</xref:System.Threading.Tasks.Task.Status%2A></xref:System.Threading.Tasks.TaskStatus>。 返されるタスクに含まれるファイルへのハンドルが破棄されている場合、<xref:System.ObjectDisposedException>での例外、<xref:System.Threading.Tasks.Task.Exception%2A>プロパティ</xref:System.Threading.Tasks.Task.Exception%2A></xref:System.ObjectDisposedException>。"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "データを書き込むバッファー。"
    - id: offset
      type: System.Int32
      description: "内の&0; から始まるバイト オフセット`buffer`ストリームにバイトのコピー開始位置を示すです。"
    - id: count
      type: System.Int32
      description: "書き込むバイトの最大数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "キャンセル要求を監視するトークンです。"
    return:
      type: System.Threading.Tasks.Task
      description: "非同期の書き込み操作を表すタスク。"
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>または<code>count</code>が負の値。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "合計<code> offset </code>と<code> count </code>バッファー長を超えています。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームは書き込みをサポートしていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは破棄されました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ストリームは、前の書き込み操作で使用するには現在します。"
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ファイル ストリームの現在の位置にバイトを書き込みます。"
  remarks: "このメソッドは<xref:System.IO.Stream.WriteByte%2A>。</xref:System.IO.Stream.WriteByte%2A>       使用して`WriteByte`にバイトを書き込む、`FileStream`効率的にします。 ストリームが閉じられているか書き込み禁止になっての場合は、例外がスローされます。      > [!NOTE] > を使用して、 <xref:System.IO.FileStream.CanWrite%2A>、現在のインスタンスが書き込みをサポートするかどうかを決定するプロパティ</xref:System.IO.FileStream.CanWrite%2A>。 詳細については、 <xref:System.IO.Stream.CanWrite%2A>。</xref:System.IO.Stream.CanWrite%2A>を参照してください。"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "ストリームに書き込むバイト。"
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "ストリームは書き込みをサポートしていません。"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
