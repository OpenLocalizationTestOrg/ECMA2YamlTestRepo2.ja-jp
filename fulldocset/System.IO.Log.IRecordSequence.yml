### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "レコードのシーケンスへの汎用インターフェイスを提供します。"
  remarks: "IRecordSequence インターフェイスでは、レコード指向ストリームの抽象インターフェイスを提供します。 IRecordSequence インスタンスは、読み取りし、書き込みのログ レコードを使用できます。       IRecordSequence インターフェイスには、次の機能が用意されています - 追加のログ記録を使用して、<xref:System.IO.Log.IRecordSequence.Append%2A>メソッド</xref:System.IO.Log.IRecordSequence.Append%2A>。      -を使用して、追加したレコードを読み取り、<xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>。      -特殊な再開レコードを使用して、書き込み、<xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>メソッド</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>。      読み取りレコードから再開レコード、直前に書き込まれた再開レコードを使用して、<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>。      -永続的ストアを使用するレコードのフラッシュ、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A>。      レコードを追加するための領域を予約します。      のログのベースを進めることでログ空き容量。      受信<xref:System.IO.Log.IRecordSequence.TailPinned>領域を解放するログのベースを移動するイベント通知</xref:System.IO.Log.IRecordSequence.TailPinned>。       IRecordSequence インスタンスにログ レコードは表示し、各ログ レコードが一意のシーケンス番号を指定します。 シーケンス番号は、厳密に単調に増加する特定のレコード シーケンス内で。 ログ レコードから成るで IRecordSequence インスタンスに渡される、不透明なデータ、<xref:System.Collections.IList>バイトの ArraySegments の</xref:System.Collections.IList>。       IRecordSequence インターフェイスでは、ログ境界に関する情報を提供するいくつかの基本的なプロパティも公開します。      -<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>プロパティには、レコード シーケンスの最初の有効なレコードのシーケンス番号が含まれています</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>。      -<xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>プロパティには、大きくすることが保証されるシーケンス番号が含まれています追加されたレコードの最後のシーケンス番号より。</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> 。      -<xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>プロパティには、最後の書き込まれた再開領域のシーケンス番号が含まれています</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>。      -<xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>プロパティには追加、または、シーケンスから読み取り可能な最大レコード サイズが含まれています</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>。      -<xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>プロパティには、このレコード シーケンスで行われたすべての予約の合計サイズが含まれています</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>。      場合、<xref:System.IO.Log.IRecordSequence.RetryAppend%2A>プロパティに設定されている`true`、および<xref:System.IO.Log.IRecordSequence.Append%2A>シーケンスの領域がないために、操作が失敗した、レコード シーケンスはしようと空き領域、および追加操作を再試行してください</xref:System.IO.Log.IRecordSequence.Append%2A></xref:System.IO.Log.IRecordSequence.RetryAppend%2A>。"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログの基本シーケンス番号を前方移動します。"
  remarks: "使用すると、<xref:System.IO.Log.LogRecordSequence>新しい基本シーケンス番号が空としてマークするのには、次のエクステントの別のログ エクステント内に存在する必要がありますインスタンスしようとして、ログ領域を解放するためのシーケンス番号を進める、.</xref:System.IO.Log.LogRecordSequence> エクステントの部分的に解放することはサポートされていません。"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "レコード シーケンスの新しい基本シーケンス番号。"
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>正しくありません。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>ログ内でアクティブではないです。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "シーケンスの変更中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、ログ レコードを書き込みます、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>です。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、ログ レコードを追加、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>です。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、ログ レコードを追加、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>、以前のシーケンスに予約された領域を使用します。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、ログ レコードを追加、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>、以前のシーケンスに予約された領域を使用します。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、現在の最初の有効なレコードのシーケンス番号を取得<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>です。"
  remarks: "有効なシーケンス番号より大きいまたは basesequencenumber と同じ値に等しいと<xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>。</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>よりも小さい       このプロパティの値を呼び出すことにより変更することができます、<xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>または<xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>メソッド</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A></xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "有効なレコードに対応する下限のシーケンス番号、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>です。"
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、非同期開始操作を追加します。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、非同期の開始シーケンスで以前に予約された領域を使用して、操作を追加します。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、非同期の開始シーケンスで以前に予約された領域を使用して操作を追加します。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、非同期の開始シーケンスで以前に予約された領域を使用して、操作を追加します。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合に、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、以前のシーケンスに予約された領域を使用して、非同期のフラッシュ操作を開始します。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>を現在のメソッドによって返される、 <xref:System.IO.Log.IRecordSequence.EndFlush%2A>、フラッシュが完了し、リソースが適切に解放されるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndFlush%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期のフラッシュ中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndFlush%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndFlush%2A>。       このメソッドを呼び出すことにより、すべてのレコードを追加されていること、<xref:System.IO.Log.IRecordSequence>は永続的に書き込まれます</xref:System.IO.Log.IRecordSequence>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など非同期フラッシュ要求、中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.IRecordSequence.EndFlush%2A>メソッドが呼び出されます</xref:System.IO.Log.IRecordSequence.EndFlush%2A>。"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "書き込む必要のある最新レコードのシーケンス番号。 この場合<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>が正しくない、すべてのレコードを書き込む必要があります。"
    - id: callback
      type: System.AsyncCallback
      description: "フラッシュが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期フラッシュ要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期のフラッシュ操作をまだ</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "オーバーライドされた場合、派生クラスでは、非同期の予約および追加を開始操作です。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す、この非同期操作を保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、十分な空き領域を新しいレコードを格納する、または予約を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "オーバーライドされた場合、派生クラスでは、非同期の予約および追加を開始操作です。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す、この非同期操作を保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、十分な空き領域を新しいレコードを格納する、または予約を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、以前のシーケンスに予約された領域を使用して、非同期の再開領域書き込み操作を開始します。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>再開領域の書き込み操作を確保するためのメソッドが完了し、リソースを適切に解放できます</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期の再開領域の書き込み操作中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       操作が正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       場合、<xref:System.IO.Log.ReservationCollection>を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します</xref:System.IO.Log.ReservationCollection>。 メソッドが成功すると、消費され、最も小さな予約データを格納できること、および予約がコレクションから削除されます。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出されます</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>。"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "再開領域の書き込みが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期の再開領域の書き込み要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期の再開領域の書き込み操作、まだでした</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、以前のシーケンスに予約された領域を使用して、非同期の再開領域書き込み操作を開始します。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>再開領域の書き込み操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期の再開領域の書き込み操作中にエラーが発生した場合、<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       操作が正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       場合、<xref:System.IO.Log.ReservationCollection>を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します</xref:System.IO.Log.ReservationCollection>。 メソッドが成功すると、消費され、最も小さな予約データを格納できること、および予約がコレクションから削除されます。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出されます</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>。"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "再開領域の書き込みが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期の再開領域の書き込み要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期の再開領域の書き込み操作、まだでした</xref:System.IAsyncResult>。"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しいレコードを格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、新たに作成<xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>です。"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新しく作成された<xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>です。"
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、追加操作を非同期の終了。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndAppend が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.IRecordSequence.BeginAppend%2A>メソッド</xref:System.IO.Log.IRecordSequence.BeginAppend%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、非同期のフラッシュ操作を終了します。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndFlush が呼び出されたときに、I/O 要求時にディスク障害など非同期フラッシュ要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.IRecordSequence.BeginFlush%2A>メソッド</xref:System.IO.Log.IRecordSequence.BeginFlush%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、非同期の終了を予約および追加操作をします。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndReserveAndAppend が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>メソッド</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、非同期の再開領域の書き込み操作を終了します。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndWriteRestartArea が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>メソッド</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "書き込まれたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、追加したすべてのレコードが書き込まれていることを確認します。"
  remarks: "このメソッドを呼び出すことにより、すべてのレコードを追加されていること、<xref:System.IO.Log.IRecordSequence>永続的に書き込まれます</xref:System.IO.Log.IRecordSequence>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、指定されたシーケンス番号を持つレコードを含むすべての追加されたレコードが永続的に書き込まれていることを確認します。"
  remarks: "このメソッドにより、すべてのレコード シーケンス番号を呼び出すと、指定されたシーケンス番号は、永続的に書き込まれています。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "書き込む必要のある最新レコードのシーケンス番号。 この場合<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>が正しくない、すべてのレコードを書き込む必要があります。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、シーケンス番号を取得するが追加された最後のレコードより大きい。"
  remarks: "このプロパティには、大きくすることが保証されるシーケンス番号が含まれています。 最後のシーケンス番号よりも、レコードを追加します。 有効なシーケンス番号がより大きいか等しい<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>LastSequenceNumber よりも小さいです</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>。      > [!NOTE] ><xref:System.IO.Log.LogRecordSequence>インスタンスの<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>値が古くなったレコードは、ログにフラッシュされるまで</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A></xref:System.IO.Log.LogRecordSequence>を使用する場合 <xref:System.IO.Log.IRecordSequence.Flush%2A><xref:System.IO.Log.RecordAppendOptions>レコード.. のフラッシュの詳細について</xref:System.IO.Log.RecordAppendOptions></xref:System.IO.Log.IRecordSequence.Flush%2A>を参照してください。"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加された最後のレコードより大きい番号シーケンス番号します。"
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、追加または (バイト単位)、このシーケンスから読み取り可能な最大レコード サイズを取得します。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "追加または (バイト単位)、このシーケンスから読み取り可能な最大レコード サイズ。"
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、シーケンス内のレコードの列挙可能なコレクションを返します。"
  remarks: "派生クラスでオーバーライドされると、シーケンス内のレコードの列挙可能なコレクションを返します。 列挙されたレコードの順序の値によって異なります、`logRecordEnum`パラメーター。"
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "読み込みを開始する最初のレコードのシーケンス番号。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "有効な<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>内からレコードを読み取る方法 (つまり、前方または後方) を指定する値、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "シーケンス内のレコードの列挙可能なコレクション。"
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの読み取り中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、シーケンス内の再開領域の列挙可能なコレクションを返します。"
  remarks: "再開領域が下限のシーケンス番号のシーケンス番号の最大値からは、反転シーケンス番号の順に列挙されます。 最後のシーケンス番号間のシーケンス番号を持つ再開領域のみと、基本シーケンス番号が列挙されます。      > [!NOTE] > 場合を含むログ エクステント、<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>が破損した場合、このメソッド、<xref:System.IO.IOException>と、エラー メッセージ&quot;予期しない I/O 例外のため、要求を実行できませんでした</xref:System.IO.IOException></xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>。 次のエラー コードが返されました:&80070;026&quot;です。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "シーケンス内の再開領域の列挙可能なコレクション。"
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの読み取り中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、自動的に単一の予約を行い、シーケンスにレコードを追加します。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>で予約を作成するコレクションを格納します。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、十分な空き領域を新しいレコードを格納する、または予約を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、自動的に単一の予約を行い、シーケンスにレコードを追加します。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、十分な空き領域を新しいレコードを格納する、または予約を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、予約されているバイトの合計数を取得します。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "このレコード シーケンスで行われたすべての予約の合計サイズ。"
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされると、直前に書き込まれた再開領域のシーケンス番号を取得します。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 回復処理が必要な場合は、最後のチェックポイント操作からのすべてのデータの取得に再開領域を解析できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "再開領域を直前に書き込まれたのシーケンス番号。"
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得または設定を示す値かどうかを追加、ログがいっぱいの場合は、自動的に再試行します。"
  remarks: "このプロパティの値が場合`true`、および<xref:System.IO.Log.IRecordSequence.Append%2A>、シーケンス内に十分な領域がないために、呼び出しが失敗し、レコード シーケンスが領域の追加を再試行して、試みた</xref:System.IO.Log.IRecordSequence.Append%2A>。"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合追加は自動的に再試行を行う場合、ログがいっぱいです。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後にプロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "レコード シーケンスでは、末尾を前方移動する必要がありますが判断した場合に発生します。"
  remarks: "レコード シーケンスが領域を使い果たしたときに、このイベントを発生させることができます。 このイベントが発生したときに、シーケンス (つまり、基本シーケンス番号) の末尾は領域を解放する前方に移動します。"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、再開領域を書き込みます、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>です。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>。       バイト配列セグメント内のデータは、レコードとして追加するための単一のバイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、再開領域を書き込みます、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>です。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 回復処理が必要な場合は、最後のチェックポイント操作からのすべてのデータの取得に再開領域を解析できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。 使用して再開領域を読み取ることができます、<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>。       バイト配列セグメント内のデータは、レコードとして追加するための単一のバイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、再開領域を書き込みます、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>基本シーケンス番号を更新"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 回復処理が必要な場合は、最後のチェックポイント操作からのすべてのデータの取得に再開領域を解析できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。 使用して再開領域を読み取ることができます、<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、再開領域を書き込みます、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>基本シーケンス番号を更新します。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 回復処理が必要な場合は、最後のチェックポイント操作からのすべてのデータの取得に再開領域を解析できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。 使用して再開領域を読み取ることができます、<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、再開領域を書き込みます、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>予約を使用して、基本シーケンス番号を更新"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 回復処理が必要な場合は、最後のチェックポイント操作からのすべてのデータの取得に再開領域を解析できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。 使用して再開領域を読み取ることができます、<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       予約を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します。 メソッドが成功すると、消費され、最も小さな予約データを持つことができること、および予約がコレクションから削除されます。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "派生クラスでオーバーライドされるとときに、再開領域を書き込みます、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>予約を使用して、基本シーケンス番号を更新します。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 回復処理が必要な場合は、最後のチェックポイント操作からのすべてのデータの取得に再開領域を解析できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。 使用して再開領域を読み取ることができます、<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       予約を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します。 メソッドが成功すると、消費され、最も小さな予約データを持つことができること、および予約がコレクションから削除されます。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
