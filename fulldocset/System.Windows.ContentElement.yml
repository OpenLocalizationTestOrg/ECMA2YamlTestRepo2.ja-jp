### YamlMime:ManagedReference
items:
- uid: System.Windows.ContentElement
  id: ContentElement
  children:
  - System.Windows.ContentElement.#ctor
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.AllowDrop
  - System.Windows.ContentElement.AllowDropProperty
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.AreAnyTouchesCaptured
  - System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.ContentElement.AreAnyTouchesOver
  - System.Windows.ContentElement.AreAnyTouchesOverProperty
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.CaptureMouse
  - System.Windows.ContentElement.CaptureStylus
  - System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.CommandBindings
  - System.Windows.ContentElement.DragEnter
  - System.Windows.ContentElement.DragEnterEvent
  - System.Windows.ContentElement.DragLeave
  - System.Windows.ContentElement.DragLeaveEvent
  - System.Windows.ContentElement.DragOver
  - System.Windows.ContentElement.DragOverEvent
  - System.Windows.ContentElement.Drop
  - System.Windows.ContentElement.DropEvent
  - System.Windows.ContentElement.Focus
  - System.Windows.ContentElement.Focusable
  - System.Windows.ContentElement.FocusableChanged
  - System.Windows.ContentElement.FocusableProperty
  - System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.ContentElement.GetUIParentCore
  - System.Windows.ContentElement.GiveFeedback
  - System.Windows.ContentElement.GiveFeedbackEvent
  - System.Windows.ContentElement.GotFocus
  - System.Windows.ContentElement.GotFocusEvent
  - System.Windows.ContentElement.GotKeyboardFocus
  - System.Windows.ContentElement.GotKeyboardFocusEvent
  - System.Windows.ContentElement.GotMouseCapture
  - System.Windows.ContentElement.GotMouseCaptureEvent
  - System.Windows.ContentElement.GotStylusCapture
  - System.Windows.ContentElement.GotStylusCaptureEvent
  - System.Windows.ContentElement.GotTouchCapture
  - System.Windows.ContentElement.GotTouchCaptureEvent
  - System.Windows.ContentElement.HasAnimatedProperties
  - System.Windows.ContentElement.InputBindings
  - System.Windows.ContentElement.IsEnabled
  - System.Windows.ContentElement.IsEnabledChanged
  - System.Windows.ContentElement.IsEnabledCore
  - System.Windows.ContentElement.IsEnabledProperty
  - System.Windows.ContentElement.IsFocused
  - System.Windows.ContentElement.IsFocusedProperty
  - System.Windows.ContentElement.IsInputMethodEnabled
  - System.Windows.ContentElement.IsKeyboardFocused
  - System.Windows.ContentElement.IsKeyboardFocusedChanged
  - System.Windows.ContentElement.IsKeyboardFocusedProperty
  - System.Windows.ContentElement.IsKeyboardFocusWithin
  - System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  - System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  - System.Windows.ContentElement.IsMouseCaptured
  - System.Windows.ContentElement.IsMouseCapturedChanged
  - System.Windows.ContentElement.IsMouseCapturedProperty
  - System.Windows.ContentElement.IsMouseCaptureWithin
  - System.Windows.ContentElement.IsMouseCaptureWithinChanged
  - System.Windows.ContentElement.IsMouseCaptureWithinProperty
  - System.Windows.ContentElement.IsMouseDirectlyOver
  - System.Windows.ContentElement.IsMouseDirectlyOverChanged
  - System.Windows.ContentElement.IsMouseDirectlyOverProperty
  - System.Windows.ContentElement.IsMouseOver
  - System.Windows.ContentElement.IsMouseOverProperty
  - System.Windows.ContentElement.IsStylusCaptured
  - System.Windows.ContentElement.IsStylusCapturedChanged
  - System.Windows.ContentElement.IsStylusCapturedProperty
  - System.Windows.ContentElement.IsStylusCaptureWithin
  - System.Windows.ContentElement.IsStylusCaptureWithinChanged
  - System.Windows.ContentElement.IsStylusCaptureWithinProperty
  - System.Windows.ContentElement.IsStylusDirectlyOver
  - System.Windows.ContentElement.IsStylusDirectlyOverChanged
  - System.Windows.ContentElement.IsStylusDirectlyOverProperty
  - System.Windows.ContentElement.IsStylusOver
  - System.Windows.ContentElement.IsStylusOverProperty
  - System.Windows.ContentElement.KeyDown
  - System.Windows.ContentElement.KeyDownEvent
  - System.Windows.ContentElement.KeyUp
  - System.Windows.ContentElement.KeyUpEvent
  - System.Windows.ContentElement.LostFocus
  - System.Windows.ContentElement.LostFocusEvent
  - System.Windows.ContentElement.LostKeyboardFocus
  - System.Windows.ContentElement.LostKeyboardFocusEvent
  - System.Windows.ContentElement.LostMouseCapture
  - System.Windows.ContentElement.LostMouseCaptureEvent
  - System.Windows.ContentElement.LostStylusCapture
  - System.Windows.ContentElement.LostStylusCaptureEvent
  - System.Windows.ContentElement.LostTouchCapture
  - System.Windows.ContentElement.LostTouchCaptureEvent
  - System.Windows.ContentElement.MouseDown
  - System.Windows.ContentElement.MouseDownEvent
  - System.Windows.ContentElement.MouseEnter
  - System.Windows.ContentElement.MouseEnterEvent
  - System.Windows.ContentElement.MouseLeave
  - System.Windows.ContentElement.MouseLeaveEvent
  - System.Windows.ContentElement.MouseLeftButtonDown
  - System.Windows.ContentElement.MouseLeftButtonDownEvent
  - System.Windows.ContentElement.MouseLeftButtonUp
  - System.Windows.ContentElement.MouseLeftButtonUpEvent
  - System.Windows.ContentElement.MouseMove
  - System.Windows.ContentElement.MouseMoveEvent
  - System.Windows.ContentElement.MouseRightButtonDown
  - System.Windows.ContentElement.MouseRightButtonDownEvent
  - System.Windows.ContentElement.MouseRightButtonUp
  - System.Windows.ContentElement.MouseRightButtonUpEvent
  - System.Windows.ContentElement.MouseUp
  - System.Windows.ContentElement.MouseUpEvent
  - System.Windows.ContentElement.MouseWheel
  - System.Windows.ContentElement.MouseWheelEvent
  - System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.ContentElement.OnCreateAutomationPeer
  - System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.ContentElement.PreviewDragEnter
  - System.Windows.ContentElement.PreviewDragEnterEvent
  - System.Windows.ContentElement.PreviewDragLeave
  - System.Windows.ContentElement.PreviewDragLeaveEvent
  - System.Windows.ContentElement.PreviewDragOver
  - System.Windows.ContentElement.PreviewDragOverEvent
  - System.Windows.ContentElement.PreviewDrop
  - System.Windows.ContentElement.PreviewDropEvent
  - System.Windows.ContentElement.PreviewGiveFeedback
  - System.Windows.ContentElement.PreviewGiveFeedbackEvent
  - System.Windows.ContentElement.PreviewGotKeyboardFocus
  - System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewKeyDown
  - System.Windows.ContentElement.PreviewKeyDownEvent
  - System.Windows.ContentElement.PreviewKeyUp
  - System.Windows.ContentElement.PreviewKeyUpEvent
  - System.Windows.ContentElement.PreviewLostKeyboardFocus
  - System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewMouseDown
  - System.Windows.ContentElement.PreviewMouseDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonDown
  - System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonUp
  - System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseMove
  - System.Windows.ContentElement.PreviewMouseMoveEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonDown
  - System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonUp
  - System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseUp
  - System.Windows.ContentElement.PreviewMouseUpEvent
  - System.Windows.ContentElement.PreviewMouseWheel
  - System.Windows.ContentElement.PreviewMouseWheelEvent
  - System.Windows.ContentElement.PreviewQueryContinueDrag
  - System.Windows.ContentElement.PreviewQueryContinueDragEvent
  - System.Windows.ContentElement.PreviewStylusButtonDown
  - System.Windows.ContentElement.PreviewStylusButtonDownEvent
  - System.Windows.ContentElement.PreviewStylusButtonUp
  - System.Windows.ContentElement.PreviewStylusButtonUpEvent
  - System.Windows.ContentElement.PreviewStylusDown
  - System.Windows.ContentElement.PreviewStylusDownEvent
  - System.Windows.ContentElement.PreviewStylusInAirMove
  - System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  - System.Windows.ContentElement.PreviewStylusInRange
  - System.Windows.ContentElement.PreviewStylusInRangeEvent
  - System.Windows.ContentElement.PreviewStylusMove
  - System.Windows.ContentElement.PreviewStylusMoveEvent
  - System.Windows.ContentElement.PreviewStylusOutOfRange
  - System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  - System.Windows.ContentElement.PreviewStylusSystemGesture
  - System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  - System.Windows.ContentElement.PreviewStylusUp
  - System.Windows.ContentElement.PreviewStylusUpEvent
  - System.Windows.ContentElement.PreviewTextInput
  - System.Windows.ContentElement.PreviewTextInputEvent
  - System.Windows.ContentElement.PreviewTouchDown
  - System.Windows.ContentElement.PreviewTouchDownEvent
  - System.Windows.ContentElement.PreviewTouchMove
  - System.Windows.ContentElement.PreviewTouchMoveEvent
  - System.Windows.ContentElement.PreviewTouchUp
  - System.Windows.ContentElement.PreviewTouchUpEvent
  - System.Windows.ContentElement.QueryContinueDrag
  - System.Windows.ContentElement.QueryContinueDragEvent
  - System.Windows.ContentElement.QueryCursor
  - System.Windows.ContentElement.QueryCursorEvent
  - System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.ReleaseAllTouchCaptures
  - System.Windows.ContentElement.ReleaseMouseCapture
  - System.Windows.ContentElement.ReleaseStylusCapture
  - System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.ShouldSerializeCommandBindings
  - System.Windows.ContentElement.ShouldSerializeInputBindings
  - System.Windows.ContentElement.StylusButtonDown
  - System.Windows.ContentElement.StylusButtonDownEvent
  - System.Windows.ContentElement.StylusButtonUp
  - System.Windows.ContentElement.StylusButtonUpEvent
  - System.Windows.ContentElement.StylusDown
  - System.Windows.ContentElement.StylusDownEvent
  - System.Windows.ContentElement.StylusEnter
  - System.Windows.ContentElement.StylusEnterEvent
  - System.Windows.ContentElement.StylusInAirMove
  - System.Windows.ContentElement.StylusInAirMoveEvent
  - System.Windows.ContentElement.StylusInRange
  - System.Windows.ContentElement.StylusInRangeEvent
  - System.Windows.ContentElement.StylusLeave
  - System.Windows.ContentElement.StylusLeaveEvent
  - System.Windows.ContentElement.StylusMove
  - System.Windows.ContentElement.StylusMoveEvent
  - System.Windows.ContentElement.StylusOutOfRange
  - System.Windows.ContentElement.StylusOutOfRangeEvent
  - System.Windows.ContentElement.StylusSystemGesture
  - System.Windows.ContentElement.StylusSystemGestureEvent
  - System.Windows.ContentElement.StylusUp
  - System.Windows.ContentElement.StylusUpEvent
  - System.Windows.ContentElement.TextInput
  - System.Windows.ContentElement.TextInputEvent
  - System.Windows.ContentElement.TouchDown
  - System.Windows.ContentElement.TouchDownEvent
  - System.Windows.ContentElement.TouchEnter
  - System.Windows.ContentElement.TouchEnterEvent
  - System.Windows.ContentElement.TouchesCaptured
  - System.Windows.ContentElement.TouchesCapturedWithin
  - System.Windows.ContentElement.TouchesDirectlyOver
  - System.Windows.ContentElement.TouchesOver
  - System.Windows.ContentElement.TouchLeave
  - System.Windows.ContentElement.TouchLeaveEvent
  - System.Windows.ContentElement.TouchMove
  - System.Windows.ContentElement.TouchMoveEvent
  - System.Windows.ContentElement.TouchUp
  - System.Windows.ContentElement.TouchUpEvent
  langs:
  - csharp
  name: ContentElement
  nameWithType: ContentElement
  fullName: System.Windows.ContentElement
  type: Class
  summary: "コンテンツの要素に WPF コア レベルの基本クラスを提供します。 コンテンツの要素は、フロー スタイル プレゼンテーションで直感的なマークアップ指向レイアウト モデルと、意図的に単純なオブジェクト モデルを使用して設計されています。"
  remarks: "ContentElement が次の一般的なコンテンツの特性を定義します。 入力 -: キーボード、マウスをドラッグ アンド ドロップの操作、スタイラス コントロール、およびアクセラレータから基本的な入力のキャプチャをサポートするすべての派生 ContentElement クラスです。      がフォーカス置か: すべての派生 ContentElement クラスは、フォーカスを設定できる可能性があります。 (ただし、ContentElement 基底クラスの既定のフォーカス可能な状態は`false`します。 フォーカスを設定できる、ContentElement を作成する方法の詳細については、「 <xref:System.Windows.ContentElement.Focusable%2A>。)</xref:System.Windows.ContentElement.Focusable%2A>さらに、このクラスが含まれています[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]関連要素の間でフォーカスを移動するを使用することできます。      イベント: ContentElement 入力およびフォーカスに関連するイベントが含まれています状態の変更のイベントも含まれています。 多くの場合は、ContentElement イベントは、ルーティングされたイベントです。 場合によっては、ルーティングされたイベントはトンネリングとバブルの両方のルーティング方法、同じ状態または条件への応答で別々 のイベントとして発生があります。 また、ContentElement も定義[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]できます raise ルーティングされるイベントを追加したり、イベント ハンドラーを削除します。       ContentElement 多くの共通の共有[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] <xref:System.Windows.UIElement></xref:System.Windows.UIElement> 。 これらの一般的な[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]共有クラスの継承を付属していません。 しかし一般的な名前付け、同様の動作と同様の内部実装の[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]クラスごとにします。 類似性があるため ContentElement および<xref:System.Windows.UIElement>基本、要素である各クラスは、そのマークアップ オブジェクト モデルの動作にさまざまな意図を持つ各が</xref:System.Windows.UIElement>。       具体的には、<xref:System.Windows.UIElement>から降下<xref:System.Windows.Media.Visual>、フロー、折り返しが設定など、ドキュメントのシナリオに一般的な概念がより簡単にサポートされているように、ContentElement 延期レンダリングが合成のウィンドウ内の四角形の領域に ContentElement を表示するため、下位のグラフィックスをサポートを提供します</xref:System.Windows.Media.Visual></xref:System.Windows.UIElement>。 これら&2; つの関連するクラスも、一般的なインターフェイスの実装<xref:System.Windows.IInputElement>と<xref:System.Windows.Media.Animation.IAnimatable>。</xref:System.Windows.Media.Animation.IAnimatable> </xref:System.Windows.IInputElement>"
  syntax:
    content: 'public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  implements:
  - System.Windows.IInputElement
  - System.Windows.Media.Animation.IAnimatable
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.ContentElement.#ctor
  id: '#ctor'
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ContentElement()
  nameWithType: ContentElement.ContentElement()
  fullName: System.Windows.ContentElement.ContentElement()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Windows.ContentElement&quot;> </xref>クラスです。"
  syntax:
    content: public ContentElement ();
    parameters: []
  overload: System.Windows.ContentElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  id: AddHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AddHandler(RoutedEvent,Delegate)
  nameWithType: ContentElement.AddHandler(RoutedEvent,Delegate)
  fullName: System.Windows.ContentElement.AddHandler(RoutedEvent,Delegate)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "現在の要素のハンドラー コレクションにハンドラーを追加する、指定したルーティング イベントのルーティング イベント ハンドラーを追加します。"
  remarks: "例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。       通常、&quot;add&quot;アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。"
  syntax:
    content: public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "ルーティング イベントを処理するための識別子です。"
    - id: handler
      type: System.Delegate
      description: "ハンドラーの実装への参照。"
  overload: System.Windows.ContentElement.AddHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  id: AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AddHandler(RoutedEvent,Delegate,Boolean)
  nameWithType: ContentElement.AddHandler(RoutedEvent,Delegate,Boolean)
  fullName: System.Windows.ContentElement.AddHandler(RoutedEvent,Delegate,Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "現在の要素のハンドラー コレクションにハンドラーを追加する、指定したルーティング イベントのルーティング イベント ハンドラーを追加します。 指定<code> handledEventsToo </code>として<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>イベント ルート上の別の要素によって処理されるように既にマークされているルーティング イベントのために呼び出される、指定したハンドラーがします。"
  remarks: "複雑なタスクは、実用的な方法で低レベルの入力イベントを処理します。 多くのコントロールと、特定のイベントが処理される、マークされた、別のより直観的なイベントに置き換えの動作を実装します。 一般に、これを行うための設計上の意図がある場合を処理済みとして、コントロールは、プラットフォームの入力イベントをマークだけです。 特定のシナリオでこれらの設計上の意図できない可能性があります、特定の入力イベントの処理が必要です。 これらのシナリオを登録するハンドラーの`handledEventsToo`として`true`が適切です。 実行しないでこの日常的にします。 処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベントを処理ロジックが複雑になります。 ハンドラーのロジックは大きな場合は、パフォーマンスの低下を参照してください可能性があります。 ここで、検出済みの特定のコントロールは、アプリケーション ロジックで処理するイベントを処理は、開発プロセス中にある場合の処理済みのイベントのハンドラーをアタッチの使用を予約する必要があります。       クラスの処理を特定のイベントとコントロールの組み合わせの動作を回避するためのもう&1; つの方法では、そのイベントのプレビューの代替手段を使用します。 たとえば場合、<xref:System.Windows.ContentElement.MouseLeftButtonDown>処理済みとしてマークは、クラス処理によってことができますのハンドラーを追加する<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>代わりにします</xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown></xref:System.Windows.ContentElement.MouseLeftButtonDown>。       例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。       通常、&quot;add&quot;アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。"
  example:
  - "The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`. This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.  \n  \n [!code-cs[EventOvwSupport#AddHandlerHandledToo](~/add/codesnippet/csharp/EventOvwSupport/page2.xaml.cs#addhandlerhandledtoo)]\n [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/add/codesnippet/visualbasic/eventovwsupport/page2.xaml.vb#addhandlerhandledtoo)]"
  syntax:
    content: public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "ルーティング イベントを処理するための識別子です。"
    - id: handler
      type: System.Delegate
      description: "ハンドラーの実装への参照。"
    - id: handledEventsToo
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>そのイベント データで処理されるルーティング イベントがマークされている場合でも呼び出されるようにハンドラーを登録するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>ことがない既定の条件に、ハンドラーを登録するルーティング イベントは既に設定されて処理される場合に呼び出されます。       既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。       定期的にメッセージを表示しないルーティング イベントを再処理をします。 詳細については、「解説」を参照してください。"
  overload: System.Windows.ContentElement.AddHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  id: AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AddToEventRoute(EventRoute,RoutedEventArgs)
  nameWithType: ContentElement.AddToEventRoute(EventRoute,RoutedEventArgs)
  fullName: System.Windows.ContentElement.AddToEventRoute(EventRoute,RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "指定したハンドラーを追加する<xref href=&quot;System.Windows.EventRoute&quot;></xref>現在の<xref href=&quot;System.Windows.ContentElement&quot;></xref>イベント ハンドラーのコレクション。"
  remarks: "このメソッドを使用して、コンテンツ ホストの要素の (実装しているかどうかに関係なく<xref:System.Windows.IContentHost>) ホスト<xref:System.Windows.EventRoute>.</xref:System.Windows.EventRoute>をコンテンツ ホストの子要素のハンドラーを追加するために</xref:System.Windows.IContentHost>"
  syntax:
    content: public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);
    parameters:
    - id: route
      type: System.Windows.EventRoute
      description: "イベント ルート ハンドラーに追加されます。"
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "イベントのデータ ハンドラーを追加するために使用します。 このメソッドを使用して、<xref:System.Windows.RoutedEventArgs.RoutedEvent*>ハンドラーを作成する引数のプロパティ</xref:System.Windows.RoutedEventArgs.RoutedEvent*>。"
  overload: System.Windows.ContentElement.AddToEventRoute*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AllowDrop
  id: AllowDrop
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AllowDrop
  nameWithType: ContentElement.AllowDrop
  fullName: System.Windows.ContentElement.AllowDrop
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素をドラッグ アンド ドロップ操作の対象として使用できるかどうかを示す値を設定します。"
  remarks: "ドラッグ アンド ドロップ操作が既定では、無効になってし、AllowDrop に設定して意図的に有効にする必要があります`true`です。 この基本的な設定を超えるドラッグ アンド ドロップの動作は完全に特定の実装、<xref:System.Windows.ContentElement>またはその他の要素の基本クラス</xref:System.Windows.ContentElement>によって定義されていません。 たとえば、特定のコントロール<xref:System.Windows.Controls.RichTextBox>は、既定の動作はありませんが<xref:System.Windows.ContentElement>派生クラスでこのような動作がある</xref:System.Windows.ContentElement></xref:System.Windows.Controls.RichTextBox>。 ドラッグ アンド ドロップの詳細については、次を参照してください。[ドラッグ アンド ドロップの概要](~/add/includes/ajax-current-ext-md.md)です。       <xref:System.Windows.FrameworkContentElement>実装では、この依存関係プロパティのメタデータをオーバーライドします。</xref:System.Windows.FrameworkContentElement> 具体的には、<xref:System.Windows.FrameworkContentElement>このプロパティがプロパティ値の継承を使用することを指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータで).</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement> このコンテキストでプロパティ値の継承は、値を持たない他のローカル値またはスタイルを使用して割り当てる AllowDrop の子要素がある場合は、し、この値は割り当てられます (ここでものいずれか既定値、またはローカルの値、スタイル)、最も近い親要素の値、その親要素から値が割り当てられているすべての未使用の子要素をプロパティ システムによってを意味します。 つまり、ルート要素でドロップ操作を許可して、すべてに値を反映するかどうかを指定できる<xref:System.Windows.FrameworkContentElement>が具体的には割り当てられていない値の子要素`false`</xref:System.Windows.FrameworkContentElement>。      <a name=&quot;dependencyPropertyInfo_AllowDrop&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.AllowDropProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.AllowDropProperty>"
  example:
  - "The following example sets AllowDrop in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)].  \n  \n [!code-xml[ContentElementsSmorgasbord#AllowDrop](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#allowdrop)]"
  syntax:
    content: public bool AllowDrop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素をドラッグ アンド ドロップ操作のターゲットとして使用できる場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.AllowDrop*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AllowDropProperty
  id: AllowDropProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AllowDropProperty
  nameWithType: ContentElement.AllowDropProperty
  fullName: System.Windows.ContentElement.AllowDropProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.AllowDrop*>依存関係プロパティ</xref:System.Windows.ContentElement.AllowDrop*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AllowDropProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素で指定した依存関係プロパティをアニメーションを適用します。 既存のアニメーションが停止され、新しいアニメーションに置き換えられます。"
  remarks: "アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。 これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 その他のクロックに割り当てられているアニメーションを実行し続けます。"
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "アニメーション化するプロパティの識別子。"
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "コントロールして宣言するアニメーション クロック。"
  overload: System.Windows.ContentElement.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素で指定した依存関係プロパティをアニメーションを適用、対処方法を指定することはどうプロパティは既に実行中のアニメーション。"
  remarks: "アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。 これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 その他のクロックに割り当てられているアニメーションを実行し続けます。"
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "アニメーション化するプロパティです。"
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "コントロールして宣言するアニメーション クロック。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "列挙体の値です。 既定値は<xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref>、する既存のアニメーションを停止し、新しいものに置き換えます。"
  overload: System.Windows.ContentElement.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesCaptured
  id: AreAnyTouchesCaptured
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesCaptured
  nameWithType: ContentElement.AreAnyTouchesCaptured
  fullName: System.Windows.ContentElement.AreAnyTouchesCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に、少なくとも&1; つのタッチがキャプチャされるかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesCaptured { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>タッチを少なくとも&1; つがキャプチャされます。 この要素にそれ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.AreAnyTouchesCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  id: AreAnyTouchesCapturedProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesCapturedProperty
  nameWithType: ContentElement.AreAnyTouchesCapturedProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.AreAnyTouchesCaptured*>依存関係プロパティ</xref:System.Windows.ContentElement.AreAnyTouchesCaptured*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  id: AreAnyTouchesCapturedWithin
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesCapturedWithin
  nameWithType: ContentElement.AreAnyTouchesCapturedWithin
  fullName: System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素またはそのビジュアル ツリー内のすべての子要素には、少なくとも&1; つのタッチがキャプチャされるかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesCapturedWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>少なくとも&1; つにタッチがキャプチャをこの要素またはそのビジュアル ツリー内のすべての子要素それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.AreAnyTouchesCapturedWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  id: AreAnyTouchesCapturedWithinProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesCapturedWithinProperty
  nameWithType: ContentElement.AreAnyTouchesCapturedWithinProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.AreAnyTouchesCapturedWithin*>依存関係プロパティ</xref:System.Windows.ContentElement.AreAnyTouchesCapturedWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  id: AreAnyTouchesDirectlyOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesDirectlyOver
  nameWithType: ContentElement.AreAnyTouchesDirectlyOver
  fullName: System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上には、少なくとも&1; つのタッチが押されたかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesDirectlyOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素上、少なくとも&1; つのタッチが押された場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.AreAnyTouchesDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  id: AreAnyTouchesDirectlyOverProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesDirectlyOverProperty
  nameWithType: ContentElement.AreAnyTouchesDirectlyOverProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.AreAnyTouchesDirectlyOver*>依存関係プロパティ</xref:System.Windows.ContentElement.AreAnyTouchesDirectlyOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesOver
  id: AreAnyTouchesOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesOver
  nameWithType: ContentElement.AreAnyTouchesOver
  fullName: System.Windows.ContentElement.AreAnyTouchesOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも&1; つのタッチが押されたかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも&1; つのタッチが押された場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.AreAnyTouchesOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.AreAnyTouchesOverProperty
  id: AreAnyTouchesOverProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: AreAnyTouchesOverProperty
  nameWithType: ContentElement.AreAnyTouchesOverProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.AreAnyTouchesOver*>依存関係プロパティ</xref:System.Windows.ContentElement.AreAnyTouchesOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素で指定したプロパティのアニメーションを開始します。"
  remarks: "プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。       場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されている</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>。       場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 タイムラインに割り当てられているその他のアニメーションを実行し続けます。"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子として指定する、アニメーション化するプロパティです。"
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "開始するアニメーションのタイムラインになります。"
  overload: System.Windows.ContentElement.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "新機能を指定するオプションを使用して、この要素で指定したアニメーション化されたプロパティの特定のアニメーションの場合は、プロパティは既に実行中のアニメーションを開始します。"
  remarks: "プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。       場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されている</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>。       場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 タイムラインに割り当てられているその他のアニメーションを実行し続けます。"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子として指定する、アニメーション化するプロパティです。"
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "適用されるアニメーションのタイムラインになります。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "新しいアニメーションがプロパティの値が既に影響を受けている現在の (実行中) アニメーションとやり取りする方法を指定する列挙体の値です。"
  overload: System.Windows.ContentElement.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.CaptureMouse
  id: CaptureMouse
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: CaptureMouse()
  nameWithType: ContentElement.CaptureMouse()
  fullName: System.Windows.ContentElement.CaptureMouse()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にマウスのキャプチャを強制しようとしています。"
  remarks: "キャプチャするのには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`ことでを呼び出す前にします</xref:System.Windows.ContentElement.IsEnabled%2A>。       呼び出すことで返されます場合`true`、し<xref:System.Windows.ContentElement.IsMouseCaptured%2A>も`true`</xref:System.Windows.ContentElement.IsMouseCaptured%2A>。       呼び出すことで返す場合`true`、<xref:System.Windows.ContentElement.GotMouseCapture>と<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントが発生すると<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=fullName>ことでメソッドが呼び出された場合、要素としてデータを報告するイベントです</xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=fullName></xref:System.Windows.ContentElement.IsMouseCapturedChanged></xref:System.Windows.ContentElement.GotMouseCapture>。 既存のキャプチャと干渉する可能性のキャプチャを強制した場合、特にのマウスでドラッグ アンド ドロップに関連するキャプチャします。       すべての要素からマウスのキャプチャをクリアする呼び出し<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName>で、`element`として指定されたパラメーター `null`</xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName> 。"
  example:
  - "The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element. Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=fullName> method. Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>. The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>. This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.  \n  \n [!code-cs[ContentElementsSmorgasbord#IsMouseCaptured](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#ismousecaptured)]\n [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#ismousecaptured)]"
  syntax:
    content: public bool CaptureMouse ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マウスが正常にキャプチャされた場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.CaptureMouse*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.CaptureStylus
  id: CaptureStylus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: CaptureStylus()
  nameWithType: ContentElement.CaptureStylus()
  fullName: System.Windows.ContentElement.CaptureStylus()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にスタイラスのキャプチャを強制しようとしています。"
  remarks: "既定の実装を常に基になる既定のスタイラス デバイスに基づいて`true`です。 ただし、入力システムのデバイスの実装を提供する入力デバイスを拡張する場合、異なる結果を返す可能性のある代替のスタイラス デバイスの実装と、システムを作成することはできます。       要素がスタイラスをキャプチャ、ときに、スタイラスが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。       基になる静的<xref:System.Windows.Input.Stylus><xref:System.Windows.Input.Stylus.Capture%2A>。</xref:System.Windows.Input.Stylus.Capture%2A>メソッド</xref:System.Windows.Input.Stylus>を呼び出すこのメソッドを呼び出す 実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。       キャプチャするのには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`CaptureStylus を呼び出す前に戻ります</xref:System.Windows.ContentElement.IsEnabled%2A>。       CaptureStylus 返しますを呼び出している場合は`true`、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>も`true`</xref:System.Windows.ContentElement.IsStylusCaptured%2A>。"
  syntax:
    content: public bool CaptureStylus ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スタイラスが正常にキャプチャされた場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.CaptureStylus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  id: CaptureTouch(System.Windows.Input.TouchDevice)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: CaptureTouch(TouchDevice)
  nameWithType: ContentElement.CaptureTouch(TouchDevice)
  fullName: System.Windows.ContentElement.CaptureTouch(TouchDevice)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に強制的にタッチをキャプチャしようとしています。"
  remarks: "CaptureTouch が返されます`false`場合、<xref:System.Windows.Input.TouchDevice>別の要素に現在キャプチャされています</xref:System.Windows.Input.TouchDevice>。       CaptureTouch を返す場合`true`、続いて、<xref:System.Windows.ContentElement.GotTouchCapture>イベントが発生します</xref:System.Windows.ContentElement.GotTouchCapture>。       解放するにはこの要素から&1; つのタッチのキャプチャを使用して、<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>メソッドを解放する、タッチ デバイスを指定します</xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>。 解放するにはこの要素からすべての調整を使用して、<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>メソッド</xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>。"
  syntax:
    content: public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);
    parameters:
    - id: touchDevice
      type: System.Windows.Input.TouchDevice
      description: "キャプチャするデバイスです。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素に指定したタッチがキャプチャされる場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.CaptureTouch*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>touchDevice</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.ContentElement.CommandBindings
  id: CommandBindings
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: CommandBindings
  nameWithType: ContentElement.CommandBindings
  fullName: System.Windows.ContentElement.CommandBindings
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "コレクションを取得<xref href=&quot;System.Windows.Input.CommandBinding&quot;></xref>この要素に関連付けられているオブジェクト。"
  remarks: "A<xref:System.Windows.Input.CommandBinding>この要素の特定のコマンドのコマンドの処理を有効にし、コマンド、そのイベントでは、この要素にアタッチされているハンドラー間のリンケージが宣言されます</xref:System.Windows.Input.CommandBinding>。       踏み込んで言うとコレクションを設定するもう&1; つの一般的な方法を使用して<xref:System.Windows.Input.CommandManager>メソッド プログラムによって</xref:System.Windows.Input.CommandManager>。      <a name=&quot;xamlPropertyElementUsage_CommandBindings&quot;></a>## XAML プロパティ要素の使用```   <object>     <object.CommandBindings>       oneOrMoreCommandBindings  </object.CommandBindings>   </object>   ``` <a name=&quot;xamlValues_CommandBindings&quot;> </a> ## XAML 値*oneOrMoreCommandBindings*&1; つまたは複数<xref:System.Windows.Input.CommandBinding>要素</xref:System.Windows.Input.CommandBinding>。       これらの各が必要、<xref:System.Windows.Input.CommandBinding.Command%2A>既知のコマンドに属性が設定され、に対して属性が設定、<xref:System.Windows.Input.CommandBinding.CanExecute>と<xref:System.Windows.Input.CommandBinding.Executed>ハンドラーの実装</xref:System.Windows.Input.CommandBinding.Executed></xref:System.Windows.Input.CommandBinding.CanExecute></xref:System.Windows.Input.CommandBinding.Command%2A>。 詳細については、 <xref:System.Windows.Input.CommandBinding>。</xref:System.Windows.Input.CommandBinding>を参照してください。"
  syntax:
    content: public System.Windows.Input.CommandBindingCollection CommandBindings { get; }
    return:
      type: System.Windows.Input.CommandBindingCollection
      description: "すべてのコレクション<xref href=&quot;System.Windows.Input.CommandBinding&quot;></xref>オブジェクト。"
  overload: System.Windows.ContentElement.CommandBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.DragEnter
  id: DragEnter
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: DragEnter
  nameWithType: ContentElement.DragEnter
  fullName: System.Windows.ContentElement.DragEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ先と、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>DragEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>。 DragEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>。      <a name=&quot;routedEventInfo_DragEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.DragEnterEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewDragEnter>.</xref:System.Windows.ContentElement.PreviewDragEnter> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.DragEnterEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnDragEnter%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler DragEnter;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.DragEnterEvent
  id: DragEnterEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: DragEnterEvent
  nameWithType: ContentElement.DragEnterEvent
  fullName: System.Windows.ContentElement.DragEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.DragEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DragEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.DragLeave
  id: DragLeave
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: DragLeave
  nameWithType: ContentElement.DragLeave
  fullName: System.Windows.ContentElement.DragLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ元に、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>いくつか一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素としては、継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>。 いくつかのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>。      <a name=&quot;routedEventInfo_DragLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.DragLeaveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応するトンネル イベントは<xref:System.Windows.DragDrop.PreviewDragLeave>.</xref:System.Windows.DragDrop.PreviewDragLeave> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.DragLeaveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnDragLeave%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler DragLeave;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.DragLeaveEvent
  id: DragLeaveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: DragLeaveEvent
  nameWithType: ContentElement.DragLeaveEvent
  fullName: System.Windows.ContentElement.DragLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.DragLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DragLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.DragOver
  id: DragOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: DragOver
  nameWithType: ContentElement.DragOver
  fullName: System.Windows.ContentElement.DragOver
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムが潜在的なドロップ ターゲットとしてこの要素で、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントは、要素の境界のドラッグを開始した場合でも発生します。 ドラッグ アンドが境界の外側を開始し、このイベントを発生すると、内側、移動だけでなく<xref:System.Windows.ContentElement.DragEnter>とプレビュー イベントを関連</xref:System.Windows.ContentElement.DragEnter>。       このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>ドラッグされたが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>。 ドラッグされたイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>。      <a name=&quot;routedEventInfo_DragOver&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.DragOverEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.DragDrop.PreviewDragOver>.</xref:System.Windows.DragDrop.PreviewDragOver> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.DragOverEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnDragOver%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler DragOver;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.DragOverEvent
  id: DragOverEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: DragOverEvent
  nameWithType: ContentElement.DragOverEvent
  fullName: System.Windows.ContentElement.DragOverEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.DragOver&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DragOverEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.Drop
  id: Drop
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: Drop
  nameWithType: ContentElement.Drop
  fullName: System.Windows.ContentElement.Drop
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.Drop?displayProperty=fullName>添付イベントをドロップ一部であるため、このクラスのクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.Drop?displayProperty=fullName>。 ドロップのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.Drop?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.Drop?displayProperty=fullName>。      <a name=&quot;routedEventInfo_Drop&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.DropEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewDrop>.</xref:System.Windows.ContentElement.PreviewDrop> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.DropEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnDrop%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler Drop;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.DropEvent
  id: DropEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: DropEvent
  nameWithType: ContentElement.DropEvent
  fullName: System.Windows.ContentElement.DropEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.Drop&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DropEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.Focus
  id: Focus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: Focus()
  nameWithType: ContentElement.Focus()
  fullName: System.Windows.ContentElement.Focus()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスを設定しようとしています。"
  remarks: "フォーカスを<xref:System.Windows.ContentElement.Focusable%2A>と<xref:System.Windows.ContentElement.IsEnabled%2A>両方`true`</xref:System.Windows.ContentElement.IsEnabled%2A></xref:System.Windows.ContentElement.Focusable%2A>。 なおほぼすべて<xref:System.Windows.ContentElement>派生クラスは、<xref:System.Windows.ContentElement.Focusable%2A>既定</xref:System.Windows.ContentElement.Focusable%2A></xref:System.Windows.ContentElement>。       場合でも、要素は、特定のツリー内でフォーカスを設定し、有効なイベント処理が、フォーカスがある、許可しないことによって、プレビューのフォーカス イベントに応答 (複合コントロールなど) ためこのメソッドは`false`します。       一般にフォーカスが&2; つの異なる概念によって拘束されます: キーボード フォーカスと論理フォーカスが常に一致しません。 このメソッドは、論理フォーカスを設定します。 プログラムです。 具体的にキーボード フォーカスを設定する手段はありません。キーボード フォーカスは、ユーザー入力によって決定されます。 詳細については、次を参照してください。[フォーカス概要](~/add/includes/ajax-current-ext-md.md)と[入力概要](~/add/includes/ajax-current-ext-md.md)です。       フォーカスを返しますを呼び出している場合は`true`、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>と<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>も`true`</xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A></xref:System.Windows.ContentElement.IsKeyboardFocused%2A>。       場合は、関連するプロパティは、既に`true`、フォーカスを呼び出すときに、次の順序で発生するか、次のイベントの&1; つ以上: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>、 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>(ソースは、新しいフォーカス ターゲット)、 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>、 <xref:System.Windows.ContentElement.LostKeyboardFocus>、 <xref:System.Windows.ContentElement.GotKeyboardFocus>(ソースは、新しいフォーカス ターゲット).</xref:System.Windows.ContentElement.GotKeyboardFocus> </xref:System.Windows.ContentElement.LostKeyboardFocus> </xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> </xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> </xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> </xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>"
  example:
  - "The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it. Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.  \n  \n [!code-cs[ContentElementsSmorgasbord#Focus](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#focus)]\n [!code-vb[ContentElementsSmorgasbord#Focus](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#focus)]"
  syntax:
    content: public bool Focus ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素にキーボード フォーカスを設定できなかった場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>場合、このメソッドの呼び出しは、フォーカスを設定できませんでした。"
  overload: System.Windows.ContentElement.Focus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.Focusable
  id: Focusable
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: Focusable
  nameWithType: ContentElement.Focusable
  fullName: System.Windows.ContentElement.Focusable
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または要素がフォーカスを受け取るかどうかを示す値を設定します。"
  remarks: "フォーカスのある要素のみでは、キーボード入力を受け取ります。       特定の派生クラスは、派生クラスでは、既定でフォーカスを設定できるように、この依存関係プロパティのメタデータをオーバーライド可能性があります。       継承<xref:System.Windows.Documents.Hyperlink>またはその派生クラスでは、<xref:System.Windows.Documents.Hyperlink>この依存関係プロパティのメタデータをオーバーライドし、このプロパティの既定値を再定義`true`</xref:System.Windows.Documents.Hyperlink></xref:System.Windows.Documents.Hyperlink>。      <a name=&quot;dependencyPropertyInfo_Focusable&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.FocusableProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.FocusableProperty>"
  example:
  - "The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.  \n  \n [!code-xml[ContentElementsSmorgasbord#Focusable](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#focusable)]"
  syntax:
    content: public bool Focusable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素がフォーカスを設定できる場合それ以外の場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 ただし、「解説」を参照してください。"
  overload: System.Windows.ContentElement.Focusable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.FocusableChanged
  id: FocusableChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: FocusableChanged
  nameWithType: ContentElement.FocusableChanged
  fullName: System.Windows.ContentElement.FocusableChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.Focusable*>プロパティが変更された</xref:System.Windows.ContentElement.Focusable*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.FocusableProperty
  id: FocusableProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: FocusableProperty
  nameWithType: ContentElement.FocusableProperty
  fullName: System.Windows.ContentElement.FocusableProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.Focusable*>依存関係プロパティ</xref:System.Windows.ContentElement.Focusable*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusableProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  id: GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: ContentElement.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.ContentElement.GetAnimationBaseValue(DependencyProperty)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の可能性のあるすべての指定したプロパティの基本プロパティ値が、実行中の値をアニメーション化または停止済みのアニメーションを返します。"
  remarks: "プロパティのアニメーションが添付されていないかどうかは、GetAnimationBaseValue 戻り値は常に、<xref:System.Windows.DependencyObject.GetValue%2A>値を返します</xref:System.Windows.DependencyObject.GetValue%2A>。 添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始を含む値を派生し、停止の値は無視され、プロパティの値はその他のすべての可能な入力に基づいて決定されます。 詳細については、次を参照してください。[依存関係プロパティの値の優先順位](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティを確認します。"
    return:
      type: System.Object
      description: "プロパティ値の指定した依存関係プロパティにアニメーションが添付されていないかのようです。"
  overload: System.Windows.ContentElement.GetAnimationBaseValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: ContentElement.GetUIParentCore()
  fullName: System.Windows.ContentElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、返す代わりに[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]ビジュアル親が存在しない場合、この要素の親です。"
  remarks: "このメソッドの既定の仮想実装`null`です。 <xref:System.Windows.FrameworkContentElement>実際の実装を提供します。</xref:System.Windows.FrameworkContentElement>       別の親は、できるように、そのイベントは、標準の親のビジュアル ツリーをルーティングの標準的なパターンから逸脱した方法でルーティングまたはプレビューのルーティング方法で下方向に要素が代替の親構造体を作成する場所の場合、イベントのルーティングに使用されます。"
  syntax:
    content: protected virtual System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "派生クラスの実装がレポートに代替の親接続を持つ場合のオブジェクト。"
  overload: System.Windows.ContentElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GiveFeedback
  id: GiveFeedback
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GiveFeedback
  nameWithType: ContentElement.GiveFeedback
  fullName: System.Windows.ContentElement.GiveFeedback
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素は、基になるドラッグ アンド ドロップ イベントを報告したときに発生します。"
  remarks: "GiveFeedback イベントは、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソースを使用します。 視覚的なフィードバックは、ドラッグ アンド ドロップ操作が、プロセスを助けます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>GiveFeedback 一部であるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>。 GiveFeedback イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GiveFeedback&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.GiveFeedbackEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewGiveFeedback>.</xref:System.Windows.ContentElement.PreviewGiveFeedback> </xref:System.Windows.GiveFeedbackEventHandler> </xref:System.Windows.ContentElement.GiveFeedbackEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnGiveFeedback%2A>。"
  syntax:
    content: public event System.Windows.GiveFeedbackEventHandler GiveFeedback;
    return:
      type: System.Windows.GiveFeedbackEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GiveFeedbackEvent
  id: GiveFeedbackEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GiveFeedbackEvent
  nameWithType: ContentElement.GiveFeedbackEvent
  fullName: System.Windows.ContentElement.GiveFeedbackEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.GiveFeedback&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotFocus
  id: GotFocus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotFocus
  nameWithType: ContentElement.GotFocus
  fullName: System.Windows.ContentElement.GotFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素が論理フォーカスを取得したときに発生します。"
  remarks: "フォーカスがメソッド呼び出しを使用して強制的に意図的には、直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、要素では、このシナリオでは、キーボード フォーカスのままで、<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します</xref:System.Windows.ContentElement.Focus%2A>。       このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更された`false`に`true`</xref:System.Windows.ContentElement.IsFocused%2A>。       このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。      <a name=&quot;routedEventInfo_GotFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.GotFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.RoutedEventHandler>|     イベントはありません対応するトンネリング</xref:System.Windows.RoutedEventHandler></xref:System.Windows.ContentElement.GotFocusEvent>。      -オーバーライド<xref:System.Windows.ContentElement.OnGotFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnGotFocus%2A>。"
  syntax:
    content: public event System.Windows.RoutedEventHandler GotFocus;
    return:
      type: System.Windows.RoutedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotFocusEvent
  id: GotFocusEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotFocusEvent
  nameWithType: ContentElement.GotFocusEvent
  fullName: System.Windows.ContentElement.GotFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.GotFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotKeyboardFocus
  id: GotKeyboardFocus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotKeyboardFocus
  nameWithType: ContentElement.GotKeyboardFocus
  fullName: System.Windows.ContentElement.GotKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスがあるときに発生します。"
  remarks: "<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>類似するイベントです。 要素のフォーカス状態を保持するプロパティで状態の変更を追跡します。GotKeyboardFocus イベントです。</xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>       このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>GotKeyboardFocus 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素としては、継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>。 GotKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GotKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.ContentElement.GotKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotKeyboardFocusEvent
  id: GotKeyboardFocusEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotKeyboardFocusEvent
  nameWithType: ContentElement.GotKeyboardFocusEvent
  fullName: System.Windows.ContentElement.GotKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.GotKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotMouseCapture
  id: GotMouseCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotMouseCapture
  nameWithType: ContentElement.GotMouseCapture
  fullName: System.Windows.ContentElement.GotMouseCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がマウスをキャプチャしたときに発生します。"
  remarks: "要素がマウスをキャプチャは、境界外にマウス ポインターがあってもマウス入力を受け取ります。 マウスでは、ドラッグ アンド ドロップ操作中にのみがキャプチャ通常され、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされたままです。       このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>マウスのある実際の要素を決定するデータのキャプチャのイベント</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>GotMouseCapture が一部になるように、このクラスのイベントを接続されているクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>。 GotMouseCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GotMouseCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.ContentElement.GotMouseCaptureEvent>。      -オーバーライド<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnGotMouseCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler GotMouseCapture;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotMouseCaptureEvent
  id: GotMouseCaptureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotMouseCaptureEvent
  nameWithType: ContentElement.GotMouseCaptureEvent
  fullName: System.Windows.ContentElement.GotMouseCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.GotMouseCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotStylusCapture
  id: GotStylusCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotStylusCapture
  nameWithType: ContentElement.GotStylusCapture
  fullName: System.Windows.ContentElement.GotStylusCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がスタイラスをキャプチャしたときに発生します。"
  remarks: "要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャを保持します。       このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A>、イベント データを実際のキャプチャを持つ要素を決定します</xref:System.Windows.RoutedEventArgs.Source%2A>。       GotStylusCapture 一部であるように、このイベントは、添付されたイベントをこのクラスのエイリアスを作成、クラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement>。 GotStylusCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GotStylusCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.ContentElement.GotStylusCaptureEvent>。      -オーバーライド<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnGotStylusCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler GotStylusCapture;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotStylusCaptureEvent
  id: GotStylusCaptureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotStylusCaptureEvent
  nameWithType: ContentElement.GotStylusCaptureEvent
  fullName: System.Windows.ContentElement.GotStylusCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.GotStylusCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotTouchCapture
  id: GotTouchCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotTouchCapture
  nameWithType: ContentElement.GotTouchCapture
  fullName: System.Windows.ContentElement.GotTouchCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にタッチがキャプチャされるときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_GotTouchCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnGotTouchCapture%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.ContentElement.GotTouchCaptureEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> GotTouchCapture;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.GotTouchCaptureEvent
  id: GotTouchCaptureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: GotTouchCaptureEvent
  nameWithType: ContentElement.GotTouchCaptureEvent
  fullName: System.Windows.ContentElement.GotTouchCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.GotTouchCapture&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.HasAnimatedProperties
  id: HasAnimatedProperties
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: HasAnimatedProperties
  nameWithType: ContentElement.HasAnimatedProperties
  fullName: System.Windows.ContentElement.HasAnimatedProperties
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がアニメーション化されたプロパティを持つかどうかを示す値を取得します。"
  remarks: "このプロパティを返します`true`(ロック、常に実行されている) の永続的なアニメーション用または特定のタイムラインのアニメーションのいずれか。"
  syntax:
    content: public bool HasAnimatedProperties { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素があるアニメーションのプロパティのいずれかに接続されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.HasAnimatedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.InputBindings
  id: InputBindings
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: InputBindings
  nameWithType: ContentElement.InputBindings
  fullName: System.Windows.ContentElement.InputBindings
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に関連付けられている入力バインドのコレクションを取得します。"
  remarks: "入力バインディングは、コマンド入力デバイスへのバインディングをサポートします。 たとえば、<xref:System.Windows.Input.MouseBinding>を実装して入力をマウス デバイスに固有のプロパティを含むバインド</xref:System.Windows.Input.MouseBinding>。       入力バインディングのコレクションには、型に関連する両方と、インスタンスで宣言されている入力バインドが含まれています。       関連するプロパティ、 <xref:System.Windows.ContentElement.CommandBindings%2A>、コマンドのショートカット キーのコレクションを保持します</xref:System.Windows.ContentElement.CommandBindings%2A>。 これらのバインディングは、入力バインドとは異なり、コマンドの処理 - これらの既知のコマンドとクラスに固有のハンドラーに関連付けられているアクションの下の次のレベルを表しています。      <a name=&quot;xamlPropertyElementUsage_InputBindings&quot;></a>## XAML プロパティ要素の使用```   <object>     <object.InputBindings>       oneOrMoreInputBindings  </object.InputBindings>   </object>   ``` <a name=&quot;xamlValues_InputBindings&quot;> </a> ## XAML 値*oneOrMoreInputBindings*&1; つまたは複数<xref:System.Windows.Input.InputBinding>要素 (通常、<xref:System.Windows.Input.KeyBinding>または<xref:System.Windows.Input.MouseBinding>派生クラス).</xref:System.Windows.Input.MouseBinding> </xref:System.Windows.Input.KeyBinding> </xref:System.Windows.Input.InputBinding>       これらの各が予期、<xref:System.Windows.Input.InputBinding.Command%2A>と<xref:System.Windows.Input.InputBinding.Gesture%2A>属性が設定されます</xref:System.Windows.Input.InputBinding.Gesture%2A></xref:System.Windows.Input.InputBinding.Command%2A>。"
  syntax:
    content: public System.Windows.Input.InputBindingCollection InputBindings { get; }
    return:
      type: System.Windows.Input.InputBindingCollection
      description: "入力バインドのコレクション。"
  overload: System.Windows.ContentElement.InputBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsEnabled
  id: IsEnabled
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsEnabled
  nameWithType: ContentElement.IsEnabled
  fullName: System.Windows.ContentElement.IsEnabled
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または設定でこの要素が有効になっているかどうかを示す値、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]です。"
  remarks: "<a name=&quot;dependencyPropertyInfo_IsEnabled&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsEnabledProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsEnabledProperty>"
  example:
  - "The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to IsEnabled `false`.  \n  \n [!code-xml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#isenabledismouseover)]"
  syntax:
    content: public bool IsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素が有効である場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsEnabledChanged
  id: IsEnabledChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsEnabledChanged
  nameWithType: ContentElement.IsEnabledChanged
  fullName: System.Windows.ContentElement.IsEnabledChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.IsEnabled*>プロパティをこの要素を変更します</xref:System.Windows.ContentElement.IsEnabled*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsEnabledCore
  id: IsEnabledCore
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsEnabledCore
  nameWithType: ContentElement.IsEnabledCore
  fullName: System.Windows.ContentElement.IsEnabledCore
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "戻り値になる値を取得<xref:System.Windows.ContentElement.IsEnabled*>派生クラス</xref:System.Windows.ContentElement.IsEnabled*>。"
  syntax:
    content: protected virtual bool IsEnabledCore { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素が有効である場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsEnabledCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsEnabledProperty
  id: IsEnabledProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsEnabledProperty
  nameWithType: ContentElement.IsEnabledProperty
  fullName: System.Windows.ContentElement.IsEnabledProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsEnabled*>依存関係プロパティ</xref:System.Windows.ContentElement.IsEnabled*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsEnabledProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsFocused
  id: IsFocused
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsFocused
  nameWithType: ContentElement.IsFocused
  fullName: System.Windows.ContentElement.IsFocused
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に論理フォーカスがあるかどうかを決定する値を取得します。"
  remarks: "アプリケーションは、複数のフォーカス区分をなど、メニューの内容と、アプリケーションの残りの部分の間に、論理フォーカスはキーボード フォーカスと異なる可能性があります。 このシナリオでは、アプリケーションの UI の&1; つの要素にキーボード フォーカスが設定できるだけ、ただし、他のフォーカス区分の特定の要素も保持したまま論理フォーカスします。 論理フォーカスの詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)と[フォーカス概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsFocused&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsFocusedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsFocusedProperty>"
  example:
  - "The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.  \n  \n [!code-xml[ContentElementsSmorgasbord#Focusable](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#focusable)]"
  syntax:
    content: public bool IsFocused { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素が論理フォーカスがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsFocused*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsFocusedProperty
  id: IsFocusedProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsFocusedProperty
  nameWithType: ContentElement.IsFocusedProperty
  fullName: System.Windows.ContentElement.IsFocusedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsFocused*>依存関係プロパティ</xref:System.Windows.ContentElement.IsFocused*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsFocusedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsInputMethodEnabled
  id: IsInputMethodEnabled
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsInputMethodEnabled
  nameWithType: ContentElement.IsInputMethodEnabled
  fullName: System.Windows.ContentElement.IsInputMethodEnabled
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "示す値を取得、入力方式システムかどうかなど、[!INCLUDE[TLA#tla_ime](~/add/includes/ajax-current-ext-md.md)]がこの要素への入力を処理するために有効になっています。"
  remarks: "このプロパティが添付プロパティによって返される値を返します<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=fullName>現在有効な入力メソッドでは (キーボード、音声、およびその他の入力デバイス).</xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=fullName>"
  syntax:
    content: public bool IsInputMethodEnabled { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>入力方式がアクティブである場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 基になる添付プロパティの既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。 ただし、この値は実行時の入力方式の状態の影響を受けます。"
  overload: System.Windows.ContentElement.IsInputMethodEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsKeyboardFocused
  id: IsKeyboardFocused
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsKeyboardFocused
  nameWithType: ContentElement.IsKeyboardFocused
  fullName: System.Windows.ContentElement.IsKeyboardFocused
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にキーボード フォーカスがあるかどうかを示す値を取得します。"
  remarks: "<a name=&quot;dependencyPropertyInfo_IsKeyboardFocused&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>"
  syntax:
    content: public bool IsKeyboardFocused { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素がキーボード フォーカスがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsKeyboardFocused*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsKeyboardFocusedChanged
  id: IsKeyboardFocusedChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsKeyboardFocusedChanged
  nameWithType: ContentElement.IsKeyboardFocusedChanged
  fullName: System.Windows.ContentElement.IsKeyboardFocusedChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocused*>この要素でプロパティが変更された</xref:System.Windows.ContentElement.IsKeyboardFocused*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsKeyboardFocusedProperty
  id: IsKeyboardFocusedProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsKeyboardFocusedProperty
  nameWithType: ContentElement.IsKeyboardFocusedProperty
  fullName: System.Windows.ContentElement.IsKeyboardFocusedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsKeyboardFocused*>依存関係プロパティ</xref:System.Windows.ContentElement.IsKeyboardFocused*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsKeyboardFocusWithin
  id: IsKeyboardFocusWithin
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsKeyboardFocusWithin
  nameWithType: ContentElement.IsKeyboardFocusWithin
  fullName: System.Windows.ContentElement.IsKeyboardFocusWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボード フォーカスが要素または子要素内で任意の場所があるかどうかを示す値を取得します。"
  remarks: "このプロパティの値に変更が通常発生させる、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベント、派生クラスがオーバーライドしない限り、<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>を抑制する状況イベント</xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A></xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>。       このプロパティを直接設定しないが、要素にフォーカスを設定するには呼び出すことによって<xref:System.Windows.ContentElement.Focus%2A>、またはすることにより、<xref:System.Windows.ContentElement.MoveFocus%2A>要求</xref:System.Windows.ContentElement.MoveFocus%2A></xref:System.Windows.ContentElement.Focus%2A>。 このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。      <a name=&quot;dependencyPropertyInfo_IsKeyboardFocusWithin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>"
  syntax:
    content: public bool IsKeyboardFocusWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素またはその子要素にキーボード フォーカスがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsKeyboardFocusWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  id: IsKeyboardFocusWithinChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsKeyboardFocusWithinChanged
  nameWithType: ContentElement.IsKeyboardFocusWithinChanged
  fullName: System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の IsKeyboardFocusWithinChanged プロパティの値が変更されたときに発生します。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  id: IsKeyboardFocusWithinProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsKeyboardFocusWithinProperty
  nameWithType: ContentElement.IsKeyboardFocusWithinProperty
  fullName: System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsKeyboardFocusWithin*>依存関係プロパティ</xref:System.Windows.ContentElement.IsKeyboardFocusWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseCaptured
  id: IsMouseCaptured
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseCaptured
  nameWithType: ContentElement.IsMouseCaptured
  fullName: System.Windows.ContentElement.IsMouseCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にマウスがキャプチャされるかどうかを示す値を取得します。"
  remarks: "マウスのキャプチャ状態は、インプロセスのドラッグ アンド ドロップ操作に関連付けられます。      <a name=&quot;dependencyPropertyInfo_IsMouseCaptured&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsMouseCapturedProperty>"
  example:
  - "The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.  \n  \n [!code-cs[ContentElementsSmorgasbord#IsMouseCaptured](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#ismousecaptured)]\n [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#ismousecaptured)]"
  syntax:
    content: public bool IsMouseCaptured { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素がマウス キャプチャがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsMouseCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseCapturedChanged
  id: IsMouseCapturedChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseCapturedChanged
  nameWithType: ContentElement.IsMouseCapturedChanged
  fullName: System.Windows.ContentElement.IsMouseCapturedChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.IsMouseCaptured*>この要素でプロパティが変更された</xref:System.Windows.ContentElement.IsMouseCaptured*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseCapturedProperty
  id: IsMouseCapturedProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseCapturedProperty
  nameWithType: ContentElement.IsMouseCapturedProperty
  fullName: System.Windows.ContentElement.IsMouseCapturedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsMouseCaptured*>依存関係プロパティ</xref:System.Windows.ContentElement.IsMouseCaptured*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseCaptureWithin
  id: IsMouseCaptureWithin
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseCaptureWithin
  nameWithType: ContentElement.IsMouseCaptureWithin
  fullName: System.Windows.ContentElement.IsMouseCaptureWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素または要素ツリー内の子要素にマウスのキャプチャを保持するかどうかを決定する値を取得します。"
  remarks: "<a name=&quot;dependencyPropertyInfo_IsMouseCaptureWithin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>"
  syntax:
    content: public bool IsMouseCaptureWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素または格納されている要素がマウス キャプチャを持つ場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsMouseCaptureWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseCaptureWithinChanged
  id: IsMouseCaptureWithinChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseCaptureWithinChanged
  nameWithType: ContentElement.IsMouseCaptureWithinChanged
  fullName: System.Windows.ContentElement.IsMouseCaptureWithinChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、 <xref href=&quot;System.Windows.ContentElement.IsMouseCaptureWithinProperty&quot;> </xref>この要素に変更します。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseCaptureWithinProperty
  id: IsMouseCaptureWithinProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseCaptureWithinProperty
  nameWithType: ContentElement.IsMouseCaptureWithinProperty
  fullName: System.Windows.ContentElement.IsMouseCaptureWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsMouseCaptureWithin*>依存関係プロパティ</xref:System.Windows.ContentElement.IsMouseCaptureWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseDirectlyOver
  id: IsMouseDirectlyOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseDirectlyOver
  nameWithType: ContentElement.IsMouseDirectlyOver
  fullName: System.Windows.ContentElement.IsMouseDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターの位置がヒット テストの結果は、要素の構成を考慮に対応しているかどうかを示す値を取得します。"
  remarks: "異なり<xref:System.Windows.ContentElement.IsMouseOver%2A>、のみ、このプロパティは`true`literal 要素上にマウス ポインターが場合などはヒット テストの</xref:System.Windows.ContentElement.IsMouseOver%2A> 子要素の上にマウス ポインターが代わりに場合、具体的には要素のより深いテンプレートおよび複合の一部である要素をこのプロパティはなります`false`です。 コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.ContentElement.IsMouseOver%2A>代わりにします</xref:System.Windows.ContentElement.IsMouseOver%2A>。       この要素にマウスがキャプチャされるかどうかと、このプロパティは、`true`のキャプチャ時に、このプロパティを返し続けます`true`までマウスのキャプチャが失われ、その境界上にポインターがありません。      <a name=&quot;dependencyPropertyInfo_IsMouseDirectlyOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>"
  syntax:
    content: public bool IsMouseDirectlyOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マウス ポインターがヒット テストと同じ要素結果の上にある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsMouseDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseDirectlyOverChanged
  id: IsMouseDirectlyOverChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseDirectlyOverChanged
  nameWithType: ContentElement.IsMouseDirectlyOverChanged
  fullName: System.Windows.ContentElement.IsMouseDirectlyOverChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.IsMouseDirectlyOver*>この要素でプロパティが変更された</xref:System.Windows.ContentElement.IsMouseDirectlyOver*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseDirectlyOverProperty
  id: IsMouseDirectlyOverProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseDirectlyOverProperty
  nameWithType: ContentElement.IsMouseDirectlyOverProperty
  fullName: System.Windows.ContentElement.IsMouseDirectlyOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsMouseDirectlyOver*>依存関係プロパティ</xref:System.Windows.ContentElement.IsMouseDirectlyOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseOver
  id: IsMouseOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseOver
  nameWithType: ContentElement.IsMouseOver
  fullName: System.Windows.ContentElement.IsMouseOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素 (visual の子要素、またはそのコントロールの複合を含む) 上にあるかどうかを示す値を取得します。"
  remarks: "類似しています&quot;IsMouseOverChanged&quot;イベントが存在しないいくつかの類似イベントを行います。 たとえば、使用することができます<xref:System.Windows.ContentElement.MouseEnter>、 <xref:System.Windows.ContentElement.MouseMove>、 <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged></xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> </xref:System.Windows.ContentElement.MouseMove> </xref:System.Windows.ContentElement.MouseEnter> 。       この要素がマウスをキャプチャする場合に、このプロパティが残ります`true`マウスのキャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。      <a name=&quot;dependencyPropertyInfo_IsMouseOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsMouseOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsMouseOverProperty>"
  example:
  - "The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports IsMouseOver `true`.  \n  \n [!code-xml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#isenabledismouseover)]"
  syntax:
    content: public bool IsMouseOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マウス ポインターが要素またはその子要素の上にある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsMouseOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsMouseOverProperty
  id: IsMouseOverProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsMouseOverProperty
  nameWithType: ContentElement.IsMouseOverProperty
  fullName: System.Windows.ContentElement.IsMouseOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsMouseOver*>依存関係プロパティ</xref:System.Windows.ContentElement.IsMouseOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusCaptured
  id: IsStylusCaptured
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusCaptured
  nameWithType: ContentElement.IsStylusCaptured
  fullName: System.Windows.ContentElement.IsStylusCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にスタイラスがキャプチャされるかどうかを示す値を取得します。"
  remarks: "タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusCaptured&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsStylusCapturedProperty>"
  syntax:
    content: public bool IsStylusCaptured { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素がスタイラス キャプチャを持つ場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsStylusCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusCapturedChanged
  id: IsStylusCapturedChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusCapturedChanged
  nameWithType: ContentElement.IsStylusCapturedChanged
  fullName: System.Windows.ContentElement.IsStylusCapturedChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptured*>この要素でプロパティが変更された</xref:System.Windows.ContentElement.IsStylusCaptured*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusCapturedProperty
  id: IsStylusCapturedProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusCapturedProperty
  nameWithType: ContentElement.IsStylusCapturedProperty
  fullName: System.Windows.ContentElement.IsStylusCapturedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsStylusCaptured*>依存関係プロパティ</xref:System.Windows.ContentElement.IsStylusCaptured*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusCaptureWithin
  id: IsStylusCaptureWithin
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusCaptureWithin
  nameWithType: ContentElement.IsStylusCaptureWithin
  fullName: System.Windows.ContentElement.IsStylusCaptureWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "子要素、およびコントロールの合成を含め、この要素によってスタイラスのキャプチャを保持するかどうかを決定する値を取得します。"
  remarks: "タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusCaptureWithin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>"
  syntax:
    content: public bool IsStylusCaptureWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スタイラスのキャプチャがこの要素内で保持されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsStylusCaptureWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusCaptureWithinChanged
  id: IsStylusCaptureWithinChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusCaptureWithinChanged
  nameWithType: ContentElement.IsStylusCaptureWithinChanged
  fullName: System.Windows.ContentElement.IsStylusCaptureWithinChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptureWithin*>この要素でプロパティが変更された</xref:System.Windows.ContentElement.IsStylusCaptureWithin*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusCaptureWithinProperty
  id: IsStylusCaptureWithinProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusCaptureWithinProperty
  nameWithType: ContentElement.IsStylusCaptureWithinProperty
  fullName: System.Windows.ContentElement.IsStylusCaptureWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsStylusCaptureWithin*>依存関係プロパティ</xref:System.Windows.ContentElement.IsStylusCaptureWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusDirectlyOver
  id: IsStylusDirectlyOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusDirectlyOver
  nameWithType: ContentElement.IsStylusDirectlyOver
  fullName: System.Windows.ContentElement.IsStylusDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスの位置がヒット テストの結果は、要素の構成を考慮に対応しているかどうかを示す値を取得します。"
  remarks: "異なり<xref:System.Windows.ContentElement.IsStylusOver%2A>、のみ、このプロパティは`true`要素の上にスタイラスがある場合</xref:System.Windows.ContentElement.IsStylusOver%2A>。 スタイラスが代わりに子要素上、または要素は要素のより深い複合の一部である場合、このプロパティはなって`false`です。       コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.ContentElement.IsStylusOver%2A>代わりにします</xref:System.Windows.ContentElement.IsStylusOver%2A>。       この要素がスタイラス キャプチャを持つプロパティは、この場合`true`のキャプチャ時に、このプロパティの値`true`までスタイラスのキャプチャが失われ、その境界上にスタイラスがありません。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusDirectlyOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>"
  syntax:
    content: public bool IsStylusDirectlyOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>ヒット テストと同じ要素上でスタイラスがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsStylusDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusDirectlyOverChanged
  id: IsStylusDirectlyOverChanged
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusDirectlyOverChanged
  nameWithType: ContentElement.IsStylusDirectlyOverChanged
  fullName: System.Windows.ContentElement.IsStylusDirectlyOverChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.ContentElement.IsStylusDirectlyOver*>この要素でプロパティが変更された</xref:System.Windows.ContentElement.IsStylusDirectlyOver*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusDirectlyOverProperty
  id: IsStylusDirectlyOverProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusDirectlyOverProperty
  nameWithType: ContentElement.IsStylusDirectlyOverProperty
  fullName: System.Windows.ContentElement.IsStylusDirectlyOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsStylusDirectlyOver*>依存関係プロパティ</xref:System.Windows.ContentElement.IsStylusDirectlyOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusOver
  id: IsStylusOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusOver
  nameWithType: ContentElement.IsStylusOver
  fullName: System.Windows.ContentElement.IsStylusOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素 (子ビジュアル要素を含む) 上にあるかどうかを示す値を取得します。"
  remarks: "この要素にスタイラスのキャプチャがある場合は、このプロパティの値`true`スタイラスのキャプチャが失われ、ポインターがその範囲外になるまでです。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.IsStylusOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.ContentElement.IsStylusOverProperty>"
  syntax:
    content: public bool IsStylusOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スタイラスが要素またはその子要素の上にある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.IsStylusOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.IsStylusOverProperty
  id: IsStylusOverProperty
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: IsStylusOverProperty
  nameWithType: ContentElement.IsStylusOverProperty
  fullName: System.Windows.ContentElement.IsStylusOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.ContentElement.IsStylusOver*>依存関係プロパティ</xref:System.Windows.ContentElement.IsStylusOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.KeyDown
  id: KeyDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: KeyDown
  nameWithType: ContentElement.KeyDown
  fullName: System.Windows.ContentElement.KeyDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスがあるときにキーが押されると発生します。"
  remarks: "キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 KeyDown イベントは使用する低レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>KeyDown 一部であるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>。 KeyDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>。      <a name=&quot;routedEventInfo_KeyDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.KeyDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewKeyDown>.</xref:System.Windows.ContentElement.PreviewKeyDown> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.ContentElement.KeyDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnKeyDown%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler KeyDown;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.KeyDownEvent
  id: KeyDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: KeyDownEvent
  nameWithType: ContentElement.KeyDownEvent
  fullName: System.Windows.ContentElement.KeyDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.KeyDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent KeyDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.KeyUp
  id: KeyUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: KeyUp
  nameWithType: ContentElement.KeyUp
  fullName: System.Windows.ContentElement.KeyUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスがあるときにキーが離されると発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>KeyUp が一部になるように、このクラスのイベントを接続されているクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>。 KeyUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>。      <a name=&quot;routedEventInfo_KeyUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.KeyUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewKeyUp>.</xref:System.Windows.ContentElement.PreviewKeyUp> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.ContentElement.KeyUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnKeyUp%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler KeyUp;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.KeyUpEvent
  id: KeyUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: KeyUpEvent
  nameWithType: ContentElement.KeyUpEvent
  fullName: System.Windows.ContentElement.KeyUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.KeyUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent KeyUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostFocus
  id: LostFocus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostFocus
  nameWithType: ContentElement.LostFocus
  fullName: System.Windows.ContentElement.LostFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素が論理フォーカスを失ったときに発生します。"
  remarks: "フォーカスが意図的に外してメソッド呼び出しを使用しているにもかかわらず直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、キーボード フォーカスは残りますが、および要素の位置、<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します</xref:System.Windows.ContentElement.Focus%2A>。       このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更される`true`に`false`</xref:System.Windows.ContentElement.IsFocused%2A>。       このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。      <a name=&quot;routedEventInfo_LostFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.LostFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.RoutedEventHandler>|     イベントはありません対応するトンネリング</xref:System.Windows.RoutedEventHandler></xref:System.Windows.ContentElement.LostFocusEvent>。      -オーバーライド<xref:System.Windows.ContentElement.OnLostFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnLostFocus%2A>。"
  syntax:
    content: public event System.Windows.RoutedEventHandler LostFocus;
    return:
      type: System.Windows.RoutedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostFocusEvent
  id: LostFocusEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostFocusEvent
  nameWithType: ContentElement.LostFocusEvent
  fullName: System.Windows.ContentElement.LostFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.LostFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostKeyboardFocus
  id: LostKeyboardFocus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostKeyboardFocus
  nameWithType: ContentElement.LostKeyboardFocus
  fullName: System.Windows.ContentElement.LostKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスが離れたときに発生します。"
  remarks: "このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>LostKeyboardFocus が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>。 LostKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_LostKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.ContentElement.LostKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostKeyboardFocusEvent
  id: LostKeyboardFocusEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostKeyboardFocusEvent
  nameWithType: ContentElement.LostKeyboardFocusEvent
  fullName: System.Windows.ContentElement.LostKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.LostKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostMouseCapture
  id: LostMouseCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostMouseCapture
  nameWithType: ContentElement.LostMouseCapture
  fullName: System.Windows.ContentElement.LostMouseCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がマウス キャプチャを失ったときに発生します。"
  remarks: "要素がマウスをキャプチャは、境界外にポインターがあってもマウス入力を受け取ります。 マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。       このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>キャプチャを失った実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>LostMouseCapture が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>。 LostMouseCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_LostMouseCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.ContentElement.LostMouseCaptureEvent>。      -オーバーライド<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnLostMouseCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler LostMouseCapture;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostMouseCaptureEvent
  id: LostMouseCaptureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostMouseCaptureEvent
  nameWithType: ContentElement.LostMouseCaptureEvent
  fullName: System.Windows.ContentElement.LostMouseCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.LostMouseCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostStylusCapture
  id: LostStylusCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostStylusCapture
  nameWithType: ContentElement.LostStylusCapture
  fullName: System.Windows.ContentElement.LostStylusCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がスタイラス キャプチャを失ったときに発生します。"
  remarks: "要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。       このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>LostStylusCapture 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素としては、継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>。 LostStylusCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_LostStylusCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.ContentElement.LostStylusCaptureEvent>。      -オーバーライド<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnLostStylusCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler LostStylusCapture;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostStylusCaptureEvent
  id: LostStylusCaptureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostStylusCaptureEvent
  nameWithType: ContentElement.LostStylusCaptureEvent
  fullName: System.Windows.ContentElement.LostStylusCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.LostStylusCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostTouchCapture
  id: LostTouchCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostTouchCapture
  nameWithType: ContentElement.LostTouchCapture
  fullName: System.Windows.ContentElement.LostTouchCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素は、タッチのキャプチャを失ったときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_LostTouchCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnLostTouchCapture%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.ContentElement.LostTouchCaptureEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> LostTouchCapture;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.LostTouchCaptureEvent
  id: LostTouchCaptureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: LostTouchCaptureEvent
  nameWithType: ContentElement.LostTouchCaptureEvent
  fullName: System.Windows.ContentElement.LostTouchCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.LostTouchCapture&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseDown
  id: MouseDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseDown
  nameWithType: ContentElement.MouseDown
  fullName: System.Windows.ContentElement.MouseDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にポインターが、任意のマウス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>MouseDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 MouseDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。       いずれかと共に MouseDown イベントが発生した多くの場合、<xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応する</xref:System.Windows.ContentElement.MouseRightButtonDown></xref:System.Windows.ContentElement.MouseLeftButtonDown>。 <xref:System.Windows.ContentElement.MouseLeftButtonDown><xref:System.Windows.ContentElement.MouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.ContentElement.MouseRightButtonDown>。</xref:System.Windows.ContentElement.MouseLeftButtonDown> <xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>。</xref:System.Windows.ContentElement.MouseRightButtonDown></xref:System.Windows.ContentElement.MouseLeftButtonDown>の「解説」を参照してください      > [!IMPORTANT] > 少数<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、本質的なイベントに対するクラス処理マウス ボタンがあります</xref:System.Windows.Documents.Hyperlink></xref:System.Windows.ContentElement>。 イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します</xref:System.Windows.Input.Mouse>。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。       前の「重要に記載されているしマウスの左ボタンを押すをこれらのソリューションのいずれかを使用処理するクラスを持つ派生クラスでイベント MouseDown イベントいる問題を解決することができます:-ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント</xref:System.Windows.ContentElement.PreviewMouseDown>。 これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。      ハンドラーを登録コントロールの手続きを呼び出して<xref:System.Windows.ContentElement.AddHandler%2A>ハンドラーにルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンできる署名オプションを選択します</xref:System.Windows.ContentElement.AddHandler%2A>。      <a name=&quot;routedEventInfo_MouseDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewMouseDown>.</xref:System.Windows.ContentElement.PreviewMouseDown> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.ContentElement.MouseDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseDown%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseDownEvent
  id: MouseDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseDownEvent
  nameWithType: ContentElement.MouseDownEvent
  fullName: System.Windows.ContentElement.MouseDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseEnter
  id: MouseEnter
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseEnter
  nameWithType: ContentElement.MouseEnter
  fullName: System.Windows.ContentElement.MouseEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素の境界に入ったときに発生します。"
  remarks: "MouseEnter、[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       MouseEnter を追跡、マウス ポインターが要素の境界に入ったときに、このイベントより文字どおりを報告している、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`false`に`true`この要素上です</xref:System.Windows.ContentElement.IsMouseOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>MouseEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>。 MouseEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>。      <a name=&quot;routedEventInfo_MouseEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseEnterEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnMouseEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseEnter%2A></xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.ContentElement.MouseEnterEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler MouseEnter;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseEnterEvent
  id: MouseEnterEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseEnterEvent
  nameWithType: ContentElement.MouseEnterEvent
  fullName: System.Windows.ContentElement.MouseEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseLeave
  id: MouseLeave
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseLeave
  nameWithType: ContentElement.MouseLeave
  fullName: System.Windows.ContentElement.MouseLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素の境界から出たときに発生します。"
  remarks: "MouseLeave は、[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       MouseLeave を追跡、マウスが要素を離れると、このイベントよりリテラルを報告している、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`true`に`false`この要素上です</xref:System.Windows.ContentElement.IsMouseOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>MouseLeave が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>。 MouseLeave イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>。      <a name=&quot;routedEventInfo_MouseLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseLeaveEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnMouseLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseLeave%2A></xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.ContentElement.MouseLeaveEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler MouseLeave;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseLeaveEvent
  id: MouseLeaveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseLeaveEvent
  nameWithType: ContentElement.MouseLeaveEvent
  fullName: System.Windows.ContentElement.MouseLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseLeftButtonDown
  id: MouseLeftButtonDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseLeftButtonDown
  nameWithType: ContentElement.MouseLeftButtonDown
  fullName: System.Windows.ContentElement.MouseLeftButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが押されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      > [!IMPORTANT] > 少数<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、本質的なイベントに対するクラス処理マウス ボタンがあります</xref:System.Windows.Documents.Hyperlink></xref:System.Windows.ContentElement>。 イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します</xref:System.Windows.Input.Mouse>。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。       前の「重要に記載されているしマウスの左ボタンを押すをこれらのソリューションのいずれかを使用処理するクラスを持つ派生クラスでイベント MouseLeftButtonDown イベントいる問題を解決することができます:-ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント</xref:System.Windows.ContentElement.PreviewMouseDown>。 これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。      ハンドラーを登録コントロールの手続きを呼び出して<xref:System.Windows.ContentElement.AddHandler%2A>ハンドラーにルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンできる署名オプションを選択します</xref:System.Windows.ContentElement.AddHandler%2A>。      <a name=&quot;routedEventInfo_MouseLeftButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseLeftButtonDownEvent
  id: MouseLeftButtonDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseLeftButtonDownEvent
  nameWithType: ContentElement.MouseLeftButtonDownEvent
  fullName: System.Windows.ContentElement.MouseLeftButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseLeftButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseLeftButtonUp
  id: MouseLeftButtonUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseLeftButtonUp
  nameWithType: ContentElement.MouseLeftButtonUp
  fullName: System.Windows.ContentElement.MouseLeftButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが離されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_MouseLeftButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseLeftButtonUpEvent
  id: MouseLeftButtonUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseLeftButtonUpEvent
  nameWithType: ContentElement.MouseLeftButtonUpEvent
  fullName: System.Windows.ContentElement.MouseLeftButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseLeftButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseMove
  id: MouseMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseMove
  nameWithType: ContentElement.MouseMove
  fullName: System.Windows.ContentElement.MouseMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上にマウス ポインターが移動したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>MouseMove が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>。 MouseMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>。      <a name=&quot;routedEventInfo_MouseMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewMouseMove>.</xref:System.Windows.ContentElement.PreviewMouseMove> </xref:System.Windows.Input.MouseEventHandler> </xref:System.Windows.ContentElement.MouseMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseMove%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler MouseMove;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseMoveEvent
  id: MouseMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseMoveEvent
  nameWithType: ContentElement.MouseMoveEvent
  fullName: System.Windows.ContentElement.MouseMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseRightButtonDown
  id: MouseRightButtonDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseRightButtonDown
  nameWithType: ContentElement.MouseRightButtonDown
  fullName: System.Windows.ContentElement.MouseRightButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが押されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>       右ボタンをマウス イベントは、アプリケーション シナリオでネイティブの処理を頻繁にあります。 たとえば、マウスの右ボタンを押すは、コンテキスト メニューを表示する可能性があります。 参照してください[ContextMenu 概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_MouseRightButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.MouseRightButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseRightButtonDownEvent
  id: MouseRightButtonDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseRightButtonDownEvent
  nameWithType: ContentElement.MouseRightButtonDownEvent
  fullName: System.Windows.ContentElement.MouseRightButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseRightButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseRightButtonUp
  id: MouseRightButtonUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseRightButtonUp
  nameWithType: ContentElement.MouseRightButtonUp
  fullName: System.Windows.ContentElement.MouseRightButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが離されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_MouseRightButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.MouseRightButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseRightButtonUpEvent
  id: MouseRightButtonUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseRightButtonUpEvent
  nameWithType: ContentElement.MouseRightButtonUpEvent
  fullName: System.Windows.ContentElement.MouseRightButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseRightButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseUp
  id: MouseUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseUp
  nameWithType: ContentElement.MouseUp
  fullName: System.Windows.ContentElement.MouseUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上で任意のマウス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>MouseUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。 MouseUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。       いずれかと共に MouseUp イベントが発生した多くの場合、<xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのリリースに対応する</xref:System.Windows.ContentElement.MouseRightButtonUp></xref:System.Windows.ContentElement.MouseLeftButtonUp>。 <xref:System.Windows.ContentElement.MouseLeftButtonUp><xref:System.Windows.ContentElement.MouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.ContentElement.MouseRightButtonUp>。</xref:System.Windows.ContentElement.MouseLeftButtonUp> <xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>。</xref:System.Windows.ContentElement.MouseRightButtonUp></xref:System.Windows.ContentElement.MouseLeftButtonUp>の「解説」を参照してください      <a name=&quot;routedEventInfo_MouseUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewMouseUp>.</xref:System.Windows.ContentElement.PreviewMouseUp> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.ContentElement.MouseUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseUp%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseUpEvent
  id: MouseUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseUpEvent
  nameWithType: ContentElement.MouseUpEvent
  fullName: System.Windows.ContentElement.MouseUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseWheel
  id: MouseWheel
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseWheel
  nameWithType: ContentElement.MouseWheel
  fullName: System.Windows.ContentElement.MouseWheel
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にマウス ポインターが、ユーザーがマウスのホイールを回転させるときに発生します。"
  remarks: "フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。このため、対象を絞ったまたはキャプチャした要素からマウス ホイールのイベントを受信する場合、マウス ポインター実際にあります別の要素上です。       このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>マウス ホイールが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>。 マウス ホイールのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>。      <a name=&quot;routedEventInfo_MouseWheel&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.MouseWheelEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseWheelEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewMouseWheel>.</xref:System.Windows.ContentElement.PreviewMouseWheel> </xref:System.Windows.Input.MouseWheelEventHandler> </xref:System.Windows.ContentElement.MouseWheelEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnMouseWheel%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseWheelEventHandler MouseWheel;
    return:
      type: System.Windows.Input.MouseWheelEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MouseWheelEvent
  id: MouseWheelEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MouseWheelEvent
  nameWithType: ContentElement.MouseWheelEvent
  fullName: System.Windows.ContentElement.MouseWheelEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.MouseWheel&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseWheelEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: ContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.ContentElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素から別の要素にフォーカスを移動しようとしています。 ガイダンスの方向になり、この要素のビジュアルの親の組織内で解釈されますが、フォーカスを移動する方向を指定します。"
  remarks: "このメソッドの戻り値を確認してください。 戻り値の`false`コントロールの構成で定義されているタブ ストップの検査を実行し、走査の各要求はラップを要求していないかどうかに返される可能性があります。"
  syntax:
    content: public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "走査の各要求を視覚的に移動するには、既存のタブ オーダーまたはを方向を走査するモードにはいずれかを示すプロパティが含まれています。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要求された検査が実行された場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnCreateAutomationPeer
  id: OnCreateAutomationPeer
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnCreateAutomationPeer()
  nameWithType: ContentElement.OnCreateAutomationPeer()
  fullName: System.Windows.ContentElement.OnCreateAutomationPeer()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "特定のクラスを返します<xref href=&quot;System.Windows.Automation.Peers.AutomationPeer&quot;></xref>の実装、[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]インフラストラクチャです。"
  syntax:
    content: protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();
    parameters: []
    return:
      type: System.Windows.Automation.Peers.AutomationPeer
      description: "型固有<xref href=&quot;System.Windows.Automation.Peers.AutomationPeer&quot;></xref>実装します。"
  overload: System.Windows.ContentElement.OnCreateAutomationPeer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  id: OnDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnDragEnter(DragEventArgs)
  nameWithType: ContentElement.OnDragEnter(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDragEnter(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDragEnter (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnDragEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  id: OnDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnDragLeave(DragEventArgs)
  nameWithType: ContentElement.OnDragLeave(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDragLeave(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDragLeave (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnDragLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  id: OnDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnDragOver(DragEventArgs)
  nameWithType: ContentElement.OnDragOver(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDragOver(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragOver?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDragOver (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnDragOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  id: OnDrop(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnDrop(DragEventArgs)
  nameWithType: ContentElement.OnDrop(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDrop(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDrop (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnDrop*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  id: OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: ContentElement.OnGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.ContentElement.OnGiveFeedback(GiveFeedbackEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);
    parameters:
    - id: e
      type: System.Windows.GiveFeedbackEventArgs
      description: "<xref href=&quot;System.Windows.GiveFeedbackEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnGiveFeedback*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: ContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.ContentElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生させる、 <xref href=&quot;System.Windows.ContentElement.GotFocus&quot;> </xref>渡されたイベント データを使用して、ルーティングされたイベント。"
  remarks: "This method, although virtual, does have a default implementation that raises the event.  \n  \n This On* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes. The OnGotFocus implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] On\\* implementations, which only provide a convenient way to add class handling for that event."
  syntax:
    content: protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "A <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納します。 このイベント データの識別子を含める必要があります、 <xref href=&quot;System.Windows.ContentElement.GotFocus&quot;> </xref>イベント。"
  overload: System.Windows.ContentElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnGotKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  id: OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnGotMouseCapture(MouseEventArgs)
  nameWithType: ContentElement.OnGotMouseCapture(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnGotMouseCapture(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnGotMouseCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  id: OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnGotStylusCapture(StylusEventArgs)
  nameWithType: ContentElement.OnGotStylusCapture(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnGotStylusCapture(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnGotStylusCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  id: OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnGotTouchCapture(TouchEventArgs)
  nameWithType: ContentElement.OnGotTouchCapture(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnGotTouchCapture(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.ContentElement.GotTouchCapture&quot;> </xref>タッチがこの要素にキャプチャされるときに発生するイベントをルーティングします。"
  remarks: "OnGotTouchCapture メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnGotTouchCapture、<xref:System.Windows.ContentElement.GotTouchCapture>イベント</xref:System.Windows.ContentElement.GotTouchCapture>。 必ずメソッドを呼び出して、基底クラスの OnGotTouchCapture 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnGotTouchCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.IsKeyboardFocusedChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>依存関係プロパティの変更</xref:System.Windows.ContentElement.IsKeyboardFocused%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>。 注意して、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>イベントは、ルーティングされたイベントではありません</xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsKeyboardFocusedChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "直前に呼び出される、 <xref href=&quot;System.Windows.ContentElement.IsKeyboardFocusWithinChanged&quot;> </xref>イベントは、この要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>依存関係プロパティの値が変更します</xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>。 注意して、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベントは、ルーティングされたイベントではありません</xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "A <xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.IsMouseCapturedChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseCaptured%2A>依存関係プロパティの値が変更します</xref:System.Windows.ContentElement.IsMouseCaptured%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.ContentElement.IsMouseCapturedChanged>。 注意して、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントは、ルーティングされたイベントではありません</xref:System.Windows.ContentElement.IsMouseCapturedChanged>。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsMouseCapturedChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.IsMouseCaptureWithinChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  syntax:
    content: protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "A <xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsMouseCaptureWithinChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.IsMouseDirectlyOverChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>依存関係プロパティの値が変更します</xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>。 注意して、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>イベントは、ルーティングされたイベントではありません</xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsMouseDirectlyOverChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.IsStylusCapturedChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>依存関係プロパティの値が変更します</xref:System.Windows.ContentElement.IsStylusCaptured%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsStylusCapturedChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.ContentElement.IsStylusCapturedChanged>。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "A <xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsStylusCapturedChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.IsStylusCaptureWithinChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>依存関係プロパティの値が変更します</xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsStylusCaptureWithinChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.IsStylusDirectlyOverChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>依存関係プロパティの値が変更します</xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnIsStylusDirectlyOverChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  id: OnKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnKeyDown(KeyEventArgs)
  nameWithType: ContentElement.OnKeyDown(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnKeyDown(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Keystrokes are handled by a dedicated input manager. Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke. If these input system features mark the event as handled, then OnKeyDown is not invoked.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnKeyDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  id: OnKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnKeyUp(KeyEventArgs)
  nameWithType: ContentElement.OnKeyUp(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnKeyUp(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Keystrokes are handled by a dedicated input manager. Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke. If these input system features mark the event as handled, then OnKeyUp is not invoked.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnKeyUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  id: OnLostFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnLostFocus(RoutedEventArgs)
  nameWithType: ContentElement.OnLostFocus(RoutedEventArgs)
  fullName: System.Windows.ContentElement.OnLostFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生させる、 <xref href=&quot;System.Windows.ContentElement.LostFocus&quot;> </xref>提供されているイベント データを使用して、ルーティングされたイベント。"
  remarks: "This method, although virtual, does have a default implementation that raises the event.  \n  \n This On* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes. This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] On\\* implementations, which only provide a convenient way to add class handling for that event."
  syntax:
    content: protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "A <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納します。 このイベント データの識別子を含める必要があります、 <xref href=&quot;System.Windows.ContentElement.LostFocus&quot;> </xref>イベント。"
  overload: System.Windows.ContentElement.OnLostFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnLostKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  id: OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnLostMouseCapture(MouseEventArgs)
  nameWithType: ContentElement.OnLostMouseCapture(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnLostMouseCapture(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnLostMouseCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  id: OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnLostStylusCapture(StylusEventArgs)
  nameWithType: ContentElement.OnLostStylusCapture(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnLostStylusCapture(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnLostStylusCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  id: OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnLostTouchCapture(TouchEventArgs)
  nameWithType: ContentElement.OnLostTouchCapture(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnLostTouchCapture(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.ContentElement.LostTouchCapture&quot;> </xref>ルーティング イベントにこの要素は、タッチのキャプチャを失ったときに発生します。"
  remarks: "OnLostTouchCapture メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnLostTouchCapture、<xref:System.Windows.ContentElement.LostTouchCapture>イベント</xref:System.Windows.ContentElement.LostTouchCapture>。 必ずメソッドを呼び出して、基底クラスの OnLostTouchCapture 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnLostTouchCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> event as handled, OnMouseDown is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>. Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnMouseDown, you are implying that your class handling accounted for all possible mouse button down actions. This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 このイベント データは、押されたマウス ボタンおよび処理済みの状態に関する詳細を報告します。"
  overload: System.Windows.ContentElement.OnMouseDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  id: OnMouseEnter(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseEnter(MouseEventArgs)
  nameWithType: ContentElement.OnMouseEnter(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnMouseEnter(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。 標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnMouseEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  id: OnMouseLeave(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseLeave(MouseEventArgs)
  nameWithType: ContentElement.OnMouseLeave(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnMouseLeave(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。 標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnMouseLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.MouseLeftButtonDown&quot;></xref>ルーティング イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.MouseLeftButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.ContentElement.MouseLeftButtonDown>。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.MouseLeftButtonDown>。</xref:System.Windows.ContentElement.MouseLeftButtonDown>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.MouseLeftButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnMouseLeftButtonDown をオーバーライドすることで</xref:System.Windows.ContentElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnMouseLeftButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 派生するなど、<xref:System.Windows.Controls.Button>基本実装を呼び出さずに派生クラスでオーバーライドして OnMouseLeftButtonDown ですただし、これをオーバーライドを無効にし、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</xref:System.Windows.Controls.Primitives.ButtonBase.Click> </xref:System.Windows.Controls.Button> 。"
  syntax:
    content: protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが押されたことを報告します。"
  overload: System.Windows.ContentElement.OnMouseLeftButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.MouseLeftButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.MouseLeftButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.ContentElement.MouseLeftButtonUp>。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.MouseLeftButtonUp>。</xref:System.Windows.ContentElement.MouseLeftButtonUp>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.MouseLeftButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnMouseLeftButtonUp をオーバーライドすることで</xref:System.Windows.ContentElement>。"
  syntax:
    content: protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが離されたことを報告します。"
  overload: System.Windows.ContentElement.OnMouseLeftButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  id: OnMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseMove(MouseEventArgs)
  nameWithType: ContentElement.OnMouseMove(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnMouseMove(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnMouseMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseRightButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.MouseRightButtonDown&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.MouseRightButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.ContentElement.MouseRightButtonDown>。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.MouseRightButtonDown>。</xref:System.Windows.ContentElement.MouseRightButtonDown>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.MouseRightButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnMouseRightButtonDown をオーバーライドすることで</xref:System.Windows.ContentElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnMouseRightButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 たとえばから派生できます<xref:System.Windows.Controls.Control>呼び出しベースせず派生クラスでオーバーライドして OnMouseRightButtonDown ですただし、このオーバーライドが含まれる、コントロール上のコンテキスト メニュー サービスを無効にし、の、<xref:System.Windows.Controls.Control>既定の動作。</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Control> 。"
  syntax:
    content: protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが押されたことを報告します。"
  overload: System.Windows.ContentElement.OnMouseRightButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseRightButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.MouseRightButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.MouseRightButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.ContentElement.MouseRightButtonUp>。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.MouseRightButtonUp>。</xref:System.Windows.ContentElement.MouseRightButtonUp>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.MouseRightButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnMouseRightButtonUp をオーバーライドすることで</xref:System.Windows.ContentElement>。"
  syntax:
    content: protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが離されたことを報告します。"
  overload: System.Windows.ContentElement.OnMouseRightButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName&gt;ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> event as handled, OnMouseUp is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>. Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnMouseUp, you are implying that your class handling accounted for all possible mouse button up actions. This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウス ボタンが離されたことを報告します。"
  overload: System.Windows.ContentElement.OnMouseUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  id: OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnMouseWheel(MouseWheelEventArgs)
  nameWithType: ContentElement.OnMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.ContentElement.OnMouseWheel(MouseWheelEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseWheelEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseWheelEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnMouseWheel*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  id: OnPreviewDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewDragEnter(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDragEnter(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDragEnter(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewDragEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  id: OnPreviewDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewDragLeave(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDragLeave(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDragLeave(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewDragLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  id: OnPreviewDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewDragOver(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDragOver(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDragOver(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewDragOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  id: OnPreviewDrop(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewDrop(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDrop(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDrop(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewDrop*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  id: OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: ContentElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);
    parameters:
    - id: e
      type: System.Windows.GiveFeedbackEventArgs
      description: "<xref href=&quot;System.Windows.GiveFeedbackEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewGiveFeedback*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewGotKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  id: OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewKeyDown(KeyEventArgs)
  nameWithType: ContentElement.OnPreviewKeyDown(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewKeyDown(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewKeyDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  id: OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewKeyUp(KeyEventArgs)
  nameWithType: ContentElement.OnPreviewKeyUp(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewKeyUp(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewKeyUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewLostKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName&gt;添付ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> event as handled, OnPreviewMouseDown is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>. Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnPreviewMouseDown, you are implying that your class handling accounted for all possible mouse button down actions. This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、1 つ以上のマウス ボタンが押されたことを報告します。"
  overload: System.Windows.ContentElement.OnPreviewMouseDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.PreviewMouseLeftButtonDown&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。</xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnPreviewMouseLeftButtonDown をオーバーライドすることで</xref:System.Windows.ContentElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnPreviewMouseLeftButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 派生するなど、<xref:System.Windows.Controls.Button>基本実装を呼び出さずに派生クラスでオーバーライドして OnPreviewMouseLeftButtonDown ですただし、これをオーバーライドを無効にし、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</xref:System.Windows.Controls.Primitives.ButtonBase.Click> </xref:System.Windows.Controls.Button> 。"
  syntax:
    content: protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが押されたことを報告します。"
  overload: System.Windows.ContentElement.OnPreviewMouseLeftButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.PreviewMouseLeftButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。</xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnPreviewMouseLeftButtonUp をオーバーライドすることで</xref:System.Windows.ContentElement>。"
  syntax:
    content: protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが離されたことを報告します。"
  overload: System.Windows.ContentElement.OnPreviewMouseLeftButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  id: OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseMove(MouseEventArgs)
  nameWithType: ContentElement.OnPreviewMouseMove(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseMove(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewMouseMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.PreviewMouseRightButtonDown&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.MouseRightButtonDown>。</xref:System.Windows.ContentElement.MouseRightButtonDown>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnPreviewMouseRightButtonDown をオーバーライドすることで</xref:System.Windows.ContentElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnPreviewMouseRightButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 たとえばから派生できます<xref:System.Windows.Controls.Control>呼び出しベースせず派生クラスでオーバーライドして OnPreviewMouseRightButtonDown ですただし、このオーバーライドが含まれる、コントロール上のコンテキスト メニュー サービスを無効にし、の、<xref:System.Windows.Controls.Control>既定の動作。</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Control> 。"
  syntax:
    content: protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが押されたことを報告します。"
  overload: System.Windows.ContentElement.OnPreviewMouseRightButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.ContentElement.PreviewMouseRightButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.ContentElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>を生成する処理と同じ</xref:System.Windows.ContentElement>には</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName></xref:System.Windows.ContentElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>OnPreviewMouseRightButtonUp をオーバーライドすることで</xref:System.Windows.ContentElement>。"
  syntax:
    content: protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが離されたことを報告します。"
  overload: System.Windows.ContentElement.OnPreviewMouseRightButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> event as handled, OnPreviewMouseUp is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>. Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnPreviewMouseUp, you are implying that your class handling accounted for all possible mouse button up actions. This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、1 つ以上のマウス ボタンが離されたことを報告します。"
  overload: System.Windows.ContentElement.OnPreviewMouseUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  id: OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewMouseWheel(MouseWheelEventArgs)
  nameWithType: ContentElement.OnPreviewMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseWheel(MouseWheelEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseWheelEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseWheelEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewMouseWheel*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  id: OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: ContentElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.QueryContinueDragEventArgs
      description: "<xref href=&quot;System.Windows.QueryContinueDragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewQueryContinueDrag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  id: OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusButtonDown(StylusButtonEventArgs)
  nameWithType: ContentElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  id: OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusButtonUp(StylusButtonEventArgs)
  nameWithType: ContentElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  id: OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusDown(StylusDownEventArgs)
  nameWithType: ContentElement.OnPreviewStylusDown(StylusDownEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusDown(StylusDownEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusDownEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusDownEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusInAirMove(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusInAirMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusInAirMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusInRange(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusInRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusInRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusInRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusMove(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusOutOfRange(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusOutOfRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusOutOfRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  id: OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: ContentElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusSystemGestureEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusSystemGestureEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusSystemGesture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewStylusUp(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusUp(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusUp(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewStylusUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  id: OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewTextInput(TextCompositionEventArgs)
  nameWithType: ContentElement.OnPreviewTextInput(TextCompositionEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTextInput(TextCompositionEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TextCompositionEventArgs
      description: "<xref href=&quot;System.Windows.Input.TextCompositionEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewTextInput*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  id: OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewTouchDown(TouchEventArgs)
  nameWithType: ContentElement.OnPreviewTouchDown(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTouchDown(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.ContentElement.PreviewTouchDown&quot;> </xref>タッチは、この要素を押したときに発生するイベントをルーティングします。"
  remarks: "OnPreviewTouchDown メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnPreviewTouchDown、<xref:System.Windows.ContentElement.PreviewTouchDown>イベント</xref:System.Windows.ContentElement.PreviewTouchDown>。 必ずメソッドを呼び出して、基底クラスの OnPreviewTouchDown 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewTouchDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  id: OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewTouchMove(TouchEventArgs)
  nameWithType: ContentElement.OnPreviewTouchMove(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTouchMove(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.ContentElement.PreviewTouchMove&quot;> </xref>タッチは、この要素の中に内部動かしたときに発生するイベントをルーティングします。"
  remarks: "OnPreviewTouchMove メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnPreviewTouchMove、<xref:System.Windows.ContentElement.PreviewTouchMove>イベント</xref:System.Windows.ContentElement.PreviewTouchMove>。 必ずメソッドを呼び出して、基底クラスの OnPreviewTouchMove 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewTouchMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  id: OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnPreviewTouchUp(TouchEventArgs)
  nameWithType: ContentElement.OnPreviewTouchUp(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTouchUp(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.ContentElement.PreviewTouchUp&quot;> </xref>タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。"
  remarks: "OnPreviewTouchUp メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnPreviewTouchUp、<xref:System.Windows.ContentElement.PreviewTouchUp>イベント</xref:System.Windows.ContentElement.PreviewTouchUp>。 必ずメソッドを呼び出して、基底クラスの OnPreviewTouchUp 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnPreviewTouchUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  id: OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: ContentElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.ContentElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.QueryContinueDragEventArgs
      description: "<xref href=&quot;System.Windows.QueryContinueDragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnQueryContinueDrag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  id: OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnQueryCursor(QueryCursorEventArgs)
  nameWithType: ContentElement.OnQueryCursor(QueryCursorEventArgs)
  fullName: System.Windows.ContentElement.OnQueryCursor(QueryCursorEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.QueryCursorEventArgs
      description: "<xref href=&quot;System.Windows.Input.QueryCursorEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnQueryCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  id: OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusButtonDown(StylusButtonEventArgs)
  nameWithType: ContentElement.OnStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnStylusButtonDown(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  id: OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusButtonUp(StylusButtonEventArgs)
  nameWithType: ContentElement.OnStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnStylusButtonUp(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  id: OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusDown(StylusDownEventArgs)
  nameWithType: ContentElement.OnStylusDown(StylusDownEventArgs)
  fullName: System.Windows.ContentElement.OnStylusDown(StylusDownEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusDownEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusDownEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  id: OnStylusEnter(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusEnter(StylusEventArgs)
  nameWithType: ContentElement.OnStylusEnter(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusEnter(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  id: OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusInAirMove(StylusEventArgs)
  nameWithType: ContentElement.OnStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusInAirMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusInAirMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  id: OnStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusInRange(StylusEventArgs)
  nameWithType: ContentElement.OnStylusInRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusInRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusInRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  id: OnStylusLeave(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusLeave(StylusEventArgs)
  nameWithType: ContentElement.OnStylusLeave(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusLeave(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  id: OnStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusMove(StylusEventArgs)
  nameWithType: ContentElement.OnStylusMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  id: OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusOutOfRange(StylusEventArgs)
  nameWithType: ContentElement.OnStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusOutOfRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusOutOfRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  id: OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: ContentElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.ContentElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusSystemGestureEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusSystemGestureEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusSystemGesture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  id: OnStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnStylusUp(StylusEventArgs)
  nameWithType: ContentElement.OnStylusUp(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusUp(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnStylusUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  id: OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnTextInput(TextCompositionEventArgs)
  nameWithType: ContentElement.OnTextInput(TextCompositionEventArgs)
  fullName: System.Windows.ContentElement.OnTextInput(TextCompositionEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TextCompositionEventArgs
      description: "<xref href=&quot;System.Windows.Input.TextCompositionEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnTextInput*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  id: OnTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnTouchDown(TouchEventArgs)
  nameWithType: ContentElement.OnTouchDown(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchDown(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.ContentElement.TouchDown&quot;> </xref>タッチがこの要素の内部を押したときに発生するイベントをルーティングします。"
  remarks: "OnTouchDown メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchDown、<xref:System.Windows.ContentElement.TouchDown>イベント</xref:System.Windows.ContentElement.TouchDown>。 必ずメソッドを呼び出して、基底クラスの OnTouchDown 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnTouchDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  id: OnTouchEnter(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnTouchEnter(TouchEventArgs)
  nameWithType: ContentElement.OnTouchEnter(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchEnter(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.ContentElement.TouchEnter&quot;> </xref>タッチから移動するときに発生するルーティング イベントをこの要素の境界内の外部です。"
  remarks: "OnTouchEnter メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchEnter、<xref:System.Windows.ContentElement.TouchEnter>イベント</xref:System.Windows.ContentElement.TouchEnter>。 必ずメソッドを呼び出して、基底クラスの OnTouchEnter 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnTouchEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  id: OnTouchLeave(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnTouchLeave(TouchEventArgs)
  nameWithType: ContentElement.OnTouchLeave(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchLeave(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.ContentElement.TouchLeave&quot;> </xref>タッチから移動するときに発生するルーティング イベントをこの要素の境界の外側の内部です。"
  remarks: "OnTouchLeave メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchLeave、<xref:System.Windows.ContentElement.TouchLeave>イベント</xref:System.Windows.ContentElement.TouchLeave>。 必ずメソッドを呼び出して、基底クラスの OnTouchLeave 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnTouchLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  id: OnTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnTouchMove(TouchEventArgs)
  nameWithType: ContentElement.OnTouchMove(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchMove(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.ContentElement.TouchMove&quot;> </xref>タッチは、この要素の中に内部動かしたときに発生するイベントをルーティングします。"
  remarks: "OnTouchMove メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchMove、<xref:System.Windows.ContentElement.TouchMove>イベント</xref:System.Windows.ContentElement.TouchMove>。 必ずメソッドを呼び出して、基底クラスの OnTouchMove 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnTouchMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  id: OnTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: OnTouchUp(TouchEventArgs)
  nameWithType: ContentElement.OnTouchUp(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchUp(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.ContentElement.TouchUp&quot;> </xref>タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。"
  remarks: "OnTouchUp メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchUp、<xref:System.Windows.ContentElement.TouchUp>イベント</xref:System.Windows.ContentElement.TouchUp>。 必ずメソッドを呼び出して、基底クラスの OnTouchUp 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.ContentElement.OnTouchUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: ContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.ContentElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、実際にその要素にフォーカスを移動しなくても指定したフォーカスの移動方向をフォーカスを受け取る要素を返します。"
  remarks: "このクラスでこのメソッドの既定の実装は完了せず、常に返します`null`です。"
  syntax:
    content: public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "要求されたフォーカスの移動の方向です。"
    return:
      type: System.Windows.DependencyObject
      description: "要素がフォーカスを受け取った場合<xref:System.Windows.ContentElement.MoveFocus*>が実際に呼び出されます</xref:System.Windows.ContentElement.MoveFocus*>。"
  overload: System.Windows.ContentElement.PredictFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDragEnter
  id: PreviewDragEnter
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDragEnter
  nameWithType: ContentElement.PreviewDragEnter
  fullName: System.Windows.ContentElement.PreviewDragEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ先と、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>PreviewDragEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>。 PreviewDragEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDragEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.DragEnter>.</xref:System.Windows.ContentElement.DragEnter> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.PreviewDragEnterEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDragEnter;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDragEnterEvent
  id: PreviewDragEnterEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDragEnterEvent
  nameWithType: ContentElement.PreviewDragEnterEvent
  fullName: System.Windows.ContentElement.PreviewDragEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewDragEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDragLeave
  id: PreviewDragLeave
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDragLeave
  nameWithType: ContentElement.PreviewDragLeave
  fullName: System.Windows.ContentElement.PreviewDragLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ元に、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>PreviewDragLeave が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>。 PreviewDragLeave イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDragLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.DragLeave>.</xref:System.Windows.ContentElement.DragLeave> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.PreviewDragLeaveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDragLeave;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDragLeaveEvent
  id: PreviewDragLeaveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDragLeaveEvent
  nameWithType: ContentElement.PreviewDragLeaveEvent
  fullName: System.Windows.ContentElement.PreviewDragLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewDragLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDragOver
  id: PreviewDragOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDragOver
  nameWithType: ContentElement.PreviewDragOver
  fullName: System.Windows.ContentElement.PreviewDragOver
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムが潜在的なドロップ ターゲットとしてこの要素で、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>PreviewDragOver が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>。 PreviewDragOver イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDragOver&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.DragOver>.</xref:System.Windows.ContentElement.DragOver> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.PreviewDragOverEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewDragOver%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDragOver;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDragOverEvent
  id: PreviewDragOverEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDragOverEvent
  nameWithType: ContentElement.PreviewDragOverEvent
  fullName: System.Windows.ContentElement.PreviewDragOverEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewDragOver&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDrop
  id: PreviewDrop
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDrop
  nameWithType: ContentElement.PreviewDrop
  fullName: System.Windows.ContentElement.PreviewDrop
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>テキストがの一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>。 テキストのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDrop&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewDropEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.Drop>.</xref:System.Windows.ContentElement.Drop> </xref:System.Windows.DragEventHandler> </xref:System.Windows.ContentElement.PreviewDropEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewDrop%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDrop;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewDropEvent
  id: PreviewDropEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewDropEvent
  nameWithType: ContentElement.PreviewDropEvent
  fullName: System.Windows.ContentElement.PreviewDropEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewDrop&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDropEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewGiveFeedback
  id: PreviewGiveFeedback
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewGiveFeedback
  nameWithType: ContentElement.PreviewGiveFeedback
  fullName: System.Windows.ContentElement.PreviewGiveFeedback
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ドラッグ アンド ドロップ操作が開始されたときに発生します。"
  remarks: "PreviewGiveFeedback イベントは、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソースを使用できます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>PreviewGiveFeedback が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>。 PreviewGiveFeedback イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewGiveFeedback&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.GiveFeedbackEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.GiveFeedback>.</xref:System.Windows.ContentElement.GiveFeedback> </xref:System.Windows.GiveFeedbackEventHandler> </xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>。"
  syntax:
    content: public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;
    return:
      type: System.Windows.GiveFeedbackEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewGiveFeedbackEvent
  id: PreviewGiveFeedbackEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewGiveFeedbackEvent
  nameWithType: ContentElement.PreviewGiveFeedbackEvent
  fullName: System.Windows.ContentElement.PreviewGiveFeedbackEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewGiveFeedback&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewGotKeyboardFocus
  id: PreviewGotKeyboardFocus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewGotKeyboardFocus
  nameWithType: ContentElement.PreviewGotKeyboardFocus
  fullName: System.Windows.ContentElement.PreviewGotKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスがあるときに発生します。"
  remarks: "このイベントは、ルーティング トンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>PreviewGotKeyboardFocus が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>。 PreviewGotKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewGotKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.GotKeyboardFocus>.</xref:System.Windows.ContentElement.GotKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  id: PreviewGotKeyboardFocusEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewGotKeyboardFocusEvent
  nameWithType: ContentElement.PreviewGotKeyboardFocusEvent
  fullName: System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewGotKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewKeyDown
  id: PreviewKeyDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewKeyDown
  nameWithType: ContentElement.PreviewKeyDown
  fullName: System.Windows.ContentElement.PreviewKeyDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にキーボードのフォーカスがある状態でキーが押されると発生します。"
  remarks: "キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 <xref:System.Windows.ContentElement.KeyDown>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります</xref:System.Windows.ContentElement.KeyDown>。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>PreviewKeyDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>。 PreviewKeyDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewKeyDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.KeyDown>.</xref:System.Windows.ContentElement.KeyDown> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.ContentElement.PreviewKeyDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler PreviewKeyDown;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewKeyDownEvent
  id: PreviewKeyDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewKeyDownEvent
  nameWithType: ContentElement.PreviewKeyDownEvent
  fullName: System.Windows.ContentElement.PreviewKeyDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewKeyDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewKeyUp
  id: PreviewKeyUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewKeyUp
  nameWithType: ContentElement.PreviewKeyUp
  fullName: System.Windows.ContentElement.PreviewKeyUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にキーボードのフォーカスがある状態でキーが離されると発生します。"
  remarks: "キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 <xref:System.Windows.ContentElement.KeyUp>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります</xref:System.Windows.ContentElement.KeyUp>。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。 詳細については、個々 のコントロールのマニュアルを確認します。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>PreviewKeyUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>。 PreviewKeyUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewKeyUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.KeyUp>.</xref:System.Windows.ContentElement.KeyUp> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.ContentElement.PreviewKeyUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler PreviewKeyUp;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewKeyUpEvent
  id: PreviewKeyUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewKeyUpEvent
  nameWithType: ContentElement.PreviewKeyUpEvent
  fullName: System.Windows.ContentElement.PreviewKeyUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewKeyUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewLostKeyboardFocus
  id: PreviewLostKeyboardFocus
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewLostKeyboardFocus
  nameWithType: ContentElement.PreviewLostKeyboardFocus
  fullName: System.Windows.ContentElement.PreviewLostKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスが離れたときに発生します。"
  remarks: "このイベントは、ルーティング トンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>PreviewLostKeyboardFocus が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>。 PreviewLostKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewLostKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.LostKeyboardFocus>.</xref:System.Windows.ContentElement.LostKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  id: PreviewLostKeyboardFocusEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewLostKeyboardFocusEvent
  nameWithType: ContentElement.PreviewLostKeyboardFocusEvent
  fullName: System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewLostKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseDown
  id: PreviewMouseDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseDown
  nameWithType: ContentElement.PreviewMouseDown
  fullName: System.Windows.ContentElement.PreviewMouseDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にポインターが、任意のマウス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>PreviewMouseDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 PreviewMouseDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。       PreviewMouseDown 多くの場合、このイベントはいずれかと共に<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応する</xref:System.Windows.ContentElement.PreviewMouseRightButtonDown></xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName></xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</xref:System.Windows.ContentElement.PreviewMouseRightButtonDown></xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>の「解説」を参照してください      <a name=&quot;routedEventInfo_PreviewMouseDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.MouseDown>.</xref:System.Windows.ContentElement.MouseDown> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.ContentElement.PreviewMouseDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseDownEvent
  id: PreviewMouseDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseDownEvent
  nameWithType: ContentElement.PreviewMouseDownEvent
  fullName: System.Windows.ContentElement.PreviewMouseDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonDown
  id: PreviewMouseLeftButtonDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonDown
  nameWithType: ContentElement.PreviewMouseLeftButtonDown
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが押されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseLeftButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  id: PreviewMouseLeftButtonDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonDownEvent
  nameWithType: ContentElement.PreviewMouseLeftButtonDownEvent
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseLeftButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonUp
  id: PreviewMouseLeftButtonUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonUp
  nameWithType: ContentElement.PreviewMouseLeftButtonUp
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが離されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseLeftButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  id: PreviewMouseLeftButtonUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonUpEvent
  nameWithType: ContentElement.PreviewMouseLeftButtonUpEvent
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseLeftButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseMove
  id: PreviewMouseMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseMove
  nameWithType: ContentElement.PreviewMouseMove
  fullName: System.Windows.ContentElement.PreviewMouseMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウス ポインターが移動したときに発生します。"
  remarks: "このイベントは、どちらも要素の境界にマウス ポインターを最初に入力し、マウス ポインターが要素の境界内に残っているときに移動するともします。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>PreviewMouseMove 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素としては、継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>。 PreviewMouseMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewMouseMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.MouseMove>.</xref:System.Windows.ContentElement.MouseMove> </xref:System.Windows.Input.MouseEventHandler> </xref:System.Windows.ContentElement.PreviewMouseMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler PreviewMouseMove;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseMoveEvent
  id: PreviewMouseMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseMoveEvent
  nameWithType: ContentElement.PreviewMouseMoveEvent
  fullName: System.Windows.ContentElement.PreviewMouseMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseRightButtonDown
  id: PreviewMouseRightButtonDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseRightButtonDown
  nameWithType: ContentElement.PreviewMouseRightButtonDown
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが押されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseRightButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  id: PreviewMouseRightButtonDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseRightButtonDownEvent
  nameWithType: ContentElement.PreviewMouseRightButtonDownEvent
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseRightButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseRightButtonUp
  id: PreviewMouseRightButtonUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseRightButtonUp
  nameWithType: ContentElement.PreviewMouseRightButtonUp
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが離されたときに発生します。"
  remarks: "この[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各<xref:System.Windows.ContentElement></xref:System.Windows.ContentElement>要素ツリーに沿って reraised を直接ルーティング イベントを実際には。       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.ContentElement.AddHandler%2A>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.ContentElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.ContentElement>.</xref:System.Windows.ContentElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseRightButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  id: PreviewMouseRightButtonUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseRightButtonUpEvent
  nameWithType: ContentElement.PreviewMouseRightButtonUpEvent
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseRightButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseUp
  id: PreviewMouseUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseUp
  nameWithType: ContentElement.PreviewMouseUp
  fullName: System.Windows.ContentElement.PreviewMouseUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にマウス ポインターが、任意のマウス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>PreviewMouseUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。 PreviewMouseUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       PreviewMouseUp 多くの場合、このイベントはいずれかと共に<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応する</xref:System.Windows.ContentElement.PreviewMouseRightButtonUp></xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName></xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</xref:System.Windows.ContentElement.PreviewMouseRightButtonUp></xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>の「解説」を参照してください      <a name=&quot;routedEventInfo_PreviewMouseUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.MouseUp>.</xref:System.Windows.ContentElement.MouseUp> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.ContentElement.PreviewMouseUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseUpEvent
  id: PreviewMouseUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseUpEvent
  nameWithType: ContentElement.PreviewMouseUpEvent
  fullName: System.Windows.ContentElement.PreviewMouseUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseWheel
  id: PreviewMouseWheel
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseWheel
  nameWithType: ContentElement.PreviewMouseWheel
  fullName: System.Windows.ContentElement.PreviewMouseWheel
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にマウス ポインターが、ユーザーがマウスのホイールを回転させるときに発生します。"
  remarks: "フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。このため、対象を絞ったまたはキャプチャした要素からこのイベントを受信する場合、マウス ポインター実際にあります別の要素上です。       このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.ContentElement.PreviewMouseMove></xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName>。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName></xref:System.Windows.ContentElement.PreviewMouseMove>。      <a name=&quot;routedEventInfo_PreviewMouseWheel&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseWheelEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.MouseWheel>.</xref:System.Windows.ContentElement.MouseWheel> </xref:System.Windows.Input.MouseWheelEventHandler> </xref:System.Windows.ContentElement.PreviewMouseWheelEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;
    return:
      type: System.Windows.Input.MouseWheelEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewMouseWheelEvent
  id: PreviewMouseWheelEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewMouseWheelEvent
  nameWithType: ContentElement.PreviewMouseWheelEvent
  fullName: System.Windows.ContentElement.PreviewMouseWheelEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewMouseWheel&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewQueryContinueDrag
  id: PreviewQueryContinueDrag
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewQueryContinueDrag
  nameWithType: ContentElement.PreviewQueryContinueDrag
  fullName: System.Windows.ContentElement.PreviewQueryContinueDrag
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ドラッグ アンド ドロップ操作中にキーボードまたはマウス ボタンの状態に変更があるときに発生します。"
  remarks: "PreviewQueryContinueDrag イベントは、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを宣言できます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>PreviewQueryContinueDrag が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>。 PreviewQueryContinueDrag イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewQueryContinueDrag&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.QueryContinueDragEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.QueryContinueDrag>.</xref:System.Windows.ContentElement.QueryContinueDrag> </xref:System.Windows.QueryContinueDragEventHandler> </xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>。"
  syntax:
    content: public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;
    return:
      type: System.Windows.QueryContinueDragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewQueryContinueDragEvent
  id: PreviewQueryContinueDragEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewQueryContinueDragEvent
  nameWithType: ContentElement.PreviewQueryContinueDragEvent
  fullName: System.Windows.ContentElement.PreviewQueryContinueDragEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewQueryContinueDrag&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusButtonDown
  id: PreviewStylusButtonDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusButtonDown
  nameWithType: ContentElement.PreviewStylusButtonDown
  fullName: System.Windows.ContentElement.PreviewStylusButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>PreviewStylusButtonDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>。 PreviewStylusButtonDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.StylusButtonDown>.</xref:System.Windows.ContentElement.StylusButtonDown> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusButtonDownEvent
  id: PreviewStylusButtonDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusButtonDownEvent
  nameWithType: ContentElement.PreviewStylusButtonDownEvent
  fullName: System.Windows.ContentElement.PreviewStylusButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusButtonUp
  id: PreviewStylusButtonUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusButtonUp
  nameWithType: ContentElement.PreviewStylusButtonUp
  fullName: System.Windows.ContentElement.PreviewStylusButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>PreviewStylusButtonUp 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素としては、継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>。 PreviewStylusButtonUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.StylusButtonUp>.</xref:System.Windows.ContentElement.StylusButtonUp> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusButtonUpEvent
  id: PreviewStylusButtonUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusButtonUpEvent
  nameWithType: ContentElement.PreviewStylusButtonUpEvent
  fullName: System.Windows.ContentElement.PreviewStylusButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusDown
  id: PreviewStylusDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusDown
  nameWithType: ContentElement.PreviewStylusDown
  fullName: System.Windows.ContentElement.PreviewStylusDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上でスタイラスがデジタイザーに触れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>PreviewStylusDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>。 PreviewStylusDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusDownEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.StylusDown>.</xref:System.Windows.ContentElement.StylusDown> </xref:System.Windows.Input.StylusDownEventHandler> </xref:System.Windows.ContentElement.PreviewStylusDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;
    return:
      type: System.Windows.Input.StylusDownEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusDownEvent
  id: PreviewStylusDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusDownEvent
  nameWithType: ContentElement.PreviewStylusDownEvent
  fullName: System.Windows.ContentElement.PreviewStylusDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusInAirMove
  id: PreviewStylusInAirMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusInAirMove
  nameWithType: ContentElement.PreviewStylusInAirMove
  fullName: System.Windows.ContentElement.PreviewStylusInAirMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "実際には、デジタイザーに触れることがなく要素上でスタイラスを動かしたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>なく previewstylusinairmove イベントが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>。 なく previewstylusinairmove イベントのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusInAirMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.StylusInAirMove>.</xref:System.Windows.ContentElement.StylusInAirMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  id: PreviewStylusInAirMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusInAirMoveEvent
  nameWithType: ContentElement.PreviewStylusInAirMoveEvent
  fullName: System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusInAirMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusInRange
  id: PreviewStylusInRange
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusInRange
  nameWithType: ContentElement.PreviewStylusInRange
  fullName: System.Windows.ContentElement.PreviewStylusInRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上で検出されるまでデジタイザーに近づいたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>PreviewStylusInRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>。 PreviewStylusInRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusInRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.StylusInRange>.</xref:System.Windows.ContentElement.StylusInRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusInRangeEvent
  id: PreviewStylusInRangeEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusInRangeEvent
  nameWithType: ContentElement.PreviewStylusInRangeEvent
  fullName: System.Windows.ContentElement.PreviewStylusInRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusInRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusMove
  id: PreviewStylusMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusMove
  nameWithType: ContentElement.PreviewStylusMove
  fullName: System.Windows.ContentElement.PreviewStylusMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "要素上でスタイラスを動かしたときに発生します。 それ以外の場合、このイベントを発生させる、デジタイザーによって検出されている間にスタイラスが移動する必要があります<xref href=&quot;System.Windows.ContentElement.PreviewStylusInAirMove&quot;></xref>が代わりに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>PreviewStylusMove が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>。 PreviewStylusMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応するバブル イベントは<xref:System.Windows.ContentElement.StylusMove>.</xref:System.Windows.ContentElement.StylusMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.PreviewStylusMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusMoveEvent
  id: PreviewStylusMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusMoveEvent
  nameWithType: ContentElement.PreviewStylusMoveEvent
  fullName: System.Windows.ContentElement.PreviewStylusMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusOutOfRange
  id: PreviewStylusOutOfRange
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusOutOfRange
  nameWithType: ContentElement.PreviewStylusOutOfRange
  fullName: System.Windows.ContentElement.PreviewStylusOutOfRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスが検出されたデジタイザーから離れすぎているときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>PreviewStylusOutOfRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>。 PreviewStylusOutOfRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusOutOfRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.StylusOutOfRange>.</xref:System.Windows.ContentElement.StylusOutOfRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  id: PreviewStylusOutOfRangeEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusOutOfRangeEvent
  nameWithType: ContentElement.PreviewStylusOutOfRangeEvent
  fullName: System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusOutOfRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusSystemGesture
  id: PreviewStylusSystemGesture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusSystemGesture
  nameWithType: ContentElement.PreviewStylusSystemGesture
  fullName: System.Windows.ContentElement.PreviewStylusSystemGesture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。"
  remarks: "スタイラス ジェスチャの詳細については、 <xref:System.Windows.Input.SystemGesture>。</xref:System.Windows.Input.SystemGesture>を参照してください。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>PreviewStylusSystemGesture が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>。 PreviewStylusSystemGesture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusSystemGesture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusSystemGestureEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.StylusSystemGesture>.</xref:System.Windows.ContentElement.StylusSystemGesture> </xref:System.Windows.Input.StylusSystemGestureEventHandler> </xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;
    return:
      type: System.Windows.Input.StylusSystemGestureEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  id: PreviewStylusSystemGestureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusSystemGestureEvent
  nameWithType: ContentElement.PreviewStylusSystemGestureEvent
  fullName: System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusSystemGesture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusUp
  id: PreviewStylusUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusUp
  nameWithType: ContentElement.PreviewStylusUp
  fullName: System.Windows.ContentElement.PreviewStylusUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にスタイラスが、ユーザーがスタイラスをデジタイザーから離れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.ContentElement.PreviewStylusDown></xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName>。 イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName></xref:System.Windows.ContentElement.PreviewStylusDown>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.StylusUp>.</xref:System.Windows.ContentElement.StylusUp> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.PreviewStylusUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusUp;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewStylusUpEvent
  id: PreviewStylusUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewStylusUpEvent
  nameWithType: ContentElement.PreviewStylusUpEvent
  fullName: System.Windows.ContentElement.PreviewStylusUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewStylusUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTextInput
  id: PreviewTextInput
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTextInput
  nameWithType: ContentElement.PreviewTextInput
  fullName: System.Windows.ContentElement.PreviewTextInput
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素は、デバイスに依存しない方法でテキストを取得したときに発生します。"
  remarks: "PreviewTextInput イベントは、コンポーネントまたはデバイスに依存しない方法でテキスト入力にリッスンするようにアプリケーションを使用します。 キーボードは、PreviewTextInput; の主な手段は、します。音声認識、手書き認識、およびその他の入力デバイスも PreviewTextInput します。       キーの組み合わせのため、既定のキーボードまたは入力方式エディターから — 複数のキー イベントが&1; つだけのテキスト入力イベントを発生させる可能性があります。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>PreviewTextInput が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>。 PreviewTextInput イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewTextInput&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.TextCompositionEventHandler>|     対応する-バブル イベントは<xref:System.Windows.ContentElement.TextInput>.</xref:System.Windows.ContentElement.TextInput> </xref:System.Windows.Input.TextCompositionEventHandler> </xref:System.Windows.ContentElement.PreviewTextInputEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewTextInput%2A>。"
  syntax:
    content: public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;
    return:
      type: System.Windows.Input.TextCompositionEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTextInputEvent
  id: PreviewTextInputEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTextInputEvent
  nameWithType: ContentElement.PreviewTextInputEvent
  fullName: System.Windows.ContentElement.PreviewTextInputEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewTextInput&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTouchDown
  id: PreviewTouchDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTouchDown
  nameWithType: ContentElement.PreviewTouchDown
  fullName: System.Windows.ContentElement.PreviewTouchDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に触れると発生します。"
  remarks: "既定では、PreviewTouchDown と<xref:System.Windows.ContentElement.TouchDown>指が画面に触れるし、移動するまでのイベントが発生しません</xref:System.Windows.ContentElement.TouchDown>。 移動することがなく保持したりする画面に指を押すと、キーを押して発生して<xref:System.Windows.Input.Stylus>。</xref:System.Windows.Input.Stylus>の動作を保持 プレス アンド ホールド動作は、マウスの右クリックに相当します。       PreviewTouchDown が発生して<xref:System.Windows.ContentElement.TouchDown>、画面に触れると発生するイベントを設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName>添付プロパティ`false`この要素の</xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName></xref:System.Windows.ContentElement.TouchDown>。      <a name=&quot;routedEventInfo_PreviewTouchDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-バブル イベントは<xref:System.Windows.ContentElement.TouchDown>.</xref:System.Windows.ContentElement.TouchDown> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.ContentElement.PreviewTouchDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> PreviewTouchDown;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTouchDownEvent
  id: PreviewTouchDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTouchDownEvent
  nameWithType: ContentElement.PreviewTouchDownEvent
  fullName: System.Windows.ContentElement.PreviewTouchDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewTouchDown&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTouchMove
  id: PreviewTouchMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTouchMove
  nameWithType: ContentElement.PreviewTouchMove
  fullName: System.Windows.ContentElement.PreviewTouchMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に指を動かしたときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_PreviewTouchMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-バブル イベントは<xref:System.Windows.ContentElement.TouchMove>.</xref:System.Windows.ContentElement.TouchMove> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.ContentElement.PreviewTouchMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> PreviewTouchMove;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTouchMoveEvent
  id: PreviewTouchMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTouchMoveEvent
  nameWithType: ContentElement.PreviewTouchMoveEvent
  fullName: System.Windows.ContentElement.PreviewTouchMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewTouchMove&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTouchUp
  id: PreviewTouchUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTouchUp
  nameWithType: ContentElement.PreviewTouchUp
  fullName: System.Windows.ContentElement.PreviewTouchUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面から離れる指が発生したときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_PreviewTouchUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-バブル イベントは<xref:System.Windows.ContentElement.TouchUp>.</xref:System.Windows.ContentElement.TouchUp> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.ContentElement.PreviewTouchUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> PreviewTouchUp;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.PreviewTouchUpEvent
  id: PreviewTouchUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: PreviewTouchUpEvent
  nameWithType: ContentElement.PreviewTouchUpEvent
  fullName: System.Windows.ContentElement.PreviewTouchUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.PreviewTouchUp&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.QueryContinueDrag
  id: QueryContinueDrag
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: QueryContinueDrag
  nameWithType: ContentElement.QueryContinueDrag
  fullName: System.Windows.ContentElement.QueryContinueDrag
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ドラッグ アンド ドロップ操作中にキーボードまたはマウス ボタンの状態に変更があるときに発生します。"
  remarks: "QueryContinueDrag イベントは、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断できます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>QueryContinueDrag が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>。 QueryContinueDrag イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>。      <a name=&quot;routedEventInfo_QueryContinueDrag&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.QueryContinueDragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</xref:System.Windows.ContentElement.PreviewQueryContinueDrag> </xref:System.Windows.QueryContinueDragEventHandler> </xref:System.Windows.ContentElement.QueryContinueDragEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>。"
  syntax:
    content: public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;
    return:
      type: System.Windows.QueryContinueDragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.QueryContinueDragEvent
  id: QueryContinueDragEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: QueryContinueDragEvent
  nameWithType: ContentElement.QueryContinueDragEvent
  fullName: System.Windows.ContentElement.QueryContinueDragEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.QueryContinueDrag&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.QueryCursor
  id: QueryCursor
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: QueryCursor
  nameWithType: ContentElement.QueryCursor
  fullName: System.Windows.ContentElement.QueryCursor
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "表示する、カーソルが要求されると発生します。 マウスのポインターはカーソル オブジェクトを変更する必要がありますが、新しい位置に基づいて、新しい場所に移動するたびに、要素にこのイベントが発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>QueryCursor が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>。 QueryCursor イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>。       このイベント名によって参照されているカーソルは、必ずしも (カーソルとも呼ばれる) テキストのカーソルではありません。 代わりに、いくつかの可能な入力に関連するデバイスまたはの概念に関連する画面上のグラフィカル表示を宣言するオブジェクトは、このコンテキストでのカーソル[!INCLUDE[TLA2#tla_win](~/add/includes/tla2sharptla-win-md.md)]プログラミングします。 そのオブジェクトがによって表される、<xref:System.Windows.Input.Cursor>クラス[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</xref:System.Windows.Input.Cursor>。 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]入力システムでは、マウス ポインターの画面上の位置を表す場合は、このカーソルを変更することができます。 定義済みの値を使用することができます、<xref:System.Windows.Input.Cursors>列挙型、または画像ファイルとしてカスタム カーソルを宣言できます</xref:System.Windows.Input.Cursors>。       QueryCursor のイベントのリッスンがカーソル管理の効率的な方法です。 代わりに、各要素が<xref:System.Windows.FrameworkContentElement.Cursor%2A><xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。</xref:System.Windows.FrameworkContentElement.ForceCursor%2A></xref:System.Windows.FrameworkContentElement.Cursor%2A>とそれぞれのカーソル動作を定義する必要があります。 WPF フレームワーク レベルの基本要素を使用していないまたはで特別な状況で要素ごとの単位でのカーソルの動作を定義するがニーズに合わない場合は、のみ QueryCursor に依存する必要があります。 QueryCursor への応答のカーソルの動作を実装する方法については、 <xref:System.Windows.Input.QueryCursorEventHandler>。</xref:System.Windows.Input.QueryCursorEventHandler>を参照してください。      <a name=&quot;routedEventInfo_QueryCursor&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.QueryCursorEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.QueryCursorEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.QueryCursorEventHandler></xref:System.Windows.ContentElement.QueryCursorEvent>。      -オーバーライド<xref:System.Windows.ContentElement.OnQueryCursor%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnQueryCursor%2A>。"
  syntax:
    content: public event System.Windows.Input.QueryCursorEventHandler QueryCursor;
    return:
      type: System.Windows.Input.QueryCursorEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.QueryCursorEvent
  id: QueryCursorEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: QueryCursorEvent
  nameWithType: ContentElement.QueryCursorEvent
  fullName: System.Windows.ContentElement.QueryCursorEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.QueryCursor&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent QueryCursorEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  id: RaiseEvent(System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: RaiseEvent(RoutedEventArgs)
  nameWithType: ContentElement.RaiseEvent(RoutedEventArgs)
  fullName: System.Windows.ContentElement.RaiseEvent(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "特定のルーティング イベントを発生させます。 <xref href=&quot;System.Windows.RoutedEvent&quot;> </xref>内で識別されるときに生成される、 <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>提供されているインスタンス (として、<xref:System.Windows.RoutedEventArgs.RoutedEvent*>そのイベント データのプロパティ).</xref:System.Windows.RoutedEventArgs.RoutedEvent*>"
  remarks: "`e`ルーティング イベントのすべてのデータの共通の基本型として型指定されたパラメーターですただし、ため発生するイベントに使用される最も固有のイベント データの種類として、イベント データを指定してください<xref:System.Windows.RoutedEventArgs>派生クラスが発生すると、特定のイベントは、特定の実際のデータ プロパティが含まれています。</xref:System.Windows.RoutedEventArgs> 。       <xref:System.Windows.RoutedEventArgs>イベントの状態のプロパティだけではありません。ルーティング イベントを発生させるも識別します。</xref:System.Windows.RoutedEventArgs> このイベント発生パターンと、ルーティングされたイベント データの両方が異なる[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]イベントに関連するプロパティを通常だけが含まれるイベントやデータのクラスです。"
  example:
  - "The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#RaiseEvent](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#raiseevent)]\n [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#raiseevent)]"
  syntax:
    content: public void RaiseEvent (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "A <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納しても発生させるイベントを識別します。"
  overload: System.Windows.ContentElement.RaiseEvent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ReleaseAllTouchCaptures
  id: ReleaseAllTouchCaptures
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ReleaseAllTouchCaptures()
  nameWithType: ContentElement.ReleaseAllTouchCaptures()
  fullName: System.Windows.ContentElement.ReleaseAllTouchCaptures()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素からすべてのキャプチャされたタッチ デバイスを解放します。"
  syntax:
    content: public void ReleaseAllTouchCaptures ();
    parameters: []
  overload: System.Windows.ContentElement.ReleaseAllTouchCaptures*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ReleaseMouseCapture
  id: ReleaseMouseCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ReleaseMouseCapture()
  nameWithType: ContentElement.ReleaseMouseCapture()
  fullName: System.Windows.ContentElement.ReleaseMouseCapture()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素には、キャプチャが保持されている場合は、マウスのキャプチャを解放します。"
  remarks: "この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。 値を確認してください<xref:System.Windows.ContentElement.IsMouseCaptured%2A>このメソッドを呼び出す前にします</xref:System.Windows.ContentElement.IsMouseCaptured%2A>。"
  example:
  - "The following handler captures or releases mouse capture according to mouse button states. The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].  \n  \n [!code-cs[ContentElementsSmorgasbord#UIElementMouseCapture](~/add/codesnippet/csharp/ContentElementsSmorgasbord/Trackball.cs#uielementmousecapture)]\n [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/add/codesnippet/visualbasic/contentelementssmorgasbord/trackball.vb#uielementmousecapture)]"
  syntax:
    content: public void ReleaseMouseCapture ();
    parameters: []
  overload: System.Windows.ContentElement.ReleaseMouseCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ReleaseStylusCapture
  id: ReleaseStylusCapture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ReleaseStylusCapture()
  nameWithType: ContentElement.ReleaseStylusCapture()
  fullName: System.Windows.ContentElement.ReleaseStylusCapture()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素には、キャプチャが保持されている場合は、スタイラス デバイスのキャプチャを解放します。"
  remarks: "この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。 値を確認してください<xref:System.Windows.ContentElement.IsStylusCaptured%2A>このメソッドを呼び出す前にします</xref:System.Windows.ContentElement.IsStylusCaptured%2A>。"
  syntax:
    content: public void ReleaseStylusCapture ();
    parameters: []
  overload: System.Windows.ContentElement.ReleaseStylusCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  id: ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ReleaseTouchCapture(TouchDevice)
  nameWithType: ContentElement.ReleaseTouchCapture(TouchDevice)
  fullName: System.Windows.ContentElement.ReleaseTouchCapture(TouchDevice)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素から指定したタッチ デバイスを解放しようとしています。"
  syntax:
    content: public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);
    parameters:
    - id: touchDevice
      type: System.Windows.Input.TouchDevice
      description: "解放するデバイスです。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>タッチ デバイスを放した場合です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.ContentElement.ReleaseTouchCapture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>touchDevice</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  id: RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: RemoveHandler(RoutedEvent,Delegate)
  nameWithType: ContentElement.RemoveHandler(RoutedEvent,Delegate)
  fullName: System.Windows.ContentElement.RemoveHandler(RoutedEvent,Delegate)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素から指定したルーティング イベント ハンドラーを削除します。"
  remarks: "これを使用するための最も一般的なシナリオ[!INCLUDE[TLA#tla_api](~/add/includes/tlasharptla-api-md.md)]を実装する場合は、[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]カスタム ルーティング イベントのハンドラーの削除」ロジックを実装するときに特に関連付けられている「ラッパー」イベント、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]レベル。 これを次の例「解説」セクションでは、このシナリオを示しています。       このメソッドを呼び出しても何も起こりませんメソッドの呼び出しの入力パラメーターに一致する条件で登録されたハンドラーがない場合。       数より多い場合に、イベント ハンドラーのストアの削除に最初のハンドラーのみ、条件に一致する&1; つのハンドラーがアタッチされます。 この動作は整合[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]の動作、`-=`演算子。       どちらも`routedEvent`も`handler`あります`null`です。 いずれかの値として提供しようとしています。`null`で例外が発生します。       このメソッドは無視、`handledEventsToo`場合は、ハンドラーが最初に提供されているパラメーターについては、追加、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>処理済みのイベントの処理を有効に署名します</xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>。 ハンドラーのいずれかの型が削除されます。"
  syntax:
    content: public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "ハンドラーがアタッチされているルーティング イベントの識別子。"
    - id: handler
      type: System.Delegate
      description: "この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。"
  overload: System.Windows.ContentElement.RemoveHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ShouldSerializeCommandBindings
  id: ShouldSerializeCommandBindings
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ShouldSerializeCommandBindings()
  nameWithType: ContentElement.ShouldSerializeCommandBindings()
  fullName: System.Windows.ContentElement.ShouldSerializeCommandBindings()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "シリアル化プロセスが、<xref:System.Windows.ContentElement.CommandBindings*>このクラスのインスタンスのプロパティ</xref:System.Windows.ContentElement.CommandBindings*>の内容をシリアル化する必要かどうかを返します"
  remarks: "これは、戻り値は`true`場合<xref:System.Windows.ContentElement.CommandBindings%2A>ローカルに設定します</xref:System.Windows.ContentElement.CommandBindings%2A>。       これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.CommandBindings%2A>プロパティには、単純な既定値にありません</xref:System.Windows.UIElement.CommandBindings%2A>。 このメソッドは、既定値から、プロパティが変更されたかどうかを示します。 デザイナーを開発または<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>を組み込む独自のコントロールを開発する場合に通常、このメソッドが呼び出す       詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public bool ShouldSerializeCommandBindings ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、<xref:System.Windows.ContentElement.CommandBindings*>プロパティの値が、それ以外のシリアル化する必要があります<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.ContentElement.CommandBindings*> 。"
  overload: System.Windows.ContentElement.ShouldSerializeCommandBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.ShouldSerializeInputBindings
  id: ShouldSerializeInputBindings
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: ShouldSerializeInputBindings()
  nameWithType: ContentElement.ShouldSerializeInputBindings()
  fullName: System.Windows.ContentElement.ShouldSerializeInputBindings()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "シリアル化プロセスが、<xref:System.Windows.ContentElement.InputBindings*>このクラスのインスタンスのプロパティ</xref:System.Windows.ContentElement.InputBindings*>の内容をシリアル化する必要かどうかを返します"
  remarks: "これは、戻り値は`true`場合<xref:System.Windows.ContentElement.InputBindings%2A>ローカルに設定します</xref:System.Windows.ContentElement.InputBindings%2A>。       これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.InputBindings%2A>プロパティには、単純な既定値にありません</xref:System.Windows.UIElement.InputBindings%2A>。 このメソッドは、既定値から、プロパティが変更されたかどうかを示します。 デザイナーを開発または<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>を組み込む独自のコントロールを開発する場合に通常、このメソッドが呼び出す       詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public bool ShouldSerializeInputBindings ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、<xref:System.Windows.ContentElement.InputBindings*>プロパティの値が、それ以外のシリアル化する必要があります<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.ContentElement.InputBindings*> 。"
  overload: System.Windows.ContentElement.ShouldSerializeInputBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusButtonDown
  id: StylusButtonDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusButtonDown
  nameWithType: ContentElement.StylusButtonDown
  fullName: System.Windows.ContentElement.StylusButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>StylusButtonDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>。 StylusButtonDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</xref:System.Windows.ContentElement.PreviewStylusButtonDown> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.ContentElement.StylusButtonDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusButtonDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusButtonDownEvent
  id: StylusButtonDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusButtonDownEvent
  nameWithType: ContentElement.StylusButtonDownEvent
  fullName: System.Windows.ContentElement.StylusButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusButtonUp
  id: StylusButtonUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusButtonUp
  nameWithType: ContentElement.StylusButtonUp
  fullName: System.Windows.ContentElement.StylusButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>StylusButtonUp 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素としては、継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>。 StylusButtonUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</xref:System.Windows.ContentElement.PreviewStylusButtonUp> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.ContentElement.StylusButtonUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusButtonUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusButtonUpEvent
  id: StylusButtonUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusButtonUpEvent
  nameWithType: ContentElement.StylusButtonUpEvent
  fullName: System.Windows.ContentElement.StylusButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusDown
  id: StylusDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusDown
  nameWithType: ContentElement.StylusDown
  fullName: System.Windows.ContentElement.StylusDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上でスタイラスがデジタイザーに触れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>StylusDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>。 StylusDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusDownEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusDown>.</xref:System.Windows.ContentElement.PreviewStylusDown> </xref:System.Windows.Input.StylusDownEventHandler> </xref:System.Windows.ContentElement.StylusDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusDownEventHandler StylusDown;
    return:
      type: System.Windows.Input.StylusDownEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusDownEvent
  id: StylusDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusDownEvent
  nameWithType: ContentElement.StylusDownEvent
  fullName: System.Windows.ContentElement.StylusDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusEnter
  id: StylusEnter
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusEnter
  nameWithType: ContentElement.StylusEnter
  fullName: System.Windows.ContentElement.StylusEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素の境界に入ったときに発生します。"
  remarks: "StylusEnter は、[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       StylusEnter を追跡、スタイラスが要素の境界に入ったときに、このイベントより文字どおりを報告している、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`false`を`true`この要素上です</xref:System.Windows.ContentElement.IsStylusOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>StylusEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>。 StylusEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusEnterEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnStylusEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusEnter%2A></xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.ContentElement.StylusEnterEvent>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusEnter;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusEnterEvent
  id: StylusEnterEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusEnterEvent
  nameWithType: ContentElement.StylusEnterEvent
  fullName: System.Windows.ContentElement.StylusEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusInAirMove
  id: StylusInAirMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusInAirMove
  nameWithType: ContentElement.StylusInAirMove
  fullName: System.Windows.ContentElement.StylusInAirMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "実際には、デジタイザーに触れることがなく要素上でスタイラスを動かしたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>なく stylusinairmove イベントが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>。 なく stylusinairmove イベントのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusInAirMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</xref:System.Windows.ContentElement.PreviewStylusInAirMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.StylusInAirMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusInAirMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusInAirMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusInAirMoveEvent
  id: StylusInAirMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusInAirMoveEvent
  nameWithType: ContentElement.StylusInAirMoveEvent
  fullName: System.Windows.ContentElement.StylusInAirMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusInAirMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusInRange
  id: StylusInRange
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusInRange
  nameWithType: ContentElement.StylusInRange
  fullName: System.Windows.ContentElement.StylusInRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上で検出されるまでデジタイザーに近づいたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>StylusInRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>。 StylusInRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusInRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusInRangeEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusInRange>.</xref:System.Windows.ContentElement.PreviewStylusInRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.StylusInRangeEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusInRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusInRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusInRangeEvent
  id: StylusInRangeEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusInRangeEvent
  nameWithType: ContentElement.StylusInRangeEvent
  fullName: System.Windows.ContentElement.StylusInRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusInRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusInRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusLeave
  id: StylusLeave
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusLeave
  nameWithType: ContentElement.StylusLeave
  fullName: System.Windows.ContentElement.StylusLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスが要素の境界から出たときに発生します。"
  remarks: "StylusLeave は、[ルーティング イベントの概要](~/add/includes/ajax-current-ext-md.md)直接イベント ルーティング方法の処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       StylusLeave を追跡スタイラスが要素の境界から出たときに、このイベントより文字どおりを報告している、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`true`に`false`この要素上です</xref:System.Windows.ContentElement.IsStylusOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>StylusLeave が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>。 StylusLeave イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusLeaveEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -オーバーライド<xref:System.Windows.ContentElement.OnStylusLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusLeave%2A></xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.ContentElement.StylusLeaveEvent>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusLeave;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusLeaveEvent
  id: StylusLeaveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusLeaveEvent
  nameWithType: ContentElement.StylusLeaveEvent
  fullName: System.Windows.ContentElement.StylusLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusMove
  id: StylusMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusMove
  nameWithType: ContentElement.StylusMove
  fullName: System.Windows.ContentElement.StylusMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上でスタイラスを動かしたときに発生します。 スタイラスがデジタイザーにこのイベントを発生時に移動する必要があります。 それ以外の場合、 <xref href=&quot;System.Windows.ContentElement.StylusInAirMove&quot;> </xref>が代わりに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>StylusMove 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素としては、継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>。 StylusMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusMove>.</xref:System.Windows.ContentElement.PreviewStylusMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.StylusMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusMoveEvent
  id: StylusMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusMoveEvent
  nameWithType: ContentElement.StylusMoveEvent
  fullName: System.Windows.ContentElement.StylusMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusOutOfRange
  id: StylusOutOfRange
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusOutOfRange
  nameWithType: ContentElement.StylusOutOfRange
  fullName: System.Windows.ContentElement.StylusOutOfRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上で、検出されたデジタイザーから離れすぎているときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>StylusOutOfRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>。 StylusOutOfRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusOutOfRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</xref:System.Windows.ContentElement.PreviewStylusOutOfRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.StylusOutOfRangeEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusOutOfRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusOutOfRangeEvent
  id: StylusOutOfRangeEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusOutOfRangeEvent
  nameWithType: ContentElement.StylusOutOfRangeEvent
  fullName: System.Windows.ContentElement.StylusOutOfRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusOutOfRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusSystemGesture
  id: StylusSystemGesture
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusSystemGesture
  nameWithType: ContentElement.StylusSystemGesture
  fullName: System.Windows.ContentElement.StylusSystemGesture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。"
  remarks: "スタイラス ジェスチャの詳細については、 <xref:System.Windows.Input.SystemGesture>。</xref:System.Windows.Input.SystemGesture>を参照してください。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>StylusSystemGesture が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>。 StylusSystemGesture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusSystemGesture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusSystemGestureEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</xref:System.Windows.ContentElement.PreviewStylusSystemGesture> </xref:System.Windows.Input.StylusSystemGestureEventHandler> </xref:System.Windows.ContentElement.StylusSystemGestureEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;
    return:
      type: System.Windows.Input.StylusSystemGestureEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusSystemGestureEvent
  id: StylusSystemGestureEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusSystemGestureEvent
  nameWithType: ContentElement.StylusSystemGestureEvent
  fullName: System.Windows.ContentElement.StylusSystemGestureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusSystemGesture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusUp
  id: StylusUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusUp
  nameWithType: ContentElement.StylusUp
  fullName: System.Windows.ContentElement.StylusUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上で、ユーザーがスタイラスをデジタイザーから離れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>StylusUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>。 StylusUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.StylusUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewStylusUp>.</xref:System.Windows.ContentElement.PreviewStylusUp> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.ContentElement.StylusUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnStylusUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusUp;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.StylusUpEvent
  id: StylusUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: StylusUpEvent
  nameWithType: ContentElement.StylusUpEvent
  fullName: System.Windows.ContentElement.StylusUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.StylusUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TextInput
  id: TextInput
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TextInput
  nameWithType: ContentElement.TextInput
  fullName: System.Windows.ContentElement.TextInput
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素は、デバイスに依存しない方法でテキストを取得したときに発生します。"
  remarks: "> [!IMPORTANT]> このイベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。 以下の解説を参照してください。       複合コントロールの内部実装によって処理される、TextInput イベントをマーク既に可能性があります。 たとえば、<xref:System.Windows.Controls.TextBox>場所 TextInput イベントは既に設定されて処理済みとして以外の場合は、合成内で複合コントロールは、</xref:System.Windows.Controls.TextBox> 。 コントロールは、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があります。 使用する場合<xref:System.Windows.ContentElement.PreviewTextInput>テキスト入力用のハンドラーをアタッチするイベント、としてより良い結果を受け取ることがあります</xref:System.Windows.ContentElement.PreviewTextInput>。 この手法は、コントロールの複合ハンドル済みとしては、このイベントをマークが既にあり、ハンドラーがイベント ルート上でイベントを受信できないように、ほとんどの場合を回避できます。       TextInput イベントは、コンポーネントまたはデバイスに依存しない方法でテキスト入力にリッスンするようにアプリケーションを使用します。 キーボードは TextInput が、音声の手書きの主な手段とも、他の入力デバイスは TextInput を生成する可能性ができます。       キーの組み合わせが原因: 既定のキーボードまたは入力方式エディターから — 複数のキー イベントが&1; つのテキスト入力イベントを発生させる可能性があります。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>TextInput が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.ContentElement>基本要素として継承します</xref:System.Windows.ContentElement></xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>。 TextInput イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>。      <a name=&quot;routedEventInfo_TextInput&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.TextInputEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.TextCompositionEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewTextInput>.</xref:System.Windows.ContentElement.PreviewTextInput> </xref:System.Windows.Input.TextCompositionEventHandler> </xref:System.Windows.ContentElement.TextInputEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnTextInput%2A>。"
  syntax:
    content: public event System.Windows.Input.TextCompositionEventHandler TextInput;
    return:
      type: System.Windows.Input.TextCompositionEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TextInputEvent
  id: TextInputEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TextInputEvent
  nameWithType: ContentElement.TextInputEvent
  fullName: System.Windows.ContentElement.TextInputEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.TextInput&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TextInputEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchDown
  id: TouchDown
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchDown
  nameWithType: ContentElement.TouchDown
  fullName: System.Windows.ContentElement.TouchDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に触れると発生します。"
  remarks: "既定では、<xref:System.Windows.ContentElement.PreviewTouchDown>し、指が画面に触れるし、移動するまで接地イベントは発生しません</xref:System.Windows.ContentElement.PreviewTouchDown>。 移動することがなく保持したりする画面に指を押すと、キーを押して発生して<xref:System.Windows.Input.Stylus>。</xref:System.Windows.Input.Stylus>の動作を保持 プレス アンド ホールド動作は、マウスの右クリックに相当します。       により、<xref:System.Windows.ContentElement.PreviewTouchDown>接地イベントは、画面に触れるとすぐにも発生を設定し、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName>添付プロパティ`false`この要素の</xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName></xref:System.Windows.ContentElement.PreviewTouchDown>。      <a name=&quot;routedEventInfo_TouchDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.TouchDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewTouchDown>.</xref:System.Windows.ContentElement.PreviewTouchDown> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.ContentElement.TouchDownEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnTouchDown%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchDown;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchDownEvent
  id: TouchDownEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchDownEvent
  nameWithType: ContentElement.TouchDownEvent
  fullName: System.Windows.ContentElement.TouchDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.TouchDown&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchEnter
  id: TouchEnter
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchEnter
  nameWithType: ContentElement.TouchEnter
  fullName: System.Windows.ContentElement.TouchEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "タッチから移動するときに発生するこの要素の境界内の外部です。"
  remarks: "このイベントはこの UI 要素にタッチ デバイスがキャプチャされるかどうか常に発生します。      <a name=&quot;routedEventInfo_TouchEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.TouchEnterEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.ContentElement.OnTouchEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnTouchEnter%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.ContentElement.TouchEnterEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchEnter;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchEnterEvent
  id: TouchEnterEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchEnterEvent
  nameWithType: ContentElement.TouchEnterEvent
  fullName: System.Windows.ContentElement.TouchEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.TouchEnter&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchesCaptured
  id: TouchesCaptured
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchesCaptured
  nameWithType: ContentElement.TouchesCaptured
  fullName: System.Windows.ContentElement.TouchesCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にキャプチャされているすべてのタッチ デバイスを取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesCaptured { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>をこの要素にキャプチャされているオブジェクト。"
  overload: System.Windows.ContentElement.TouchesCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchesCapturedWithin
  id: TouchesCapturedWithin
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchesCapturedWithin
  nameWithType: ContentElement.TouchesCapturedWithin
  fullName: System.Windows.ContentElement.TouchesCapturedWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "そのビジュアル ツリー内には、この要素にキャプチャされているすべてのタッチ デバイスまたはすべての子要素を取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesCapturedWithin { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>この要素またはそのビジュアル ツリー内のすべての子要素にキャプチャされているオブジェクト。"
  overload: System.Windows.ContentElement.TouchesCapturedWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchesDirectlyOver
  id: TouchesDirectlyOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchesDirectlyOver
  nameWithType: ContentElement.TouchesDirectlyOver
  fullName: System.Windows.ContentElement.TouchesDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にあるすべてのタッチ デバイスを取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesDirectlyOver { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>この要素の上にあるオブジェクト。"
  overload: System.Windows.ContentElement.TouchesDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchesOver
  id: TouchesOver
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchesOver
  nameWithType: ContentElement.TouchesOver
  fullName: System.Windows.ContentElement.TouchesOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "そのビジュアル ツリー内には、この要素の上にあるすべてのタッチ デバイスまたはすべての子要素を取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesOver { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>この要素またはそのビジュアル ツリー内のすべての子要素の上にあるオブジェクト。"
  overload: System.Windows.ContentElement.TouchesOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchLeave
  id: TouchLeave
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchLeave
  nameWithType: ContentElement.TouchLeave
  fullName: System.Windows.ContentElement.TouchLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "タッチから移動するときに発生するこの要素の境界の外側の内部です。"
  remarks: "<a name=&quot;routedEventInfo_TouchLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.TouchLeaveEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.ContentElement.OnTouchLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnTouchLeave%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.ContentElement.TouchLeaveEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchLeave;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchLeaveEvent
  id: TouchLeaveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchLeaveEvent
  nameWithType: ContentElement.TouchLeaveEvent
  fullName: System.Windows.ContentElement.TouchLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.TouchLeave&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchMove
  id: TouchMove
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchMove
  nameWithType: ContentElement.TouchMove
  fullName: System.Windows.ContentElement.TouchMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に指を動かしたときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_TouchMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.TouchMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewTouchMove>.</xref:System.Windows.ContentElement.PreviewTouchMove> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.ContentElement.TouchMoveEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnTouchMove%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchMove;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchMoveEvent
  id: TouchMoveEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchMoveEvent
  nameWithType: ContentElement.TouchMoveEvent
  fullName: System.Windows.ContentElement.TouchMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.TouchMove&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchUp
  id: TouchUp
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchUp
  nameWithType: ContentElement.TouchUp
  fullName: System.Windows.ContentElement.TouchUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面から離れる指が発生したときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_TouchUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.ContentElement.TouchUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-トンネリング イベントは<xref:System.Windows.ContentElement.PreviewTouchUp>.</xref:System.Windows.ContentElement.PreviewTouchUp> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.ContentElement.TouchUpEvent>      -オーバーライド<xref:System.Windows.ContentElement.OnTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.ContentElement.OnTouchUp%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchUp;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.ContentElement.TouchUpEvent
  id: TouchUpEvent
  parent: System.Windows.ContentElement
  langs:
  - csharp
  name: TouchUpEvent
  nameWithType: ContentElement.TouchUpEvent
  fullName: System.Windows.ContentElement.TouchUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.ContentElement.TouchUp&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.DependencyObject
  isExternal: false
  name: System.Windows.DependencyObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Windows.ContentElement.#ctor
  parent: System.Windows.ContentElement
  isExternal: false
  name: ContentElement()
  nameWithType: ContentElement.ContentElement()
  fullName: System.Windows.ContentElement.ContentElement()
- uid: System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.ContentElement
  isExternal: false
  name: AddHandler(RoutedEvent,Delegate)
  nameWithType: ContentElement.AddHandler(RoutedEvent,Delegate)
  fullName: System.Windows.ContentElement.AddHandler(RoutedEvent,Delegate)
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  parent: System.Windows.ContentElement
  isExternal: false
  name: AddHandler(RoutedEvent,Delegate,Boolean)
  nameWithType: ContentElement.AddHandler(RoutedEvent,Delegate,Boolean)
  fullName: System.Windows.ContentElement.AddHandler(RoutedEvent,Delegate,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: AddToEventRoute(EventRoute,RoutedEventArgs)
  nameWithType: ContentElement.AddToEventRoute(EventRoute,RoutedEventArgs)
  fullName: System.Windows.ContentElement.AddToEventRoute(EventRoute,RoutedEventArgs)
- uid: System.Windows.EventRoute
  parent: System.Windows
  isExternal: false
  name: EventRoute
  nameWithType: EventRoute
  fullName: System.Windows.EventRoute
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.ContentElement.AllowDrop
  parent: System.Windows.ContentElement
  isExternal: false
  name: AllowDrop
  nameWithType: ContentElement.AllowDrop
  fullName: System.Windows.ContentElement.AllowDrop
- uid: System.Windows.ContentElement.AllowDropProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: AllowDropProperty
  nameWithType: ContentElement.AllowDropProperty
  fullName: System.Windows.ContentElement.AllowDropProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.ContentElement
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
- uid: System.Windows.Media.Animation.AnimationClock
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationClock
  nameWithType: AnimationClock
  fullName: System.Windows.Media.Animation.AnimationClock
- uid: System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.ContentElement
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.ContentElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.ContentElement.AreAnyTouchesCaptured
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesCaptured
  nameWithType: ContentElement.AreAnyTouchesCaptured
  fullName: System.Windows.ContentElement.AreAnyTouchesCaptured
- uid: System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesCapturedProperty
  nameWithType: ContentElement.AreAnyTouchesCapturedProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesCapturedProperty
- uid: System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesCapturedWithin
  nameWithType: ContentElement.AreAnyTouchesCapturedWithin
  fullName: System.Windows.ContentElement.AreAnyTouchesCapturedWithin
- uid: System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesCapturedWithinProperty
  nameWithType: ContentElement.AreAnyTouchesCapturedWithinProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
- uid: System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesDirectlyOver
  nameWithType: ContentElement.AreAnyTouchesDirectlyOver
  fullName: System.Windows.ContentElement.AreAnyTouchesDirectlyOver
- uid: System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesDirectlyOverProperty
  nameWithType: ContentElement.AreAnyTouchesDirectlyOverProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
- uid: System.Windows.ContentElement.AreAnyTouchesOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesOver
  nameWithType: ContentElement.AreAnyTouchesOver
  fullName: System.Windows.ContentElement.AreAnyTouchesOver
- uid: System.Windows.ContentElement.AreAnyTouchesOverProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesOverProperty
  nameWithType: ContentElement.AreAnyTouchesOverProperty
  fullName: System.Windows.ContentElement.AreAnyTouchesOverProperty
- uid: System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.ContentElement
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline)
- uid: System.Windows.Media.Animation.AnimationTimeline
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationTimeline
  nameWithType: AnimationTimeline
  fullName: System.Windows.Media.Animation.AnimationTimeline
- uid: System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.ContentElement
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.ContentElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
- uid: System.Windows.ContentElement.CaptureMouse
  parent: System.Windows.ContentElement
  isExternal: false
  name: CaptureMouse()
  nameWithType: ContentElement.CaptureMouse()
  fullName: System.Windows.ContentElement.CaptureMouse()
- uid: System.Windows.ContentElement.CaptureStylus
  parent: System.Windows.ContentElement
  isExternal: false
  name: CaptureStylus()
  nameWithType: ContentElement.CaptureStylus()
  fullName: System.Windows.ContentElement.CaptureStylus()
- uid: System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  parent: System.Windows.ContentElement
  isExternal: false
  name: CaptureTouch(TouchDevice)
  nameWithType: ContentElement.CaptureTouch(TouchDevice)
  fullName: System.Windows.ContentElement.CaptureTouch(TouchDevice)
- uid: System.Windows.Input.TouchDevice
  parent: System.Windows.Input
  isExternal: false
  name: TouchDevice
  nameWithType: TouchDevice
  fullName: System.Windows.Input.TouchDevice
- uid: System.Windows.ContentElement.CommandBindings
  parent: System.Windows.ContentElement
  isExternal: false
  name: CommandBindings
  nameWithType: ContentElement.CommandBindings
  fullName: System.Windows.ContentElement.CommandBindings
- uid: System.Windows.Input.CommandBindingCollection
  parent: System.Windows.Input
  isExternal: false
  name: CommandBindingCollection
  nameWithType: CommandBindingCollection
  fullName: System.Windows.Input.CommandBindingCollection
- uid: System.Windows.ContentElement.DragEnter
  parent: System.Windows.ContentElement
  isExternal: false
  name: DragEnter
  nameWithType: ContentElement.DragEnter
  fullName: System.Windows.ContentElement.DragEnter
- uid: System.Windows.DragEventHandler
  parent: System.Windows
  isExternal: false
  name: DragEventHandler
  nameWithType: DragEventHandler
  fullName: System.Windows.DragEventHandler
- uid: System.Windows.ContentElement.DragEnterEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: DragEnterEvent
  nameWithType: ContentElement.DragEnterEvent
  fullName: System.Windows.ContentElement.DragEnterEvent
- uid: System.Windows.ContentElement.DragLeave
  parent: System.Windows.ContentElement
  isExternal: false
  name: DragLeave
  nameWithType: ContentElement.DragLeave
  fullName: System.Windows.ContentElement.DragLeave
- uid: System.Windows.ContentElement.DragLeaveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: DragLeaveEvent
  nameWithType: ContentElement.DragLeaveEvent
  fullName: System.Windows.ContentElement.DragLeaveEvent
- uid: System.Windows.ContentElement.DragOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: DragOver
  nameWithType: ContentElement.DragOver
  fullName: System.Windows.ContentElement.DragOver
- uid: System.Windows.ContentElement.DragOverEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: DragOverEvent
  nameWithType: ContentElement.DragOverEvent
  fullName: System.Windows.ContentElement.DragOverEvent
- uid: System.Windows.ContentElement.Drop
  parent: System.Windows.ContentElement
  isExternal: false
  name: Drop
  nameWithType: ContentElement.Drop
  fullName: System.Windows.ContentElement.Drop
- uid: System.Windows.ContentElement.DropEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: DropEvent
  nameWithType: ContentElement.DropEvent
  fullName: System.Windows.ContentElement.DropEvent
- uid: System.Windows.ContentElement.Focus
  parent: System.Windows.ContentElement
  isExternal: false
  name: Focus()
  nameWithType: ContentElement.Focus()
  fullName: System.Windows.ContentElement.Focus()
- uid: System.Windows.ContentElement.Focusable
  parent: System.Windows.ContentElement
  isExternal: false
  name: Focusable
  nameWithType: ContentElement.Focusable
  fullName: System.Windows.ContentElement.Focusable
- uid: System.Windows.ContentElement.FocusableChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: FocusableChanged
  nameWithType: ContentElement.FocusableChanged
  fullName: System.Windows.ContentElement.FocusableChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.ContentElement.FocusableProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: FocusableProperty
  nameWithType: ContentElement.FocusableProperty
  fullName: System.Windows.ContentElement.FocusableProperty
- uid: System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.ContentElement
  isExternal: false
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: ContentElement.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.ContentElement.GetAnimationBaseValue(DependencyProperty)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.ContentElement.GetUIParentCore
  parent: System.Windows.ContentElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: ContentElement.GetUIParentCore()
  fullName: System.Windows.ContentElement.GetUIParentCore()
- uid: System.Windows.ContentElement.GiveFeedback
  parent: System.Windows.ContentElement
  isExternal: false
  name: GiveFeedback
  nameWithType: ContentElement.GiveFeedback
  fullName: System.Windows.ContentElement.GiveFeedback
- uid: System.Windows.GiveFeedbackEventHandler
  parent: System.Windows
  isExternal: false
  name: GiveFeedbackEventHandler
  nameWithType: GiveFeedbackEventHandler
  fullName: System.Windows.GiveFeedbackEventHandler
- uid: System.Windows.ContentElement.GiveFeedbackEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: GiveFeedbackEvent
  nameWithType: ContentElement.GiveFeedbackEvent
  fullName: System.Windows.ContentElement.GiveFeedbackEvent
- uid: System.Windows.ContentElement.GotFocus
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotFocus
  nameWithType: ContentElement.GotFocus
  fullName: System.Windows.ContentElement.GotFocus
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.ContentElement.GotFocusEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotFocusEvent
  nameWithType: ContentElement.GotFocusEvent
  fullName: System.Windows.ContentElement.GotFocusEvent
- uid: System.Windows.ContentElement.GotKeyboardFocus
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotKeyboardFocus
  nameWithType: ContentElement.GotKeyboardFocus
  fullName: System.Windows.ContentElement.GotKeyboardFocus
- uid: System.Windows.Input.KeyboardFocusChangedEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: KeyboardFocusChangedEventHandler
  nameWithType: KeyboardFocusChangedEventHandler
  fullName: System.Windows.Input.KeyboardFocusChangedEventHandler
- uid: System.Windows.ContentElement.GotKeyboardFocusEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotKeyboardFocusEvent
  nameWithType: ContentElement.GotKeyboardFocusEvent
  fullName: System.Windows.ContentElement.GotKeyboardFocusEvent
- uid: System.Windows.ContentElement.GotMouseCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotMouseCapture
  nameWithType: ContentElement.GotMouseCapture
  fullName: System.Windows.ContentElement.GotMouseCapture
- uid: System.Windows.Input.MouseEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: MouseEventHandler
  nameWithType: MouseEventHandler
  fullName: System.Windows.Input.MouseEventHandler
- uid: System.Windows.ContentElement.GotMouseCaptureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotMouseCaptureEvent
  nameWithType: ContentElement.GotMouseCaptureEvent
  fullName: System.Windows.ContentElement.GotMouseCaptureEvent
- uid: System.Windows.ContentElement.GotStylusCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotStylusCapture
  nameWithType: ContentElement.GotStylusCapture
  fullName: System.Windows.ContentElement.GotStylusCapture
- uid: System.Windows.Input.StylusEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusEventHandler
  nameWithType: StylusEventHandler
  fullName: System.Windows.Input.StylusEventHandler
- uid: System.Windows.ContentElement.GotStylusCaptureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotStylusCaptureEvent
  nameWithType: ContentElement.GotStylusCaptureEvent
  fullName: System.Windows.ContentElement.GotStylusCaptureEvent
- uid: System.Windows.ContentElement.GotTouchCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotTouchCapture
  nameWithType: ContentElement.GotTouchCapture
  fullName: System.Windows.ContentElement.GotTouchCapture
- uid: System.EventHandler{System.Windows.Input.TouchEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TouchEventArgs>
  nameWithType: EventHandler<TouchEventArgs>
  fullName: System.EventHandler<System.Windows.Input.TouchEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.TouchEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.TouchEventArgs
    name: TouchEventArgs
    nameWithType: TouchEventArgs
    fullName: TouchEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.ContentElement.GotTouchCaptureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: GotTouchCaptureEvent
  nameWithType: ContentElement.GotTouchCaptureEvent
  fullName: System.Windows.ContentElement.GotTouchCaptureEvent
- uid: System.Windows.ContentElement.HasAnimatedProperties
  parent: System.Windows.ContentElement
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: ContentElement.HasAnimatedProperties
  fullName: System.Windows.ContentElement.HasAnimatedProperties
- uid: System.Windows.ContentElement.InputBindings
  parent: System.Windows.ContentElement
  isExternal: false
  name: InputBindings
  nameWithType: ContentElement.InputBindings
  fullName: System.Windows.ContentElement.InputBindings
- uid: System.Windows.Input.InputBindingCollection
  parent: System.Windows.Input
  isExternal: false
  name: InputBindingCollection
  nameWithType: InputBindingCollection
  fullName: System.Windows.Input.InputBindingCollection
- uid: System.Windows.ContentElement.IsEnabled
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsEnabled
  nameWithType: ContentElement.IsEnabled
  fullName: System.Windows.ContentElement.IsEnabled
- uid: System.Windows.ContentElement.IsEnabledChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsEnabledChanged
  nameWithType: ContentElement.IsEnabledChanged
  fullName: System.Windows.ContentElement.IsEnabledChanged
- uid: System.Windows.ContentElement.IsEnabledCore
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsEnabledCore
  nameWithType: ContentElement.IsEnabledCore
  fullName: System.Windows.ContentElement.IsEnabledCore
- uid: System.Windows.ContentElement.IsEnabledProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsEnabledProperty
  nameWithType: ContentElement.IsEnabledProperty
  fullName: System.Windows.ContentElement.IsEnabledProperty
- uid: System.Windows.ContentElement.IsFocused
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsFocused
  nameWithType: ContentElement.IsFocused
  fullName: System.Windows.ContentElement.IsFocused
- uid: System.Windows.ContentElement.IsFocusedProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsFocusedProperty
  nameWithType: ContentElement.IsFocusedProperty
  fullName: System.Windows.ContentElement.IsFocusedProperty
- uid: System.Windows.ContentElement.IsInputMethodEnabled
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsInputMethodEnabled
  nameWithType: ContentElement.IsInputMethodEnabled
  fullName: System.Windows.ContentElement.IsInputMethodEnabled
- uid: System.Windows.ContentElement.IsKeyboardFocused
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocused
  nameWithType: ContentElement.IsKeyboardFocused
  fullName: System.Windows.ContentElement.IsKeyboardFocused
- uid: System.Windows.ContentElement.IsKeyboardFocusedChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocusedChanged
  nameWithType: ContentElement.IsKeyboardFocusedChanged
  fullName: System.Windows.ContentElement.IsKeyboardFocusedChanged
- uid: System.Windows.ContentElement.IsKeyboardFocusedProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocusedProperty
  nameWithType: ContentElement.IsKeyboardFocusedProperty
  fullName: System.Windows.ContentElement.IsKeyboardFocusedProperty
- uid: System.Windows.ContentElement.IsKeyboardFocusWithin
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocusWithin
  nameWithType: ContentElement.IsKeyboardFocusWithin
  fullName: System.Windows.ContentElement.IsKeyboardFocusWithin
- uid: System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocusWithinChanged
  nameWithType: ContentElement.IsKeyboardFocusWithinChanged
  fullName: System.Windows.ContentElement.IsKeyboardFocusWithinChanged
- uid: System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocusWithinProperty
  nameWithType: ContentElement.IsKeyboardFocusWithinProperty
  fullName: System.Windows.ContentElement.IsKeyboardFocusWithinProperty
- uid: System.Windows.ContentElement.IsMouseCaptured
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCaptured
  nameWithType: ContentElement.IsMouseCaptured
  fullName: System.Windows.ContentElement.IsMouseCaptured
- uid: System.Windows.ContentElement.IsMouseCapturedChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCapturedChanged
  nameWithType: ContentElement.IsMouseCapturedChanged
  fullName: System.Windows.ContentElement.IsMouseCapturedChanged
- uid: System.Windows.ContentElement.IsMouseCapturedProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCapturedProperty
  nameWithType: ContentElement.IsMouseCapturedProperty
  fullName: System.Windows.ContentElement.IsMouseCapturedProperty
- uid: System.Windows.ContentElement.IsMouseCaptureWithin
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCaptureWithin
  nameWithType: ContentElement.IsMouseCaptureWithin
  fullName: System.Windows.ContentElement.IsMouseCaptureWithin
- uid: System.Windows.ContentElement.IsMouseCaptureWithinChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCaptureWithinChanged
  nameWithType: ContentElement.IsMouseCaptureWithinChanged
  fullName: System.Windows.ContentElement.IsMouseCaptureWithinChanged
- uid: System.Windows.ContentElement.IsMouseCaptureWithinProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCaptureWithinProperty
  nameWithType: ContentElement.IsMouseCaptureWithinProperty
  fullName: System.Windows.ContentElement.IsMouseCaptureWithinProperty
- uid: System.Windows.ContentElement.IsMouseDirectlyOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseDirectlyOver
  nameWithType: ContentElement.IsMouseDirectlyOver
  fullName: System.Windows.ContentElement.IsMouseDirectlyOver
- uid: System.Windows.ContentElement.IsMouseDirectlyOverChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseDirectlyOverChanged
  nameWithType: ContentElement.IsMouseDirectlyOverChanged
  fullName: System.Windows.ContentElement.IsMouseDirectlyOverChanged
- uid: System.Windows.ContentElement.IsMouseDirectlyOverProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseDirectlyOverProperty
  nameWithType: ContentElement.IsMouseDirectlyOverProperty
  fullName: System.Windows.ContentElement.IsMouseDirectlyOverProperty
- uid: System.Windows.ContentElement.IsMouseOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseOver
  nameWithType: ContentElement.IsMouseOver
  fullName: System.Windows.ContentElement.IsMouseOver
- uid: System.Windows.ContentElement.IsMouseOverProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseOverProperty
  nameWithType: ContentElement.IsMouseOverProperty
  fullName: System.Windows.ContentElement.IsMouseOverProperty
- uid: System.Windows.ContentElement.IsStylusCaptured
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCaptured
  nameWithType: ContentElement.IsStylusCaptured
  fullName: System.Windows.ContentElement.IsStylusCaptured
- uid: System.Windows.ContentElement.IsStylusCapturedChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCapturedChanged
  nameWithType: ContentElement.IsStylusCapturedChanged
  fullName: System.Windows.ContentElement.IsStylusCapturedChanged
- uid: System.Windows.ContentElement.IsStylusCapturedProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCapturedProperty
  nameWithType: ContentElement.IsStylusCapturedProperty
  fullName: System.Windows.ContentElement.IsStylusCapturedProperty
- uid: System.Windows.ContentElement.IsStylusCaptureWithin
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCaptureWithin
  nameWithType: ContentElement.IsStylusCaptureWithin
  fullName: System.Windows.ContentElement.IsStylusCaptureWithin
- uid: System.Windows.ContentElement.IsStylusCaptureWithinChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCaptureWithinChanged
  nameWithType: ContentElement.IsStylusCaptureWithinChanged
  fullName: System.Windows.ContentElement.IsStylusCaptureWithinChanged
- uid: System.Windows.ContentElement.IsStylusCaptureWithinProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCaptureWithinProperty
  nameWithType: ContentElement.IsStylusCaptureWithinProperty
  fullName: System.Windows.ContentElement.IsStylusCaptureWithinProperty
- uid: System.Windows.ContentElement.IsStylusDirectlyOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusDirectlyOver
  nameWithType: ContentElement.IsStylusDirectlyOver
  fullName: System.Windows.ContentElement.IsStylusDirectlyOver
- uid: System.Windows.ContentElement.IsStylusDirectlyOverChanged
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusDirectlyOverChanged
  nameWithType: ContentElement.IsStylusDirectlyOverChanged
  fullName: System.Windows.ContentElement.IsStylusDirectlyOverChanged
- uid: System.Windows.ContentElement.IsStylusDirectlyOverProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusDirectlyOverProperty
  nameWithType: ContentElement.IsStylusDirectlyOverProperty
  fullName: System.Windows.ContentElement.IsStylusDirectlyOverProperty
- uid: System.Windows.ContentElement.IsStylusOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusOver
  nameWithType: ContentElement.IsStylusOver
  fullName: System.Windows.ContentElement.IsStylusOver
- uid: System.Windows.ContentElement.IsStylusOverProperty
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusOverProperty
  nameWithType: ContentElement.IsStylusOverProperty
  fullName: System.Windows.ContentElement.IsStylusOverProperty
- uid: System.Windows.ContentElement.KeyDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: KeyDown
  nameWithType: ContentElement.KeyDown
  fullName: System.Windows.ContentElement.KeyDown
- uid: System.Windows.Input.KeyEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: KeyEventHandler
  nameWithType: KeyEventHandler
  fullName: System.Windows.Input.KeyEventHandler
- uid: System.Windows.ContentElement.KeyDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: KeyDownEvent
  nameWithType: ContentElement.KeyDownEvent
  fullName: System.Windows.ContentElement.KeyDownEvent
- uid: System.Windows.ContentElement.KeyUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: KeyUp
  nameWithType: ContentElement.KeyUp
  fullName: System.Windows.ContentElement.KeyUp
- uid: System.Windows.ContentElement.KeyUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: KeyUpEvent
  nameWithType: ContentElement.KeyUpEvent
  fullName: System.Windows.ContentElement.KeyUpEvent
- uid: System.Windows.ContentElement.LostFocus
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostFocus
  nameWithType: ContentElement.LostFocus
  fullName: System.Windows.ContentElement.LostFocus
- uid: System.Windows.ContentElement.LostFocusEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostFocusEvent
  nameWithType: ContentElement.LostFocusEvent
  fullName: System.Windows.ContentElement.LostFocusEvent
- uid: System.Windows.ContentElement.LostKeyboardFocus
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostKeyboardFocus
  nameWithType: ContentElement.LostKeyboardFocus
  fullName: System.Windows.ContentElement.LostKeyboardFocus
- uid: System.Windows.ContentElement.LostKeyboardFocusEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostKeyboardFocusEvent
  nameWithType: ContentElement.LostKeyboardFocusEvent
  fullName: System.Windows.ContentElement.LostKeyboardFocusEvent
- uid: System.Windows.ContentElement.LostMouseCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostMouseCapture
  nameWithType: ContentElement.LostMouseCapture
  fullName: System.Windows.ContentElement.LostMouseCapture
- uid: System.Windows.ContentElement.LostMouseCaptureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostMouseCaptureEvent
  nameWithType: ContentElement.LostMouseCaptureEvent
  fullName: System.Windows.ContentElement.LostMouseCaptureEvent
- uid: System.Windows.ContentElement.LostStylusCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostStylusCapture
  nameWithType: ContentElement.LostStylusCapture
  fullName: System.Windows.ContentElement.LostStylusCapture
- uid: System.Windows.ContentElement.LostStylusCaptureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostStylusCaptureEvent
  nameWithType: ContentElement.LostStylusCaptureEvent
  fullName: System.Windows.ContentElement.LostStylusCaptureEvent
- uid: System.Windows.ContentElement.LostTouchCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostTouchCapture
  nameWithType: ContentElement.LostTouchCapture
  fullName: System.Windows.ContentElement.LostTouchCapture
- uid: System.Windows.ContentElement.LostTouchCaptureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: LostTouchCaptureEvent
  nameWithType: ContentElement.LostTouchCaptureEvent
  fullName: System.Windows.ContentElement.LostTouchCaptureEvent
- uid: System.Windows.ContentElement.MouseDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseDown
  nameWithType: ContentElement.MouseDown
  fullName: System.Windows.ContentElement.MouseDown
- uid: System.Windows.Input.MouseButtonEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: MouseButtonEventHandler
  nameWithType: MouseButtonEventHandler
  fullName: System.Windows.Input.MouseButtonEventHandler
- uid: System.Windows.ContentElement.MouseDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseDownEvent
  nameWithType: ContentElement.MouseDownEvent
  fullName: System.Windows.ContentElement.MouseDownEvent
- uid: System.Windows.ContentElement.MouseEnter
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseEnter
  nameWithType: ContentElement.MouseEnter
  fullName: System.Windows.ContentElement.MouseEnter
- uid: System.Windows.ContentElement.MouseEnterEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseEnterEvent
  nameWithType: ContentElement.MouseEnterEvent
  fullName: System.Windows.ContentElement.MouseEnterEvent
- uid: System.Windows.ContentElement.MouseLeave
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseLeave
  nameWithType: ContentElement.MouseLeave
  fullName: System.Windows.ContentElement.MouseLeave
- uid: System.Windows.ContentElement.MouseLeaveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseLeaveEvent
  nameWithType: ContentElement.MouseLeaveEvent
  fullName: System.Windows.ContentElement.MouseLeaveEvent
- uid: System.Windows.ContentElement.MouseLeftButtonDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseLeftButtonDown
  nameWithType: ContentElement.MouseLeftButtonDown
  fullName: System.Windows.ContentElement.MouseLeftButtonDown
- uid: System.Windows.ContentElement.MouseLeftButtonDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseLeftButtonDownEvent
  nameWithType: ContentElement.MouseLeftButtonDownEvent
  fullName: System.Windows.ContentElement.MouseLeftButtonDownEvent
- uid: System.Windows.ContentElement.MouseLeftButtonUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseLeftButtonUp
  nameWithType: ContentElement.MouseLeftButtonUp
  fullName: System.Windows.ContentElement.MouseLeftButtonUp
- uid: System.Windows.ContentElement.MouseLeftButtonUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseLeftButtonUpEvent
  nameWithType: ContentElement.MouseLeftButtonUpEvent
  fullName: System.Windows.ContentElement.MouseLeftButtonUpEvent
- uid: System.Windows.ContentElement.MouseMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseMove
  nameWithType: ContentElement.MouseMove
  fullName: System.Windows.ContentElement.MouseMove
- uid: System.Windows.ContentElement.MouseMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseMoveEvent
  nameWithType: ContentElement.MouseMoveEvent
  fullName: System.Windows.ContentElement.MouseMoveEvent
- uid: System.Windows.ContentElement.MouseRightButtonDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseRightButtonDown
  nameWithType: ContentElement.MouseRightButtonDown
  fullName: System.Windows.ContentElement.MouseRightButtonDown
- uid: System.Windows.ContentElement.MouseRightButtonDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseRightButtonDownEvent
  nameWithType: ContentElement.MouseRightButtonDownEvent
  fullName: System.Windows.ContentElement.MouseRightButtonDownEvent
- uid: System.Windows.ContentElement.MouseRightButtonUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseRightButtonUp
  nameWithType: ContentElement.MouseRightButtonUp
  fullName: System.Windows.ContentElement.MouseRightButtonUp
- uid: System.Windows.ContentElement.MouseRightButtonUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseRightButtonUpEvent
  nameWithType: ContentElement.MouseRightButtonUpEvent
  fullName: System.Windows.ContentElement.MouseRightButtonUpEvent
- uid: System.Windows.ContentElement.MouseUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseUp
  nameWithType: ContentElement.MouseUp
  fullName: System.Windows.ContentElement.MouseUp
- uid: System.Windows.ContentElement.MouseUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseUpEvent
  nameWithType: ContentElement.MouseUpEvent
  fullName: System.Windows.ContentElement.MouseUpEvent
- uid: System.Windows.ContentElement.MouseWheel
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseWheel
  nameWithType: ContentElement.MouseWheel
  fullName: System.Windows.ContentElement.MouseWheel
- uid: System.Windows.Input.MouseWheelEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: MouseWheelEventHandler
  nameWithType: MouseWheelEventHandler
  fullName: System.Windows.Input.MouseWheelEventHandler
- uid: System.Windows.ContentElement.MouseWheelEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: MouseWheelEvent
  nameWithType: ContentElement.MouseWheelEvent
  fullName: System.Windows.ContentElement.MouseWheelEvent
- uid: System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.ContentElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: ContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.ContentElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.ContentElement.OnCreateAutomationPeer
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnCreateAutomationPeer()
  nameWithType: ContentElement.OnCreateAutomationPeer()
  fullName: System.Windows.ContentElement.OnCreateAutomationPeer()
- uid: System.Windows.Automation.Peers.AutomationPeer
  parent: System.Windows.Automation.Peers
  isExternal: false
  name: AutomationPeer
  nameWithType: AutomationPeer
  fullName: System.Windows.Automation.Peers.AutomationPeer
- uid: System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDragEnter(DragEventArgs)
  nameWithType: ContentElement.OnDragEnter(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDragEnter(DragEventArgs)
- uid: System.Windows.DragEventArgs
  parent: System.Windows
  isExternal: false
  name: DragEventArgs
  nameWithType: DragEventArgs
  fullName: System.Windows.DragEventArgs
- uid: System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDragLeave(DragEventArgs)
  nameWithType: ContentElement.OnDragLeave(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDragLeave(DragEventArgs)
- uid: System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDragOver(DragEventArgs)
  nameWithType: ContentElement.OnDragOver(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDragOver(DragEventArgs)
- uid: System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDrop(DragEventArgs)
  nameWithType: ContentElement.OnDrop(DragEventArgs)
  fullName: System.Windows.ContentElement.OnDrop(DragEventArgs)
- uid: System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: ContentElement.OnGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.ContentElement.OnGiveFeedback(GiveFeedbackEventArgs)
- uid: System.Windows.GiveFeedbackEventArgs
  parent: System.Windows
  isExternal: false
  name: GiveFeedbackEventArgs
  nameWithType: GiveFeedbackEventArgs
  fullName: System.Windows.GiveFeedbackEventArgs
- uid: System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: ContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.ContentElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.Input.KeyboardFocusChangedEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: KeyboardFocusChangedEventArgs
  nameWithType: KeyboardFocusChangedEventArgs
  fullName: System.Windows.Input.KeyboardFocusChangedEventArgs
- uid: System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotMouseCapture(MouseEventArgs)
  nameWithType: ContentElement.OnGotMouseCapture(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnGotMouseCapture(MouseEventArgs)
- uid: System.Windows.Input.MouseEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: MouseEventArgs
  nameWithType: MouseEventArgs
  fullName: System.Windows.Input.MouseEventArgs
- uid: System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotStylusCapture(StylusEventArgs)
  nameWithType: ContentElement.OnGotStylusCapture(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnGotStylusCapture(StylusEventArgs)
- uid: System.Windows.Input.StylusEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusEventArgs
  nameWithType: StylusEventArgs
  fullName: System.Windows.Input.StylusEventArgs
- uid: System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotTouchCapture(TouchEventArgs)
  nameWithType: ContentElement.OnGotTouchCapture(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnGotTouchCapture(TouchEventArgs)
- uid: System.Windows.Input.TouchEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: TouchEventArgs
  nameWithType: TouchEventArgs
  fullName: System.Windows.Input.TouchEventArgs
- uid: System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: ContentElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnKeyDown(KeyEventArgs)
  nameWithType: ContentElement.OnKeyDown(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnKeyDown(KeyEventArgs)
- uid: System.Windows.Input.KeyEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: KeyEventArgs
  nameWithType: KeyEventArgs
  fullName: System.Windows.Input.KeyEventArgs
- uid: System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnKeyUp(KeyEventArgs)
  nameWithType: ContentElement.OnKeyUp(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnKeyUp(KeyEventArgs)
- uid: System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostFocus(RoutedEventArgs)
  nameWithType: ContentElement.OnLostFocus(RoutedEventArgs)
  fullName: System.Windows.ContentElement.OnLostFocus(RoutedEventArgs)
- uid: System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostMouseCapture(MouseEventArgs)
  nameWithType: ContentElement.OnLostMouseCapture(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnLostMouseCapture(MouseEventArgs)
- uid: System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostStylusCapture(StylusEventArgs)
  nameWithType: ContentElement.OnLostStylusCapture(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnLostStylusCapture(StylusEventArgs)
- uid: System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostTouchCapture(TouchEventArgs)
  nameWithType: ContentElement.OnLostTouchCapture(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnLostTouchCapture(TouchEventArgs)
- uid: System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseDown(MouseButtonEventArgs)
- uid: System.Windows.Input.MouseButtonEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: MouseButtonEventArgs
  nameWithType: MouseButtonEventArgs
  fullName: System.Windows.Input.MouseButtonEventArgs
- uid: System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseEnter(MouseEventArgs)
  nameWithType: ContentElement.OnMouseEnter(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnMouseEnter(MouseEventArgs)
- uid: System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseLeave(MouseEventArgs)
  nameWithType: ContentElement.OnMouseLeave(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnMouseLeave(MouseEventArgs)
- uid: System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseMove(MouseEventArgs)
  nameWithType: ContentElement.OnMouseMove(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnMouseMove(MouseEventArgs)
- uid: System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseRightButtonDown(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseRightButtonUp(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnMouseUp(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseWheel(MouseWheelEventArgs)
  nameWithType: ContentElement.OnMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.ContentElement.OnMouseWheel(MouseWheelEventArgs)
- uid: System.Windows.Input.MouseWheelEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: MouseWheelEventArgs
  nameWithType: MouseWheelEventArgs
  fullName: System.Windows.Input.MouseWheelEventArgs
- uid: System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDragEnter(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDragEnter(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDragEnter(DragEventArgs)
- uid: System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDragLeave(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDragLeave(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDragLeave(DragEventArgs)
- uid: System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDragOver(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDragOver(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDragOver(DragEventArgs)
- uid: System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDrop(DragEventArgs)
  nameWithType: ContentElement.OnPreviewDrop(DragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewDrop(DragEventArgs)
- uid: System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: ContentElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
- uid: System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewKeyDown(KeyEventArgs)
  nameWithType: ContentElement.OnPreviewKeyDown(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewKeyDown(KeyEventArgs)
- uid: System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewKeyUp(KeyEventArgs)
  nameWithType: ContentElement.OnPreviewKeyUp(KeyEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewKeyUp(KeyEventArgs)
- uid: System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: ContentElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseDown(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseMove(MouseEventArgs)
  nameWithType: ContentElement.OnPreviewMouseMove(MouseEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseMove(MouseEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseUp(MouseButtonEventArgs)
  nameWithType: ContentElement.OnPreviewMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseUp(MouseButtonEventArgs)
- uid: System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseWheel(MouseWheelEventArgs)
  nameWithType: ContentElement.OnPreviewMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewMouseWheel(MouseWheelEventArgs)
- uid: System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: ContentElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
- uid: System.Windows.QueryContinueDragEventArgs
  parent: System.Windows
  isExternal: false
  name: QueryContinueDragEventArgs
  nameWithType: QueryContinueDragEventArgs
  fullName: System.Windows.QueryContinueDragEventArgs
- uid: System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusButtonDown(StylusButtonEventArgs)
  nameWithType: ContentElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
- uid: System.Windows.Input.StylusButtonEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusButtonEventArgs
  nameWithType: StylusButtonEventArgs
  fullName: System.Windows.Input.StylusButtonEventArgs
- uid: System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusButtonUp(StylusButtonEventArgs)
  nameWithType: ContentElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
- uid: System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusDown(StylusDownEventArgs)
  nameWithType: ContentElement.OnPreviewStylusDown(StylusDownEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusDown(StylusDownEventArgs)
- uid: System.Windows.Input.StylusDownEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusDownEventArgs
  nameWithType: StylusDownEventArgs
  fullName: System.Windows.Input.StylusDownEventArgs
- uid: System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusInAirMove(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusInAirMove(StylusEventArgs)
- uid: System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusInRange(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusInRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusInRange(StylusEventArgs)
- uid: System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusMove(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusMove(StylusEventArgs)
- uid: System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusOutOfRange(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusOutOfRange(StylusEventArgs)
- uid: System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: ContentElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
- uid: System.Windows.Input.StylusSystemGestureEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusSystemGestureEventArgs
  nameWithType: StylusSystemGestureEventArgs
  fullName: System.Windows.Input.StylusSystemGestureEventArgs
- uid: System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusUp(StylusEventArgs)
  nameWithType: ContentElement.OnPreviewStylusUp(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewStylusUp(StylusEventArgs)
- uid: System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTextInput(TextCompositionEventArgs)
  nameWithType: ContentElement.OnPreviewTextInput(TextCompositionEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTextInput(TextCompositionEventArgs)
- uid: System.Windows.Input.TextCompositionEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: TextCompositionEventArgs
  nameWithType: TextCompositionEventArgs
  fullName: System.Windows.Input.TextCompositionEventArgs
- uid: System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTouchDown(TouchEventArgs)
  nameWithType: ContentElement.OnPreviewTouchDown(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTouchDown(TouchEventArgs)
- uid: System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTouchMove(TouchEventArgs)
  nameWithType: ContentElement.OnPreviewTouchMove(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTouchMove(TouchEventArgs)
- uid: System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTouchUp(TouchEventArgs)
  nameWithType: ContentElement.OnPreviewTouchUp(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnPreviewTouchUp(TouchEventArgs)
- uid: System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: ContentElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.ContentElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
- uid: System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnQueryCursor(QueryCursorEventArgs)
  nameWithType: ContentElement.OnQueryCursor(QueryCursorEventArgs)
  fullName: System.Windows.ContentElement.OnQueryCursor(QueryCursorEventArgs)
- uid: System.Windows.Input.QueryCursorEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: QueryCursorEventArgs
  nameWithType: QueryCursorEventArgs
  fullName: System.Windows.Input.QueryCursorEventArgs
- uid: System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusButtonDown(StylusButtonEventArgs)
  nameWithType: ContentElement.OnStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnStylusButtonDown(StylusButtonEventArgs)
- uid: System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusButtonUp(StylusButtonEventArgs)
  nameWithType: ContentElement.OnStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.ContentElement.OnStylusButtonUp(StylusButtonEventArgs)
- uid: System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusDown(StylusDownEventArgs)
  nameWithType: ContentElement.OnStylusDown(StylusDownEventArgs)
  fullName: System.Windows.ContentElement.OnStylusDown(StylusDownEventArgs)
- uid: System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusEnter(StylusEventArgs)
  nameWithType: ContentElement.OnStylusEnter(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusEnter(StylusEventArgs)
- uid: System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusInAirMove(StylusEventArgs)
  nameWithType: ContentElement.OnStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusInAirMove(StylusEventArgs)
- uid: System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusInRange(StylusEventArgs)
  nameWithType: ContentElement.OnStylusInRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusInRange(StylusEventArgs)
- uid: System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusLeave(StylusEventArgs)
  nameWithType: ContentElement.OnStylusLeave(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusLeave(StylusEventArgs)
- uid: System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusMove(StylusEventArgs)
  nameWithType: ContentElement.OnStylusMove(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusMove(StylusEventArgs)
- uid: System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusOutOfRange(StylusEventArgs)
  nameWithType: ContentElement.OnStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusOutOfRange(StylusEventArgs)
- uid: System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: ContentElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.ContentElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
- uid: System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusUp(StylusEventArgs)
  nameWithType: ContentElement.OnStylusUp(StylusEventArgs)
  fullName: System.Windows.ContentElement.OnStylusUp(StylusEventArgs)
- uid: System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTextInput(TextCompositionEventArgs)
  nameWithType: ContentElement.OnTextInput(TextCompositionEventArgs)
  fullName: System.Windows.ContentElement.OnTextInput(TextCompositionEventArgs)
- uid: System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchDown(TouchEventArgs)
  nameWithType: ContentElement.OnTouchDown(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchDown(TouchEventArgs)
- uid: System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchEnter(TouchEventArgs)
  nameWithType: ContentElement.OnTouchEnter(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchEnter(TouchEventArgs)
- uid: System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchLeave(TouchEventArgs)
  nameWithType: ContentElement.OnTouchLeave(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchLeave(TouchEventArgs)
- uid: System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchMove(TouchEventArgs)
  nameWithType: ContentElement.OnTouchMove(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchMove(TouchEventArgs)
- uid: System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchUp(TouchEventArgs)
  nameWithType: ContentElement.OnTouchUp(TouchEventArgs)
  fullName: System.Windows.ContentElement.OnTouchUp(TouchEventArgs)
- uid: System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.ContentElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: ContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.ContentElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.ContentElement.PreviewDragEnter
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDragEnter
  nameWithType: ContentElement.PreviewDragEnter
  fullName: System.Windows.ContentElement.PreviewDragEnter
- uid: System.Windows.ContentElement.PreviewDragEnterEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDragEnterEvent
  nameWithType: ContentElement.PreviewDragEnterEvent
  fullName: System.Windows.ContentElement.PreviewDragEnterEvent
- uid: System.Windows.ContentElement.PreviewDragLeave
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDragLeave
  nameWithType: ContentElement.PreviewDragLeave
  fullName: System.Windows.ContentElement.PreviewDragLeave
- uid: System.Windows.ContentElement.PreviewDragLeaveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDragLeaveEvent
  nameWithType: ContentElement.PreviewDragLeaveEvent
  fullName: System.Windows.ContentElement.PreviewDragLeaveEvent
- uid: System.Windows.ContentElement.PreviewDragOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDragOver
  nameWithType: ContentElement.PreviewDragOver
  fullName: System.Windows.ContentElement.PreviewDragOver
- uid: System.Windows.ContentElement.PreviewDragOverEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDragOverEvent
  nameWithType: ContentElement.PreviewDragOverEvent
  fullName: System.Windows.ContentElement.PreviewDragOverEvent
- uid: System.Windows.ContentElement.PreviewDrop
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDrop
  nameWithType: ContentElement.PreviewDrop
  fullName: System.Windows.ContentElement.PreviewDrop
- uid: System.Windows.ContentElement.PreviewDropEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewDropEvent
  nameWithType: ContentElement.PreviewDropEvent
  fullName: System.Windows.ContentElement.PreviewDropEvent
- uid: System.Windows.ContentElement.PreviewGiveFeedback
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewGiveFeedback
  nameWithType: ContentElement.PreviewGiveFeedback
  fullName: System.Windows.ContentElement.PreviewGiveFeedback
- uid: System.Windows.ContentElement.PreviewGiveFeedbackEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewGiveFeedbackEvent
  nameWithType: ContentElement.PreviewGiveFeedbackEvent
  fullName: System.Windows.ContentElement.PreviewGiveFeedbackEvent
- uid: System.Windows.ContentElement.PreviewGotKeyboardFocus
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewGotKeyboardFocus
  nameWithType: ContentElement.PreviewGotKeyboardFocus
  fullName: System.Windows.ContentElement.PreviewGotKeyboardFocus
- uid: System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewGotKeyboardFocusEvent
  nameWithType: ContentElement.PreviewGotKeyboardFocusEvent
  fullName: System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
- uid: System.Windows.ContentElement.PreviewKeyDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewKeyDown
  nameWithType: ContentElement.PreviewKeyDown
  fullName: System.Windows.ContentElement.PreviewKeyDown
- uid: System.Windows.ContentElement.PreviewKeyDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewKeyDownEvent
  nameWithType: ContentElement.PreviewKeyDownEvent
  fullName: System.Windows.ContentElement.PreviewKeyDownEvent
- uid: System.Windows.ContentElement.PreviewKeyUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewKeyUp
  nameWithType: ContentElement.PreviewKeyUp
  fullName: System.Windows.ContentElement.PreviewKeyUp
- uid: System.Windows.ContentElement.PreviewKeyUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewKeyUpEvent
  nameWithType: ContentElement.PreviewKeyUpEvent
  fullName: System.Windows.ContentElement.PreviewKeyUpEvent
- uid: System.Windows.ContentElement.PreviewLostKeyboardFocus
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewLostKeyboardFocus
  nameWithType: ContentElement.PreviewLostKeyboardFocus
  fullName: System.Windows.ContentElement.PreviewLostKeyboardFocus
- uid: System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewLostKeyboardFocusEvent
  nameWithType: ContentElement.PreviewLostKeyboardFocusEvent
  fullName: System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
- uid: System.Windows.ContentElement.PreviewMouseDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseDown
  nameWithType: ContentElement.PreviewMouseDown
  fullName: System.Windows.ContentElement.PreviewMouseDown
- uid: System.Windows.ContentElement.PreviewMouseDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseDownEvent
  nameWithType: ContentElement.PreviewMouseDownEvent
  fullName: System.Windows.ContentElement.PreviewMouseDownEvent
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseLeftButtonDown
  nameWithType: ContentElement.PreviewMouseLeftButtonDown
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonDown
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseLeftButtonDownEvent
  nameWithType: ContentElement.PreviewMouseLeftButtonDownEvent
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseLeftButtonUp
  nameWithType: ContentElement.PreviewMouseLeftButtonUp
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonUp
- uid: System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseLeftButtonUpEvent
  nameWithType: ContentElement.PreviewMouseLeftButtonUpEvent
  fullName: System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
- uid: System.Windows.ContentElement.PreviewMouseMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseMove
  nameWithType: ContentElement.PreviewMouseMove
  fullName: System.Windows.ContentElement.PreviewMouseMove
- uid: System.Windows.ContentElement.PreviewMouseMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseMoveEvent
  nameWithType: ContentElement.PreviewMouseMoveEvent
  fullName: System.Windows.ContentElement.PreviewMouseMoveEvent
- uid: System.Windows.ContentElement.PreviewMouseRightButtonDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseRightButtonDown
  nameWithType: ContentElement.PreviewMouseRightButtonDown
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonDown
- uid: System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseRightButtonDownEvent
  nameWithType: ContentElement.PreviewMouseRightButtonDownEvent
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
- uid: System.Windows.ContentElement.PreviewMouseRightButtonUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseRightButtonUp
  nameWithType: ContentElement.PreviewMouseRightButtonUp
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonUp
- uid: System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseRightButtonUpEvent
  nameWithType: ContentElement.PreviewMouseRightButtonUpEvent
  fullName: System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
- uid: System.Windows.ContentElement.PreviewMouseUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseUp
  nameWithType: ContentElement.PreviewMouseUp
  fullName: System.Windows.ContentElement.PreviewMouseUp
- uid: System.Windows.ContentElement.PreviewMouseUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseUpEvent
  nameWithType: ContentElement.PreviewMouseUpEvent
  fullName: System.Windows.ContentElement.PreviewMouseUpEvent
- uid: System.Windows.ContentElement.PreviewMouseWheel
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseWheel
  nameWithType: ContentElement.PreviewMouseWheel
  fullName: System.Windows.ContentElement.PreviewMouseWheel
- uid: System.Windows.ContentElement.PreviewMouseWheelEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewMouseWheelEvent
  nameWithType: ContentElement.PreviewMouseWheelEvent
  fullName: System.Windows.ContentElement.PreviewMouseWheelEvent
- uid: System.Windows.ContentElement.PreviewQueryContinueDrag
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewQueryContinueDrag
  nameWithType: ContentElement.PreviewQueryContinueDrag
  fullName: System.Windows.ContentElement.PreviewQueryContinueDrag
- uid: System.Windows.QueryContinueDragEventHandler
  parent: System.Windows
  isExternal: false
  name: QueryContinueDragEventHandler
  nameWithType: QueryContinueDragEventHandler
  fullName: System.Windows.QueryContinueDragEventHandler
- uid: System.Windows.ContentElement.PreviewQueryContinueDragEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewQueryContinueDragEvent
  nameWithType: ContentElement.PreviewQueryContinueDragEvent
  fullName: System.Windows.ContentElement.PreviewQueryContinueDragEvent
- uid: System.Windows.ContentElement.PreviewStylusButtonDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusButtonDown
  nameWithType: ContentElement.PreviewStylusButtonDown
  fullName: System.Windows.ContentElement.PreviewStylusButtonDown
- uid: System.Windows.Input.StylusButtonEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusButtonEventHandler
  nameWithType: StylusButtonEventHandler
  fullName: System.Windows.Input.StylusButtonEventHandler
- uid: System.Windows.ContentElement.PreviewStylusButtonDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusButtonDownEvent
  nameWithType: ContentElement.PreviewStylusButtonDownEvent
  fullName: System.Windows.ContentElement.PreviewStylusButtonDownEvent
- uid: System.Windows.ContentElement.PreviewStylusButtonUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusButtonUp
  nameWithType: ContentElement.PreviewStylusButtonUp
  fullName: System.Windows.ContentElement.PreviewStylusButtonUp
- uid: System.Windows.ContentElement.PreviewStylusButtonUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusButtonUpEvent
  nameWithType: ContentElement.PreviewStylusButtonUpEvent
  fullName: System.Windows.ContentElement.PreviewStylusButtonUpEvent
- uid: System.Windows.ContentElement.PreviewStylusDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusDown
  nameWithType: ContentElement.PreviewStylusDown
  fullName: System.Windows.ContentElement.PreviewStylusDown
- uid: System.Windows.Input.StylusDownEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusDownEventHandler
  nameWithType: StylusDownEventHandler
  fullName: System.Windows.Input.StylusDownEventHandler
- uid: System.Windows.ContentElement.PreviewStylusDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusDownEvent
  nameWithType: ContentElement.PreviewStylusDownEvent
  fullName: System.Windows.ContentElement.PreviewStylusDownEvent
- uid: System.Windows.ContentElement.PreviewStylusInAirMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusInAirMove
  nameWithType: ContentElement.PreviewStylusInAirMove
  fullName: System.Windows.ContentElement.PreviewStylusInAirMove
- uid: System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusInAirMoveEvent
  nameWithType: ContentElement.PreviewStylusInAirMoveEvent
  fullName: System.Windows.ContentElement.PreviewStylusInAirMoveEvent
- uid: System.Windows.ContentElement.PreviewStylusInRange
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusInRange
  nameWithType: ContentElement.PreviewStylusInRange
  fullName: System.Windows.ContentElement.PreviewStylusInRange
- uid: System.Windows.ContentElement.PreviewStylusInRangeEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusInRangeEvent
  nameWithType: ContentElement.PreviewStylusInRangeEvent
  fullName: System.Windows.ContentElement.PreviewStylusInRangeEvent
- uid: System.Windows.ContentElement.PreviewStylusMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusMove
  nameWithType: ContentElement.PreviewStylusMove
  fullName: System.Windows.ContentElement.PreviewStylusMove
- uid: System.Windows.ContentElement.PreviewStylusMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusMoveEvent
  nameWithType: ContentElement.PreviewStylusMoveEvent
  fullName: System.Windows.ContentElement.PreviewStylusMoveEvent
- uid: System.Windows.ContentElement.PreviewStylusOutOfRange
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusOutOfRange
  nameWithType: ContentElement.PreviewStylusOutOfRange
  fullName: System.Windows.ContentElement.PreviewStylusOutOfRange
- uid: System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusOutOfRangeEvent
  nameWithType: ContentElement.PreviewStylusOutOfRangeEvent
  fullName: System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
- uid: System.Windows.ContentElement.PreviewStylusSystemGesture
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusSystemGesture
  nameWithType: ContentElement.PreviewStylusSystemGesture
  fullName: System.Windows.ContentElement.PreviewStylusSystemGesture
- uid: System.Windows.Input.StylusSystemGestureEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusSystemGestureEventHandler
  nameWithType: StylusSystemGestureEventHandler
  fullName: System.Windows.Input.StylusSystemGestureEventHandler
- uid: System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusSystemGestureEvent
  nameWithType: ContentElement.PreviewStylusSystemGestureEvent
  fullName: System.Windows.ContentElement.PreviewStylusSystemGestureEvent
- uid: System.Windows.ContentElement.PreviewStylusUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusUp
  nameWithType: ContentElement.PreviewStylusUp
  fullName: System.Windows.ContentElement.PreviewStylusUp
- uid: System.Windows.ContentElement.PreviewStylusUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewStylusUpEvent
  nameWithType: ContentElement.PreviewStylusUpEvent
  fullName: System.Windows.ContentElement.PreviewStylusUpEvent
- uid: System.Windows.ContentElement.PreviewTextInput
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTextInput
  nameWithType: ContentElement.PreviewTextInput
  fullName: System.Windows.ContentElement.PreviewTextInput
- uid: System.Windows.Input.TextCompositionEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: TextCompositionEventHandler
  nameWithType: TextCompositionEventHandler
  fullName: System.Windows.Input.TextCompositionEventHandler
- uid: System.Windows.ContentElement.PreviewTextInputEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTextInputEvent
  nameWithType: ContentElement.PreviewTextInputEvent
  fullName: System.Windows.ContentElement.PreviewTextInputEvent
- uid: System.Windows.ContentElement.PreviewTouchDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTouchDown
  nameWithType: ContentElement.PreviewTouchDown
  fullName: System.Windows.ContentElement.PreviewTouchDown
- uid: System.Windows.ContentElement.PreviewTouchDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTouchDownEvent
  nameWithType: ContentElement.PreviewTouchDownEvent
  fullName: System.Windows.ContentElement.PreviewTouchDownEvent
- uid: System.Windows.ContentElement.PreviewTouchMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTouchMove
  nameWithType: ContentElement.PreviewTouchMove
  fullName: System.Windows.ContentElement.PreviewTouchMove
- uid: System.Windows.ContentElement.PreviewTouchMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTouchMoveEvent
  nameWithType: ContentElement.PreviewTouchMoveEvent
  fullName: System.Windows.ContentElement.PreviewTouchMoveEvent
- uid: System.Windows.ContentElement.PreviewTouchUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTouchUp
  nameWithType: ContentElement.PreviewTouchUp
  fullName: System.Windows.ContentElement.PreviewTouchUp
- uid: System.Windows.ContentElement.PreviewTouchUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: PreviewTouchUpEvent
  nameWithType: ContentElement.PreviewTouchUpEvent
  fullName: System.Windows.ContentElement.PreviewTouchUpEvent
- uid: System.Windows.ContentElement.QueryContinueDrag
  parent: System.Windows.ContentElement
  isExternal: false
  name: QueryContinueDrag
  nameWithType: ContentElement.QueryContinueDrag
  fullName: System.Windows.ContentElement.QueryContinueDrag
- uid: System.Windows.ContentElement.QueryContinueDragEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: QueryContinueDragEvent
  nameWithType: ContentElement.QueryContinueDragEvent
  fullName: System.Windows.ContentElement.QueryContinueDragEvent
- uid: System.Windows.ContentElement.QueryCursor
  parent: System.Windows.ContentElement
  isExternal: false
  name: QueryCursor
  nameWithType: ContentElement.QueryCursor
  fullName: System.Windows.ContentElement.QueryCursor
- uid: System.Windows.Input.QueryCursorEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: QueryCursorEventHandler
  nameWithType: QueryCursorEventHandler
  fullName: System.Windows.Input.QueryCursorEventHandler
- uid: System.Windows.ContentElement.QueryCursorEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: QueryCursorEvent
  nameWithType: ContentElement.QueryCursorEvent
  fullName: System.Windows.ContentElement.QueryCursorEvent
- uid: System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  parent: System.Windows.ContentElement
  isExternal: false
  name: RaiseEvent(RoutedEventArgs)
  nameWithType: ContentElement.RaiseEvent(RoutedEventArgs)
  fullName: System.Windows.ContentElement.RaiseEvent(RoutedEventArgs)
- uid: System.Windows.ContentElement.ReleaseAllTouchCaptures
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseAllTouchCaptures()
  nameWithType: ContentElement.ReleaseAllTouchCaptures()
  fullName: System.Windows.ContentElement.ReleaseAllTouchCaptures()
- uid: System.Windows.ContentElement.ReleaseMouseCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseMouseCapture()
  nameWithType: ContentElement.ReleaseMouseCapture()
  fullName: System.Windows.ContentElement.ReleaseMouseCapture()
- uid: System.Windows.ContentElement.ReleaseStylusCapture
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseStylusCapture()
  nameWithType: ContentElement.ReleaseStylusCapture()
  fullName: System.Windows.ContentElement.ReleaseStylusCapture()
- uid: System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseTouchCapture(TouchDevice)
  nameWithType: ContentElement.ReleaseTouchCapture(TouchDevice)
  fullName: System.Windows.ContentElement.ReleaseTouchCapture(TouchDevice)
- uid: System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.ContentElement
  isExternal: false
  name: RemoveHandler(RoutedEvent,Delegate)
  nameWithType: ContentElement.RemoveHandler(RoutedEvent,Delegate)
  fullName: System.Windows.ContentElement.RemoveHandler(RoutedEvent,Delegate)
- uid: System.Windows.ContentElement.ShouldSerializeCommandBindings
  parent: System.Windows.ContentElement
  isExternal: false
  name: ShouldSerializeCommandBindings()
  nameWithType: ContentElement.ShouldSerializeCommandBindings()
  fullName: System.Windows.ContentElement.ShouldSerializeCommandBindings()
- uid: System.Windows.ContentElement.ShouldSerializeInputBindings
  parent: System.Windows.ContentElement
  isExternal: false
  name: ShouldSerializeInputBindings()
  nameWithType: ContentElement.ShouldSerializeInputBindings()
  fullName: System.Windows.ContentElement.ShouldSerializeInputBindings()
- uid: System.Windows.ContentElement.StylusButtonDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusButtonDown
  nameWithType: ContentElement.StylusButtonDown
  fullName: System.Windows.ContentElement.StylusButtonDown
- uid: System.Windows.ContentElement.StylusButtonDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusButtonDownEvent
  nameWithType: ContentElement.StylusButtonDownEvent
  fullName: System.Windows.ContentElement.StylusButtonDownEvent
- uid: System.Windows.ContentElement.StylusButtonUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusButtonUp
  nameWithType: ContentElement.StylusButtonUp
  fullName: System.Windows.ContentElement.StylusButtonUp
- uid: System.Windows.ContentElement.StylusButtonUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusButtonUpEvent
  nameWithType: ContentElement.StylusButtonUpEvent
  fullName: System.Windows.ContentElement.StylusButtonUpEvent
- uid: System.Windows.ContentElement.StylusDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusDown
  nameWithType: ContentElement.StylusDown
  fullName: System.Windows.ContentElement.StylusDown
- uid: System.Windows.ContentElement.StylusDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusDownEvent
  nameWithType: ContentElement.StylusDownEvent
  fullName: System.Windows.ContentElement.StylusDownEvent
- uid: System.Windows.ContentElement.StylusEnter
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusEnter
  nameWithType: ContentElement.StylusEnter
  fullName: System.Windows.ContentElement.StylusEnter
- uid: System.Windows.ContentElement.StylusEnterEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusEnterEvent
  nameWithType: ContentElement.StylusEnterEvent
  fullName: System.Windows.ContentElement.StylusEnterEvent
- uid: System.Windows.ContentElement.StylusInAirMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusInAirMove
  nameWithType: ContentElement.StylusInAirMove
  fullName: System.Windows.ContentElement.StylusInAirMove
- uid: System.Windows.ContentElement.StylusInAirMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusInAirMoveEvent
  nameWithType: ContentElement.StylusInAirMoveEvent
  fullName: System.Windows.ContentElement.StylusInAirMoveEvent
- uid: System.Windows.ContentElement.StylusInRange
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusInRange
  nameWithType: ContentElement.StylusInRange
  fullName: System.Windows.ContentElement.StylusInRange
- uid: System.Windows.ContentElement.StylusInRangeEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusInRangeEvent
  nameWithType: ContentElement.StylusInRangeEvent
  fullName: System.Windows.ContentElement.StylusInRangeEvent
- uid: System.Windows.ContentElement.StylusLeave
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusLeave
  nameWithType: ContentElement.StylusLeave
  fullName: System.Windows.ContentElement.StylusLeave
- uid: System.Windows.ContentElement.StylusLeaveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusLeaveEvent
  nameWithType: ContentElement.StylusLeaveEvent
  fullName: System.Windows.ContentElement.StylusLeaveEvent
- uid: System.Windows.ContentElement.StylusMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusMove
  nameWithType: ContentElement.StylusMove
  fullName: System.Windows.ContentElement.StylusMove
- uid: System.Windows.ContentElement.StylusMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusMoveEvent
  nameWithType: ContentElement.StylusMoveEvent
  fullName: System.Windows.ContentElement.StylusMoveEvent
- uid: System.Windows.ContentElement.StylusOutOfRange
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusOutOfRange
  nameWithType: ContentElement.StylusOutOfRange
  fullName: System.Windows.ContentElement.StylusOutOfRange
- uid: System.Windows.ContentElement.StylusOutOfRangeEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusOutOfRangeEvent
  nameWithType: ContentElement.StylusOutOfRangeEvent
  fullName: System.Windows.ContentElement.StylusOutOfRangeEvent
- uid: System.Windows.ContentElement.StylusSystemGesture
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusSystemGesture
  nameWithType: ContentElement.StylusSystemGesture
  fullName: System.Windows.ContentElement.StylusSystemGesture
- uid: System.Windows.ContentElement.StylusSystemGestureEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusSystemGestureEvent
  nameWithType: ContentElement.StylusSystemGestureEvent
  fullName: System.Windows.ContentElement.StylusSystemGestureEvent
- uid: System.Windows.ContentElement.StylusUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusUp
  nameWithType: ContentElement.StylusUp
  fullName: System.Windows.ContentElement.StylusUp
- uid: System.Windows.ContentElement.StylusUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: StylusUpEvent
  nameWithType: ContentElement.StylusUpEvent
  fullName: System.Windows.ContentElement.StylusUpEvent
- uid: System.Windows.ContentElement.TextInput
  parent: System.Windows.ContentElement
  isExternal: false
  name: TextInput
  nameWithType: ContentElement.TextInput
  fullName: System.Windows.ContentElement.TextInput
- uid: System.Windows.ContentElement.TextInputEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: TextInputEvent
  nameWithType: ContentElement.TextInputEvent
  fullName: System.Windows.ContentElement.TextInputEvent
- uid: System.Windows.ContentElement.TouchDown
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchDown
  nameWithType: ContentElement.TouchDown
  fullName: System.Windows.ContentElement.TouchDown
- uid: System.Windows.ContentElement.TouchDownEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchDownEvent
  nameWithType: ContentElement.TouchDownEvent
  fullName: System.Windows.ContentElement.TouchDownEvent
- uid: System.Windows.ContentElement.TouchEnter
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchEnter
  nameWithType: ContentElement.TouchEnter
  fullName: System.Windows.ContentElement.TouchEnter
- uid: System.Windows.ContentElement.TouchEnterEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchEnterEvent
  nameWithType: ContentElement.TouchEnterEvent
  fullName: System.Windows.ContentElement.TouchEnterEvent
- uid: System.Windows.ContentElement.TouchesCaptured
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesCaptured
  nameWithType: ContentElement.TouchesCaptured
  fullName: System.Windows.ContentElement.TouchesCaptured
- uid: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<TouchDevice>
  nameWithType: IEnumerable<TouchDevice>
  fullName: System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Windows.Input.TouchDevice>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.TouchDevice
    name: TouchDevice
    nameWithType: TouchDevice
    fullName: TouchDevice
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.ContentElement.TouchesCapturedWithin
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesCapturedWithin
  nameWithType: ContentElement.TouchesCapturedWithin
  fullName: System.Windows.ContentElement.TouchesCapturedWithin
- uid: System.Windows.ContentElement.TouchesDirectlyOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesDirectlyOver
  nameWithType: ContentElement.TouchesDirectlyOver
  fullName: System.Windows.ContentElement.TouchesDirectlyOver
- uid: System.Windows.ContentElement.TouchesOver
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesOver
  nameWithType: ContentElement.TouchesOver
  fullName: System.Windows.ContentElement.TouchesOver
- uid: System.Windows.ContentElement.TouchLeave
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchLeave
  nameWithType: ContentElement.TouchLeave
  fullName: System.Windows.ContentElement.TouchLeave
- uid: System.Windows.ContentElement.TouchLeaveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchLeaveEvent
  nameWithType: ContentElement.TouchLeaveEvent
  fullName: System.Windows.ContentElement.TouchLeaveEvent
- uid: System.Windows.ContentElement.TouchMove
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchMove
  nameWithType: ContentElement.TouchMove
  fullName: System.Windows.ContentElement.TouchMove
- uid: System.Windows.ContentElement.TouchMoveEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchMoveEvent
  nameWithType: ContentElement.TouchMoveEvent
  fullName: System.Windows.ContentElement.TouchMoveEvent
- uid: System.Windows.ContentElement.TouchUp
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchUp
  nameWithType: ContentElement.TouchUp
  fullName: System.Windows.ContentElement.TouchUp
- uid: System.Windows.ContentElement.TouchUpEvent
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchUpEvent
  nameWithType: ContentElement.TouchUpEvent
  fullName: System.Windows.ContentElement.TouchUpEvent
- uid: System.Windows.ContentElement.#ctor*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ContentElement
  nameWithType: ContentElement.ContentElement
- uid: System.Windows.ContentElement.AddHandler*
  parent: System.Windows.ContentElement
  isExternal: false
  name: AddHandler
  nameWithType: ContentElement.AddHandler
- uid: System.Windows.ContentElement.AddToEventRoute*
  parent: System.Windows.ContentElement
  isExternal: false
  name: AddToEventRoute
  nameWithType: ContentElement.AddToEventRoute
- uid: System.Windows.ContentElement.AllowDrop*
  parent: System.Windows.ContentElement
  isExternal: false
  name: AllowDrop
  nameWithType: ContentElement.AllowDrop
- uid: System.Windows.ContentElement.ApplyAnimationClock*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ApplyAnimationClock
  nameWithType: ContentElement.ApplyAnimationClock
- uid: System.Windows.ContentElement.AreAnyTouchesCaptured*
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesCaptured
  nameWithType: ContentElement.AreAnyTouchesCaptured
- uid: System.Windows.ContentElement.AreAnyTouchesCapturedWithin*
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesCapturedWithin
  nameWithType: ContentElement.AreAnyTouchesCapturedWithin
- uid: System.Windows.ContentElement.AreAnyTouchesDirectlyOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesDirectlyOver
  nameWithType: ContentElement.AreAnyTouchesDirectlyOver
- uid: System.Windows.ContentElement.AreAnyTouchesOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: AreAnyTouchesOver
  nameWithType: ContentElement.AreAnyTouchesOver
- uid: System.Windows.ContentElement.BeginAnimation*
  parent: System.Windows.ContentElement
  isExternal: false
  name: BeginAnimation
  nameWithType: ContentElement.BeginAnimation
- uid: System.Windows.ContentElement.CaptureMouse*
  parent: System.Windows.ContentElement
  isExternal: false
  name: CaptureMouse
  nameWithType: ContentElement.CaptureMouse
- uid: System.Windows.ContentElement.CaptureStylus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: CaptureStylus
  nameWithType: ContentElement.CaptureStylus
- uid: System.Windows.ContentElement.CaptureTouch*
  parent: System.Windows.ContentElement
  isExternal: false
  name: CaptureTouch
  nameWithType: ContentElement.CaptureTouch
- uid: System.Windows.ContentElement.CommandBindings*
  parent: System.Windows.ContentElement
  isExternal: false
  name: CommandBindings
  nameWithType: ContentElement.CommandBindings
- uid: System.Windows.ContentElement.Focus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: Focus
  nameWithType: ContentElement.Focus
- uid: System.Windows.ContentElement.Focusable*
  parent: System.Windows.ContentElement
  isExternal: false
  name: Focusable
  nameWithType: ContentElement.Focusable
- uid: System.Windows.ContentElement.GetAnimationBaseValue*
  parent: System.Windows.ContentElement
  isExternal: false
  name: GetAnimationBaseValue
  nameWithType: ContentElement.GetAnimationBaseValue
- uid: System.Windows.ContentElement.GetUIParentCore*
  parent: System.Windows.ContentElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: ContentElement.GetUIParentCore
- uid: System.Windows.ContentElement.HasAnimatedProperties*
  parent: System.Windows.ContentElement
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: ContentElement.HasAnimatedProperties
- uid: System.Windows.ContentElement.InputBindings*
  parent: System.Windows.ContentElement
  isExternal: false
  name: InputBindings
  nameWithType: ContentElement.InputBindings
- uid: System.Windows.ContentElement.IsEnabled*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsEnabled
  nameWithType: ContentElement.IsEnabled
- uid: System.Windows.ContentElement.IsEnabledCore*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsEnabledCore
  nameWithType: ContentElement.IsEnabledCore
- uid: System.Windows.ContentElement.IsFocused*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsFocused
  nameWithType: ContentElement.IsFocused
- uid: System.Windows.ContentElement.IsInputMethodEnabled*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsInputMethodEnabled
  nameWithType: ContentElement.IsInputMethodEnabled
- uid: System.Windows.ContentElement.IsKeyboardFocused*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocused
  nameWithType: ContentElement.IsKeyboardFocused
- uid: System.Windows.ContentElement.IsKeyboardFocusWithin*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsKeyboardFocusWithin
  nameWithType: ContentElement.IsKeyboardFocusWithin
- uid: System.Windows.ContentElement.IsMouseCaptured*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCaptured
  nameWithType: ContentElement.IsMouseCaptured
- uid: System.Windows.ContentElement.IsMouseCaptureWithin*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseCaptureWithin
  nameWithType: ContentElement.IsMouseCaptureWithin
- uid: System.Windows.ContentElement.IsMouseDirectlyOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseDirectlyOver
  nameWithType: ContentElement.IsMouseDirectlyOver
- uid: System.Windows.ContentElement.IsMouseOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsMouseOver
  nameWithType: ContentElement.IsMouseOver
- uid: System.Windows.ContentElement.IsStylusCaptured*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCaptured
  nameWithType: ContentElement.IsStylusCaptured
- uid: System.Windows.ContentElement.IsStylusCaptureWithin*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusCaptureWithin
  nameWithType: ContentElement.IsStylusCaptureWithin
- uid: System.Windows.ContentElement.IsStylusDirectlyOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusDirectlyOver
  nameWithType: ContentElement.IsStylusDirectlyOver
- uid: System.Windows.ContentElement.IsStylusOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: IsStylusOver
  nameWithType: ContentElement.IsStylusOver
- uid: System.Windows.ContentElement.MoveFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: MoveFocus
  nameWithType: ContentElement.MoveFocus
- uid: System.Windows.ContentElement.OnCreateAutomationPeer*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnCreateAutomationPeer
  nameWithType: ContentElement.OnCreateAutomationPeer
- uid: System.Windows.ContentElement.OnDragEnter*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDragEnter
  nameWithType: ContentElement.OnDragEnter
- uid: System.Windows.ContentElement.OnDragLeave*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDragLeave
  nameWithType: ContentElement.OnDragLeave
- uid: System.Windows.ContentElement.OnDragOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDragOver
  nameWithType: ContentElement.OnDragOver
- uid: System.Windows.ContentElement.OnDrop*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnDrop
  nameWithType: ContentElement.OnDrop
- uid: System.Windows.ContentElement.OnGiveFeedback*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGiveFeedback
  nameWithType: ContentElement.OnGiveFeedback
- uid: System.Windows.ContentElement.OnGotFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotFocus
  nameWithType: ContentElement.OnGotFocus
- uid: System.Windows.ContentElement.OnGotKeyboardFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotKeyboardFocus
  nameWithType: ContentElement.OnGotKeyboardFocus
- uid: System.Windows.ContentElement.OnGotMouseCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotMouseCapture
  nameWithType: ContentElement.OnGotMouseCapture
- uid: System.Windows.ContentElement.OnGotStylusCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotStylusCapture
  nameWithType: ContentElement.OnGotStylusCapture
- uid: System.Windows.ContentElement.OnGotTouchCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnGotTouchCapture
  nameWithType: ContentElement.OnGotTouchCapture
- uid: System.Windows.ContentElement.OnIsKeyboardFocusedChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsKeyboardFocusedChanged
  nameWithType: ContentElement.OnIsKeyboardFocusedChanged
- uid: System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsKeyboardFocusWithinChanged
  nameWithType: ContentElement.OnIsKeyboardFocusWithinChanged
- uid: System.Windows.ContentElement.OnIsMouseCapturedChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsMouseCapturedChanged
  nameWithType: ContentElement.OnIsMouseCapturedChanged
- uid: System.Windows.ContentElement.OnIsMouseCaptureWithinChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsMouseCaptureWithinChanged
  nameWithType: ContentElement.OnIsMouseCaptureWithinChanged
- uid: System.Windows.ContentElement.OnIsMouseDirectlyOverChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsMouseDirectlyOverChanged
  nameWithType: ContentElement.OnIsMouseDirectlyOverChanged
- uid: System.Windows.ContentElement.OnIsStylusCapturedChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsStylusCapturedChanged
  nameWithType: ContentElement.OnIsStylusCapturedChanged
- uid: System.Windows.ContentElement.OnIsStylusCaptureWithinChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsStylusCaptureWithinChanged
  nameWithType: ContentElement.OnIsStylusCaptureWithinChanged
- uid: System.Windows.ContentElement.OnIsStylusDirectlyOverChanged*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnIsStylusDirectlyOverChanged
  nameWithType: ContentElement.OnIsStylusDirectlyOverChanged
- uid: System.Windows.ContentElement.OnKeyDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnKeyDown
  nameWithType: ContentElement.OnKeyDown
- uid: System.Windows.ContentElement.OnKeyUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnKeyUp
  nameWithType: ContentElement.OnKeyUp
- uid: System.Windows.ContentElement.OnLostFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostFocus
  nameWithType: ContentElement.OnLostFocus
- uid: System.Windows.ContentElement.OnLostKeyboardFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostKeyboardFocus
  nameWithType: ContentElement.OnLostKeyboardFocus
- uid: System.Windows.ContentElement.OnLostMouseCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostMouseCapture
  nameWithType: ContentElement.OnLostMouseCapture
- uid: System.Windows.ContentElement.OnLostStylusCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostStylusCapture
  nameWithType: ContentElement.OnLostStylusCapture
- uid: System.Windows.ContentElement.OnLostTouchCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnLostTouchCapture
  nameWithType: ContentElement.OnLostTouchCapture
- uid: System.Windows.ContentElement.OnMouseDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseDown
  nameWithType: ContentElement.OnMouseDown
- uid: System.Windows.ContentElement.OnMouseEnter*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseEnter
  nameWithType: ContentElement.OnMouseEnter
- uid: System.Windows.ContentElement.OnMouseLeave*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseLeave
  nameWithType: ContentElement.OnMouseLeave
- uid: System.Windows.ContentElement.OnMouseLeftButtonDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseLeftButtonDown
  nameWithType: ContentElement.OnMouseLeftButtonDown
- uid: System.Windows.ContentElement.OnMouseLeftButtonUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseLeftButtonUp
  nameWithType: ContentElement.OnMouseLeftButtonUp
- uid: System.Windows.ContentElement.OnMouseMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseMove
  nameWithType: ContentElement.OnMouseMove
- uid: System.Windows.ContentElement.OnMouseRightButtonDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseRightButtonDown
  nameWithType: ContentElement.OnMouseRightButtonDown
- uid: System.Windows.ContentElement.OnMouseRightButtonUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseRightButtonUp
  nameWithType: ContentElement.OnMouseRightButtonUp
- uid: System.Windows.ContentElement.OnMouseUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseUp
  nameWithType: ContentElement.OnMouseUp
- uid: System.Windows.ContentElement.OnMouseWheel*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnMouseWheel
  nameWithType: ContentElement.OnMouseWheel
- uid: System.Windows.ContentElement.OnPreviewDragEnter*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDragEnter
  nameWithType: ContentElement.OnPreviewDragEnter
- uid: System.Windows.ContentElement.OnPreviewDragLeave*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDragLeave
  nameWithType: ContentElement.OnPreviewDragLeave
- uid: System.Windows.ContentElement.OnPreviewDragOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDragOver
  nameWithType: ContentElement.OnPreviewDragOver
- uid: System.Windows.ContentElement.OnPreviewDrop*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewDrop
  nameWithType: ContentElement.OnPreviewDrop
- uid: System.Windows.ContentElement.OnPreviewGiveFeedback*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewGiveFeedback
  nameWithType: ContentElement.OnPreviewGiveFeedback
- uid: System.Windows.ContentElement.OnPreviewGotKeyboardFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewGotKeyboardFocus
  nameWithType: ContentElement.OnPreviewGotKeyboardFocus
- uid: System.Windows.ContentElement.OnPreviewKeyDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewKeyDown
  nameWithType: ContentElement.OnPreviewKeyDown
- uid: System.Windows.ContentElement.OnPreviewKeyUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewKeyUp
  nameWithType: ContentElement.OnPreviewKeyUp
- uid: System.Windows.ContentElement.OnPreviewLostKeyboardFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewLostKeyboardFocus
  nameWithType: ContentElement.OnPreviewLostKeyboardFocus
- uid: System.Windows.ContentElement.OnPreviewMouseDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseDown
  nameWithType: ContentElement.OnPreviewMouseDown
- uid: System.Windows.ContentElement.OnPreviewMouseLeftButtonDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseLeftButtonDown
  nameWithType: ContentElement.OnPreviewMouseLeftButtonDown
- uid: System.Windows.ContentElement.OnPreviewMouseLeftButtonUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseLeftButtonUp
  nameWithType: ContentElement.OnPreviewMouseLeftButtonUp
- uid: System.Windows.ContentElement.OnPreviewMouseMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseMove
  nameWithType: ContentElement.OnPreviewMouseMove
- uid: System.Windows.ContentElement.OnPreviewMouseRightButtonDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseRightButtonDown
  nameWithType: ContentElement.OnPreviewMouseRightButtonDown
- uid: System.Windows.ContentElement.OnPreviewMouseRightButtonUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseRightButtonUp
  nameWithType: ContentElement.OnPreviewMouseRightButtonUp
- uid: System.Windows.ContentElement.OnPreviewMouseUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseUp
  nameWithType: ContentElement.OnPreviewMouseUp
- uid: System.Windows.ContentElement.OnPreviewMouseWheel*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewMouseWheel
  nameWithType: ContentElement.OnPreviewMouseWheel
- uid: System.Windows.ContentElement.OnPreviewQueryContinueDrag*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewQueryContinueDrag
  nameWithType: ContentElement.OnPreviewQueryContinueDrag
- uid: System.Windows.ContentElement.OnPreviewStylusButtonDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusButtonDown
  nameWithType: ContentElement.OnPreviewStylusButtonDown
- uid: System.Windows.ContentElement.OnPreviewStylusButtonUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusButtonUp
  nameWithType: ContentElement.OnPreviewStylusButtonUp
- uid: System.Windows.ContentElement.OnPreviewStylusDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusDown
  nameWithType: ContentElement.OnPreviewStylusDown
- uid: System.Windows.ContentElement.OnPreviewStylusInAirMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusInAirMove
  nameWithType: ContentElement.OnPreviewStylusInAirMove
- uid: System.Windows.ContentElement.OnPreviewStylusInRange*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusInRange
  nameWithType: ContentElement.OnPreviewStylusInRange
- uid: System.Windows.ContentElement.OnPreviewStylusMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusMove
  nameWithType: ContentElement.OnPreviewStylusMove
- uid: System.Windows.ContentElement.OnPreviewStylusOutOfRange*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusOutOfRange
  nameWithType: ContentElement.OnPreviewStylusOutOfRange
- uid: System.Windows.ContentElement.OnPreviewStylusSystemGesture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusSystemGesture
  nameWithType: ContentElement.OnPreviewStylusSystemGesture
- uid: System.Windows.ContentElement.OnPreviewStylusUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewStylusUp
  nameWithType: ContentElement.OnPreviewStylusUp
- uid: System.Windows.ContentElement.OnPreviewTextInput*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTextInput
  nameWithType: ContentElement.OnPreviewTextInput
- uid: System.Windows.ContentElement.OnPreviewTouchDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTouchDown
  nameWithType: ContentElement.OnPreviewTouchDown
- uid: System.Windows.ContentElement.OnPreviewTouchMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTouchMove
  nameWithType: ContentElement.OnPreviewTouchMove
- uid: System.Windows.ContentElement.OnPreviewTouchUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnPreviewTouchUp
  nameWithType: ContentElement.OnPreviewTouchUp
- uid: System.Windows.ContentElement.OnQueryContinueDrag*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnQueryContinueDrag
  nameWithType: ContentElement.OnQueryContinueDrag
- uid: System.Windows.ContentElement.OnQueryCursor*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnQueryCursor
  nameWithType: ContentElement.OnQueryCursor
- uid: System.Windows.ContentElement.OnStylusButtonDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusButtonDown
  nameWithType: ContentElement.OnStylusButtonDown
- uid: System.Windows.ContentElement.OnStylusButtonUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusButtonUp
  nameWithType: ContentElement.OnStylusButtonUp
- uid: System.Windows.ContentElement.OnStylusDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusDown
  nameWithType: ContentElement.OnStylusDown
- uid: System.Windows.ContentElement.OnStylusEnter*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusEnter
  nameWithType: ContentElement.OnStylusEnter
- uid: System.Windows.ContentElement.OnStylusInAirMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusInAirMove
  nameWithType: ContentElement.OnStylusInAirMove
- uid: System.Windows.ContentElement.OnStylusInRange*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusInRange
  nameWithType: ContentElement.OnStylusInRange
- uid: System.Windows.ContentElement.OnStylusLeave*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusLeave
  nameWithType: ContentElement.OnStylusLeave
- uid: System.Windows.ContentElement.OnStylusMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusMove
  nameWithType: ContentElement.OnStylusMove
- uid: System.Windows.ContentElement.OnStylusOutOfRange*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusOutOfRange
  nameWithType: ContentElement.OnStylusOutOfRange
- uid: System.Windows.ContentElement.OnStylusSystemGesture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusSystemGesture
  nameWithType: ContentElement.OnStylusSystemGesture
- uid: System.Windows.ContentElement.OnStylusUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnStylusUp
  nameWithType: ContentElement.OnStylusUp
- uid: System.Windows.ContentElement.OnTextInput*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTextInput
  nameWithType: ContentElement.OnTextInput
- uid: System.Windows.ContentElement.OnTouchDown*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchDown
  nameWithType: ContentElement.OnTouchDown
- uid: System.Windows.ContentElement.OnTouchEnter*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchEnter
  nameWithType: ContentElement.OnTouchEnter
- uid: System.Windows.ContentElement.OnTouchLeave*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchLeave
  nameWithType: ContentElement.OnTouchLeave
- uid: System.Windows.ContentElement.OnTouchMove*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchMove
  nameWithType: ContentElement.OnTouchMove
- uid: System.Windows.ContentElement.OnTouchUp*
  parent: System.Windows.ContentElement
  isExternal: false
  name: OnTouchUp
  nameWithType: ContentElement.OnTouchUp
- uid: System.Windows.ContentElement.PredictFocus*
  parent: System.Windows.ContentElement
  isExternal: false
  name: PredictFocus
  nameWithType: ContentElement.PredictFocus
- uid: System.Windows.ContentElement.RaiseEvent*
  parent: System.Windows.ContentElement
  isExternal: false
  name: RaiseEvent
  nameWithType: ContentElement.RaiseEvent
- uid: System.Windows.ContentElement.ReleaseAllTouchCaptures*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseAllTouchCaptures
  nameWithType: ContentElement.ReleaseAllTouchCaptures
- uid: System.Windows.ContentElement.ReleaseMouseCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseMouseCapture
  nameWithType: ContentElement.ReleaseMouseCapture
- uid: System.Windows.ContentElement.ReleaseStylusCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseStylusCapture
  nameWithType: ContentElement.ReleaseStylusCapture
- uid: System.Windows.ContentElement.ReleaseTouchCapture*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ReleaseTouchCapture
  nameWithType: ContentElement.ReleaseTouchCapture
- uid: System.Windows.ContentElement.RemoveHandler*
  parent: System.Windows.ContentElement
  isExternal: false
  name: RemoveHandler
  nameWithType: ContentElement.RemoveHandler
- uid: System.Windows.ContentElement.ShouldSerializeCommandBindings*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ShouldSerializeCommandBindings
  nameWithType: ContentElement.ShouldSerializeCommandBindings
- uid: System.Windows.ContentElement.ShouldSerializeInputBindings*
  parent: System.Windows.ContentElement
  isExternal: false
  name: ShouldSerializeInputBindings
  nameWithType: ContentElement.ShouldSerializeInputBindings
- uid: System.Windows.ContentElement.TouchesCaptured*
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesCaptured
  nameWithType: ContentElement.TouchesCaptured
- uid: System.Windows.ContentElement.TouchesCapturedWithin*
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesCapturedWithin
  nameWithType: ContentElement.TouchesCapturedWithin
- uid: System.Windows.ContentElement.TouchesDirectlyOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesDirectlyOver
  nameWithType: ContentElement.TouchesDirectlyOver
- uid: System.Windows.ContentElement.TouchesOver*
  parent: System.Windows.ContentElement
  isExternal: false
  name: TouchesOver
  nameWithType: ContentElement.TouchesOver
