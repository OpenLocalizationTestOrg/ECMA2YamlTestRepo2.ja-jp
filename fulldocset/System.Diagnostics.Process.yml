### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "ローカルおよびリモート プロセスへのアクセスを提供しを起動し、ローカル システム プロセスを停止することができます。       この型の .NET Framework ソース コードを参照するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)です。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>クラスです。"
  remarks: "指定しない場合、<xref:System.Diagnostics.Process.MachineName%2A>プロパティの既定値は、ローカル コンピューター (&quot;です&quot;)。</xref:System.Diagnostics.Process.MachineName%2A> 。       新しい関連付けの&2; つのオプションがある<xref:System.Diagnostics.Process>コンポーネントは、コンピューター上のプロセス</xref:System.Diagnostics.Process>。 コンス トラクターを使用して作成する&1; つ目は、<xref:System.Diagnostics.Process>コンポーネント、設定の適切なメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティと呼び出し<xref:System.Diagnostics.Process.Start%2A>に関連付けるには、<xref:System.Diagnostics.Process>で新しいシステム プロセスです</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A></xref:System.Diagnostics.Process.StartInfo%2A></xref:System.Diagnostics.Process>。 関連付けるには、2 番目のオプション、<xref:System.Diagnostics.Process>を使用して実行中のシステム プロセスと<xref:System.Diagnostics.Process.GetProcessById%2A>またはのいずれか、<xref:System.Diagnostics.Process.GetProcesses%2A>値を返します</xref:System.Diagnostics.Process.GetProcesses%2A></xref:System.Diagnostics.Process.GetProcessById%2A></xref:System.Diagnostics.Process>。       使用する場合、`static`のオーバー ロード、<xref:System.Diagnostics.Process.Start%2A>メソッド、新規システム プロセスを開始するメソッドが新たに作成<xref:System.Diagnostics.Process>コンポーネントと、プロセスに関連付けます</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A>。       ときに、<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>プロパティがその既定値に設定`true`を使用して次のような方法で、アプリケーションとドキュメントを開始することができます、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> 。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>は`false`、実行可能ファイルだけを開始することができます</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>。       コマンドラインから呼び出すことができる実行可能ファイルは、2 つの方法で開始できます: の適切なメンバーを設定して、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティは、通話、<xref:System.Diagnostics.Process.Start%2A>メソッド パラメーターなしで、または適切なパラメーターを渡すことによって、 `static` <xref:System.Diagnostics.Process.Start%2A>メンバー</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> 。       作成することができます、<xref:System.Diagnostics.Process>静的のいずれかのコンス トラクターを使用して、コンポーネント<xref:System.Diagnostics.Process.Start%2A>のいずれかのオーバー ロード、または、 <xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcesses%2A>、または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド</xref:System.Diagnostics.Process.GetProcessesByName%2A></xref:System.Diagnostics.Process.GetProcesses%2A></xref:System.Diagnostics.Process.GetProcessById%2A></xref:System.Diagnostics.Process.Start%2A></xref:System.Diagnostics.Process>。 これを完了したら、関連付けられたプロセスにビューがあります。 これは、メモリ内でプロセスのプロパティが変更されたときに自動的に更新される動的なビューではありません。 代わりに、呼び出す必要があります<xref:System.Diagnostics.Process.Refresh%2A>コンポーネントを更新するため、<xref:System.Diagnostics.Process>アプリケーションのプロパティの情報</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Refresh%2A>。"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスの基本優先順位を取得します。"
  remarks: "プロセスの BasePriority は、関連付けられているプロセス内で作成されたスレッドを開始する優先度です。 システム モニターの基本優先度カウンターを使用する基本優先順位に関する情報を表示することができます。       プロセスは、他のユーザーの前に配置するときに、経過時間、またはその他の要因をオペレーティング システムは基本の優先順位を変更できます時間に基づいています。       BasePriority プロパティを使用して、プロセスに割り当てられている開始の優先度を表示できます。 ただし、これは、読み取り専用であるために、プロセスの優先順位を設定、BasePriority を使用できません。 優先順位を変更するには、使用、<xref:System.Diagnostics.Process.PriorityClass%2A>プロパティ</xref:System.Diagnostics.Process.PriorityClass%2A>。 BasePriority は表示中に、システム モニターを使用して、<xref:System.Diagnostics.Process.PriorityClass%2A>はありません</xref:System.Diagnostics.Process.PriorityClass%2A>。 両方の BasePriority と<xref:System.Diagnostics.Process.PriorityClass%2A>プログラムから表示できます</xref:System.Diagnostics.Process.PriorityClass%2A>。 次の表に、BasePriority 値間のリレーションシップと<xref:System.Diagnostics.Process.PriorityClass%2A>値</xref:System.Diagnostics.Process.PriorityClass%2A>。      |BasePriority |PriorityClass |  |------------------|-------------------|  |&4; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&8; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&13; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&24; |<xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "算出される基本優先度、<xref:System.Diagnostics.Process.PriorityClass*>関連付けられたプロセスの</xref:System.Diagnostics.Process.PriorityClass*>。"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定、 &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;プロパティを<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスは終了しました。       または、プロセスが開始されていないので、プロセス ID はありません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "リダイレクトされたで読み取り操作を非同期開始<xref:System.Diagnostics.Process.StandardError*>アプリケーションのストリーム</xref:System.Diagnostics.Process.StandardError*>。"
  remarks: "<xref:System.Diagnostics.Process.StandardError%2A>同期または非同期でストリームを読み取ることができます</xref:System.Diagnostics.Process.StandardError%2A>。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームの同期読み取り操作を実行します</xref:System.IO.StreamReader.ReadToEnd%2A></xref:System.IO.StreamReader.ReadLine%2A></xref:System.IO.StreamReader.Read%2A>。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>に書き込み、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはストリームを閉じます</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process>。       これに対し、BeginErrorReadLine が開始される非同期読み取り操作で、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A>。 このメソッドは、ストリームの出力で指定されたイベント ハンドラーを有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。       非同期読み取り操作を実行する次の手順に従って<xref:System.Diagnostics.Process.StandardError%2A>の<xref:System.Diagnostics.Process>: 1</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> 。  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  イベント ハンドラーを追加、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント</xref:System.Diagnostics.Process.ErrorDataReceived>。 イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>デリゲート シグネチャ</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>。      4.  <xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process>の開始します。      5.  <xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process> BeginErrorReadLine を呼び出す この呼び出しにより、 <xref:System.Diagnostics.Process.StandardError%2A>。</xref:System.Diagnostics.Process.StandardError%2A>非同期読み取り操作       たびに、関連付けられている非同期読み取り操作を開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>へのテキストの行を書き込むその<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process>。       <xref:System.Diagnostics.Process.CancelErrorRead%2A>。</xref:System.Diagnostics.Process.CancelErrorRead%2A>を呼び出すことによって、非同期読み取り操作を取り消すことができます。 呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。 キャンセル後に、非同期読み取り操作を再開するには、もう一度 BeginErrorReadLine を呼び出すことができます。      > [!NOTE] > リダイレクトされたストリームで読み取り操作を非同期および同期が混在することはできません。 リダイレクトされたストリームの&1; 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります</xref:System.Diagnostics.Process>。 たとえばに従っていません BeginErrorReadLine への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>で、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはその逆</xref:System.Diagnostics.Process.StandardError%2A></xref:System.IO.StreamReader.ReadLine%2A>。 ただし、さまざまなモードで異なる&2; つのストリームを読み取ることができます。 たとえば、BeginErrorReadLine を呼び出すし、し、呼び出す<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.IO.StreamReader.ReadLine%2A>。"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "リダイレクトされたで読み取り操作を非同期開始<xref:System.Diagnostics.Process.StandardOutput*>アプリケーションのストリーム</xref:System.Diagnostics.Process.StandardOutput*>。"
  remarks: "<xref:System.Diagnostics.Process.StandardOutput%2A>同期または非同期でストリームを読み取ることができます</xref:System.Diagnostics.Process.StandardOutput%2A>。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームの同期読み取り操作を実行します</xref:System.IO.StreamReader.ReadToEnd%2A></xref:System.IO.StreamReader.ReadLine%2A></xref:System.IO.StreamReader.Read%2A>。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはストリームを閉じます</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process>。       これに対し、BeginOutputReadLine が開始される非同期読み取り操作で、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A>。 このメソッドは、指定されたイベントのハンドラーをストリーム出力を有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。       非同期読み取り操作を実行する次の手順に従って<xref:System.Diagnostics.Process.StandardOutput%2A>の<xref:System.Diagnostics.Process>: 1</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> 。  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  イベント ハンドラーを追加、<xref:System.Diagnostics.Process.OutputDataReceived>イベント</xref:System.Diagnostics.Process.OutputDataReceived>。 イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>デリゲート シグネチャ</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>。      4.  <xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process>の開始します。      5.  <xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process> BeginOutputReadLine を呼び出す この呼び出しにより、 <xref:System.Diagnostics.Process.StandardOutput%2A>。</xref:System.Diagnostics.Process.StandardOutput%2A>非同期読み取り操作       たびに、関連付けられている非同期読み取り操作を開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>へのテキストの行を書き込むその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process>。       <xref:System.Diagnostics.Process.CancelOutputRead%2A>。</xref:System.Diagnostics.Process.CancelOutputRead%2A>を呼び出すことによって、非同期読み取り操作を取り消すことができます。 呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。 キャンセル後に、非同期読み取り操作を再開するには、もう一度 BeginOutputReadLine を呼び出すことができます。      > [!NOTE] > リダイレクトされたストリームで読み取り操作を非同期および同期が混在することはできません。 リダイレクトされたストリームの&1; 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります</xref:System.Diagnostics.Process>。 たとえばに従っていません BeginOutputReadLine への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>で、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはその逆</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.IO.StreamReader.ReadLine%2A>。 ただし、さまざまなモードで異なる&2; つのストリームを読み取ることができます。 たとえば、BeginOutputReadLine を呼び出すし、し、呼び出す<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A></xref:System.IO.StreamReader.ReadLine%2A>。"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "非同期の読み取り操作をキャンセルのリダイレクトされた<xref:System.Diagnostics.Process.StandardError*>アプリケーションのストリーム</xref:System.Diagnostics.Process.StandardError*>。"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A>。</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead は、非同期読み取り操作を終了します。       キャンセル後に呼び出すことによって、非同期読み取り操作を再開することができます<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>再度</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。       CancelErrorRead を呼び出すときに進行中のすべての読み取り操作<xref:System.Diagnostics.Process.StandardError%2A>が完了してから、イベント ハンドラーが無効にします</xref:System.Diagnostics.Process.StandardError%2A>。 出力をさらにリダイレクトすべて<xref:System.Diagnostics.Process.StandardError%2A>バッファーに保存されます</xref:System.Diagnostics.Process.StandardError%2A>。 イベント ハンドラー呼び出しを再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、保存済みの出力は、イベント ハンドラーに送信し、非同期読み取り操作を再開します</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 非同期の読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に、既存のイベント ハンドラーを削除する必要があります: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > リダイレクトされたで読み取り操作を非同期および同期が混在することはできません<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A>。 リダイレクトされたストリームの&1; 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります</xref:System.Diagnostics.Process>。 キャンセルすると、非同期の読み取り操作で<xref:System.Diagnostics.Process.StandardError%2A>一度からの読み取り、ストリーム、使用する必要がある必要があります<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を再開する</xref:System.Diagnostics.Process.BeginErrorReadLine%2A></xref:System.Diagnostics.Process.StandardError%2A>。 場合は、同期読み取りメソッドを呼び出して CancelErrorRead に従っていない<xref:System.Diagnostics.Process.StandardError%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Diagnostics.Process.StandardError*>非同期読み取り操作のストリームが有効になっていません</xref:System.Diagnostics.Process.StandardError*>。"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "非同期の読み取り操作をキャンセルのリダイレクトされた<xref:System.Diagnostics.Process.StandardOutput*>アプリケーションのストリーム</xref:System.Diagnostics.Process.StandardOutput*>。"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A>。</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead は、非同期読み取り操作を終了します。       キャンセル後に呼び出すことによって、非同期読み取り操作を再開することができます<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>再度</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。       CancelOutputRead を呼び出すときに進行中のすべての読み取り操作<xref:System.Diagnostics.Process.StandardOutput%2A>が完了してから、イベント ハンドラーが無効にします</xref:System.Diagnostics.Process.StandardOutput%2A>。 出力をさらにリダイレクトすべて<xref:System.Diagnostics.Process.StandardOutput%2A>バッファーに保存されます</xref:System.Diagnostics.Process.StandardOutput%2A>。 イベント ハンドラー呼び出しを再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、保存済みの出力は、イベント ハンドラーに送信し、非同期読み取り操作を再開します</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 非同期の読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に、既存のイベント ハンドラーを削除する必要があります: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > リダイレクトされたで読み取り操作を非同期および同期が混在することはできません<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A>。 リダイレクトされたストリームの&1; 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります</xref:System.Diagnostics.Process>。 キャンセルすると、非同期の読み取り操作で<xref:System.Diagnostics.Process.StandardOutput%2A>一度からの読み取り、ストリーム、使用する必要がある必要があります<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を再開する</xref:System.Diagnostics.Process.BeginOutputReadLine%2A></xref:System.Diagnostics.Process.StandardOutput%2A>。 場合は、同期読み取りメソッドを呼び出して CancelOutputRead に従っていない<xref:System.Diagnostics.Process.StandardOutput%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Diagnostics.Process.StandardOutput*>非同期読み取り操作のストリームが有効になっていません</xref:System.Diagnostics.Process.StandardOutput*>。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "このコンポーネントに関連付けられているすべてのリソースを解放します。"
  remarks: "Close メソッドには、待機していた、プロセス ハンドルを終了し、プロセスに固有のプロパティをクリアする場合は、終了の待機を停止する処理が行われます。 閉じる閉じません標準出力、入力、およびエラーのリーダーとライターが外部から参照されている場合にします。      > [!NOTE] >、<xref:System.Diagnostics.Process.Dispose%2A>メソッドは Close を呼び出します</xref:System.Diagnostics.Process.Dispose%2A>。 配置すること、<xref:System.Diagnostics.Process>内のオブジェクト、`using`ブロック Close を呼び出す必要がないリソースを破棄します</xref:System.Diagnostics.Process>。"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "メイン ウィンドウにクローズ メッセージを送信することによってユーザー インターフェイスのあるプロセスを終了します。"
  remarks: "プロセスを実行するときに、メッセージ ループは、待機状態にです。 Windows メッセージが、オペレーティング システムによって、プロセスに送信されるたびにメッセージ ループを実行します。 CloseMainWindow を呼び出すことが、整形式のアプリケーションで子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループを取り消すと、メイン ウィンドウに近いへの要求を送信します。 CloseMainWindow を呼び出すことによって、プロセスを終了する要求は、アプリケーションの終了を強制しません。 アプリケーションが終了してから、前にユーザーの確認を求めることや終了を拒否できます。 アプリケーションを終了するを使用して、<xref:System.Diagnostics.Process.Kill%2A>メソッド</xref:System.Diagnostics.Process.Kill%2A>。 CloseMainWindow の動作は、システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーのものと同じです。 そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。       プロセスによって編集されたデータまたはプロセスに割り当てられたリソースが失われる場合<xref:System.Diagnostics.Process.Kill%2A>。</xref:System.Diagnostics.Process.Kill%2A>を呼び出す <xref:System.Diagnostics.Process.Kill%2A>異常なプロセス終了では、および必要な場合にのみ使用する必要があります。</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow では、プロセスの適切な順序の終了を有効にし、インターフェイスを持つアプリケーションのことをお勧めようにすべてのウィンドウを閉じます。 使用することができます CloseMainWindow が失敗した場合、 <xref:System.Diagnostics.Process.Kill%2A>、プロセスを終了する</xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A>グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。</xref:System.Diagnostics.Process.Kill%2A>       呼び出すことができます<xref:System.Diagnostics.Process.Kill%2A>とローカル コンピューターで実行されているプロセスに対してのみ CloseMainWindow</xref:System.Diagnostics.Process.Kill%2A> 。 終了するリモート コンピューター上のプロセスが発生することはできません。 リモート コンピューターで実行されているプロセスの情報のみ表示できます。"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>クローズ メッセージが正常に送信されました。 場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>関連付けられたプロセスにメイン ウィンドウがない場合、または (たとえば、モーダル ダイアログ ボックスが表示されている場合など) のメイン ウィンドウが無効になっています。"
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定、 &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;プロパティを<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスは既に終了しています。       または、これに関連付けられたプロセスがない<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "このプロセスによって使用されているすべてのリソースを解放します。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マネージ コードとアンマネージ リソースを解放するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>アンマネージ リソースだけを解放します。"
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または設定するかどうか、 <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref>プロセスが終了したときに、イベントを発生させる必要があります。"
  remarks: "EnableRaisingEvents プロパティは、オペレーティング システムがプロセスをシャット ダウン時にコンポーネントを通知する必要があるかどうかを示します。 EnableRaisingEvents プロパティは、プロセスは終了して、アプリケーションに通知する非同期処理で使用されます。 強制的に終了イベント (終了イベントが発生するまで、アプリケーションの処理が中断される) を同期的に待機するアプリケーションを使用して、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッド</xref:System.Diagnostics.Process.WaitForExit%2A>。      > [!NOTE] > をダブルクリックして Visual Studio を使用している場合、<xref:System.Diagnostics.Process>プロジェクトで、コンポーネント、<xref:System.Diagnostics.Process.Exited>自動的に生成されたイベントのデリゲートとイベント ハンドラー</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> 。 追加のコードでは、EnableRaisingEvents プロパティを設定`false`です。 このプロパティを変更する必要があります`true`関連付けられたプロセスが終了したときに実行されるイベント ハンドラーのです。       後、関連付けられたプロセスが終了するときにシャット ダウン、オペレーティング システムによってか、正常終了または異常終了、経由、オペレーティング システムに通知プロセスが関連付けられているどのプロセス コンポーネントは各コンポーネントの EnableRaisingEvents 値として`true`です。 コンポーネントには、プロセスが開始されている場合、コンポーネントは、オペレーティング システムでまだ保存されている、関連付けられたプロセスの管理情報をし、アクセスできます。 このような情報が含まれています、 <xref:System.Diagnostics.Process.ExitTime%2A>、 <xref:System.Diagnostics.Process.ExitCode%2A></xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A> 。       関連付けられたプロセスが終了した後、<xref:System.Diagnostics.Process.Handle%2A>のコンポーネントを示していない既存のプロセス リソース</xref:System.Diagnostics.Process.Handle%2A>。 代わりに、プロセスのリソースに関する情報のオペレーティング システムのアクセスにのみ使用できます。 オペレーティング システムが、解放されていない終了のプロセスへのハンドルがあることに注意してください<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>メモリ内の情報</xref:System.Diagnostics.Process.Handle%2A></xref:System.Diagnostics.Process.ExitTime%2A></xref:System.Diagnostics.Process>。       プロセスが終了するを監視に関連するコストがあります。 EnableRaisingEvents 場合`true`、<xref:System.Diagnostics.Process.Exited>イベントは、関連付けられたプロセスが終了するときに発生します</xref:System.Diagnostics.Process.Exited>。 指定したプロシージャ、<xref:System.Diagnostics.Process.Exited>時に実行されるイベント</xref:System.Diagnostics.Process.Exited>。       場合によっては、アプリケーションはプロセスを開始しますが、そのクロージャの通知を受信する必要はありません。 など、アプリケーションは、テキストの編集 を実行するアクセス許可をメモ帳を起動がそれ以上の活用、メモ帳アプリケーション。 通知されません、プロセスが終了すると、アプリケーションの継続的な操作に関係がないために選択できます。 設定 EnableRaisingEvents`false`システム リソースを節約します。"
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、 <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref>関連付けられたプロセスが終了すると、イベントを発生させる必要があります (正常終了またはへの呼び出しのどちらかを通じて<xref:System.Diagnostics.Process.Kill*>)、それ以外の<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Diagnostics.Process.Kill*> 。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "配置、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>オペレーティング システムと対話する状態でコンポーネントをネイティブのプロパティを有効にして、特殊なモードで実行されているプロセス<xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;></xref>現在のスレッドにします。"
  remarks: "いくつかのオペレーティング システム プロセスは、特殊なモードで実行されます。 コンポーネントの EnterDebugMode を呼び出した場合を除きのプロパティを読み取るか、これらのプロセスにアタッチしようとしています。 ことはできません。 呼び出す<xref:System.Diagnostics.Process.LeaveDebugMode%2A>特殊なモードで実行されているこれらのプロセスへのアクセスが不要します</xref:System.Diagnostics.Process.LeaveDebugMode%2A>。"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーションが、リダイレクトされたに書き込む場合に発生<xref:System.Diagnostics.Process.StandardError*>ストリーム</xref:System.Diagnostics.Process.StandardError*>。"
  remarks: "ErrorDataReceived イベントでは、関連付けられたプロセスが、リダイレクトされたに書き込まれたことを示します<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A>。       <xref:System.Diagnostics.Process.StandardError%2A>。</xref:System.Diagnostics.Process.StandardError%2A>非同期の読み取り操作中にのみ、イベントが発生します。 非同期読み取り操作を開始するには<xref:System.Diagnostics.Process.StandardError%2A>の<xref:System.Diagnostics.Process>ErrorDataReceived イベントにイベント ハンドラーを追加、および<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>を呼び出して</xref:System.Diagnostics.Process>ストリーム</xref:System.Diagnostics.Process.StandardError%2A>をリダイレクトする必要があります。 その後、ErrorDataReceived イベント シグナルたびに、プロセスに行を書き込む、リダイレクトされた<xref:System.Diagnostics.Process.StandardError%2A>プロセスを終了するまで、ストリームまたは<xref:System.Diagnostics.Process.CancelErrorRead%2A>。</xref:System.Diagnostics.Process.CancelErrorRead%2A>の呼び出し</xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > 非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを出力バッファーがフラッシュされたことを確認してください</xref:System.Diagnostics.Process.WaitForExit%2A>。"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスが終了したときを指定した値を取得します。"
  remarks: "ExitCode を使用して、システム プロセスは終了ときに返される状態を取得します。 かなり整数からの戻り値と同じように、終了コードを使用することができます、`main()`プロシージャです。       プロセスの ExitCode 値には、そのプロセスのアプリケーションの開発者によって実装されている特定の規則が反映されます。 意思決定を行うコードで終了コード値を使用する場合は、アプリケーションのプロセスによって使用される終了コード規則を理解していることを確認します。       通常、開発者は ExitCode 値は&0; で正常に終了を示すためし、呼び出し元のメソッドを使用して、異常なプロセスの終了の原因を識別する&0; 以外の値によってエラーを指定します。 これらのガイドラインに従う必要はありませんが、規則できます。       プロセスが終了する前に、ExitCode を取得しようとする場合の試行は例外をスローします。 確認、<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了するかどうかを確認するには、最初のプロパティ</xref:System.Diagnostics.Process.HasExited%2A>。      > [!NOTE] > 非同期イベント ハンドラーを標準出力がリダイレクトされたときに可能であれば、出力の処理が完了していない場合に<xref:System.Diagnostics.Process.HasExited%2A>返します`true`</xref:System.Diagnostics.Process.HasExited%2A>。 非同期イベント処理が完了したことを呼び出してください<xref:System.Diagnostics.Process.WaitForExit>を受け取る<xref:System.Diagnostics.Process.HasExited%2A>。</xref:System.Diagnostics.Process.HasExited%2A>をチェックする前にパラメーターなしのオーバー ロード</xref:System.Diagnostics.Process.WaitForExit>       使用することができます、<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>メソッドを呼び出すと、関連付けられたプロセスが終了する</xref:System.Diagnostics.Process.Kill%2A></xref:System.Diagnostics.Process.CloseMainWindow%2A>。       関連付けられたプロセスが終了したときの通知の&2; つの方法: 同期的および非同期的にします。 同期通知が呼び出し元では、<xref:System.Diagnostics.Process.WaitForExit%2A>を関連付けられたコンポーネントを終了するまで、アプリケーションの処理を一時停止する方法</xref:System.Diagnostics.Process.WaitForExit%2A>。 非同期の通知は、<xref:System.Diagnostics.Process.Exited>イベント</xref:System.Diagnostics.Process.Exited>。 非同期の通知を使用するときに<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`の<xref:System.Diagnostics.Process>、プロセスが終了したことを示す通知を受信するコンポーネント</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.EnableRaisingEvents%2A>。"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "終了したときに関連付けられたプロセスが指定されているコード。"
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスが終了していません。       - または - プロセス<xref:System.Diagnostics.Process.Handle*>が正しくありません</xref:System.Diagnostics.Process.Handle*>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの ExitCode プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセスが終了したときに発生します。"
  remarks: "Exited イベントは、関連付けられたプロセスが終了していることを示します。 この発生したことを示します、プロセス (中断) 終了したか、正常終了します。 場合にのみ、このイベントが発生する可能性がの値、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは`true`</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>。       関連付けられたプロセスが終了したときの通知の&2; つの方法: 同期的および非同期的にします。 同期の通知呼び出しの意味、<xref:System.Diagnostics.Process.WaitForExit%2A>プロセスを終了するまで、現在のスレッドをブロックするメソッド</xref:System.Diagnostics.Process.WaitForExit%2A>。 非同期の通知には、呼び出し元のスレッド間の実行を続行できる Exited イベントが使用されます。 後者の場合、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`Exited イベントを受け取る、呼び出し元のアプリケーション用</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>。       オペレーティング システムがシャット ダウン プロセス、Exited イベントのハンドラーを登録している他のすべてのプロセスを通知します。 この時点でなどにアクセスするいくつかのプロパティだけが終了したプロセスのハンドルを使用できます<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.HasExited%2A>そのハンドルを完全に解放されるまでに、オペレーティング システムが維持されます</xref:System.Diagnostics.Process.HasExited%2A></xref:System.Diagnostics.Process.ExitTime%2A>。      > [!NOTE] > 場合でも、終了したプロセスへのハンドルがある場合は、呼び出すことができません<xref:System.Diagnostics.Process.Start%2A>再接続するには、同じプロセス</xref:System.Diagnostics.Process.Start%2A>。 <xref:System.Diagnostics.Process.Start%2A>自動的に関連付けられたプロセスを解放し同じファイルが、まったく新しい<xref:System.Diagnostics.Process.Handle%2A>。</xref:System.Diagnostics.Process.Handle%2A>プロセスに接続</xref:System.Diagnostics.Process.Start%2A>を呼び出す       Windows フォーム アプリケーションで、Exited イベントの使用に関する詳細については、次を参照してください、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティ。</xref:System.Diagnostics.Process.SynchronizingObject%2A> 。"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスが終了した時刻を取得します。"
  remarks: "プロセスが終了していない場合は、例外をスロー ExitTime プロパティを取得しようとしています。 使用して<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了するかどうかを決定する ExitTime プロパティを取得する前にします</xref:System.Diagnostics.Process.HasExited%2A>。"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "A<xref:System.DateTime>を示す、関連付けられたプロセスが終了しました</xref:System.DateTime>。"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの ExitTime プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しい取得<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントと現在アクティブなプロセスに関連付けます。"
  remarks: "このメソッドを使用して、新しい作成<xref:System.Diagnostics.Process>をインスタンス化し、ローカル コンピューター上のプロセス リソースに関連付けます</xref:System.Diagnostics.Process>。       などの類似<xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcessesByName%2A>、および<xref:System.Diagnostics.Process.GetProcesses%2A>メソッド、GetCurrentProcess を新しい既存のリソースに関連付けます<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcesses%2A></xref:System.Diagnostics.Process.GetProcessesByName%2A></xref:System.Diagnostics.Process.GetProcessById%2A>。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>呼び出し元のアプリケーションを実行しているプロセス リソースに関連付けられたコンポーネントです。"
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しいを返します<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネント、ローカル コンピューター上のプロセス id を指定します。"
  remarks: "このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ローカル コンピューター上のプロセス リソースに関連付けます</xref:System.Diagnostics.Process>。 プロセス リソースが既に存在して、コンピューターに GetProcessById がシステム リソースは作成されませんが、アプリケーションによって生成ではなく関連付けますリソースのため<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process>。 プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行されているプロセスにのみ取得できます</xref:System.Diagnostics.Process.Id%2A>。 プロセスの終了後に期限切れの識別子を渡す場合 GetProcessById 例外をスローします。       任意の特定のコンピューター上のプロセス id は一意です。 GetProcessById では、最大で&1; つのプロセスを返します。 特定のアプリケーションを実行しているすべてのプロセスを取得する場合は、使用<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 指定されたアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>に関連付けられたすべてのプロセスを含む配列を返します</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 これらの各プロセスの識別子の順番を照会できます。 プロセス id で表示できます、 `Processes` Windows タスク マネージャーのパネルです。 `PID`列には、プロセスに割り当てられているプロセス id が表示されます。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "プロセス リソースのシステムで一意な識別子です。"
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントで識別されるローカル プロセス リソースに関連付けられている、 <code> processId </code>パラメーター。"
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定されたプロセス、 <code> processId </code>パラメーターが実行されていません。 識別子は有効期限が切れて可能性があります。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "このオブジェクトによって、プロセスは開始されませんでした。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新しいを返します<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネント、ネットワーク上のプロセス id と、コンピューターの名前を指定します。"
  remarks: "このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ネットワーク上のリモート コンピューター上のプロセス リソースに関連付けます</xref:System.Diagnostics.Process>。 プロセス リソースが既に存在して、指定したコンピューターに GetProcessById がシステム リソースは作成されませんが、アプリケーションによって生成ではなく関連付けますリソースのため<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process>。 プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行されているプロセスにのみ取得できます</xref:System.Diagnostics.Process.Id%2A>。 プロセスの終了後に期限切れの識別子を渡す場合 GetProcessById 例外をスローします。       任意の特定のコンピューター上のプロセス id は一意です。 GetProcessById では、最大で&1; つのプロセスを返します。 特定のアプリケーションを実行しているすべてのプロセスを取得する場合は、使用<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 指定されたアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>に関連付けられたすべてのプロセスを含む配列を返します</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 これらの各プロセスの識別子の順番を照会できます。 プロセス id で表示できます、 `Processes` Windows タスク マネージャーのパネルです。 `PID`列には、プロセスに割り当てられているプロセス id が表示されます。       指定しない場合、 `machineName`、ローカル コンピューターが使用されます。 設定しているローカル コンピューターを指定する代わりに、`machineName`値に&quot;です。&quot;または空の文字列 (&quot;&quot;) です。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "プロセス リソースのシステムで一意な識別子です。"
    - id: machineName
      type: System.String
      description: "ネットワーク上のコンピューターの名前です。"
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントで識別されるリモート プロセス リソースに関連付けられている、 <code> processId </code>パラメーター。"
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定されたプロセス、 <code> processId </code>パラメーターが実行されていません。 識別子は有効期限が切れて可能性があります。       - または -、 <code> machineName </code>パラメーター構文が無効です。 名前には、長さゼロ (0) 可能性があります。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "このオブジェクトによって、プロセスは開始されませんでした。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新たに作成<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネント、ローカル コンピューター上の各プロセス リソースをします。"
  remarks: "新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし、ローカル コンピューター上のすべてのプロセス リソースに関連付ける</xref:System.Diagnostics.Process>。 プロセス リソースが既に存在して、ローカル コンピューター上 GetProcesses がシステム リソースは作成されませんが、アプリケーションによって生成されたしてため<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process>。 オペレーティング システム自体には、バック グラウンド プロセスが実行されて、この配列は空ではありません。       使用してその数を制限するには、コンピューターで実行中のプロセスをすべて取得しないようにする場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド</xref:System.Diagnostics.Process.GetProcessesByName%2A></xref:System.Diagnostics.Process.GetProcessById%2A>。 <xref:System.Diagnostics.Process.GetProcessById%2A>作成、<xref:System.Diagnostics.Process>メソッドに渡すプロセス識別子によって、システムで識別されるプロセスに関連付けられているコンポーネント</xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>配列を作成<xref:System.Diagnostics.Process>関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントがメソッドに渡します</xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > サービス ホスト プロセス (svchost.exe) の同じインスタンス内で複数の Windows サービスを読み込むことができます。 GetProcesses が個々 のサービスです。 これらを識別できません。そのため、 <xref:System.ServiceProcess.ServiceController.GetServices%2A>。</xref:System.ServiceProcess.ServiceController.GetServices%2A>を参照してください。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "型の配列<xref href=&quot;System.Diagnostics.Process&quot;></xref>ローカル コンピューターで実行されているすべてのプロセス リソースを表すです。"
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "新たに作成<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントに対して指定したコンピューター上の各プロセス リソース。"
  remarks: "新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし (通常はリモート) 指定したコンピューター上のすべてのプロセス リソースに関連付ける</xref:System.Diagnostics.Process>。 プロセス リソースが既に存在して、ローカル コンピューターであるため<xref:System.Diagnostics.Process.GetProcesses%2A>システム リソースは作成されませんが、アプリケーションによって生成されたして<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcesses%2A>。 オペレーティング システム自体には、バック グラウンド プロセスが実行されて、この配列は空ではありません。       使用してその数を制限するには、コンピューターで実行中のプロセスをすべて取得しないようにする場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド</xref:System.Diagnostics.Process.GetProcessesByName%2A></xref:System.Diagnostics.Process.GetProcessById%2A>。 <xref:System.Diagnostics.Process.GetProcessById%2A>作成、<xref:System.Diagnostics.Process>メソッドに渡すプロセス識別子によって、システムで識別されるプロセスに関連付けられているコンポーネント</xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>配列を作成<xref:System.Diagnostics.Process>関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントがメソッドに渡します</xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process.GetProcessesByName%2A>       このオーバー ロード、<xref:System.Diagnostics.Process.GetProcesses%2A>メソッドが、ネットワーク上のリモート コンピューターで実行されているプロセス リソースの一覧の取得に使用される一般を渡すことによって、ローカル コンピューターを指定することが&quot;です&quot;。</xref:System.Diagnostics.Process.GetProcesses%2A> 。      > [!NOTE] > サービス ホスト プロセス (svchost.exe) の同じインスタンス内で複数の Windows サービスを読み込むことができます。 GetProcesses が個々 のサービスです。 これらを識別できません。そのため、 <xref:System.ServiceProcess.ServiceController.GetServices%2A>。</xref:System.ServiceProcess.ServiceController.GetServices%2A>を参照してください。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "プロセスの一覧を読み取る対象のコンピューター。"
    return:
      type: System.Diagnostics.Process[]
      description: "型の配列<xref href=&quot;System.Diagnostics.Process&quot;></xref>指定されたコンピューターで実行されているすべてのプロセス リソースを表すです。"
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>パラメーター構文が無効です。 長さがゼロ (0) があります。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "オペレーティング システム プラットフォームは、リモート コンピューターでこの操作をサポートしていません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "API のプロセス情報を取得するために使用するパフォーマンス カウンターにアクセスする問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "基になるシステム API へのアクセスに問題が発生しました。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "配列を新規作成<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントし、指定したプロセス名を共有するローカル コンピューターのすべてのプロセス リソースに関連付けます。"
  remarks: "新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし、ローカル コンピューターで、同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付ける</xref:System.Diagnostics.Process>。 プロセス リソースが既に存在して、コンピューターに GetProcessesByName がシステム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成されるため<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process>。 A`processName`が現在実行されていない、ローカル コンピューター上、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定することができます。       このプロセスの名前は、Outlook の場合、拡張子 .exe またはパスが含まれていないなど、プロセスのフレンドリ名です。 GetProcessesByName は取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作する場合に便利です。 たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。       プロセス<xref:System.Diagnostics.Process.Id%2A>は、システム上の&1; つのプロセス リソースに一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター</xref:System.Diagnostics.Process.Id%2A> 。 したがって、<xref:System.Diagnostics.Process.GetProcessById%2A>が返されます&1; つのプロセス多くても GetProcessesByName を返しますが、関連付けられているすべてのプロセスを格納する配列</xref:System.Diagnostics.Process.GetProcessById%2A>。 標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、これらの各プロセスの識別子の順番を照会できます。 プロセス リソースにアクセスすることはできません、プロセスの名前を使ってだけでは、配列を取得したら<xref:System.Diagnostics.Process>コンポーネントが関連付けられているプロセス リソースにすることができますを開始、終了、およびそれ以外の場合、システム リソースを操作します</xref:System.Diagnostics.Process>。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "プロセスのフレンドリ名。"
    return:
      type: System.Diagnostics.Process[]
      description: "型の配列<xref href=&quot;System.Diagnostics.Process&quot;></xref>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表すです。"
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "API のプロセス情報を取得するために使用するパフォーマンス カウンターにアクセスする問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有です。"
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "配列を新規作成<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントし、指定したプロセス名を共有するリモート コンピューターのすべてのプロセス リソースに関連付けます。"
  remarks: "新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし、指定されたコンピューターで、同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付ける</xref:System.Diagnostics.Process>。 プロセス リソースが既に存在して、コンピューターにあるため<xref:System.Diagnostics.Process.GetProcessesByName%2A>システム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成された<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>。 A`processName`が現在実行されていない、ローカル コンピューター上、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定することができます。       このプロセスの名前は、Outlook の場合、拡張子 .exe またはパスが含まれていないなど、プロセスのフレンドリ名です。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作するのに便利です。</xref:System.Diagnostics.Process.GetProcessesByName%2A> たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。       プロセス<xref:System.Diagnostics.Process.Id%2A>は、システム上の&1; つのプロセス リソースに一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター</xref:System.Diagnostics.Process.Id%2A> 。 したがって、<xref:System.Diagnostics.Process.GetProcessById%2A>多くても&1; つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A>関連付けられているすべてのプロセスを含む配列を返します</xref:System.Diagnostics.Process.GetProcessesByName%2A></xref:System.Diagnostics.Process.GetProcessById%2A>。 標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、これらの各プロセスの識別子の順番を照会できます。 プロセス リソースにアクセスすることはできません、プロセスの名前を使ってだけでは、配列を取得したら<xref:System.Diagnostics.Process>コンポーネントが関連付けられているプロセス リソースにすることができますを開始、終了、およびそれ以外の場合、システム リソースを操作します</xref:System.Diagnostics.Process>。       このオーバー ロードを使用すると、ローカル コンピューター上だけでなく、リモート コンピューター上のプロセスを取得します。 使用して&quot;です。&quot;ローカル コンピューターを指定します。 既定では、ローカル コンピューターを使用して別のオーバー ロードが存在します。       プロセスに関する統計情報などの情報を表示するのみのリモート コンピューター上のプロセスにアクセスできます。 閉じて、終了することはできません (を使用して<xref:System.Diagnostics.Process.Kill%2A>)、またはリモート コンピューター上のプロセスを開始します</xref:System.Diagnostics.Process.Kill%2A>。"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "プロセスのフレンドリ名。"
    - id: machineName
      type: System.String
      description: "ネットワーク上のコンピューターの名前です。"
    return:
      type: System.Diagnostics.Process[]
      description: "型の配列<xref href=&quot;System.Diagnostics.Process&quot;></xref>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表すです。"
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>パラメーター構文が無効です。 長さがゼロ (0) があります。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "オペレーティング システム プラットフォームは、リモート コンピューターでこの操作をサポートしていません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "API のプロセス情報を取得するために使用するパフォーマンス カウンターにアクセスする問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "基になるシステム API へのアクセスに問題が発生しました。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスのネイティブ ハンドルを取得します。"
  remarks: "アプリケーションでは、多くのプロセス情報および制御関数のパラメーターとして使用できるプロセスへのハンドルを取得できます。 このハンドルを使用するには初期化するために、<xref:System.Threading.WaitHandle>またはプラットフォームでネイティブ メソッドの呼び出しを呼び出す</xref:System.Threading.WaitHandle>。       このプロセスのハンドルは、アプリケーションごとにつまり、ハンドルを共有することはできませんプロセス プライベートです。 プロセスを含むプロセスもは<xref:System.Diagnostics.Process.Id%2A>、これとは異なり、ハンドルは一意と、そのため、システム全体で有効です</xref:System.Diagnostics.Process.Id%2A>。       呼び出すことによって開始されたプロセスのみ<xref:System.Diagnostics.Process.Start%2A>の対応するハンドル プロパティを設定する<xref:System.Diagnostics.Process>インスタンス</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A>。"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "プロセスが開始されたときに、オペレーティング システムが関連付けられたプロセスに割り当てられているハンドルです。 システムでは、このハンドルを使用して、プロセス属性の追跡します。"
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスが開始されていないかが終了しました。 これに関連付けられたプロセスがないので、Handle プロパティを読み取ることができません<xref href=&quot;System.Diagnostics.Process&quot;></xref>インスタンス。       - または -、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>インスタンスが実行中のプロセスに関連付けられているが、フル アクセス権を持つハンドルを取得するために必要なアクセス許可がありません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスのハンドル プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセスが開いたハンドルの数を取得します。"
  remarks: "ハンドルは、プロセス オブジェクトを参照するための手段を提供します。 プロセスでは、ファイル、リソース、メッセージ キュー、およびその他の多くのオペレーティング システムのオブジェクトへのハンドルを取得できます。 オペレーティング システム ハンドルの数が&0; である場合にのみ、プロセスに関連付けられているメモリを解放します。"
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "プロセスが開いたオペレーティング システム ハンドルの数。"
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定、 &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;プロパティを<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスが終了したかどうかを示す値を取得します。"
  remarks: "値`true`HasExited は、関連付けられたプロセスが終了した、通常または異常のいずれかを示すためです。 リクエストするか<xref:System.Diagnostics.Process.CloseMainWindow%2A>、または<xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A></xref:System.Diagnostics.Process.CloseMainWindow%2A>を呼び出すことによって終了する関連付けられたプロセスを強制 ハンドルが開かれているプロセスの場合は、オペレーティング システムは、プロセスが終了しましたが、ハンドル、終了コード、および終了時刻などのプロセスに関する管理情報を保持する場合、プロセス メモリを解放します。 この情報を取得するには、使用することができます、<xref:System.Diagnostics.Process.ExitCode%2A>と<xref:System.Diagnostics.Process.ExitTime%2A>プロパティ</xref:System.Diagnostics.Process.ExitTime%2A></xref:System.Diagnostics.Process.ExitCode%2A>。 これらのプロパティは、このコンポーネントによって起動されたプロセスを自動的に設定されます。 管理情報がリリースされたときにすべて、<xref:System.Diagnostics.Process>システム プロセスに関連付けられているコンポーネントは破棄され、これ以上のハンドルを終了したプロセスに保持します</xref:System.Diagnostics.Process>。       コードとは無関係に、プロセスを終了できます。 このコンポーネントを使用して、プロセスを開始した場合、システムは、関連付けられたプロセスが個別に終了した場合でも、自動的に HasExited の値を更新します。      > [!NOTE] > 非同期イベント ハンドラーを標準出力がリダイレクトされたときにこのプロパティが返されるときでは出力の処理が完了していないことは`true`します。 非同期イベント処理が完了したことを呼び出して、 <xref:System.Diagnostics.Process.WaitForExit>HasExited をチェックする前にパラメーターを受け取らないオーバー ロード</xref:System.Diagnostics.Process.WaitForExit>。"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>によって、オペレーティング システム プロセスが参照されている場合、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントが終了します。 それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "オブジェクトに関連付けられているプロセスはありません。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "プロセスの終了コードを取得できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの HasExited プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスの一意の識別子を取得します。"
  remarks: "プロセス Id が関連付けられたプロセスが実行されていない場合は無効です。 そのため、Id プロパティを取得する前に、プロセスが実行されていることを確認する必要があります。 プロセスが終了するまでプロセス識別子は、システム全体でプロセスを一意に識別します。       新しいローカルまたはリモート コンピューターで実行されているプロセスを接続する<xref:System.Diagnostics.Process>インスタンスにプロセス id を渡すことによって、<xref:System.Diagnostics.Process.GetProcessById%2A>メソッド</xref:System.Diagnostics.Process.GetProcessById%2A></xref:System.Diagnostics.Process>。 <xref:System.Diagnostics.Process.GetProcessById%2A>`static`新しいコンポーネントを作成し、新しい Id プロパティを設定するメソッド<xref:System.Diagnostics.Process>自動的にインスタンス化します</xref:System.Diagnostics.Process>。</xref:System.Diagnostics.Process.GetProcessById%2A>       プロセス id は、システムで再利用できます。 Id プロパティの値は、関連付けられたプロセスが実行中にのみ一意です。 プロセスが終了した後、システムは、関連のないプロセスの Id プロパティの値を再利用できます。       識別子は、システム上で一意であるために渡すことができる他のスレッドを受け渡しする代わりに、<xref:System.Diagnostics.Process>インスタンス</xref:System.Diagnostics.Process>。 この操作は、システム リソースを節約まだ、プロセスが正しく識別されることを保証します。"
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "これによって参照されているプロセスのシステムによって生成された一意の識別子<xref href=&quot;System.Diagnostics.Process&quot;></xref>インスタンス。"
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスの Id プロパティが設定されていません。       - または - これに関連付けられたプロセスがない<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定、 &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;プロパティを<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスが直ちに停止します。"
  remarks: "Kill 強制的に、プロセスの終了中に<xref:System.Diagnostics.Process.CloseMainWindow%2A>のみ、終了を要求します</xref:System.Diagnostics.Process.CloseMainWindow%2A>。 グラフィカル インターフェイスを持つプロセスを実行するときに、メッセージ ループは、待機状態です。 Windows メッセージが、オペレーティング システムによって、プロセスに送信されるたびにメッセージ ループを実行します。 呼び出す<xref:System.Diagnostics.Process.CloseMainWindow%2A>、メイン ウィンドウに、アプリケーションでは整形式、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループでは失効の近くに要求を送信します</xref:System.Diagnostics.Process.CloseMainWindow%2A>。 呼び出すことによって、プロセスを終了する要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>アプリケーションの終了を強制されません</xref:System.Diagnostics.Process.CloseMainWindow%2A>。 アプリケーションが終了してから、前にユーザーの確認を求めることや終了を拒否できます。 アプリケーションの終了を強制するには、Kill メソッドを使用します。 動作<xref:System.Diagnostics.Process.CloseMainWindow%2A>システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーの場合と同じです</xref:System.Diagnostics.Process.CloseMainWindow%2A>。 そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。      > [!NOTE] >、Kill メソッドが非同期的に実行します。 Kill メソッドを呼び出した後に呼び出し、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを終了しても、または確認するを待ち、 <xref:System.Diagnostics.Process.HasExited%2A>、プロセスが終了したかどうかを決定するプロパティ</xref:System.Diagnostics.Process.HasExited%2A></xref:System.Diagnostics.Process.WaitForExit%2A>。       Kill を呼び出す場合に、プロセスによって編集されたデータまたはプロセスに割り当てられているリソースを失われることができます。 Kill は異常なプロセス終了し、必要な場合にのみ使用する必要があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A>プロセスの適切な順序の終了を有効にし、インターフェイスを持つアプリケーションにも適していますが、すべてのウィンドウを閉じます。</xref:System.Diagnostics.Process.CloseMainWindow%2A> 場合<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗した場合、Kill を使用して、プロセスを終了します</xref:System.Diagnostics.Process.CloseMainWindow%2A>。 強制終了は、グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。       Kill を呼び出すことができ、 <xref:System.Diagnostics.Process.CloseMainWindow%2A>、ローカル コンピューターで実行されているプロセスに対してのみです</xref:System.Diagnostics.Process.CloseMainWindow%2A>。 終了するリモート コンピューター上のプロセスが発生することはできません。 リモート コンピューターで実行されているプロセスの情報のみ表示できます。      > [!NOTE] > プロセスを終了して現在中に、強制終了メソッドの呼び出しが行われた場合、<xref:System.ComponentModel.Win32Exception>アクセス拒否がスローされます</xref:System.ComponentModel.Win32Exception>。"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられたプロセスを終了できませんでした。       または、プロセスは終了します。       または、関連付けられたプロセスが Win16 実行可能ファイル。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの強制終了を呼び出すしようとするとします。 このメソッドは、ローカル コンピューターで実行中のプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスは既に終了しています。       - または - これに関連付けられたプロセスがない<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。"
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "<xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントを特殊なモードで実行されているオペレーティング システム プロセスと対話する状態から解放します。"
  remarks: "いくつかのオペレーティング システム プロセスは、特殊なモードで実行されます。 プロパティを読み取るか、これらのプロセスにアタッチしようとしていますは、呼び出した<xref:System.Diagnostics.Process.EnterDebugMode%2A>コンポーネント。</xref:System.Diagnostics.Process.EnterDebugMode%2A> 。 特殊なモードで実行されているこれらのプロセスへのアクセスが不要になったときに、LeaveDebugMode を呼び出します。"
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスが実行されているコンピューターの名前を取得します。"
  remarks: "統計データを表示してがリモート コンピューターで実行されているプロセスのプロセス情報を呼び出すことはできません<xref:System.Diagnostics.Process.Start%2A>、 <xref:System.Diagnostics.Process.CloseMainWindow%2A>、または<xref:System.Diagnostics.Process.Kill%2A>リモート コンピューターにします</xref:System.Diagnostics.Process.Kill%2A></xref:System.Diagnostics.Process.CloseMainWindow%2A></xref:System.Diagnostics.Process.Start%2A>。      > [!NOTE] >、ローカル コンピューターでは、関連付けられたプロセスを実行する場合、このプロパティはピリオドを返します (&quot;です。&quot;) マシン名をします。 使用する必要があります、<xref:System.Environment.MachineName%2A?displayProperty=fullName>正しいコンピューター名を取得するプロパティ</xref:System.Environment.MachineName%2A?displayProperty=fullName>。"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "関連付けられたプロセスがで実行されているコンピューターの名前。"
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "これに関連付けられているプロセスはありません<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。"
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスのメイン モジュールを取得します。"
  remarks: "プロセス モジュールでは、特定のプロセスに読み込まれる.dll .exe またはファイルを表します。 MainModule プロパティでは、モジュール名、ファイル名、およびモジュールのメモリの詳細をなど、プロセスを開始するために使用する実行可能ファイルに関する情報を表示できます。"
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "<xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref>プロセスを開始に使用されました。"
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの MainModule プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "32 ビット プロセスが 64 ビット プロセスのモジュールにアクセスしようとしています。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセス<xref:System.Diagnostics.Process.Id*>は使用できません</xref:System.Diagnostics.Process.Id*>。       または、プロセスが終了しました。"
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスのメイン ウィンドウのウィンドウ ハンドルを取得します。"
  remarks: "メイン ウィンドウが、フォーカスされているプロセスによって開かれたウィンドウ (、<xref:System.Windows.Forms.Form.TopLevel%2A>形式).</xref:System.Windows.Forms.Form.TopLevel%2A> 使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>が変更された場合は、現在のメイン ウィンドウ ハンドルを取得するオブジェクト</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Refresh%2A>。 一般に、ウィンドウ ハンドルがキャッシュされているために使用<xref:System.Diagnostics.Process.Refresh%2A>、現在のハンドルを取得することを保証するために事前</xref:System.Diagnostics.Process.Refresh%2A>。       ローカル コンピューターで実行されているプロセスに対してのみ MainWindowHandle プロパティを取得できます。 MainWindowHandle プロパティは、プロセスに関連付けられているウィンドウを一意に識別する値です。       プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみに関連付けられているメイン ウィンドウがあります。 関連付けられたプロセスにメイン ウィンドウ、MainWindowHandle 値は&0; です。 値は、0 の非表示になって、プロセスのタスク バーに表示されていないプロセス、つまりもです。 これは、タスク バーの右端にある、通知領域にアイコンとして表示されるプロセスの場合です。       プロセスを開始したしてメイン ウィンドウ ハンドルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>メソッドを処理が完了以降では、メイン ウィンドウのハンドルが作成されていることを確認します</xref:System.Diagnostics.Process.WaitForInputIdle%2A>。 それ以外の場合は、例外がスローされます。"
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "関連付けられたプロセスのメイン ウィンドウのシステムが生成したウィンドウ ハンドル。"
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスが終了したため、MainWindowHandle が定義されていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの MainWindowHandle プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセスのメイン ウィンドウのキャプションを取得します。"
  remarks: "プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみに関連付けられているメイン ウィンドウがあります。 関連付けられたプロセスにメイン ウィンドウがない場合 (ように<xref:System.Diagnostics.Process.MainWindowHandle%2A>ゼロ)、MainWindowTitle は空の文字列 (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> プロセスを開始したしてメイン ウィンドウのタイトルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>メソッドを処理が完了以降では、メイン ウィンドウのハンドルが作成されていることを確認します</xref:System.Diagnostics.Process.WaitForInputIdle%2A>。 それ以外の場合、システムでは、例外をスローします。      > [!NOTE] > メイン ウィンドウが現在フォーカスのあるウィンドウであるこのできないことがあります、プロセスの主なウィンドウに注意してください。 使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>が変更された場合は、現在のメイン ウィンドウ ハンドルを取得するオブジェクト</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Refresh%2A>。"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "プロセスのメイン ウィンドウのタイトル。"
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "MainWindowTitle プロパティは、プロセスが終了したため、定義されていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの MainWindowTitle プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または関連付けられたプロセスのバイト単位で許可される最大のワーキング セット サイズを設定します。"
  remarks: "プロセスのワーキング セットは、物理 RAM メモリ内のプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。       ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、アプリケーションの実行、.dll ファイルや system.dll ファイルのページなどのすべての命令を含むページが含まれます。 ワーキング セットのサイズが増加、必要なメモリが増加します。       プロセスでは、最小と最大ワーキング セットのサイズがします。 プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。 仮想メモリ マネージャー差を埋めようと少なくとも最小メモリ量常駐しているプロセスがアクティブな場合は最大サイズを超える保持しません。       システムでは、既定の作業セットのサイズを設定します。 MaxWorkingSet を使用してこれらのサイズを変更して<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバー</xref:System.Diagnostics.Process.MinWorkingSet%2A> 。 ただし、これらの値の設定は保証されません、メモリがある予約または常駐。      > [!NOTE] > システムの残りの部分から物理メモリを消費するプロセスのワーキング セットのサイズを大きくとします。 システム パフォーマンスが低下することができますが大きすぎるため、最小または最大ワーキング セットのサイズを要求しないことを確認します。"
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "ワーキング セットの最大許可されているサイズ (バイト単位)、プロセスのメモリにします。"
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "最大作業セット サイズが正しくありません。 これは、最小ワーキング セット サイズ以上にする必要があります。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているプロセス リソースからワーキング セット情報を取得できません。       - または - プロセス id またはプロセス ハンドルが、0、プロセスが開始されていないためです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの MaxWorkingSet プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセス<xref:System.Diagnostics.Process.Id*>は使用できません</xref:System.Diagnostics.Process.Id*>。       または、プロセスが終了しました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または関連付けられたプロセスのバイト単位で許可される最小のワーキング セット サイズを設定します。"
  remarks: "プロセスのワーキング セットは、物理 RAM メモリ内のプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。       ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、アプリケーションの実行、.dll ファイルや system.dll ファイルのページなどのすべての命令を含むページが含まれます。 ワーキング セットのサイズが増加、必要なメモリが増加します。       プロセスでは、最小と最大ワーキング セットのサイズがします。 プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。 仮想メモリ マネージャー差を埋めようと少なくとも最小メモリ量常駐しているプロセスがアクティブな場合は最大サイズを超える保持しません。       システムでは、既定の作業セットのサイズを設定します。 使用してこれらのサイズを変更することができます、<xref:System.Diagnostics.Process.MaxWorkingSet%2A>と MinWorkingSet メンバー</xref:System.Diagnostics.Process.MaxWorkingSet%2A> 。 ただし、これらの値の設定は保証されません、メモリがある予約または常駐。      > [!NOTE] > システムの残りの部分から物理メモリを消費するプロセスのワーキング セットのサイズを大きくとします。 システム パフォーマンスが低下することができますが大きすぎるため、最小または最大ワーキング セットのサイズを要求しないことを確認します。"
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "(バイト単位)、プロセスのメモリの最小ワーキング セットのために必要なサイズ。"
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "最小ワーキング セット サイズが正しくありません。 最大作業セット サイズ以下を指定する必要があります。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているプロセス リソースからワーキング セット情報を取得できません。       - または - プロセス id またはプロセス ハンドルが、0、プロセスが開始されていないためです。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの MinWorkingSet プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセス<xref:System.Diagnostics.Process.Id*>は使用できません</xref:System.Diagnostics.Process.Id*>。       または、プロセスが終了しました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスに読み込まれたモジュールを取得します。"
  remarks: "プロセス モジュールでは、特定のプロセスに読み込まれる.dll .exe またはファイルを表します。 A<xref:System.Diagnostics.ProcessModule>インスタンスでは、モジュール名、ファイル名、およびモジュールのメモリの詳細を含め、モジュールに関する情報を表示することができます</xref:System.Diagnostics.ProcessModule>。       プロセスは、メモリに複数のモジュールを読み込むことができます。 たとえば、.exe ファイルを追加の .dll ファイルを読み込むには、複数のモジュールがあります。       プロセスを開始した後、システムのプロセスが読み込まれるまでこのコレクションは空です。 プロセスにメイン ウィンドウがある場合は、呼び出す<xref:System.Diagnostics.Process.WaitForInputIdle%2A>一覧を取得するコレクションが空でない場合にことを確認するには、このプロパティを取得する前にします</xref:System.Diagnostics.Process.WaitForInputIdle%2A>。"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "型の配列<xref href=&quot;System.Diagnostics.ProcessModule&quot;></xref>関連付けられたプロセスに読み込まれたモジュールを表すです。"
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスのモジュールのプロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセス<xref:System.Diagnostics.Process.Id*>は使用できません</xref:System.Diagnostics.Process.Id*>。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "システム プロセスまたはアイドル状態のプロセスのいずれかのモジュールのプロパティにアクセスしようとするとします。 これらのプロセスでは、モジュールが存在しません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスに割り当てられたページングされないシステム メモリの量を取得します。"
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "システムが書き込むことができない仮想メモリ ページング ファイルに関連付けられたプロセスに割り当てられたメモリ (バイト単位) の容量。"
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスに割り当てられたページングされないシステム メモリの量を取得します。"
  remarks: "このプロパティによって返される値は、(バイト単位)、プロセスによって使用されているページングされないシステム メモリの現在のサイズを表します。 システム メモリは、オペレーティング システムによって使用される物理メモリであり、ページおよび非ページ プールに分割できます。 非ページ メモリの割り当ては、システム メモリ内に存在し、仮想メモリ ページング ファイルにページ アウトされません。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Pool Nonpaged Bytes**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "書き込むことができない仮想メモリ ページング ファイルに関連付けられたプロセスに割り当てられたバイトで、システム メモリの量。"
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "発生させる、 <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref>イベント。"
  remarks: "OnExited は API メソッドを発生させる、<xref:System.Diagnostics.Process.Exited>イベント</xref:System.Diagnostics.Process.Exited>。 OnExited 原因を呼び出して、<xref:System.Diagnostics.Process.Exited>イベントが発生するを使用してイベントを発生させる唯一の方法であり、<xref:System.Diagnostics.Process>コンポーネント</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Exited>。 コンポーネントからクラスを派生している場合、OnExited は主に使用します。       OnExited する代わりに、独自のイベント ハンドラーを記述できます。 独自のイベント ハンドラー デリゲートと、独自のイベント処理メソッドを作成します。      > [!NOTE] > Visual Studio 環境を使用しているイベント ハンドラー デリゲート (AddOnExited) とイベント処理メソッド (Process1_Exited) が作成するのにドラッグすると、<xref:System.Diagnostics.Process>コンポーネントをフォームにアイコンをダブルクリックします</xref:System.Diagnostics.Process>。 ときに実行するコードを作成する、 <xref:System.Diagnostics.Process.Exited>Process1_Exited プロシージャに入力されたイベントが発生した</xref:System.Diagnostics.Process.Exited>。 実装されているために、OnExited メンバーを作成する必要はありません。       イベントを発生させるには、イベント ハンドラーがデリゲートからを呼び出されます。 概要については、次を参照してください。[イベント](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーションが、リダイレクトされたに行を書き込むたびに発生<xref:System.Diagnostics.Process.StandardOutput*>ストリーム</xref:System.Diagnostics.Process.StandardOutput*>。"
  remarks: "OutputDataReceived イベントには、ことを示します、関連付けられている<xref:System.Diagnostics.Process>に改行文字をリダイレクトされたを終了して、行が書き込ま<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process>。       <xref:System.Diagnostics.Process.StandardOutput%2A>。</xref:System.Diagnostics.Process.StandardOutput%2A>非同期の読み取り操作中にイベントが有効になっています。 非同期読み取り操作を開始するには<xref:System.Diagnostics.Process.StandardOutput%2A>の<xref:System.Diagnostics.Process>OutputDataReceived イベントにイベント ハンドラーを追加、および<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出して</xref:System.Diagnostics.Process>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A>をリダイレクトする必要があります。 その後、OutputDataReceived イベント シグナルたびに、プロセスに行を書き込む、リダイレクトされた<xref:System.Diagnostics.Process.StandardOutput%2A>プロセスを終了するまで、ストリームまたは<xref:System.Diagnostics.Process.CancelOutputRead%2A>。</xref:System.Diagnostics.Process.CancelOutputRead%2A>の呼び出し</xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > 非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを出力バッファーがフラッシュされたことを確認してください</xref:System.Diagnostics.Process.WaitForExit%2A>。"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスに割り当てられたバイトのページ メモリの量を取得します。"
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスによって割り当てられたバイトのメモリの量。"
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスに割り当てられたバイトのページ メモリの量を取得します。"
  remarks: "このプロパティによって返される値は、(バイト単位)、プロセスによって使用される仮想メモリ ページング ファイル内のメモリの現在のサイズを表します。 オペレーティング システムでは、各プロセスの仮想アドレス空間を管理するのに物理メモリと組み合わせて仮想メモリ ページング ファイルを使用します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。 プロセスのオペレーティング システムで使用されるメモリのサイズを取得するを使用して、<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>プロパティ</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**ページ ファイル バイト**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "関連付けられたプロセスの仮想メモリ ページング ファイルに割り当てられたバイトのメモリの量。"
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量を取得します。"
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "システムが仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスに割り当てられたメモリ (バイト単位) の容量。"
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量を取得します。"
  remarks: "このプロパティの値によって返される値は、(バイト単位)、プロセスによって使用されているページング可能なシステム メモリの現在のサイズを表します。 システム メモリは、オペレーティング システムによって使用される物理メモリであり、ページおよび非ページ プールに分割できます。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。 プロセスによって使用される、アプリケーションのメモリのサイズを取得するを使用して、<xref:System.Diagnostics.Process.PagedMemorySize64%2A>プロパティ</xref:System.Diagnostics.Process.PagedMemorySize64%2A>。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**プール (ページ バイト)**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスに割り当てられたバイトで、システム メモリの量。"
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスによって使用されるバイト数で、仮想メモリ ページング ファイル内の最大メモリ量を取得します。"
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "仮想メモリ ページング ファイルに書き込むことができた関連付けられたプロセスによって割り当てられたバイトのメモリの最大量。"
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスによって使用されるバイト数で、仮想メモリ ページング ファイル内の最大メモリ量を取得します。"
  remarks: "このプロパティの値によって返される値は、(バイト単位)、起動されてから、プロセスによって使用される仮想メモリ ページング ファイル内のメモリの最大サイズを表します。 オペレーティング システムでは、各プロセスの仮想アドレス空間を管理するのに物理メモリと組み合わせて仮想メモリ ページング ファイルを使用します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値と等価です、**ページ ファイル バイト数ピーク**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "(バイト単位) が開始されてから、関連付けられたプロセスの仮想メモリ ページング ファイルに割り当てられたメモリの最大量。"
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスによって使用される仮想メモリの最大量を取得します。"
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "関連付けられたプロセスが要求したバイト数での仮想メモリの最大量。"
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスによって使用される仮想メモリの最大量を取得します。"
  remarks: "このプロパティによって返される値は、(バイト単位)、起動されてから、プロセスによって使用される仮想メモリの最大サイズを表します。 オペレーティング システムでは、物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページに読み込まれるページのいずれかの各プロセスの仮想アドレス空間をマップします。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**仮想バイト ピーク**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "(バイト単位) が開始されてから、関連付けられたプロセスに割り当てられた、仮想メモリの最大量。"
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスのワーキング セット最大値を取得します。"
  remarks: "プロセスのワーキング セットは、物理 RAM メモリ内のプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。       ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールやシステム ライブラリなど、プロセスが実行されるすべての指示を含むページが含まれます。"
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "(バイト単位)、関連付けられたプロセスがすべて一度に要求した物理メモリの最大量。"
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスによって使用されているバイトの物理メモリの最大量を取得します。"
  remarks: "このプロパティによって返される値は、ワーキング セット メモリ (バイト単位)、開始以降にプロセスによって使用の最大サイズを表します。 プロセスのワーキング セットは、物理 RAM メモリ内のプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。       ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールとシステム ライブラリからの指示を含む、プロセスが実行されるすべての指示を含むページが含まれます。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Working Set Peak**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "(バイト単位) が開始されてから、関連付けられたプロセスに割り当てられた物理メモリの最大量。"
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得またはかどうか関連付けられているプロセスの優先順位を一時的に上げるオペレーティング システムによってメイン ウィンドウのフォーカス時に示す値を設定します。"
  remarks: "対象の優先度クラスには、動的な優先順位の列挙値のいずれかのプロセスでスレッドが実行されるとき (<xref:System.Diagnostics.ProcessPriorityClass>、 <xref:System.Diagnostics.ProcessPriorityClass>、または<xref:System.Diagnostics.ProcessPriorityClass>)、システムは、待機状態から抜けたときに一時的に、スレッドの優先度をブーストします</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>。 この操作では、他のプロセスが現在のスレッドの処理を中断できなくなります。 PriorityBoostEnabled 設定は、既存のすべてのスレッドおよびプロセスによって作成された後でそのスレッドに影響します。 通常の動作を復元するに PriorityBoostEnabled プロパティを設定します。`false`です。      > [!NOTE] > 重要なオペレーティング システムやネットワーク機能、他のオペレーティング システム タスクと問題の原因からリソースをドレイン高すぎるの優先度を上げることができます。"
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>プロセスの優先順位を動的に上げる処理を実行するプロセスの待機状態から抜けたときに場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているプロセス リソースから priority boost 情報を取得できませんでした。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。       - または - プロセス識別子またはプロセス ハンドルが&0; です。 (プロセスが開始されていません。)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの PriorityBoostEnabled プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセス<xref:System.Diagnostics.Process.Id*>は使用できません</xref:System.Diagnostics.Process.Id*>。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または関連付けられたプロセスの全体的な優先順位カテゴリを設定します。"
  remarks: "プロセス優先度クラスには、スレッドの優先度レベルの範囲が含まれます。 プロセスで実行されている優先順位が異なるスレッドは、プロセスの優先度クラスを基準として実行します。 Win32 では、クラスごとの&7; つの基本優先度レベルを持つ&4; つの優先度クラスを使用します。 これらのプロセス優先度クラスがキャプチャされます、<xref:System.Diagnostics.ProcessPriorityClass>する列挙体にプロセスの優先順位を設定する<xref:System.Diagnostics.ProcessPriorityClass>、 <xref:System.Diagnostics.ProcessPriorityClass>、 <xref:System.Diagnostics.ProcessPriorityClass>、 <xref:System.Diagnostics.ProcessPriorityClass>、 <xref:System.Diagnostics.ProcessPriorityClass>、または<xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> プロセスがプロセッサにアクセスするための他のユーザーの前配置する必要がある場合、オペレーティング システムによって経過またはその他の要因、基本の優先度レベルを変更できます時間に基づいています。 さらに、設定、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>を一時的に待機状態から取得したスレッドの優先度レベルを上げる</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>。 プロセスが待機状態に戻るときに、優先順位がリセットされます。       <xref:System.Diagnostics.Process.BasePriority%2A>プロパティを使用して、プロセスに割り当てられている開始優先度を表示できます</xref:System.Diagnostics.Process.BasePriority%2A>。 ただし、これは、読み取り専用であるために使用できません、<xref:System.Diagnostics.Process.BasePriority%2A>プロセスの優先順位を設定するプロパティ</xref:System.Diagnostics.Process.BasePriority%2A>。 優先順位を変更するには、PriorityClass プロパティを取得または設定、プロセスの全体的な優先順位カテゴリを使用します。       システム モニターを使用して、優先度クラスを表示できません。 次の表は、関係を示しています、<xref:System.Diagnostics.Process.BasePriority%2A>と PriorityClass 値</xref:System.Diagnostics.Process.BasePriority%2A>。      |BasePriority |PriorityClass |  |------------------|-------------------|  |&4; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&8; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&13; |<xref:System.Diagnostics.ProcessPriorityClass>|  |&24; |<xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "元となる、関連付けられたプロセスの優先順位カテゴリ、<xref:System.Diagnostics.Process.BasePriority*>プロセスの計算</xref:System.Diagnostics.Process.BasePriority*>。"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "プロセス優先度情報を設定または関連付けられているプロセス リソースから取得できなかった。       - または - プロセス識別子またはプロセス ハンドルが&0; です。 (プロセスが開始されていません。)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの PriorityClass プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセス<xref:System.Diagnostics.Process.Id*>は使用できません</xref:System.Diagnostics.Process.Id*>。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "設定して、PriorityClass <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref>または<xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> Windows 98 または Windows Millennium Edition (Windows Me) を使用する場合。 これらのプラットフォームは、優先度クラスのこれらの値をサポートしていません。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "優先度クラスを設定できません有効な値は使用されないためで定義されている、 <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref>列挙します。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスに割り当てられたプライベート メモリの量を取得します。"
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "他のプロセスと共有できない、関連付けられたプロセスによって割り当てられたバイト数。"
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "(バイト単位)、関連付けられたプロセスに割り当てられたプライベート メモリの量を取得します。"
  remarks: "このプロパティによって返される値は、他のプロセスと共有できないバイトで、プロセスによって使用されるメモリの現在のサイズを表します。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Private Bytes**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "他のプロセスと共有できない関連付けられたプロセスに割り当てられたバイトのメモリの量。"
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "このプロセスの特権プロセッサ時間を取得します。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A<xref:System.TimeSpan>のプロセスが、オペレーティング システム コア内でコードを実行に費やした時間の合計を示す</xref:System.TimeSpan>。"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの PrivilegedProcessorTime プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセスの名前を取得します。"
  remarks: "ProcessName プロパティでは、Outlook の場合、拡張子 .exe またはパスが含まれていないなど、実行可能ファイル名を保持します。 取得し、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。      > [!NOTE] > で[!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)]オペレーティング システムで ProcessName プロパティは切り詰め 15 文字までにプロセス モジュールの情報を取得できません。       呼び出すことができます<xref:System.Diagnostics.Process.GetProcessesByName%2A>、指定したコンピューター上のすべての実行インスタンスを格納する配列を取得する、実行可能ファイル名を渡します</xref:System.Diagnostics.Process.GetProcessesByName%2A>。 たとえば、この配列を使用すると、実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンします。"
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "システムで使用する、ユーザーがプロセスを識別する名前です。"
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスには、識別子がないかに関連付けられているプロセスがない、 <xref href=&quot;System.Diagnostics.Process&quot;></xref>です。       または、関連付けられたプロセスが終了しました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "プロセスは、このコンピューターがありません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得またはを実行するこのプロセスのスレッドをスケジュールできるプロセッサを設定します。"
  remarks: "Windows 2000 以降では、プロセスのスレッドがプロセッサ キャッシュの再読み込みの各移行、プロセッサーを移行できます。 重い負荷、プロセッサが特定のスレッドを実行する必要がありますを指定することができますパフォーマンスを向上させる、プロセッサのキャッシュが再読み込みされる回数を減らすことによってです。 プロセッサと、スレッド間の関連付けには、プロセッサのアフィニティは呼び出されます。       各プロセッサは、ビットで表されます。 ビット 0 は、プロセッサ 1、ビット 1、2、プロセッサなどです。 設定するビット値を 1 に、スレッドの割り当て、対応するプロセッサが選択されます。 ゼロに ProcessorAffinity 値を設定すると、オペレーティング システムのスケジューリング アルゴリズムは、スレッドのアフィニティを設定します。 ProcessorAffinity 値が&0; 以外の値に設定されている場合、値は、選択可能なプロセッサを指定するビット マスクとして解釈されます。       次の表は、8 プロセッサ システム ProcessorAffinity 値の選択範囲を示します。      |ビットマスク |バイナリ値 |対象となるプロセッサ |  |-------------|------------------|-------------------------|  | 0x0001 | 00000000 00000001 | 1 |  | 0x0003 | 00000000 00000011 | 1 と 2 |  | 0x0007 | 00000000 00000111 | 1、2 および 3 |  | 0x0009 | 00000000 00001001 | 1 および 4 |  | 0x007F | 00000000 01111111 | 1、2、3、4、5、6 および 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "関連付けられたプロセスのスレッドを実行できるプロセッサを示すビットマスク。 既定値は、コンピューターのプロセッサの数によって異なります。 既定値は 2 <sup>n</sup> -1 で、n はプロセッサの数。"
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "ProcessorAffinity 情報の設定または関連付けられているプロセス リソースから取得されませんでした。       - または - プロセス識別子またはプロセス ハンドルが&0; です。 (プロセスが開始されていません。)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの ProcessorAffinity プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセス<xref:System.Diagnostics.Process.Id*>を使用できませんでした</xref:System.Diagnostics.Process.Id*>。       または、プロセスが終了しました。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセス コンポーネントにキャッシュされている関連付けられたプロセスに関する情報を破棄します。"
  remarks: "更新が呼び出された後、各プロパティについては、最初の要求は、関連付けられているプロセスから新しい値を取得するプロセスのコンポーネントをさせます。       ときに、<xref:System.Diagnostics.Process>コンポーネントは、プロセスのリソースのプロパティ値に関連付けられて、<xref:System.Diagnostics.Process>はすぐに関連付けられたプロセスの状態に応じて設定されます</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process>。 関連付けられたプロセスに関する情報が、後で変更された場合、それらの変更には反映されません、<xref:System.Diagnostics.Process>コンポーネントのキャッシュされた値</xref:System.Diagnostics.Process>。 <xref:System.Diagnostics.Process>コンポーネントが関連付けられている時のプロセス リソースのスナップショットです</xref:System.Diagnostics.Process>。 関連付けられたプロセスの現在の値を表示するには、更新メソッドを呼び出します。"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセスのユーザー インターフェイスが応答しているかどうかを示す値を取得します。"
  remarks: "ユーザー インターフェイスを含むプロセスには、対応するプロパティは、プロセスがユーザー入力に応答しているかどうかを決定するユーザー インターフェイスを接続します。 インターフェイスが応答しない場合、すぐに稼働中のプロパティから返される`false`です。 このプロパティを使用して、関連付けられたプロセスのインターフェイスの応答が停止したかどうかを判断します。       プロセスがない場合、 <xref:System.Diagnostics.Process.MainWindowHandle%2A>、このプロパティを返します`true`</xref:System.Diagnostics.Process.MainWindowHandle%2A>。"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>関連付けられたプロセスのユーザー インターフェイスがシステムに応答している場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "これに関連付けられているプロセスはありません<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスに対応するプロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "このプロセスへのネイティブ ハンドルを取得します。"
  remarks: "ハンドルは呼び出し元のコンポーネントがプロセスを開始した場合にのみ使用します。"
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "このプロセスへのネイティブ ハンドルです。"
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスのターミナル サービス セッション識別子を取得します。"
  remarks: "SessionId プロパティは、アプリケーションが現在実行されているセッションを識別します。"
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "関連付けられたプロセスのターミナル サービス セッション識別子。"
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "このプロセスに関連付けられているセッションはありません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "このセッション id に関連付けられたプロセスはありません。       または、関連付けられたプロセスがこのコンピューターにします。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Windows 98 では、SessionId プロパティがサポートされていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーションのエラー出力の読み取りに使用されるストリームを取得します。"
  remarks: "ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準エラー ストリームにテキストを書き込みます</xref:System.Diagnostics.Process>。 StandardError ストリームをリダイレクトするには、すると、操作したり、プロセスのエラー出力を抑制することができます。 たとえば、テキストのフィルター処理、異なる書式を設定して、または、コンソールと、指定したログ ファイルの両方に出力を書き込むできます。      > [!NOTE] > StandardError を使用するに設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>に`false`、設定する必要がありますと<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>に`true`</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName></xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>。 それ以外の場合、StandardError ストリームを読み取るには、例外がスローされます。       同期または非同期で、リダイレクトされた StandardError ストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームの同期読み取り操作を実行します</xref:System.IO.StreamReader.ReadToEnd%2A></xref:System.IO.StreamReader.ReadLine%2A></xref:System.IO.StreamReader.Read%2A>。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>ストリームを閉じたり、StandardError ストリームに書き込みます</xref:System.Diagnostics.Process>。       これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>が開始される非同期の読み取り、StandardError ストリームに操作します</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 このメソッドは、指定されたイベントのハンドラーをストリーム出力を有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。       同期読み取り操作では、呼び出し元は、StandardError ストリームおよびストリームに書き込み、子プロセスからの読み取り、間の依存関係について説明します。 これらの依存関係は、デッドロックの状態になります。 呼び出し元は、子プロセスのリダイレクトされたストリームから読み取り、ときに、子に依存しています。 呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。 子プロセスでは、リダイレクトされたストリームを入力するための十分なデータを書き込む、場合に、親に依存しています。 子プロセスは、親のすべてのストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。 デッドロックが発生すると、呼び出し元と子プロセスが、操作を完了する相互に待機を続行することもできます。 呼び出し元と子プロセスの間の依存関係を評価することにより、デッドロックを回避できます。       次の c# コードでは、たとえば、リダイレクトされたストリームから読み取るし、子プロセスを終了するまで待機する方法を示します。      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```このコード例を呼び出して、デッドロック状態を回避できます`p.StandardError.ReadToEnd`する前に`p.WaitForExit`です。 親の呼び出しを処理する場合、デッドロック状態が発生することができます`p.WaitForExit`する前に`p.StandardError.ReadToEnd`子プロセスがリダイレクトされたストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスが終了する無期限に待機します。 子プロセスがいつまでも待ちます完全 StandardError ストリームから読み取ったの親です。       同様の問題があるすべてのテキストを標準出力と標準エラー ストリームの両方から読み取るときにします。 次の c# コードでは、たとえば、両方のストリームで読み取り操作を実行します。      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```コード例は、非同期の読み取り操作を実行してデッドロックの状態を回避できます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A>。 親の呼び出しを処理する場合に、デッドロック状態が結果`p.StandardOutput.ReadToEnd`続く`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスが終了するを無期限に待機その<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム</xref:System.Diagnostics.Process.StandardOutput%2A>。 子プロセスがいつまでも待ちます完全 StandardError ストリームから読み取ったの親です。       非同期読み取り操作を使用して、これらの依存関係とデッドロックの可能性を回避することができます。 代わりに、別のスレッドで各ストリームの出力の読み取りを&2; つのスレッドを作成して、デッドロックを回避できます。      > [!NOTE] > リダイレクトされたストリームで読み取り操作を非同期および同期が混在することはできません。 リダイレクトされたストリームの&1; 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります</xref:System.Diagnostics.Process>。 たとえばに従っていません<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>StandardError ストリーム、またはその逆</xref:System.IO.StreamReader.ReadLine%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 ただし、さまざまなモードで異なる&2; つのストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>およびを呼び出す<xref:System.IO.StreamReader.ReadLine%2A>StandardError ストリームの</xref:System.IO.StreamReader.ReadLine%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "A<xref:System.IO.StreamReader>アプリケーションの標準エラー ストリームの読み取りに使用できる</xref:System.IO.StreamReader>。"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーションの入力の書き込みに使用されるストリームを取得します。"
  remarks: "A<xref:System.Diagnostics.Process>標準入力ストリーム、通常は、キーボードから入力テキストを読み取ることができます</xref:System.Diagnostics.Process>。 StandardInput ストリームをリダイレクトするには、入力をプログラムで指定できます。 たとえば、キーボード入力を使用する代わりに、指定したファイルの内容からテキストまたは別のアプリケーションからの出力を提供できます。      > [!NOTE] > StandardInput を使用するに設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>に`false`、設定する必要がありますと<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>に`true`</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName></xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>。 ストリームはそれ以外の場合、StandardInput への書き込みで例外をスローします。"
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "A<xref:System.IO.StreamWriter>を使用して、アプリケーションの標準入力ストリームの書き込みをすることができます</xref:System.IO.StreamWriter>。"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "StandardInput ストリームが定義されていないため&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;に設定されている<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーションのテキスト出力の読み取りに使用されるストリームを取得します。"
  remarks: "ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準的なストリームにテキストを書き込みます</xref:System.Diagnostics.Process>。 StandardOutput ストリームをリダイレクトするには、すると、操作したり、プロセスの出力を抑制することができます。 たとえば、テキストのフィルター処理、異なる書式を設定して、または、コンソールと、指定したログ ファイルの両方に出力を書き込むできます。      > [!NOTE] > StandardOutput を使用するに設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>に`false`、設定する必要がありますと<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>に`true`</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName></xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>。 それ以外の場合、StandardOutput ストリームを読み取るには、例外がスローされます。       同期または非同期で、リダイレクトされた StandardOutput ストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームの同期読み取り操作を実行します</xref:System.IO.StreamReader.ReadToEnd%2A></xref:System.IO.StreamReader.ReadLine%2A></xref:System.IO.StreamReader.Read%2A>。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>その StandardOutput ストリームに書き込みまたはストリームを閉じます</xref:System.Diagnostics.Process>。       これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>が開始される非同期読み取り StandardOutput ストリームで操作します</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 このメソッドは、指定されたイベントのハンドラーをストリーム出力を有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。       同期読み取り操作では、呼び出し元は StandardOutput ストリームとそのストリームに書き込み、子プロセスからの読み取り、間の依存関係について説明します。 これらの依存関係は、デッドロックの状態になります。 呼び出し元は、子プロセスのリダイレクトされたストリームから読み取り、ときに、子に依存しています。 呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。 子プロセスでは、リダイレクトされたストリームを入力するための十分なデータを書き込む、場合に、親に依存しています。 子プロセスは、親のすべてのストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。 デッドロックが発生すると、呼び出し元と子プロセスが、操作を完了する相互に待機を続行することもできます。 呼び出し元と子プロセスの間の依存関係を評価することにより、デッドロックを回避できます。       次の c# コードでは、たとえば、リダイレクトされたストリームから読み取るし、子プロセスを終了するまで待機する方法を示します。      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```このコード例を呼び出して、デッドロック状態を回避できます`p.StandardOutput.ReadToEnd`する前に`p.WaitForExit`です。 親の呼び出しを処理する場合、デッドロック状態が発生することができます`p.WaitForExit`する前に`p.StandardOutput.ReadToEnd`子プロセスがリダイレクトされたストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスが終了する無期限に待機します。 子プロセスがいつまでも待ちます完全 StandardOutput ストリームから読み取ったの親です。       同様の問題があるすべてのテキストを標準出力と標準エラー ストリームの両方から読み取るときにします。 次の c# コードでは、たとえば、両方のストリームで読み取り操作を実行します。      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```コード例では、StandardOutput ストリームで非同期の読み取り操作を実行することによって、デッドロックを回避できます。 親の呼び出しを処理する場合に、デッドロック状態が結果`p.StandardOutput.ReadToEnd`続く`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスがその StandardOutput ストリームを閉じるに無期限に待機します。 子プロセスが無期限に待機する、フル アクセスから読み取りに親<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A>。       非同期読み取り操作を使用して、これらの依存関係とデッドロックの可能性を回避することができます。 代わりに、別のスレッドで各ストリームの出力の読み取りを&2; つのスレッドを作成して、デッドロックを回避できます。      > [!NOTE] > リダイレクトされたストリームで読み取り操作を非同期および同期が混在することはできません。 リダイレクトされたストリームの&1; 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります</xref:System.Diagnostics.Process>。 たとえばに従っていません<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>StandardOutput ストリームで、またはその逆</xref:System.IO.StreamReader.ReadLine%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 ただし、さまざまなモードで異なる&2; つのストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>およびを呼び出す<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム</xref:System.Diagnostics.Process.StandardError%2A></xref:System.IO.StreamReader.ReadLine%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "A<xref:System.IO.StreamReader>アプリケーションの標準出力ストリームの読み取りに使用できる</xref:System.IO.StreamReader>。"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定されているプロセス リソースを起動 (または再利用)、<xref:System.Diagnostics.Process.StartInfo*>このプロパティ<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントをコンポーネントに関連付けます</xref:System.Diagnostics.Process.StartInfo*>。"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>プロセス リソースが開始されている場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (たとえば、既存のプロセスを再利用される) 場合に新しいプロセス リソースが起動されていない場合。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ファイル名が指定されていません、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントの<> *> です。      - または -、 &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;のメンバー、 <> </> *> プロパティは<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>中&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;、 &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;、または&lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt;は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているファイルを開くときにエラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "プロセス オブジェクトは既に破棄されています。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセス起動情報 (たとえば、開始するプロセスのファイル名) を含むパラメーターで指定されているプロセス リソースを起動し、リソースを新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントです。"
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref>ファイル名やコマンドライン引数など、プロセスの起動に使用される情報を格納します。"
    return:
      type: System.Diagnostics.Process
      description: "新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>プロセス リソースに関連付けられているまたは<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>プロセス リソースが起動されていない場合。 と共に既に同じプロセスのインスタンスの実行が開始される新しいプロセスが、他のユーザーから独立してなることに注意してください。 さらに、開始と null 以外のプロセスを返す可能性があります、<xref:System.Diagnostics.Process.HasExited*>プロパティに既に設定<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Diagnostics.Process.HasExited*> 。 ここでは、起動されたプロセスを自体の既存のインスタンスをアクティブ化しを終了した可能性があります。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ファイル名が指定されていません、 <code> startInfo </code>パラメーターの<> *> プロパティです。      -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.      - または -、 <> </> *> のプロパティ、 <code> startInfo </code>パラメーターは<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>と<> *> プロパティは使用されません<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>または空、または<> *> プロパティは使用されません<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "プロセス オブジェクトは既に破棄されています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "指定されたファイル、 <code> startInfo </code>パラメーターの<xref:System.Diagnostics.ProcessStartInfo.FileName*>プロパティが見つかりませんでした</xref:System.Diagnostics.ProcessStartInfo.FileName*>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているファイルを開くときにエラーが発生しました。       または、引数の長さとプロセスへの完全パスの長さの合計が、2080 を超えています。 この例外に関連付けられているエラー メッセージは、次のいずれかを指定できます:「システムの呼び出しに渡されるデータ領域が小さすぎます」。 または「アクセスが拒否されました&quot;"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "文書またはアプリケーション ファイルの名前を指定してプロセス リソースを起動し、リソースを新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントです。"
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "プロセスで実行する文書またはアプリケーション ファイルの名前。"
    return:
      type: System.Diagnostics.Process
      description: "新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>プロセス リソースに関連付けられているまたは<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>プロセス リソースが起動されていない場合。 と共に既に同じプロセスのインスタンスの実行が開始される新しいプロセスが、他のユーザーから独立してなることに注意してください。 さらに、開始と null 以外のプロセスを返す可能性があります、<xref:System.Diagnostics.Process.HasExited*>プロパティに既に設定<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Diagnostics.Process.HasExited*> 。 ここでは、起動されたプロセスを自体の既存のインスタンスをアクティブ化しを終了した可能性があります。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているファイルを開くときにエラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "プロセス オブジェクトは既に破棄されています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "PATH 環境変数は、引用符を含む文字列です。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーションの名前とコマンドライン引数のセットを指定してプロセス リソースを起動し、リソースを新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントです。"
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "プロセスで実行するアプリケーション ファイルの名前。"
    - id: arguments
      type: System.String
      description: "プロセスを開始するときに渡すコマンドライン引数。"
    return:
      type: System.Diagnostics.Process
      description: "新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>プロセス リソースに関連付けられているまたは<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>プロセス リソースが起動されていない場合。 と共に既に同じプロセスのインスタンスの実行が開始される新しいプロセスが、他のユーザーから独立してなることに注意してください。 さらに、開始と null 以外のプロセスを返す可能性があります、<xref:System.Diagnostics.Process.HasExited*>プロパティに既に設定<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Diagnostics.Process.HasExited*> 。 ここでは、起動されたプロセスを自体の既存のインスタンスをアクティブ化しを終了した可能性があります。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているファイルを開くときにエラーが発生しました。       または、引数の長さとプロセスへの完全パスの長さの合計が、2080 を超えています。 この例外に関連付けられているエラー メッセージは、次のいずれかを指定できます:「システムの呼び出しに渡されるデータ領域が小さすぎます」。 または「アクセスが拒否されました&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "プロセス オブジェクトは既に破棄されています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "PATH 環境変数は、引用符を含む文字列です。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーションの名前、ユーザー名、パスワード、およびドメインを指定してプロセス リソースを起動し、リソースを新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントです。"
  remarks: "このオーバー ロードを使用すると、そのファイル名、ユーザー名、パスワード、およびドメインを指定することによって、新しいプロセスとそのプライマリ スレッドを作成できます。 後、新しいプロセスは、指定された資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティ コンテキストで指定された実行可能ファイルを実行します。      > [!NOTE] > リモート ドライブ上の実行可能ファイルが配置されている場合は、リンク先のドライブ文字ではなく uniform resource identifier (URI) を使用して、ネットワーク共有を識別する必要があります。      > [!NOTE] > を開始する実行可能ファイルのアドレスが URL である場合は、プロセスが開始されていないと`null`が返されます。       このオーバー ロードでは、作成しなくても、新しいプロセスを開始できます<xref:System.Diagnostics.Process>インスタンス。</xref:System.Diagnostics.Process> 。 オーバー ロードは、手順の代わりに、明示的な新しいを作成する<xref:System.Diagnostics.Process>インスタンス、設定、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A></xref:System.Diagnostics.Process.StartInfo%2A></xref:System.Diagnostics.ProcessStartInfo.Domain%2A></xref:System.Diagnostics.ProcessStartInfo.Password%2A></xref:System.Diagnostics.ProcessStartInfo.UserName%2A></xref:System.Diagnostics.ProcessStartInfo.FileName%2A></xref:System.Diagnostics.Process>。       同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` &quot;Notepad.exe&quot;または&quot;Notepad&quot;のいずれかのパラメーターです。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、テキスト ファイルなど、対象となるファイルを表す場合があります`Notepad.exe myfile.txt`です。      > [!NOTE] > ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>を持つオーバー ロード`userName`、 `password`、および`domain`パラメーター</xref:System.Diagnostics.Process.Start%2A> 。       使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性があります</xref:System.Diagnostics.Process.Start%2A>。 <xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>。</xref:System.Diagnostics.Process.Kill%2A></xref:System.Diagnostics.Process.CloseMainWindow%2A>を使用してプロセスを終了します。 その<xref:System.Diagnostics.Process.HasExited%2A>プロパティ..</xref:System.Diagnostics.Process.HasExited%2A>を使用して、プロセスが既に閉じられているかどうかを確認することができます。"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "プロセスで実行するアプリケーション ファイルの名前。"
    - id: userName
      type: System.String
      description: "プロセスの開始時に使用するユーザー名。"
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref>プロセスの開始時に使用するパスワードを格納しています。"
    - id: domain
      type: System.String
      description: "プロセスの開始時に使用するドメインです。"
    return:
      type: System.Diagnostics.Process
      description: "新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>プロセス リソースに関連付けられているまたは<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>プロセス リソースが起動されていない場合。 と共に既に同じプロセスのインスタンスの実行が開始される新しいプロセスが、他のユーザーから独立してなることに注意してください。 さらに、開始と null 以外のプロセスを返す可能性があります、<xref:System.Diagnostics.Process.HasExited*>プロパティに既に設定<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Diagnostics.Process.HasExited*> 。 ここでは、起動されたプロセスを自体の既存のインスタンスをアクティブ化しを終了した可能性があります。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ファイル名が指定されていません。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているファイルを開くときにエラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "プロセス オブジェクトは既に破棄されています。"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "アプリケーション、コマンドライン引数のセット、ユーザー名、パスワード、およびドメインの名前を指定してプロセス リソースを起動し、リソースを新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>コンポーネントです。"
  remarks: "このオーバー ロードを使用すると、そのファイルの名前、コマンドライン引数、ユーザー名、パスワード、およびドメインを指定することによって、新しいプロセスとそのプライマリ スレッドを作成できます。 後、新しいプロセスは、指定された資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティ コンテキストで指定された実行可能ファイルを実行します。      > [!NOTE] > リモート ドライブ上の実行可能ファイルが配置されている場合は、リンク先のドライブ文字ではなく uniform resource identifier (URI) を使用して、ネットワーク共有を識別する必要があります。      > [!NOTE] > を開始する実行可能ファイルのアドレスが URL である場合は、プロセスが開始されていないと`null`が返されます。       このオーバー ロードでは、作成しなくても、新しいプロセスを開始できます<xref:System.Diagnostics.Process>インスタンス。</xref:System.Diagnostics.Process> 。 オーバー ロードが新たに作成するの明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>設定インスタンス、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A></xref:System.Diagnostics.Process.StartInfo%2A></xref:System.Diagnostics.ProcessStartInfo.Domain%2A></xref:System.Diagnostics.ProcessStartInfo.Password%2A></xref:System.Diagnostics.ProcessStartInfo.UserName%2A></xref:System.Diagnostics.ProcessStartInfo.Arguments%2A></xref:System.Diagnostics.ProcessStartInfo.FileName%2A></xref:System.Diagnostics.Process>。       同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` &quot;Notepad.exe&quot;または&quot;Notepad&quot;のいずれかのパラメーターです。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、テキスト ファイルなど、対象となるファイルを表す場合があります`Notepad.exe myfile.txt`です。      > [!NOTE] > ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>を持つオーバー ロード`userName`、 `password`、および`domain`パラメーター</xref:System.Diagnostics.Process.Start%2A> 。       使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性があります</xref:System.Diagnostics.Process.Start%2A>。 <xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>。</xref:System.Diagnostics.Process.Kill%2A></xref:System.Diagnostics.Process.CloseMainWindow%2A>を使用してプロセスを終了します。 その<xref:System.Diagnostics.Process.HasExited%2A>プロパティ..</xref:System.Diagnostics.Process.HasExited%2A>を使用して、プロセスが既に閉じられているかどうかを確認することができます。"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "プロセスで実行するアプリケーション ファイルの名前。"
    - id: arguments
      type: System.String
      description: "プロセスを開始するときに渡すコマンドライン引数。"
    - id: userName
      type: System.String
      description: "プロセスの開始時に使用するユーザー名。"
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref>プロセスの開始時に使用するパスワードを格納しています。"
    - id: domain
      type: System.String
      description: "プロセスの開始時に使用するドメインです。"
    return:
      type: System.Diagnostics.Process
      description: "新しい<xref href=&quot;System.Diagnostics.Process&quot;></xref>プロセス リソースに関連付けられているまたは<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>プロセス リソースが起動されていない場合。 と共に既に同じプロセスのインスタンスの実行が開始される新しいプロセスが、他のユーザーから独立してなることに注意してください。 さらに、開始と null 以外のプロセスを返す可能性があります、<xref:System.Diagnostics.Process.HasExited*>プロパティに既に設定<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Diagnostics.Process.HasExited*> 。 ここでは、起動されたプロセスを自体の既存のインスタンスをアクティブ化しを終了した可能性があります。"
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ファイル名が指定されていません。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "関連付けられているファイルを開くときにエラーが発生しました。       または、引数の長さと関連ファイルへの完全パスの長さの合計が、2080 を超えています。 この例外に関連付けられているエラー メッセージは、次のいずれかを指定できます:「システムの呼び出しに渡されるデータ領域が小さすぎます」。 または「アクセスが拒否されました&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "プロセス オブジェクトは既に破棄されています。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得または設定を渡すプロパティを<xref:System.Diagnostics.Process.Start*>のメソッド、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref></xref:System.Diagnostics.Process.Start*> 。"
  remarks: "StartInfo では、使用して、プロセスを開始するパラメーターのセットを表します。 ときに<xref:System.Diagnostics.Process.Start%2A>が呼び出されると、StartInfo は使用を開始するプロセスを指定します</xref:System.Diagnostics.Process.Start%2A>。 設定するために必要なだけ StartInfo メンバーは、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 指定してプロセスを開始、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは内の情報を入力することに似ています、**実行** ダイアログ ボックス、Windows の**開始**メニュー</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 。 したがって、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、実行可能ファイルを表す必要はありません</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 任意の拡張機能が関連付けられて、システムにインストールされているアプリケーションとファイルの種類のだということです。 たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>か、テキスト ファイルをメモ帳などのエディターに関連付けられた Microsoft Word などのワード プロセッシング ツールを使用して関連付けてファイルがある場合、.doc を持つことができますが、.txt 拡張子を持つことができます</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 。 たとえば、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティを&quot;Notepad.exe&quot;または&quot;Notepad&quot;のいずれか</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。       ClickOnce アプリケーションを起動するには設定して、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティをアプリケーションをインストールした最初の場所 (たとえば、Web アドレス).</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> ハード ドライブ上のインストール場所を指定することで、ClickOnce アプリケーションは開始されません。       ファイル名には、.doc ファイルなどの非実行可能ファイルが含まれている場合は、ファイルを実行するアクションを指定する動詞を含めることができます。 たとえば、設定する、 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>.doc 拡張子で終わるファイルの&quot;print&quot;.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 指定されたファイル名、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、拡張子が付いている場合の値を手動で入力する必要はありません、<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>プロパティ</xref:System.Diagnostics.ProcessStartInfo.Verb%2A></xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 ただし、使用する場合、<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>動詞を確認するにはできるが、拡張機能を含める必要があります</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>。       呼び出したときまで StartInfo プロパティで指定されたパラメーターを変更することができます、<xref:System.Diagnostics.Process.Start%2A>プロセス メソッド</xref:System.Diagnostics.Process.Start%2A>。 プロセスを開始した後 StartInfo 値を変更する影響やしません関連付けられているプロセスを再開します。 呼び出す場合は、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>メソッドを<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>と<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>プロパティ セットには、アンマネージ`CreateProcessWithLogonW`関数が呼び出されると、新しいウィンドウでも場合に、プロセスが開始する、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>プロパティの値が`true`または<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>プロパティの値が<xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       使用していない場合、 <xref:System.Diagnostics.Process.Start%2A>StartInfo プロパティ、プロセスを開始するメソッドは、プロセスを開始するためのパラメーターが反映されません</xref:System.Diagnostics.Process.Start%2A>。 たとえば、使用する場合<xref:System.Diagnostics.Process.GetProcesses%2A>StartInfo プロパティの各コンピューターで実行されているプロセスの配列を取得する<xref:System.Diagnostics.Process>、元のファイル名またはプロセスを開始するための引数が含まれていません</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcesses%2A>。       ファイル名、(読み取り専用) のメンバーを追加するファイルでは、プロセスが開始されると、<xref:System.Diagnostics.Process.MainModule%2A>プロパティ</xref:System.Diagnostics.Process.MainModule%2A>。 使用して、プロセスが開始した後、プロセスに関連付けられている実行可能ファイルを取得する場合、<xref:System.Diagnostics.Process.MainModule%2A>プロパティ</xref:System.Diagnostics.Process.MainModule%2A>。 実行可能ファイルを設定する場合、<xref:System.Diagnostics.Process>インスタンスが関連付けられたプロセスが開始されていないため、StartInfo プロパティの使用<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> 。 StartInfo プロパティのメンバーが引数に渡されるため、<xref:System.Diagnostics.Process.Start%2A>を変更する、プロセスのメソッド、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>関連付けられたプロセスが開始された後のプロパティはリセットされません、<xref:System.Diagnostics.Process.MainModule%2A>プロパティ</xref:System.Diagnostics.Process.MainModule%2A></xref:System.Diagnostics.ProcessStartInfo.FileName%2A></xref:System.Diagnostics.Process.Start%2A>。 これらのプロパティは、関連付けられたプロセスを初期化するためにのみ使用されます。"
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref>プロセスを開始するときに使用されたデータを表すです。 これらの引数には、実行可能ファイルまたはプロセスを開始するために使用するドキュメントの名前が含まれます。"
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "StartInfo を指定する値は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスが開始された時刻を取得します。"
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "処理の開始を示すオブジェクト。 プロセスが実行されていない場合は、例外がスローされます。"
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの StartTime プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスは終了しました。       または、プロセスが開始されていません。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Windows の関数の呼び出しでエラーが発生しました。"
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得またはプロセス終了イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャ リングに使用するオブジェクトを設定します。"
  remarks: "ときに<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>は`null`、処理するメソッド、<xref:System.Diagnostics.Process.Exited>イベントがシステムのスレッド プールのスレッドで呼び出されます</xref:System.Diagnostics.Process.Exited></xref:System.Diagnostics.EventLog.SynchronizingObject%2A>。 システム スレッド プールの詳細については、 <xref:System.Threading.ThreadPool>。</xref:System.Threading.ThreadPool>を参照してください。       ときに、<xref:System.Diagnostics.Process.Exited>イベントは Windows フォームのビジュアル コンポーネントなど、 <xref:System.Windows.Forms.Button>、システム スレッド プールを介したコンポーネントへのアクセスが機能しない、または例外が発生する可能性があります</xref:System.Windows.Forms.Button></xref:System.Diagnostics.Process.Exited>。 これを回避する SynchronizingObject を処理するメソッドを、Windows フォームのコンポーネントに設定して、<xref:System.Diagnostics.Process.Exited>コンポーネントが作成されたスレッドと同じスレッドで呼び出されるイベント</xref:System.Diagnostics.Process.Exited>。       場合、<xref:System.Diagnostics.Process>内で使用する[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]、Windows フォーム デザイナーで SynchronizingObject は自動的に<xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>を含むコントロールに設定</xref:System.Diagnostics.Process> 配置する場合など、<xref:System.Diagnostics.Process>をデザイナーで`Form1`(から継承される<xref:System.Windows.Forms.Form>) の SynchronizingObject プロパティ<xref:System.Diagnostics.Process>のインスタンスに設定されている`Form1`: [!code-cpp [Process_SynchronizingObject&2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject&2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject&2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ]通常、このプロパティは設定コントロールまたはフォームの内部コンポーネントを配置しているときにこれらのコンポーネントは、特定のスレッドにバインドされるためです    </xref:System.Diagnostics.Process></xref:System.Windows.Forms.Form></xref:System.Diagnostics.Process>。"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>の結果として発行されるイベント ハンドラー呼び出しをマーシャ リングするために使用する<xref href=&quot;System.Diagnostics.Process.Exited&quot;></xref>プロセスのイベントです。"
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスで実行されているスレッドのセットを取得します。"
  remarks: "スレッドは、プロセスでコードを実行します。 単一のスレッド、そのプライマリ スレッドでは、各プロセスが開始します。 どのスレッドでは、追加のスレッドを作成できます。 プロセス内のスレッドは、プロセスのアドレス空間を共有します。       使用して<xref:System.Diagnostics.ProcessThread>を現在のプロセスに関連付けられているすべてのスレッドを取得します</xref:System.Diagnostics.ProcessThread>。 プライマリ スレッドが必ずしも配列内のインデックス&0; の位置です。"
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "型の配列<xref href=&quot;System.Diagnostics.ProcessThread&quot;></xref>オペレーティング システム スレッドを表す関連付けられたプロセスで現在実行中です。"
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "プロセスがない、<xref:System.Diagnostics.Process.Id*>に関連付けられているプロセスがないか、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>インスタンス</xref:System.Diagnostics.Process.Id*>。       または、関連付けられたプロセスが終了しました。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。設定&lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt;に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98 や Windows me でこのプロパティにアクセスするには"
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセスの名前を親コンポーネントの種類と組み合わせる、該当する場合、文字列として書式設定します。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "<> </> *> ベース コンポーネントのと組み合わせた<> *> 値を返します。"
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Windows 98 では、ToString はサポートされていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "このプロセスの合計プロセッサ時間を取得します。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A<xref:System.TimeSpan>の関連付けられたプロセスが CPU の利用に費やした時間の合計を示す</xref:System.TimeSpan>。 この値の合計では、 <> </> *> と<> *> です。"
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの TotalProcessorTime プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "このプロセスのユーザー プロセッサ時間を取得します。"
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A<xref:System.TimeSpan>の関連付けられたプロセスがアプリケーション部分の内部 (オペレーティング システムのコア) プロセスのコードの実行に費やした時間の合計を示す</xref:System.TimeSpan>。"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "リモート コンピューターで実行されているプロセスの UserProcessorTime プロパティにアクセスしようとするとします。 このプロパティは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "プロセスの仮想メモリのサイズをバイト単位で取得します。"
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "関連付けられたプロセスが要求したバイト数での仮想メモリの量。"
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスに割り当てられたバイトの仮想メモリの量を取得します。"
  remarks: "このプロパティによって返される値は、(バイト単位)、プロセスによって使用される仮想メモリの現在のサイズを表します。 オペレーティング システムでは、物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページに読み込まれるページのいずれかの各プロセスの仮想アドレス空間をマップします。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Virtual Bytes**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "関連付けられたプロセスに割り当てられたバイト内の仮想メモリの量。"
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指示、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントを無期限に関連付けられたプロセスが終了する待機です。"
  remarks: "WaitForExit は、現在のスレッドが関連付けられているプロセスが終了するまで待機します。  これは、プロセスに関するその他のすべてのメソッドが呼び出された後に呼び出す必要があります。 現在のスレッドがブロックを回避するのには、使用、<xref:System.Diagnostics.Process.Exited>イベント</xref:System.Diagnostics.Process.Exited>。       このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントをプロセスのイベント ハンドラーを終了する日時の時間は無制限に待機します</xref:System.Diagnostics.Process>。 これには、アプリケーションの応答を停止する可能性があります。 呼び出す場合など、<xref:System.Diagnostics.Process.CloseMainWindow%2A>ユーザー インターフェイスのあるプロセスでは、関連付けられているプロセスを終了するオペレーティング システムに要求可能性がある処理されない場合は、プロセスは、メッセージ ループを入力しないでに書き込まれます</xref:System.Diagnostics.Process.CloseMainWindow%2A>。      > [!NOTE] > で、 [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] WaitForExit オーバー ロードの待機時間を以前のバージョン、および<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、無期限にありません</xref:System.Int32.MaxValue>。 また、以前のバージョンでしたを待たない場合を終了するイベント ハンドラーの完全<xref:System.Int32.MaxValue>時間に達しました</xref:System.Int32.MaxValue>。       このオーバー ロードにより、リダイレクトされた標準出力に非同期のイベントの処理など、すべての処理が完了したこと。 呼び出しの後に、このオーバー ロードを使用する必要があります、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>非同期イベント ハンドラーを標準出力がリダイレクトされたとき、オーバー ロードします</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>。       (つまり、これによってがシャット ダウンにより、通常終了または異常終了操作システム) 場合は、関連付けられたプロセスが終了すると、システムは、プロセスに関する管理情報を格納し、WaitForExit と呼ばれますが、コンポーネントを返します。 <xref:System.Diagnostics.Process>コンポーネントが含まれる情報にアクセスできます、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>に終了したプロセスです</xref:System.Diagnostics.Process.Handle%2A></xref:System.Diagnostics.Process.ExitTime%2A></xref:System.Diagnostics.Process>。       関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが既存のプロセス リソースを参照しない</xref:System.Diagnostics.Process.Handle%2A>。 代わりに、ハンドルは、プロセスのリソースについて、オペレーティング システムの情報にアクセスするには、のみ使用できます。 システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Handle%2A></xref:System.Diagnostics.Process.ExitTime%2A></xref:System.Diagnostics.Process>。 このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A><xref:System.Diagnostics.Process>インスタンス、呼び出しは、<xref:System.Diagnostics.Process.Close%2A>関連付けられたプロセスが終了する場合とそれに関する情報は管理が必要な不要になった場合</xref:System.Diagnostics.Process.Close%2A></xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>終了したプロセスに割り当てられたメモリを解放します。</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "待機設定にアクセスできませんでした。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "プロセスがありません<> *> が設定されていると、 <> </> *> 元となる、<xref:System.Diagnostics.Process.Id*>存在しないプロパティを決定できます</xref:System.Diagnostics.Process.Id*>。       - または - これに関連付けられたプロセスがない<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。       または、リモート コンピューターで実行されているプロセスの WaitForExit を呼び出すしようとしています。 このメソッドは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指示、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントを指定した関連付けられたプロセスが終了するミリ秒数を待機します。"
  remarks: "WaitForExit は、現在のスレッドが関連付けられているプロセスが終了するまで待機します。 これは、プロセスに関するその他のすべてのメソッドが呼び出された後に呼び出す必要があります。 現在のスレッドがブロックを回避するのには、使用、<xref:System.Diagnostics.Process.Exited>イベント</xref:System.Diagnostics.Process.Exited>。       このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントを有限時間、プロセスが終了するを待機します</xref:System.Diagnostics.Process>。 終了要求が拒否されたため、間隔の終了で関連付けられたプロセスは終了しない場合`false`が呼び出し元のプロシージャに返されます。 負の数を指定することができます (<xref:System.Threading.Timeout.Infinite>) の`milliseconds`、WaitForExit と同様に動作がおよび、<xref:System.Diagnostics.Process.WaitForExit>オーバー ロードします</xref:System.Diagnostics.Process.WaitForExit></xref:System.Threading.Timeout.Infinite>。 返すかどうかは 0 (ゼロ) をメソッドに渡す`true`プロセスは既に終了している場合にのみ、すぐに返します`false`です。      > [!NOTE] > で、[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]と以前のバージョンで場合`milliseconds`-1、オーバー ロードの待機時間を WaitForExit でした<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、無期限に not</xref:System.Int32.MaxValue> 。       非同期のイベント ハンドラーを標準出力がリダイレクトされたときに、このメソッドが戻るときでは出力の処理が完了していないことができます。 非同期イベント処理が完了したことを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>受信後にパラメーターを受け取らないオーバー ロード、`true`このオーバー ロードから</xref:System.Diagnostics.Process.WaitForExit>。 いることを確認する、 <xref:System.Diagnostics.Process.Exited>Windows フォーム アプリケーションで適切に処理されるイベントは、設定、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティ</xref:System.Diagnostics.Process.SynchronizingObject%2A></xref:System.Diagnostics.Process.Exited>。       関連付けられたプロセスが終了したとき (がシャット ダウン、通常終了または異常終了により、オペレーティング システムによって)、システムがプロセスに関する管理の情報を格納し、WaitForExit と呼ばれますが、コンポーネントを返します。 <xref:System.Diagnostics.Process>コンポーネントが含まれる情報にアクセスできます、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>に終了したプロセスです</xref:System.Diagnostics.Process.Handle%2A></xref:System.Diagnostics.Process.ExitTime%2A></xref:System.Diagnostics.Process>。       関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが既存のプロセス リソースを参照しない</xref:System.Diagnostics.Process.Handle%2A>。 代わりに、ハンドルは、プロセスのリソースについて、オペレーティング システムの情報にアクセスするには、のみ使用できます。 システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Handle%2A></xref:System.Diagnostics.Process.ExitTime%2A></xref:System.Diagnostics.Process>。 このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A><xref:System.Diagnostics.Process>インスタンス、呼び出しは、<xref:System.Diagnostics.Process.Close%2A>関連付けられたプロセスが終了する場合とそれに関する情報は管理が必要な不要になった場合</xref:System.Diagnostics.Process.Close%2A></xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>終了したプロセスに割り当てられたメモリを解放します。</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "関連付けられたプロセスが終了するまで待機するミリ秒単位の時間数。 最大値は、オペレーティング システムに対して無限大で表現される 32 ビット整数の最大有効値です。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、関連付けられたプロセスが終了しました。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "待機設定にアクセスできませんでした。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "プロセスがありません<> *> が設定されていると、 <> </> *> 元となる、<xref:System.Diagnostics.Process.Id*>存在しないプロパティを決定できます</xref:System.Diagnostics.Process.Id*>。       - または - これに関連付けられたプロセスがない<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。       または、リモート コンピューターで実行されているプロセスの WaitForExit を呼び出すしようとしています。 このメソッドは、ローカル コンピューターで実行されているプロセスに対してのみ使用できます。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "により、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントをアイドル状態に関連付けられたプロセスに無期限に待機します。 このオーバー ロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスのみに適用されます。"
  remarks: "WaitForInputIdle を使用して、メッセージ ループは、アイドル状態に戻りました。 するまで待機する、アプリケーションの処理を強制します。 ユーザー インターフェイスを持つプロセスを実行するときに、オペレーティング システムによって Windows のメッセージがプロセスに送信されるたびに、メッセージ ループを実行します。 プロセスは、メッセージ ループにしを返します。 プロセスは、メッセージ ループ内でメッセージを待っているときに、アイドル状態にすると表現されます。 この状態役に立ちます、たとえば、アプリケーションは、プロセスの開始前に、そのウィンドウと通信するアプリケーションのメイン ウィンドウの作成を完了するまで待機する必要がある場合。       WaitForInputIdle が<xref:System.InvalidOperationException>。</xref:System.InvalidOperationException>をスローする場合は、プロセスには、メッセージ ループはありません、       WaitForInputIdle オーバー ロードするように指示、<xref:System.Diagnostics.Process>メッセージ ループ内でアイドル状態になるプロセスを無期限に待機するコンポーネント</xref:System.Diagnostics.Process>。 この命令には、アプリケーションの応答を停止する可能性があります。 たとえば、プロセスが常に作成する場合、メッセージ ループを即座に終了コード フラグメントのように`while(true)`です。"
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>関連付けられたプロセスがアイドル状態に達して場合います。"
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスには、グラフィカル インターフェイスはありません。       - または - 不明なエラーが発生しました。 プロセスがアイドル状態にできませんでした。       または、プロセスは既に終了しています。       または、これに関連付けられたプロセスがない<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "により、 <xref href=&quot;System.Diagnostics.Process&quot;> </xref>コンポーネントを指定した、アイドル状態に関連付けられたプロセスのミリ秒数を待機します。 このオーバー ロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスのみに適用されます。"
  remarks: "WaitForInputIdle を使用して、メッセージ ループは、アイドル状態に戻りました。 するまで待機する、アプリケーションの処理を強制します。 ユーザー インターフェイスを持つプロセスを実行するときに、オペレーティング システムによって Windows のメッセージがプロセスに送信されるたびに、メッセージ ループを実行します。 プロセスは、メッセージ ループにしを返します。 プロセスは、メッセージ ループ内でメッセージを待っているときに、アイドル状態にすると表現されます。 この状態役に立ちます、たとえば、アプリケーションは、プロセスの開始前に、そのウィンドウと通信するアプリケーションのメイン ウィンドウの作成を完了するまで待機する必要がある場合。       WaitForInputIdle が<xref:System.InvalidOperationException>。</xref:System.InvalidOperationException>をスローする場合は、プロセスには、メッセージ ループはありません、       WaitForInputIdle オーバー ロードするように指示、<xref:System.Diagnostics.Process>コンポーネントをメッセージ ループでアイドル状態になるプロセスの有限の時間を待機します</xref:System.Diagnostics.Process>。 関連付けられたプロセスには、ループには、メッセージがまだ処理間隔の終了までにアイドル状態ならなかった場合`false`が呼び出し元のプロシージャに返されます。       イベント処理の詳細については、次を参照してください。[イベント](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "値が 1<xref:System.Int32>関連付けられたプロセスがアイドル状態になるまで待機するミリ秒単位の時間の大きさを指定します</xref:System.Int32>。 値が 0 が、即時の戻り値を指定し、-1 の値が、無期限の待機を指定します。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>関連付けられたプロセスがアイドル状態になった; に達した場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "プロセスには、グラフィカル インターフェイスはありません。       - または - 不明なエラーが発生しました。 プロセスがアイドル状態にできませんでした。       または、プロセスは既に終了しています。       または、これに関連付けられたプロセスがない<xref href=&quot;System.Diagnostics.Process&quot;></xref>オブジェクト。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスの物理メモリ使用量をバイト単位で取得します。"
  remarks: "このプロパティによって返される値は、ワーキング セット メモリ (バイト単位)、プロセスによって使用されるは、現在のサイズを表します。 プロセスのワーキング セットは、物理 RAM メモリ内のプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。       ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールとシステム ライブラリなど、プロセスが実行されるすべての指示を含むページが含まれます。"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "物理メモリの総量、関連付けられたプロセスが使用して、(バイト単位)。"
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "関連付けられたプロセスに割り当てられたバイトの物理メモリの量を取得します。"
  remarks: "このプロパティによって返される値は、ワーキング セット メモリ (バイト単位)、プロセスによって使用されるは、現在のサイズを表します。 プロセスのワーキング セットは、物理 RAM メモリ内のプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。       ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールとシステム ライブラリで手順を含む、プロセスが実行されるすべての指示を含むページが含まれます。       このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**ワーキング セット**プロセスのパフォーマンス カウンター。"
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "関連付けられたプロセスに割り当てられたバイトで、物理メモリの量。"
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "プラットフォームは、Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティをサポートしていません。"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
