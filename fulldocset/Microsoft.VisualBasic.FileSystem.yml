### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "<xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref>モジュールには、ファイル、ディレクトリまたはフォルダー、およびシステムの操作の実行に使用されるプロシージャが含まれています。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上を使用するよりもファイル I/O 操作で、 <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref>モジュール。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "このモジュールは、Visual Basic 言語キーワードおよびファイルとフォルダーにアクセスするランタイム ライブラリ メンバーをサポートします。"
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "現在のディレクトリまたはフォルダーを変更します。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作で、 <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;></xref>関数。 詳細については、 <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>を参照してください。"
  remarks: "`ChDir`関数は、既定のディレクトリが既定のドライブを変更します。 たとえば、C を既定のドライブには、次のステートメントは D ドライブの既定のディレクトリを変更 C が既定のドライブに残ります: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ]相対にすることができますディレクトリの変更は、次のように&2; つのピリオドを入力して: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] >、`ChDir`関数には、部分的に信頼された状況での実行に影響を与えるアンマネージ コードのアクセス許可が必要です。 詳細については、次を参照してください<xref:System.Security.Permissions.SecurityPermission>および。</xref:System.Security.Permissions.SecurityPermission> 。"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必須。 A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>ディレクトリまたはフォルダーを識別する式は、新しい既定のディレクトリまたはフォルダーになります。 `Path`ドライブを含めることができます。 ドライブが指定されていない場合<xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;></xref>既定のディレクトリまたは現在のドライブ上のフォルダーを変更します。"
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>空です。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "無効なドライブを指定すると、またはドライブは利用できません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "現在のドライブを変更します。"
  remarks: "`ChDrive`関数には、部分的に信頼された状況での実行に影響する可能性があります、アンマネージ コード権限が必要です。 詳細については、次を参照してください<xref:System.Security.Permissions.SecurityPermission>と[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission> 。"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "必須。 既存のドライブを指定する文字列式です。 長さ&0; の文字列を指定する場合 (&quot;&quot;)、現在のドライブは変更されません。 場合、`Drive`引数は複数の文字文字列<xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;></xref>が最初の文字のみを使用します。"
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無効なドライブを指定すると、またはドライブは利用できません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "現在のドライブを変更します。"
  remarks: "`ChDrive`関数には、部分的に信頼された状況での実行に影響する可能性があります、アンマネージ コード権限が必要です。 詳細については、次を参照してください<xref:System.Security.Permissions.SecurityPermission>と[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission> 。"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "必須。 既存のドライブを指定する文字列式です。 長さ&0; の文字列を指定する場合 (&quot;&quot;)、現在のドライブは変更されません。 場合、`Drive`引数は複数の文字文字列<xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;></xref>が最初の文字のみを使用します。"
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無効なドライブを指定すると、またはドライブは利用できません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "現在のパスを表す文字列を返します。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>は、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;></xref>です。 詳細については、 <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>を参照してください。"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "現在のパスを表す文字列。"
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "現在のパスを表す文字列を返します。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>は、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;></xref>です。 詳細については、 <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>を参照してください。"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "任意。 <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>既存のドライブを指定する式。 ドライブが指定されていない場合、または場合`Drive`は長さ&0; の文字列 (&quot;&quot;)、 <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>現在のドライブ パスを返します。"
    return:
      type: System.String
      description: "現在のパスを表す文字列。"
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列を返します。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>よりもファイル I/O 操作の生産性とパフォーマンスが向上するにより、 <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref>関数。 参照してください<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>詳細についてはします</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>。"
  remarks: "`Dir`関数は、複数の文字の使用をサポートしています (`*`) と単一文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。       `VbVolume`特定のファイル名の代わりに、ドライブのボリューム ラベルを返します。       指定する必要があります、`PathName`初めて呼び出すこと、`Dir`関数。 次の項目を取得するには、後続の呼び出しを行うことができます、`Dir`パラメーターのない関数です。      > [!IMPORTANT] > は正常に実行する、`Dir`関数に必要な<xref:System.Security.Permissions.FileIOPermissionAccess>と<xref:System.Security.Permissions.FileIOPermissionAccess>のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可する</xref:System.Security.Permissions.FileIOPermission></xref:System.Security.Permissions.FileIOPermissionAccess></xref:System.Security.Permissions.FileIOPermissionAccess>。 詳細については、次を参照してください<xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>、および[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission> 。       `Attributes`引数列挙の値は次のとおり: | | |  |-|-|-|  |値 |定数 |説明 |  |`Normal`|`vbnormal`|既定値です。 属性のないファイルを指定します |。  |`ReadOnly`|`vbReadOnly`|属性のないファイルや読み取り専用ファイルを指定します |。  |`Hidden`|`vbHidden`|属性のないファイルや隠しファイルを指定します |。  |`System`|`vbSystem`|システム ファイル、および属性のないファイルを指定します |。  |`Volume`|`vbVolume`|ボリューム ラベルを指定しますその他の属性が指定されている場合`vbVolume`は無視されます |。  |`Directory`|`vbDirectory`|ディレクトリまたはフォルダーを指定し、属性のないファイルもします |。  |`Archive`|`vbArchive`|ファイルが前回のバックアップ以降に変更します |。  |`Alias`|`vbAlias`|ファイルが別の名前です |。     > [!NOTE] > これらの列挙は、Visual Basic 言語によって指定され、実際の値ではなく、コード内の任意の場所で使用できます。"
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列。"
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列を返します。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>よりもファイル I/O 操作の生産性とパフォーマンスが向上するにより、 <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref>関数。 参照してください<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>詳細についてはします</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>。"
  remarks: "`Dir`関数は、複数の文字の使用をサポートしています (`*`) と単一文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。       `VbVolume`特定のファイル名の代わりに、ドライブのボリューム ラベルを返します。       指定する必要があります、`PathName`初めて呼び出すこと、`Dir`関数。 次の項目を取得するには、後続の呼び出しを行うことができます、`Dir`ないパラメーターを持つ関数です。      > [!IMPORTANT] > は正常に実行する、`Dir`関数に必要な<xref:System.Security.Permissions.FileIOPermissionAccess>と<xref:System.Security.Permissions.FileIOPermissionAccess>のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可する</xref:System.Security.Permissions.FileIOPermission></xref:System.Security.Permissions.FileIOPermissionAccess></xref:System.Security.Permissions.FileIOPermissionAccess>。 詳細については、次を参照してください<xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>、および[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission> 。       `Attributes`引数列挙の値は次のとおり: | | |  |-|-|-|  |値 |定数 |説明 |  |`Normal`|`vbnormal`|既定値です。 属性を持たないファイルを指定します |。  |`ReadOnly`|`vbReadOnly`|属性を持たないファイルに加えて、読み取り専用のファイルを指定します |。  |`Hidden`|`vbHidden`|属性を持たないファイルに加えて、隠しファイルを指定します |。  |`System`|`vbSystem`|属性を持たないファイルに加え、システム ファイルを指定します |。  |`Volume`|`vbVolume`|ボリューム ラベルを指定しますその他の属性が指定されている場合`vbVolume`は無視されます |。  |`Directory`|`vbDirectory`|属性を持たないファイルに、さらにディレクトリまたはフォルダーを指定します |。  |`Archive`|`vbArchive`|ファイルが前回のバックアップ以降に変更します |。  |`Alias`|`vbAlias`|ファイルが別の名前です |。     > [!NOTE] > これらの列挙は、Visual Basic 言語によって指定され、実際の値の代わりに、コード内の任意の場所で使用できます。"
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "任意。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>ファイル名、ディレクトリまたはフォルダー名、またはドライブのボリューム ラベルを指定する式。 長さ&0; の文字列 (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) 場合に返される`PathName`が見つかりません。"
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "任意。 ファイル属性を指定する値を持つ列挙型または数値式です。 省略した場合、 <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref>返しますファイルと一致する`PathName`が属性がありません。"
    return:
      type: System.String
      description: "ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列。"
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "ブール値を返します<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;></xref>のファイルの末尾が開いたときに<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>または順次<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>に達しています。"
  remarks: "使用して`EOF`ファイルの末尾の入力を取得しようとして生成されたエラーを回避します。       `EOF`関数が返される`False`まで、ファイルの末尾に達しています。 開いたファイル`Random`または`Binary`アクセス、`EOF`返します`False`最後に実行されるまで`FileGet`関数は、全体のレコードを読み取ることができません。       開かれたファイルで`Binary`にアクセスするを使用してファイルを読み込もうとすると、`Input`まで関数`EOF`を返します`True`でエラーが生成されます。 使用して、`LOF`と`Loc`関数の代わりに`EOF`と共にバイナリ ファイルを読み取るとき`Input`、使用または`Get`を使用する場合、`EOF`関数。 開いたファイル`Output`、`EOF`は常に返します`True`です。"
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>任意の有効なファイル数を格納しています。"
    return:
      type: System.Boolean
      description: "ブール値を返します<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;></xref>のファイルの末尾が開いたときに<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>または順次<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>に達しています。"
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルのファイル モードを表す列挙を返します、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>よりもファイル I/O 操作の生産性とパフォーマンスが向上するにより、 <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;></xref>関数。 参照してください<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>詳細についてはします</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>。"
  remarks: "この関数は、ファイルのモードを使用して開かれたファイルを表す列挙体を返します、`FileOpen`関数。"
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. 任意の有効なファイル数。"
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "次の列挙値は、ファイル アクセス モードを指定します。       <table><tbody><tr><td> 値       </td><td> モード       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルへの入力/出力 (I/O) を終了、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>ことの生産性とパフォーマンスの向上でのファイル I/O 操作します。 参照してください<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>詳細についてはします。"
  remarks: "`FileClose`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。[する方法: StreamReader を持つファイルをテキストの読み取り](~/add/includes/ajax-current-ext-md.md)、[する方法: StreamWriter を持つファイルに書き込むテキスト](~/add/includes/ajax-current-ext-md.md)、および[チュートリアル: Visual Basic での操作のファイルおよびディレクトリ](~/add/includes/ajax-current-ext-md.md)です。       省略した場合`FileNumbers`、すべてのアクティブなファイルを開く、`FileOpen`関数が終了します。       開かれているファイルを閉じるときに`Output`または`Append`出力の最終的なバッファーがそのファイルのオペレーティング システムのバッファーに書き込まれます。 すべてのバッファー領域が閉じたに関連付けられているファイルを解放します。       ときに、`FileClose`関数が実行され、ファイルをそのファイルの関連付け番号が終了します。"
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "任意。 0 または終了するチャネルのパラメーターの配列です。"
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>存在しません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "ファイルをコピーします。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>は、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;></xref>です。 参照してください<xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>詳細についてはします</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>。"
  remarks: "使用しようとする場合、`FileCopy`現在開いているファイルの関数のエラーが発生します。       `FileCopy`ローカル ドライブで動作する完全な信頼が必要です。"
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>コピーするファイルの名前を指定する式。 `Source`ディレクトリまたはフォルダー、およびソース ファイルのドライブを含めることがあります。"
    - id: Destination
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>対象ファイルの名前を指定する式。 `Destination`ディレクトリまたはフォルダー、およびドライブをコピー先ファイルを含めることがあります。"
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>または<code>Destination</code>無効であるか、または指定されていません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイルが既に開いています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ファイルが存在しません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref>ファイルに書き込んだ日時を示す値。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>ファイル名を指定する式。 `PathName`ディレクトリまたはフォルダー、およびドライブを含めることがあります。"
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>値を示す日付ファイルが作成または最後に変更されました。"
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>正しくないか、ワイルドカードが含まれています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ターゲット ファイルが存在しません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Boolean
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Byte
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Char
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.DateTime
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Decimal
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Double
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int16
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int32
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int64
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Single
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.ValueType
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.String
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "任意。 文字列を書き込む場合にのみ適用されます。 2 バイトの記述子の長さを表す文字列を書き込むかどうかを指定します。 既定値は<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;></xref>です。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Array
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "任意。 配列を書き込む場合にのみ適用されます。 配列の動的に処理するかどうかと、サイズと配列の境界を表す配列記述子が必要かどうかを指定します。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "任意。 文字列を書き込む場合にのみ適用されます。 2 バイトの記述子の長さを表す文字列を書き込むかどうかを指定します。 既定値は<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;></xref>です。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数に、ディスク ファイルからデータを読み取ります。  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Object
      description: "必須。 データの読み取り先変数名は無効です。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 読み込みの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>ファイルの長さをバイト単位で指定する値。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;></xref>です。 詳細については、 <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>を参照してください。"
  remarks: "場合は、指定したファイルが開いているときに、`FileLen`関数が呼び出されると、返された値は、開かれた時点で、ファイルのサイズを表します。      > [!NOTE] >、開いているファイルの現在の長さを取得するを使用して、`LOF`関数。"
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>ファイルを指定する式。 `PathName`ディレクトリまたはフォルダー、およびドライブを含めることがあります。"
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>ファイルの長さをバイト単位で指定する値。"
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ファイルが存在しません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "入力または出力用のファイルを開きます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FileOpen`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       すべての I/O 操作を実行する前にファイルを開く必要があります。 `FileOpen`ファイルへの I/O バッファーを割り当てます、バッファーへのアクセス モードを決定します。      > [!IMPORTANT] > を記述しようとするファイルが存在しない場合ファイルに書き込む場合、アプリケーションが、ファイルを作成する必要があります。 これを行うには、ファイルが作成されるディレクトリのアクセス許可が必要です。 ただし、によってファイルが指定されている場合`FileName`が存在するアプリケーションのニーズ`Write`ファイル自体にのみアクセスを許可します。 可能な限りセキュリティを強化するが展開および許可中にファイルを作成する任意の場所`Write`そのファイルへのアクセス許可のみの代わりに、全体のディレクトリにします。 セキュリティを強化するには、ルート ディレクトリまたは Program Files ディレクトリへの代わりにユーザーのディレクトリにデータを書き込みます。       開くには、チャネルを使用して検索することができます、`FreeFile()`関数。      > [!IMPORTANT] >、`FileOpen`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体は、部分的な信頼されている状況での実行に影響を与える可能性があります。 詳細については、次を参照してください<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です。</xref:System.Security.Permissions.FileIOPermissionAccess> 。"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。 使用して、 <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> [次へ] の使用可能なファイル数を取得します。"
    - id: FileName
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>ファイル名を指定する式、ディレクトリまたはフォルダーが含まれますとドライブです。"
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: '必須。 Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref>です。'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: '任意。 開いているファイルで、操作を指定する列挙体は許可されて: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>、または<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref>です。'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: '任意。 他のプロセスでは、開いているファイルに許可されない操作を指定する列挙体: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>、および<xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref>です。'
    - id: RecordLength
      type: System.Int32
      description: "任意。 32,767 (バイト) 以下を数値します。 ランダム アクセスに開かれたファイルでは、この値はレコードの長さです。 シーケンシャル ファイルは、この値はバッファー内の文字数です。"
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "レコードの長さが負の値 (-1 に等しくない) です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>既に開かれて、または<code>FileName</code>が無効です。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Boolean
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Byte
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Char
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.DateTime
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Decimal
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Double
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、`VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int16
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int32
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int64
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Single
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.ValueType
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Object
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Object
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>.。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.String
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "任意。 文字列を書き込む場合にのみ適用されます。 文字列の&2; バイトの文字列の長さ記述子をファイルに書き込むかどうかを指定します。 既定値は<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;></xref>です。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePut`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePut`を使用して、ファイルから読み取った通常`FileGet`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      -文字列の場合、変数、`FilePut`文字列の長さを含み、変数にデータを書き込む&2; バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は&2; バイト以上で、文字列の実際の長さより大きくする必要があります。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePut`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePut`2 バイト記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子の。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ]書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合 -`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。      -`FilePut`要素間の余白がない点を除いて、それぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。          > [!NOTE] > バイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに ## でバイナリ モードのファイルを開く`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 開かれているファイルに対する次の規則`Binary`モードは、の規則とは異なる`Random`モード: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。      -すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。      - `FilePut`&2; バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントがファイル番号 1 を 11 バイトを書き込みます: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] - を使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Array
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "任意。 配列を書き込む場合にのみ適用されます。 配列のダイナミックとして処理するかどうかと長さを表す文字列の配列記述子を書き込むかどうかを指定します。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "任意。 文字列を書き込む場合にのみ適用されます。 文字列の&2; バイトの文字列の長さ記述子をファイルに書き込むかどうかを指定します。 既定値は<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;></xref>です。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 と-1 に等しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "変数からデータをディスク ファイルに書き込みます。  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`FilePutObject`関数がの代わりに使用される`FilePut`場合は、コンパイル時にあいまいさを避けるために型`Object`など、他の型ではなく渡された`Integer`、 `Long`、`Short`などのようにします。       `FilePutObject`書き込みをオブジェクトを記述する記述子を読み取ります。 記述する場合、`Variant`型、`FilePutObject`が必要です。 必ず使用することお勧めに迷う場合、2 番目のパラメーター オブジェクトを使用している場合、`FilePutObject`と`FileGetObject`です。       `FilePutObject`のみ有効な`Random`と`Binary`モード。       書き込まれたデータ`FilePutObject`を使用して、ファイルから読み取った通常`FileGetObject`です。       最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、 `FilePutObject` 、最後の後に次のレコードまたはバイトを書き込みます`FileGetObject`または`FilePutObject`関数 (レコードまたはバイトを指す最後または`Seek`関数)。       `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePutObject`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePutObject`と同じ操作を実行する必要がある`FileGetObject`長さが予期する文字列が初期化されていることを確認することも必要とします。      ## ランダムなモードのファイルを開く`Random`モードでは、次の規則が適用されます: - 書き込まれるデータの長さがで指定された長さより短い場合、`RecordLength`の句、`FileOpen`関数、`FilePutObject`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と&1; つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量を正確に判断できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。      書き込まれている変数が数値型を格納しているオブジェクトである場合`FilePutObject`を識別する&2; つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePutObject`&6; バイトを書き込みます: としてオブジェクトを識別するための&2; バイト`VarType(`3`)` (`Integer`) と、データが含まれて&4; つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は&2; バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。      場合、書き込まれている変数は、文字列を格納しているオブジェクトでは`FilePutObject`2 バイトの記述子を書き込み、 `VarType(`8`)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す&2; バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも&4; バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。      -書き込まれている変数が、配列で指定されたレコード長の場合、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。      ## バイナリ モードのファイルを開く`Binary`モードでは、すべて、`Random`モードの規則を適用するを除く: -`RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePutObject`つまり、レコード間の余白ことがなく、ディスク データを連続的、すべての変数に書き込みます。"
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Object
      description: "必須。 書き込まれたデータを含む有効な変数名をディスクにします。"
    - id: RecordNumber
      type: System.Int64
      description: "任意。 番号を記録 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>モードのファイル) またはバイト数 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>モードのファイル) 書き込みを行うの開始位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルに出力行の幅を割り当てます、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。"
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: RecordWidth
      type: System.Int32
      description: "必須。 新しい行を開始する前に、行に表示される文字数を示す 0 ~ 255 の範囲の数値式です。 場合`RecordWidth`が 0 と等しい、行の長さに制限はありません。 既定値`RecordWidth`は 0 です。"
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>で使用可能な次のファイル数を表す値、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。"
  remarks: "使用して`FreeFile`が既に使用されていないファイルの番号を指定します。"
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "返します、 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>で使用可能な次のファイル数を表す値、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。"
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "255 よりも多くのファイルは、使用中です。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>ファイル、ディレクトリ、またはフォルダーの属性を表す値です。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "どの属性が設定を確認するには`And`オペレーターによって返される値のビットごとの比較を実行する、`GetAttr`関数とする個々 のファイル属性の値。 結果が&0; でない場合、その属性は、名前付きのファイルに設定します。 次の戻り値など、`And`式が場合は&0; では、`Archive`属性が設定されていません:```vb#   Result = GetAttr(FName) And vbArchive   ```場合&0; 以外の値が返されます、`Archive`属性が設定されています。"
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>ファイル、ディレクトリ、またはフォルダーの名前を指定する式。 `PathName`ディレクトリまたはフォルダー、およびドライブを含めることができます。"
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "によって返される値<xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;></xref>次の列挙値の合計です。       <table><tbody><tr><td> 値       </td><td> 定数の説明       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>法線。       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>読み取り専用です。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>非表示にします。       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>システム ファイルです。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>ディレクトリまたはフォルダーです。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>ファイルは、最後のバックアップから変更されました。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>ファイルは、別の名前です。       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    これらの列挙は、Visual Basic 言語によって指定されます。 名前は、実際の値の代わりに、コード内の任意の場所で使用できます。      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>正しくないか、ワイルドカードが含まれています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ターゲット ファイルが存在しません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Boolean
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Byte
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Char
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.DateTime
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Decimal
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Double
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int16
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語バージョンでは、3,14159、入力した場合、小数点としての代わりに変数の区切り記号としてコンマが処理されるため、3 だけを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int32
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Int64
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Object
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.Single
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。"
  remarks: "`Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。       読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。      |||  |-|-|  |データ |変数に割り当てられた値 |  |コンマまたは空白行を区切る |空 |  | NULL #|`DBNull`|  | [TRUE] または [FALSE] |`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日付や式で表された時間 |  |#ERROR `errornumber` #| `errornumber` (変数は、エラーとしてタグ付けされたオブジェクトを) |      データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。      > [!NOTE] >、`Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。      > [!IMPORTANT] > を使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Value
      type: System.String
      description: "必須。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>で開かれているファイルから文字を含む値<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>モード。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`InputString`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを読み取り、`InputString`関数が通常に書き込まれ、ファイルを使用して`Print`または`FilePut`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。       異なり、 `Input` 、関数、`InputString`関数がそこにすべての文字を返します。 これには、コンマ、キャリッジ リターン、ライン フィード、引用符、および先頭のスペースが含まれます。       開いたファイル`Binary`にアクセスするを使用して、ファイルを読み取ろうとして、`InputString`まで関数`EOF`を返します`True`でエラーが生成されます。 使用して、`LOF`と`Loc`関数の代わりに`EOF`を使用してバイナリ ファイルを読み取るときに`InputString`、使用または`FileGet`を使用する場合、`EOF`関数。      > [!NOTE] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容に関するセキュリティ上の決定します。 たとえば、Form1.vb という名前のファイルには、Visual Basic のソース ファイル可能性がありますできません。"
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: CharCount
      type: System.Int32
      description: "必須。 有効な数値式を読み取る文字の数を指定します。"
    return:
      type: System.String
      description: "返します<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>で開かれているファイルから文字を含む値<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>または<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>モード。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;></xref>です。"
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>存在しません。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "ディスクからファイルを削除します。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>です。"
  remarks: "`Kill`複数の文字の使用をサポートしています (`*`) と単一の文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。       **セキュリティに関する注意**を実行するために、`Kill`関数に必要な`Read`と`PathDiscovery`のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可する</xref:System.Security.Permissions.FileIOPermission>。 詳細についてを参照してください<xref:System.Security.SecurityException>[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>削除する&1; つまたは複数のファイル名を指定する式。 `PathName`ディレクトリまたはフォルダー、およびドライブを含めることができます。"
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "対象のファイルを開きます。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ターゲット ファイルが見つかりません。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "権限が拒否されました。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開いているシーケンシャル ファイルから&1; 行を読み取りに割り当てます、 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>変数。"
  remarks: "`LineInput`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       データを使用して読み取る`LineInput`が通常に書き込まれ、ファイルを使用して`Print`です。      > [!IMPORTANT] > ファイルから読み取る場合、しないでください、ファイル名拡張子に基づいてファイルの内容を判断します。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。       `LineInput`関数ファイルの&1; 文字からが一度に読み取ってキャリッジ リターンを検出するまで (`Chr(`13`)`) またはキャリッジ リターン/ライン フィード (`Chr(`13`)` + `Chr(`10`)`) シーケンス。 キャリッジ リターン/ライン フィードのシーケンスは、文字の文字列に追加の代わりにスキップされます。      > [!IMPORTANT] > を使用してファイルから読み取る、`LineInput`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体です</xref:System.Security.Permissions.FileIOPermissionAccess>。"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    return:
      type: System.String
      description: "開いているシーケンシャル ファイルから&1; 行を読み取りに割り当てます、 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>変数。"
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "ファイルの終わりに達しました。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>存在しません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>開いているファイルの現在の読み取り/書き込み位置を示す値。"
  remarks: "`Loc`関数は 0 から始まる以外の場合は、ファイルの最初のバイトの取得に使用すると、0 が返されます。       `Loc`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       各ファイル アクセス モードの戻り値を以下に示します: | | |  |-|-|  |モード |戻り値 |  |`Random`|読み取りまたはファイルに書き込まれた最後のレコードの数です |。  |`Sequential`|128 で割った値、ファイル内の現在のバイト位置。 ただしから返される情報`Loc`のシーケンシャル ファイルが使用されるも必要です |。  |`Binary`|最後のバイトの読み取りや書き込みの位置 |。"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効な<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>ファイル番号。"
    return:
      type: System.Int64
      description: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>開いているファイルの現在の読み取り/書き込み位置を示す値。"
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、 <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>と<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。       `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。       場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている&1; つのレコードがロック/ロック解除されます。       連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、 <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>と<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。       `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。       場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている&1; つのレコードがロック/ロック解除されます。       連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Record
      type: System.Int64
      description: "任意。 唯一の数のレコードまたはロックまたはロック解除するバイト"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、 <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>と<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。       `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。       場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている&1; つのレコードがロック/ロック解除されます。       連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: FromRecord
      type: System.Int64
      description: "任意。 最初のレコードまたはロックまたはロック解除するバイトの数。"
    - id: ToRecord
      type: System.Int64
      description: "任意。 最後のレコードまたはロックまたはロック解除するバイトの数。"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>を使用して開かれたファイルのバイト単位のサイズを表す、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "使用して、`FileLen`開かれていないファイルの長さを取得します。"
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>有効なファイル数を格納しています。"
    return:
      type: System.Int64
      description: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>を使用して開かれたファイルのバイト単位のサイズを表す、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;></xref>です。"
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "新しいディレクトリを作成します。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;></xref>です。 詳細については、 <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>を参照してください。"
  remarks: "この関数は、新しいディレクトリを作成します。"
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>作成するディレクトリを識別する式。 `Path`ドライブを含めることができます。 ドライブが指定されていない場合<xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;></xref>現在のドライブに新しいディレクトリを作成します。"
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>指定されていないか空です。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "権限が拒否されました。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ディレクトリは既に存在します。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "表示形式データをシーケンシャル ファイルに書き込みます。"
  remarks: "`Print`と`PrintLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       `Print`行の最後に、改行は含まれませんただし、`PrintLine`ライン フィードが含まれます。       書き込まれたデータ`Print`を使用して、ファイルから読み取った通常`LineInput`または`Input`です。       省略した場合`Output`の`PrintLine`、ファイル以外の空白行が出力`Print`出力は、何も行われません。 タブ境界がミキシング コンマ上、コンマで区切られた複数の式に配置され、`TAB`一貫性のない結果が生じる可能性があります。       `Boolean`データか、`True`または`False`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。       日付データは、システムによって認識される標準の短い日付形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか&0; の場合は、提供された部分のみがファイルに書き込まれます。       場合、ファイルに書き込まれますが何も`Output`データが空です。 ただし場合、`Output`リスト データは`DBNull`、`Null`ファイルに書き込まれます。       `Error`として表示されるデータ、出力`Error errorcode`です。 `Error`キーワードが、ロケールに関係なく、変換されません。       使用して、ファイルに書き込まれたすべてのデータ`Print`が国際的に対応しています。 つまり、データ形式が正しく、適切な小数点区切り文字を使用します。 ユーザーが複数のロケールで使用するデータを出力したい場合`Write`使用する必要があります。       使用してファイルへの書き込み、`Print`または`PrintLine`関数が必要です`Write`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Output
      type: System.Object[]
      description: "任意。 ファイルへの書き込みに&0; 個以上のコンマで区切られた式。       `Output`引数の設定が: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: ファイル モードが有効ではありません。       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>:`FileNumber`存在しません。"
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "表示形式データをシーケンシャル ファイルに書き込みます。"
  remarks: "`Print`と`PrintLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       `Print`行の最後に、改行は含まれませんただし、`PrintLine`ライン フィードが含まれます。       書き込まれたデータ`Print`を使用して、ファイルから読み取った通常`LineInput`または`Input`です。       省略した場合`Output`の`PrintLine`、ファイル以外の空白行が出力`Print`出力は、何も行われません。 タブ境界がミキシング コンマ上、コンマで区切られた複数の式に配置され、`TAB`一貫性のない結果が生じる可能性があります。       `Boolean`データか、`True`または`False`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。       日付データは、システムによって認識される標準の短い日付形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか&0; の場合は、提供された部分のみがファイルに書き込まれます。       場合、ファイルに書き込まれますが何も`Output`データが空です。 ただし場合、`Output`リスト データは`DBNull`、`Null`ファイルに書き込まれます。       `Error`として表示されるデータ、出力`Error errorcode`です。 `Error`キーワードが、ロケールに関係なく、変換されません。       使用して、ファイルに書き込まれたすべてのデータ`Print`が国際的に対応しています。 つまり、データ形式が正しく、適切な小数点区切り文字を使用します。 ユーザーが複数のロケールで使用するデータを出力したい場合`Write`使用する必要があります。       使用してファイルへの書き込み、`Print`または`PrintLine`関数が必要です`Write`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Output
      type: System.Object[]
      description: "任意。 ファイルへの書き込みに&0; 個以上のコンマで区切られた式。       `Output`引数の設定が: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: ファイル モードが有効ではありません。       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>:`FileNumber`存在しません。"
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "ディスク ファイルまたはディレクトリの名前を変更します。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Rename`関数は、ファイルの名前を変更し、必要がある場合は、別のディレクトリに移動します。 `Rename`関数は、ドライブ間でファイルを移動できます。 ただし、既存のディレクトリの名前を変更ことできますのみと両方`NewPath`と`OldPath`同じドライブ上にあります。 `Rename`新しいファイルまたはディレクトリを作成できません。       使用して、`Rename`開かれたファイルで関数がエラーを生成します。 名前を変更する前に、開いているファイルを閉じる必要があります。 `Rename`引数には、複数の文字 (*) と単一文字 (?) のワイルドカードを含めることはできません。      > [!IMPORTANT] > を使用する場合`Rename`保護されていない場所からファイルを保護された場所にコピーするファイルは制限の少ない権限を保持します。 セキュリティ リスクの可能性を大きくしないことを確認します。"
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>既存のファイル名と場所を指定する式です。 `OldPath`ディレクトリ、およびファイルのドライブを含めることがあります。"
    - id: NewPath
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>新しいファイル名と場所を指定する式です。 `NewPath`ディレクトリおよびコピー先のドライブを含めることがあります。 指定されたファイル名`NewPath`に存在しません。"
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "パスが有効ではありません。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>ファイルが存在しません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "別のデバイスに名前を変更することはできません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "すべてのディスクを使用して開かれたファイルが閉じ、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Reset`関数によって開かれたすべてのアクティブなファイルを閉じ、`FileOpen`関数し、同じ機能を持つ`FileClose()`パラメーターを使用せずします。"
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "既存のディレクトリを削除します。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;></xref>です。 詳細については、 <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>。</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>を参照してください。"
  remarks: "使用しようとする場合、エラーが発生した`RmDir`ファイルを格納するディレクトリにします。 使用して、`Kill`ディレクトリを削除しようとする前に、すべてのファイルを削除する関数。"
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>ディレクトリまたは削除するフォルダーを識別する式。 `Path`ドライブを含めることができます。 ドライブが指定されていない場合<xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;></xref>現在のドライブ上のディレクトリを削除します。"
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>指定されていないか空です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ターゲット ディレクトリには、ファイルが含まれています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ディレクトリが存在しません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>を使用して開かれたファイル内の現在の読み取り/書き込み位置を指定する、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数、またはセットを使用して開かれたファイルで、[次へ] の読み取り/書き込み操作の位置、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Seek`1 ~ 2,147, 483,647 の範囲値を返します (= 2 ^31-1)、包括的です。       各ファイル アクセス モードの戻り値を以下に示します: | | |  |-|-|  |モード |戻り値 |  |`Random`|次のレコードの読み取りや書き込みの数 |  |`Binary`, `Input`, `Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイト位置は 1、2 番目のバイトの位置 2 というようになります |。"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>有効なファイル数を格納しています。"
    return:
      type: System.Int64
      description: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>を使用して開かれたファイル内の現在の読み取り/書き込み位置を指定する、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数、またはセットを使用して開かれたファイルで、[次へ] の読み取り/書き込み操作の位置、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。"
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "返します、 <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref>を使用して開かれたファイル内の現在の読み取り/書き込み位置を指定する、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数、またはセットを使用して開かれたファイルで、[次へ] の読み取り/書き込み操作の位置、 <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Seek`1 ~ 2,147, 483,647 の範囲値を返します (= 2 ^31-1)、包括的です。       各ファイル アクセス モードの戻り値を以下に示します: | | |  |-|-|  |モード |戻り値 |  |`Random`|次のレコードの読み取りや書き込みの数 |  |`Binary`, `Input`, `Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイト位置は 1、2 番目のバイトの位置 2 というようになります |。"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>有効なファイル数を格納しています。"
    - id: Position
      type: System.Int64
      description: "必須。 次に読み取り/書き込みを行う場所を示す 1 ~ 2,147, 483,647 の範囲の数値が発生する必要があります。"
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "属性のファイルの情報を設定します。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能により、生産性の向上とパフォーマンスよりもファイル I/O 操作の<xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "開いているファイルの属性を設定しようとすると、実行時エラーが発生します。       `Attributes`引数列挙の値は次のとおり: | | |  |-|-|-|  |値 |定数 |説明 |  |`Normal`|`vbNormal`|標準 (既定). |  |`ReadOnly`|`vbReadOnly`|読み取り専用です |。  |`Hidden`|`vbHidden`|非表示にします |。  |`System`|`vbSystem`|システム ファイルです |。  |`Volume`|`vbVolume`|ボリューム ラベル |  |`Directory`|`vbDirectory`|ディレクトリまたはフォルダー |。  |`Archive`|`vbArchive`|ファイルが前回のバックアップ以降に変更します |。  |`Alias`|`vbAlias`|ファイルが別の名前です |。     > [!NOTE] > これらの列挙は、Visual Basic 言語で指定します。 名前は、実際の値ではなく、コード内の任意の場所で使用できます。"
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "必須。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>ファイル名を指定する式。 `PathName`ディレクトリまたはフォルダーを含めることができ、ドライブです。"
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "必須。 定数、または数値式、合計は、ファイル属性を指定します。"
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>型が正しくありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用、 <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref>または<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>出力に移動します。"
  remarks: "場合`Count`が出力線の幅を次の出力位置にすぐに次の空白の数よりも少ない。 場合`Count`出力線の幅より大きい`SPC`式を使用して次の出力の位置が計算されます: `currentprintposition`(+ (`Count``Mod``width`)) 24 は、現在の印刷位置は、出力行の幅は 80、および指定した場合など`SPC(`90`)`34 (現在の印刷位置 + 90/80 の残りの部分) の位置に、次の出力が開始されます。 現在の出力の位置と出力の線の幅の違いがある場合より小さい`Count`(または`Count` `Mod` *幅*) では、`SPC`関数は、次の行の先頭にはスキップし、スペースと等しいが生成されます`Count`– (*幅*–*桁数*)。      > [!NOTE] >、表の列は、ワイド文字のための十分なことを確認します。"
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "必須。 表示または一覧の次の式を印刷する前に挿入するスペースの数。"
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "使用、 <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref>または<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>出力に移動します。"
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用、 <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref>または<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>関数に出力を配置します。"
  remarks: "現在の行の現在の印刷位置がよりも大きいかどうか`Column`、`TAB`では、列の値に等しいへスキップ`Column`次の出力行にします。 場合`Column`が 1 より小さい`TAB`1 列目に印刷位置を移動します。 場合`Column`出力線の幅よりも大きい`TAB`式を使用して次の出力の位置が計算されます: 例については、列 Mod 幅場合*幅*80 は、指定した`TAB(`90`)`10 (90/80 の残りの部分) 列に、次の出力が開始されます。 場合`Column`現在印刷位置、計算の印刷位置にある次の行に印刷を開始よりも小さいです。 計算された印刷位置が現在の印刷位置よりも大きい場合は、計算された印刷を開始は、同じ行に位置を印刷します。       出力行の左端の位置を印刷は常に 1 です。 使用する場合、`Print`または`PrintLine`ファイルに出力する関数を使用して設定できる出力ファイルの現在の幅は、右端の印刷位置は、`FileWidth`関数。       `TAB`関数はでも使用できます、`WriteLine`関数。 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>または<xref:System.Console.WriteLine%2A?displayProperty=fullName>。</xref:System.Console.WriteLine%2A?displayProperty=fullName></xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>で使用することはできません。      > [!NOTE] >、表の列は、ワイド文字の十分なことを確認します。"
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "使用、 <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref>または<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>関数に出力を配置します。"
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用、 <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref>または<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>関数に出力を配置します。"
  remarks: "現在の行の現在の印刷位置がより大きいかどうか`Column`、`TAB`では、列の値に等しいへスキップ`Column`次の出力行にします。 場合`Column`が 1 より小さい`TAB`1 列目に印刷位置を移動します。 場合`Column`出力線の幅より大きい`TAB`式を使用して次の出力の位置が計算されます: 例については、列 Mod 幅場合*幅*80 は、指定した`TAB(`90`)`10 (90/80 の残りの部分) 列に、次の出力が開始されます。 場合`Column`現在印刷位置、計算の印刷位置にある次の行に印刷を開始よりも小さいです。 計算された印刷位置が現在の印刷位置よりも大きい場合は、計算された印刷を開始は、同じ行に位置を印刷します。       出力行の左端の位置を印刷は常に 1 です。 使用する場合、`Print`または`PrintLine`ファイルに出力する関数を使用して設定できる出力ファイルの現在の幅は、右端の印刷位置は、`FileWidth`関数。       `TAB`関数はでも使用できます、`WriteLine`関数。 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>または<xref:System.Console.WriteLine%2A?displayProperty=fullName>。</xref:System.Console.WriteLine%2A?displayProperty=fullName></xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>で使用することはできません。      > [!NOTE] >、表の列は、ワイド文字の十分なことを確認します。"
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "任意。 列数は、表示または一覧の次の式を印刷する前に移動します。 省略した場合、 <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref>は次の印刷領域の先頭にカーソルを移動します。"
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "使用、 <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref>または<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>関数に出力を配置します。"
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、 <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>と<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。       `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。       場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている&1; つのレコードがロック/ロック解除されます。       連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、 <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>と<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。       `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。       場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている&1; つのレコードがロック/ロック解除されます。       連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: Record
      type: System.Int64
      description: "任意。 唯一の数のレコードまたはロックまたはロック解除するバイト"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、 <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>関数。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>と<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;></xref>です。 詳細については、次を参照してください。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>です。"
  remarks: "`Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。       `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。       場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている&1; つのレコードがロック/ロック解除されます。       連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 任意の有効なファイル数。"
    - id: FromRecord
      type: System.Int64
      description: "任意。 最初のレコードまたはロックまたはロック解除するバイトの数。"
    - id: ToRecord
      type: System.Int64
      description: "任意。 最後のレコードまたはロックまたはロック解除するバイトの数。"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "シーケンシャル ファイルにデータを書き込みます。 書き込まれたデータ<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>を使用して、ファイルから読み取った通常<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>です。"
  remarks: "`Write`と`WriteLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       省略した場合`Output`、空白行がファイルに出力します。 複数の式は、コンマで区切ってことができます。       異なり、 `Print` 、関数、`Write`関数は、ファイルに書き込まれる項目と文字列を囲む引用符の間にコンマを挿入します。 一覧に明示的な区切り記号を配置する必要はありません。 ときに`Write`をファイルにのみ数値データの書き込みに使用`Boolean`、日付、null の場合、および`Error`データ形式がサポートされます。 データが読み取ることができを使用してを正しく解釈されるようにされている次の前提`Input`ロケールに関係なく、: 数値データが常に書き込まれる、小数点区切り文字としてピリオドを使用します。      -`Boolean`データか、`#TRUE#`または`#FALSE#`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。      -日付データは、汎用の日付の書式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか&0; の場合は、提供された部分のみがファイルに書き込まれます。      -何も書き込まれません、ファイルに場合`Output`データが空です。 ただし、null のデータの`#NULL#`が書き込まれます。      -`Error`として表示されるデータ、出力`#ERROR errorcode#`です。 `Error`キーワードは翻訳されません、ロケールに関係なく。       `WriteLine`改行文字を挿入 (つまり、キャリッジ リターン/ライン フィード、または`Chr(13) + Chr(10)`) が記述されている最後の文字の後、`Output`ファイルにします。       二重引用符を使用して文字列に引用符を埋め込むことができます、または&quot;&quot;です。 たとえば、 [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ]文字列の値を返します`Double quotation marks aren&quot;t &quot;difficult&quot; to handle`です。       使用してファイルへの書き込み、`Write`または`WriteLine`関数が必要です`Append`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>任意の有効なファイル数を含む式です。"
    - id: Output
      type: System.Object[]
      description: "任意。 ファイルに書き込む&1; つ以上のコンマで区切られた式です。"
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ファイル モードが有効ではありません。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "シーケンシャル ファイルにデータを書き込みます。 書き込まれたデータ<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>を使用して、ファイルから読み取った通常<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>です。"
  remarks: "`Write`と`WriteLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/add/includes/ajax-current-ext-md.md)です。       省略した場合`Output`、空白行がファイルに出力します。 複数の式は、コンマで区切ってことができます。       異なり、 `Print` 、関数、`Write`関数は、ファイルに書き込まれる項目と文字列を囲む引用符の間にコンマを挿入します。 一覧に明示的な区切り記号を配置する必要はありません。 ときに`Write`をファイルにのみ数値データの書き込みに使用`Boolean`、日付、null の場合、および`Error`データ形式がサポートされます。 データが読み取ることができを使用してを正しく解釈されるようにされている次の前提`Input`ロケールに関係なく、: 数値データが常に書き込まれる、小数点区切り文字としてピリオドを使用します。      -`Boolean`データか、`#TRUE#`または`#FALSE#`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。      -日付データは、汎用の日付の書式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか&0; の場合は、提供された部分のみがファイルに書き込まれます。      -何も書き込まれません、ファイルに場合`Output`データが空です。 ただし、null のデータの`#NULL#`が書き込まれます。      -`Error`として表示されるデータ、出力`#ERROR errorcode#`です。 `Error`キーワードは翻訳されません、ロケールに関係なく。       `WriteLine`改行文字を挿入 (つまり、キャリッジ リターン/ライン フィード、または`Chr(13) + Chr(10)`) が記述されている最後の文字の後、`Output`ファイルにします。       二重引用符を使用して文字列に引用符を埋め込むことができます、または&quot;&quot;です。 たとえば、 [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ]文字列の値を返します`Double quotation marks aren&quot;t &quot;difficult&quot; to handle`です。       使用してファイルへの書き込み、`Write`または`WriteLine`関数が必要です`Append`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、 <xref:System.Security.Permissions.FileIOPermissionAccess>。</xref:System.Security.Permissions.FileIOPermissionAccess>を参照してください。"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必須。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>任意の有効なファイル数を含む式です。"
    - id: Output
      type: System.Object[]
      description: "任意。 ファイルに書き込む&1; つ以上のコンマで区切られた式です。"
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
