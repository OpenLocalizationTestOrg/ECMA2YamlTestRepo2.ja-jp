### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "作成およびスレッドを制御、その優先順位を設定、その状態を取得します。"
  remarks: "プロセスの開始時に、共通言語ランタイムは自動的にアプリケーション コードを実行する&1; つのフォア グラウンド スレッドを作成します。 このメインのフォア グラウンド スレッドとプロセスは、プロセスに関連付けられているプログラム コードの一部を実行する&1; つまたは複数のスレッドを作成できます。 これらのスレッドをフォア グラウンドまたはバック グラウンドで実行できます。 さらに、使用することができます、<xref:System.Threading.ThreadPool>共通言語ランタイムによって管理されるワーカー スレッドでコードを実行するクラス</xref:System.Threading.ThreadPool>。       このセクションで[スレッドを開始](#Starting)[を取得するスレッド オブジェクト](#Retrieving)[フォア グラウンドとバック グラウンド スレッド](#Foreground)[カルチャとスレッド](#Culture)[と制御についてのスレッドの情報を取得する](#Properties)[スレッド クラスのソース コードへのアクセス](#Source)<a name=&quot;Starting&quot;> </a> ## スレッドは、そのクラス コンス トラクターで実行するメソッドを表すデリゲートを指定することによって、スレッドを開始するスレッドを開始します。                                次に呼び出し、<xref:System.Threading.Thread.Start%2A>実行を開始するメソッド</xref:System.Threading.Thread.Start%2A>。       スレッド コンス トラクターを実行するメソッドに引数を渡すことができるかどうかに基づいて、2 つのデリゲート型のいずれかを受け取ることができます:-渡す引数を持つメソッドがない場合、<xref:System.Threading.ThreadStart>コンス トラクターに委任します</xref:System.Threading.ThreadStart>。 シグネチャを持つ: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ```次の例は、作成しを実行するスレッドを開始、`ExecuteInForeground`メソッドです。           メソッドは、一部のスレッド プロパティに関する情報を表示し、実行ループを&0;.5 秒を一時停止して経過秒数を表示します。 少なくとも&5; 秒間のスレッドが実行されたときに、ループが終了し、スレッドは、実行を終了します。           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -メソッドは、引数を持つ、渡す、<xref:System.Threading.ParameterizedThreadStart>コンス トラクターに委任します</xref:System.Threading.ParameterizedThreadStart>。       シグネチャを持つ: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```デリゲートによって実行されるメソッドのキャスト (c#) または (Visual Basic) のパラメーターを適切な型に変換できますし、します。                     呼び出しする点を除いて、次の例は、1 つ前と同じ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>コンス トラクター</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 。 このバージョンの`ExecuteInForeground`メソッドには、ループは、実行するミリ秒単位のおおよその数を表す&1; つのパラメーターです。           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ]スレッドを起動した後、スレッド オブジェクトへの参照を保持する必要はありません。       スレッドは、スレッド処理が完了するまでの実行を継続します。      <a name=&quot;Retrieving&quot;></a>## スレッドを取得するオブジェクトを静的なを使用することができます (`Shared` Visual Basic で)<xref:System.Threading.Thread.CurrentThread%2A>スレッドが実行されているコードから実行中のスレッドへの参照を取得するプロパティ</xref:System.Threading.Thread.CurrentThread%2A>。 次の例では、<xref:System.Threading.Thread.CurrentThread%2A>メイン アプリケーション スレッド、もう&1; つのフォア グラウンド スレッド、バック グラウンド スレッドおよびスレッド プールのスレッドに関する情報を表示するプロパティ</xref:System.Threading.Thread.CurrentThread%2A>。       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> ## フォア グラウンドとバック グラウンドのスレッドのスレッドのクラスのインスタンスは、フォア グラウンド スレッドまたはバック グラウンド スレッドを表します。         バック グラウンド スレッドは同じですがフォア グラウンド スレッドを&1; つの例外: すべてのフォア グラウンド スレッドが終了した場合、バック グラウンド スレッドが実行されているプロセスを維持しません。 すべてのフォア グラウンド スレッドを停止すると、ランタイムはすべてのバック グラウンド スレッドを停止し、シャット ダウンします。       既定では、次のスレッドをフォア グラウンドで実行します。-メイン アプリケーション スレッドです。      -すべてのスレッドがスレッド クラスのコンス トラクターを呼び出すことによって作成します。       既定では、次のスレッドがバック グラウンドで実行します。-、ランタイムによって保守されるワーカー スレッドのプールは、プールのスレッドのスレッド。  <xref:System.Threading.ThreadPool>クラス</xref:System.Threading.ThreadPool>を使用して、スレッド プールのスレッドでスレッド プールとスケジュールの作業を構成することができます。          > [!NOTE] > スレッド プールのスレッドで自動的にタスク ベースの非同期操作を実行します。 タスク ベースの非同期操作を使用して、<xref:System.Threading.Tasks.Task>と<xref:System.Threading.Tasks.Task%601>を実装するクラス、[タスク ベースの非同期パターン](~/add/includes/ajax-current-ext-md.md)</xref:System.Threading.Tasks.Task%601></xref:System.Threading.Tasks.Task>。      -すべてのスレッドをアンマネージ コードからマネージ実行環境を入力します。       設定して、バック グラウンドで実行するスレッドを変更することができます、<xref:System.Threading.Thread.IsBackground%2A>いつでもプロパティ</xref:System.Threading.Thread.IsBackground%2A>。  バック グラウンド スレッドは、すべての操作を続行する限り、アプリケーションが実行しているが、終了、ファイル システムの変更またはソケットの受信接続の監視など、アプリケーションをしないようにする必要がありますを便利です。       次の例は、フォア グラウンドとバック グラウンド スレッド間の違いを示しています。 最初の例のようなもの、 [、スレッドの起動](#Starting)セクションを起動する前に、バック グラウンドで実行するスレッドを設定する点を除いて。 出力では、5 秒間実行前に、ループが中断されました。       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> ## 各スレッドには、カルチャ、によって表されるカルチャとスレッド、<xref:System.Threading.Thread.CurrentCulture%2A>によって表されるプロパティ、および UI カルチャ、<xref:System.Threading.Thread.CurrentUICulture%2A>プロパティ</xref:System.Threading.Thread.CurrentUICulture%2A></xref:System.Threading.Thread.CurrentCulture%2A>。          現在のカルチャでは、解析および書式設定、文字列比較と並べ替えなどのカルチャに依存した操作をサポートしているしもスレッドで使用する暦、書記体系を制御します。 現在の UI カルチャは、リソース ファイル内のリソースのカルチャに依存した検索を提供します。       新しいスレッドがインスタンス化されるときに、によって、現在のシステム カルチャと UI カルチャ、およびカルチャと、新しいスレッドの作成元のスレッドの UI カルチャではなく、そのカルチャおよび UI カルチャが定義されました。 つまり、たとえば、現在のシステム カルチャが英語 (米国) と、アプリケーションのプライマリ スレッドの現在のカルチャがフランス語 (フランス)、呼び出すことによって作成された新しいスレッドのカルチャの場合、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>プライマリ スレッドからコンス トラクターは、英語 (米国) とフランス語 (フランス).</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 詳細については、の「カルチャとスレッド」セクションを参照して、<xref:System.Globalization.CultureInfo>クラスに関するトピック。</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > をターゲットとするアプリの非同期操作を実行するスレッドの場合は true。 これはありません、[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]と以降のバージョンでこのケースでは、カルチャと UI カルチャで非同期操作のコンテキストの一部です。 既定では非同期操作を実行するスレッドのカルチャおよび非同期操作の開始元のスレッドの UI カルチャを継承します。 詳細については、の「カルチャとタスク ベースの非同期操作」セクションを参照して、<xref:System.Globalization.CultureInfo>クラスに関するトピック。</xref:System.Globalization.CultureInfo>       いずれかを行うことができることのすべてのスレッドを確認するには、次は、同じカルチャおよび UI カルチャがアプリケーションで実行する共有: に渡すことができます、<xref:System.Globalization.CultureInfo>にカルチャを表すオブジェクト、<xref:System.Threading.ParameterizedThreadStart>委任または<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>メソッド</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName></xref:System.Threading.ParameterizedThreadStart></xref:System.Globalization.CultureInfo>。      -で実行されているアプリに対して、 [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] 、以降のバージョン、カルチャおよびの値を設定して、アプリケーション ドメインで作成したすべてのスレッドに割り当てられるには、UI カルチャを定義できます、<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>と<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>プロパティ</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName></xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>。 これはアプリケーションごとのドメインの設定であることに注意してください。       詳細と例については、の「カルチャとスレッド」セクションを参照して、<xref:System.Globalization.CultureInfo>クラスに関するトピック。</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a>## 情報を取得して、スレッドを制御するには、スレッドに関する情報を提供するプロパティの値の数を取得できます。 場合によっては、これらのスレッドの操作を制御するプロパティの値を設定することもできます。 これらのスレッド プロパティを含める:-名前。 <xref:System.Threading.Thread.Name%2A>書き込みが可能-1 回、スレッドの識別に使用できるプロパティです。</xref:System.Threading.Thread.Name%2A>  既定値は`null`します。      ハッシュ コードを呼び出すことによって取得できます、<xref:System.Threading.Thread.GetHashCode%2A>メソッド</xref:System.Threading.Thread.GetHashCode%2A>。 ハッシュ コードを使用して; スレッドを一意に識別することができます。スレッドの有効期間中には、値を取得するアプリケーション ドメインに関係なく、他のスレッドからの値でそのハッシュ コードが競合するはありません。      は、スレッド id です。 読み取り専用の値<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティが、ランタイムによって割り当てられるし、そのプロセス内のスレッドを一意に識別します</xref:System.Threading.Thread.ManagedThreadId%2A>。          > [!NOTE] > オペレーティング システム[ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)アンマネージ ホストがマネージ コードとアンマネージ スレッド間の関係を制御できるため、マネージ スレッドを固定的な関係がありません。 具体的には、高度なホストを使用できる、 [CLR ホスティング API](https://msdn.microsoft.com/library/ms404385.aspx)同じオペレーティング システムのスレッドに対して多数のマネージ スレッドのスケジュールを設定するか、別のオペレーティング システム スレッド間で、マネージ スレッドを移動します。      -スレッドの現在の状態。 その存在の期間中、スレッドは常に&1; つ以上のによって定義されている状態で、<xref:System.Threading.ThreadState>プロパティ</xref:System.Threading.ThreadState>。      は、スケジューリング優先順位レベルで定義されている、<xref:System.Threading.ThreadPriority>プロパティ</xref:System.Threading.ThreadPriority>。 スレッドの優先順位を要求するには、この値を設定できますが、オペレーティング システムで受け入れられるは保証されません。      -読み取り専用<xref:System.Threading.Thread.IsThreadPoolThread%2A>プロパティで、スレッドがスレッド プールのスレッドであるかどうかを示す</xref:System.Threading.Thread.IsThreadPoolThread%2A>。      -<xref:System.Threading.Thread.IsBackground%2A>プロパティ</xref:System.Threading.Thread.IsBackground%2A>。 詳細については、次を参照してください。、[フォア グラウンドとバック グラウンド スレッド](#Foreground)セクションです。      <a name=&quot;Source&quot;></a>## スレッド クラスの .NET Framework ソース コードを表示するスレッド クラスのソース コードへのアクセスを参照してください、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。"
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Threading.Thread&quot;> </xref>クラス、スレッドが開始されたときに、スレッドに渡されるオブジェクトを許可するデリゲートを指定します。"
  remarks: "スレッドが作成されるときの実行を開始しません。 スレッドの実行をスケジュールするには、呼び出し、<xref:System.Threading.Thread.Start%2A>メソッド</xref:System.Threading.Thread.Start%2A>。 スレッドに渡すデータ オブジェクトを使用して、<xref:System.Threading.Thread.Start%28System.Object%29>メソッドのオーバー ロード</xref:System.Threading.Thread.Start%28System.Object%29>。      > [!NOTE] > Visual Basic の場合は省略できます、<xref:System.Threading.ThreadStart>スレッドを作成するときにコンス トラクター</xref:System.Threading.ThreadStart> 。 使用して、`AddressOf`演算子など、そのメソッドを渡すときに`Dim t As New Thread(AddressOf ThreadProc)`です。 Visual Basic を自動的に呼び出して、<xref:System.Threading.ThreadStart>コンス トラクター</xref:System.Threading.ThreadStart> 。"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Threading.Thread&quot;> </xref>クラスです。"
  remarks: "スレッドが作成されるときの実行を開始しません。 スレッドの実行をスケジュールするには、呼び出し、<xref:System.Threading.Thread.Start%2A>メソッド</xref:System.Threading.Thread.Start%2A>。      > [!NOTE] > Visual Basic の場合は省略できます、<xref:System.Threading.ThreadStart>スレッドを作成するときにコンス トラクター</xref:System.Threading.ThreadStart> 。 使用して、`AddressOf`演算子など、メソッドを渡すときに`Dim t As New Thread(AddressOf ThreadProc)`です。 Visual Basic を自動的に呼び出して、<xref:System.Threading.ThreadStart>コンス トラクター</xref:System.Threading.ThreadStart> 。"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref>このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Threading.Thread&quot;> </xref>クラス、スレッドが開始されたときに、スレッドに渡されるオブジェクトを許可するデリゲートとスレッドの最大スタック サイズを指定します。"
  remarks: "このコンス トラクター オーバー ロードを使用しないでください。 によって使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>。 スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングします。      > [!IMPORTANT] > で始まる、[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]コード設定を完全に信頼できるのみ、`maxStackSize`が既定のスタック サイズ (1 メガバイト) より大きい値にします。 大きい値を指定した場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されますと既定のスタック サイズを使用します。 例外はスローされません。 任意の信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。      > [!NOTE] > かどうか、部分的に信頼されたコードで使用される完全に信頼されたライブラリを開発して大きなスタックを必要とするスレッドを開始する必要があります、スレッドを作成する前に完全な信頼をアサートする必要がありますまたは既定のスタック サイズが使用されます。 こうしないスレッド上で実行されるコードを完全に制御しない限り、します。       場合`maxStackSize`が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。 場合`maxStackSize`倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。 たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262、144 バイト) が最小のスタック サイズとページ サイズは 64 KB (65,536 バイト)。      > [!NOTE] > バージョンの Windows XP および Windows Server 2003 以前の Microsoft Windows`maxStackSize`は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。       非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "A <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref>このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。"
    - id: maxStackSize
      type: System.Int32
      description: "最大スタック サイズ (バイト単位) を実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する、スレッド、または 0 で使用します。       重要: 部分的に信頼されているコード、`maxStackSize`を既定のスタック サイズを超える場合は無視されます。 例外はスローされません。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>0 未満です。"
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Threading.Thread&quot;> </xref>クラス、スレッドの最大スタック サイズを指定します。"
  remarks: "このコンス トラクター オーバー ロードを使用しないでください。 によって使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>。 スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングします。      > [!IMPORTANT] > で始まる、[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]コード設定を完全に信頼できるのみ、`maxStackSize`が既定のスタック サイズ (1 メガバイト) より大きい値にします。 大きい値を指定した場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されますと既定のスタック サイズを使用します。 例外はスローされません。 任意の信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。      > [!NOTE] > かどうか、部分的に信頼されたコードで使用される完全に信頼されたライブラリを開発して大きなスタックを必要とするスレッドを開始する必要があります、スレッドを作成する前に完全な信頼をアサートする必要がありますまたは既定のスタック サイズが使用されます。 こうしないスレッド上で実行されるコードを完全に制御しない限り、します。       場合`maxStackSize`が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。 場合`maxStackSize`倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。 たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262、144 バイト) が最小のスタック サイズとページ サイズは 64 KB (65,536 バイト)。      > [!NOTE] > バージョンの Windows XP および Windows Server 2003 以前の Microsoft Windows`maxStackSize`は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。       非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref>このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。"
    - id: maxStackSize
      type: System.Int32
      description: "最大スタック サイズ (バイト単位) を実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する、スレッド、または 0 で使用します。       重要: 部分的に信頼されているコード、`maxStackSize`を既定のスタック サイズを超える場合は無視されます。 例外はスローされません。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>0 未満です。"
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "発生させる、 <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref>これが呼び出される、そのスレッドの終了処理を開始するスレッドでします。 通常、このメソッドを呼び出すと、スレッドが終了します。"
  remarks: "システム<xref:System.Threading.ThreadAbortException>それを中止するスレッドで</xref:System.Threading.ThreadAbortException>スローのスレッドでこのメソッドが呼び出されると、 `ThreadAbortException`アプリケーション コードによってキャッチできる特別な例外は、最後の再スローされますが、`catch`しない限り、ブロック<xref:System.Threading.Thread.ResetAbort%2A>と呼びます</xref:System.Threading.Thread.ResetAbort%2A>。 `ResetAbort`中止するには要求を取り消したになり、`ThreadAbortException`がスレッドを終了します。 実行されていない`finally`ブロックは、スレッドが中止される前に実行されます。      > [!NOTE] > スレッドを呼び出すと`Abort`自体で効果に似ていますが、例外をスロー、 <xref:System.Threading.ThreadAbortException>、即座に実行され、結果は予測可能な</xref:System.Threading.ThreadAbortException>。 ただし、1 つのスレッドを呼び出す場合`Abort`どのようなコードが実行されているが、中止別のスレッドで中断します。 静的コンス トラクターが中断される可能性もあります。 まれに、原因として考えられますそのクラスのインスタンスからそのアプリケーション ドメインで作成されています。 .NET Framework バージョン 1.0 および 1.1 では、可能性がある可能性があります、スレッドの中止中に、`finally`ブロックが実行されている、その場合、`finally`ブロックが中止されました。       スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドが無制限で計算の場合に発生することができます、`finally`中止が無期限にそれによって遅れる、中止の手順の一部として呼び出されるブロック。 スレッドが中止されるまで待ってを呼び出すことができます、 <xref:System.Threading.Thread.Join%2A>Abort メソッドの呼び出し後に、スレッドでメソッドが、待機が終了するという保証はありません</xref:System.Threading.Thread.Join%2A>。      > [!NOTE] > 中止中のスレッドが場合、コードの保護領域など Abort を呼び出すスレッドをブロックする可能性があります、`catch`ブロック、`finally`ブロック、または制約された実行領域。 Abort を呼び出すスレッドは、中断されたスレッドが必要なロックを保持して、デッドロックが発生することができます。       場合`Abort`と呼びますが開始されていないスレッドでスレッドが中止される場合<xref:System.Threading.Thread.Start%2A>と呼びます</xref:System.Threading.Thread.Start%2A>。 場合`Abort`と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止されました。       場合`Abort`が中断されているスレッドで呼び出される、<xref:System.Threading.ThreadStateException>を呼び出したスレッドでスローされた<xref:System.Threading.Thread.Abort%2A>、および<xref:System.Threading.ThreadState>に追加、<xref:System.Threading.Thread.ThreadState%2A>中止中のスレッドのプロパティ</xref:System.Threading.Thread.ThreadState%2A></xref:System.Threading.ThreadState></xref:System.Threading.Thread.Abort%2A></xref:System.Threading.ThreadStateException>。 A<xref:System.Threading.ThreadAbortException>まで中断されたスレッドでスローされない<xref:System.Threading.Thread.Resume%2A>と呼びます</xref:System.Threading.Thread.Resume%2A></xref:System.Threading.ThreadAbortException>。       場合`Abort`、アンマネージ コードの実行中にマネージ スレッドで呼び出される、`ThreadAbortException`スレッドがマネージ コードに返されるまではスローされません。       2 回の呼び出しに場合`Abort`は、同時に&1; 回の呼び出しの状態情報を設定して、その他の呼び出しを実行する可能性が、`Abort`です。 ただし、アプリケーションは、このような状況を検出することはできません。       後に`Abort`が呼び出される、スレッドの状態にはスレッドで<xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>が含まれています 呼び出しに成功した結果として、スレッドが終了したら`Abort`、<xref:System.Threading.ThreadState></xref:System.Threading.ThreadState>スレッドの状態が変更されました。 十分なアクセス許可を持つスレッドの対象となって、`Abort`中止を使用して、取り消すことができます、`ResetAbort`メソッドです。 呼び出すことを示す例については、`ResetAbort`メソッドを参照してください、`ThreadAbortException`クラスです。"
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "中止中のスレッドは現在中断されています。"
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "発生させる、 <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref>これが呼び出される、スレッドの終了に関する例外情報を提供する一方、スレッドを終了するプロセスを開始するスレッドでします。 通常、このメソッドを呼び出すと、スレッドが終了します。"
  remarks: "システム<xref:System.Threading.ThreadAbortException>それを中止するスレッドで</xref:System.Threading.ThreadAbortException>スローのスレッドでこのメソッドが呼び出されると、 `ThreadAbortException`アプリケーション コードによってキャッチできる特別な例外は、最後の再スローされますが、`catch`しない限り、ブロック<xref:System.Threading.Thread.ResetAbort%2A>と呼びます</xref:System.Threading.Thread.ResetAbort%2A>。 `ResetAbort`中止するには要求を取り消したになり、`ThreadAbortException`がスレッドを終了します。 実行されていない`finally`ブロックは、スレッドが中止される前に実行されます。      > [!NOTE] > スレッドを呼び出すと`Abort`自体で効果に似ていますが、例外をスロー、 <xref:System.Threading.ThreadAbortException>、即座に実行され、結果は予測可能な</xref:System.Threading.ThreadAbortException>。 ただし、1 つのスレッドを呼び出す場合`Abort`どのようなコードが実行されているが、中止別のスレッドで中断します。 静的コンス トラクターが中断される可能性があります。 まれに、原因として考えられますそのクラスのインスタンスからそのアプリケーション ドメインで作成されています。 .NET Framework バージョン 1.0 および 1.1 では、可能性がある可能性があります、スレッドの中止中に、`finally`ブロックが実行されている、その場合、`finally`ブロックが中止されました。       スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドが無制限で計算の場合に発生することができます、`finally`中止が無期限にそれによって遅れる、中止の手順の一部として呼び出されるブロック。 スレッドが中止されるまで待ってを呼び出すことができます、 <xref:System.Threading.Thread.Join%2A>Abort メソッドの呼び出し後に、スレッドでメソッドが、待機が終了されるという保証はありません</xref:System.Threading.Thread.Join%2A>。      > [!NOTE] > を呼び出すスレッド<xref:System.Threading.Thread.Abort%2A>中止中のスレッドが場合、コードの保護領域などをブロックする可能性があります、`catch`ブロック、`finally`ブロック、または制約された実行領域</xref:System.Threading.Thread.Abort%2A>。 かどうか、スレッドを呼び出す<xref:System.Threading.Thread.Abort%2A>、デッドロックが発生する可能性が中止されたスレッドが必要なロックを保持します</xref:System.Threading.Thread.Abort%2A>。       場合`Abort`と呼びますが開始されていないスレッドでスレッドが中止される場合<xref:System.Threading.Thread.Start%2A>と呼びます</xref:System.Threading.Thread.Start%2A>。 場合`Abort`と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止されました。       場合`Abort`が中断されているスレッドで呼び出される、<xref:System.Threading.ThreadStateException>を呼び出したスレッドでスローされた<xref:System.Threading.Thread.Abort%2A>、および<xref:System.Threading.ThreadState>に追加、<xref:System.Threading.Thread.ThreadState%2A>中止中のスレッドのプロパティ</xref:System.Threading.Thread.ThreadState%2A></xref:System.Threading.ThreadState></xref:System.Threading.Thread.Abort%2A></xref:System.Threading.ThreadStateException>。 A<xref:System.Threading.ThreadAbortException>まで中断されたスレッドでスローされない<xref:System.Threading.Thread.Resume%2A>と呼びます</xref:System.Threading.Thread.Resume%2A></xref:System.Threading.ThreadAbortException>。       場合`Abort`、アンマネージ コードの実行中にマネージ スレッドで呼び出される、`ThreadAbortException`スレッドがマネージ コードに返されるまではスローされません。       2 回の呼び出しに場合`Abort`は、同時に&1; 回の呼び出しの状態情報を設定して、その他の呼び出しを実行する可能性が、`Abort`です。 ただし、アプリケーションは、このような状況を検出することはできません。       後に`Abort`が呼び出される、スレッドの状態にはスレッドで<xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>が含まれています 呼び出しに成功した結果として、スレッドが終了したら`Abort`、<xref:System.Threading.ThreadState></xref:System.Threading.ThreadState>スレッドの状態が変更されました。 十分なアクセス許可を持つスレッドの対象となって、`Abort`中止を使用して、取り消すことができます、`ResetAbort`メソッドです。 呼び出すことを示す例については、`ResetAbort`メソッドを参照してください、`ThreadAbortException`クラスです。"
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "中止するスレッドが使用できるように状態などのアプリケーションに固有の情報を格納するオブジェクト。"
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "中止中のスレッドは現在中断されています。"
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "無名のデータ スロットをすべてのスレッドに割り当てます。 パフォーマンス向上のためにマークされているフィールドを使用して、<xref:System.ThreadStaticAttribute>属性の代わりにします</xref:System.ThreadStaticAttribute>。"
  remarks: "> [!IMPORTANT]>、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット</xref:System.ThreadStaticAttribute>。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/add/includes/ajax-current-ext-md.md)です。       スロットは、すべてのスレッドに割り当てられます。       スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "割り当て済みの名前付きデータ スロットをすべてのスレッドです。"
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "名前付きデータ スロットをすべてのスレッドを割り当てます。 パフォーマンス向上のためにマークされているフィールドを使用して、<xref:System.ThreadStaticAttribute>属性の代わりにします</xref:System.ThreadStaticAttribute>。"
  remarks: "> [!IMPORTANT]>、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット</xref:System.ThreadStaticAttribute>。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/add/includes/ajax-current-ext-md.md)です。       スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。       メソッドを使用して AllocateNamedDataSlot 名前付きデータ スロットを割り当てるために必要はありません、<xref:System.Threading.Thread.GetNamedDataSlot%2A>メソッドは、既に割り当てられていない場合に、スロットを割り当てます</xref:System.Threading.Thread.GetNamedDataSlot%2A>。      > [!NOTE] > AllocateNamedDataSlot メソッドを使用する場合に呼び出す必要があります、プログラムの起動時に、メイン スレッドで指定した名前のスロットが既に割り当てられている場合、例外をスローするためです。 スロットが既に割り当てられているかどうかをテストする方法はありません。       <xref:System.Threading.Thread.FreeNamedDataSlot%2A>。</xref:System.Threading.Thread.FreeNamedDataSlot%2A>によってこのメソッドによって割り当てられたスロットを解放する必要があります。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "割り当てられるデータ スロットの名前。"
    return:
      type: System.LocalDataStoreSlot
      description: "割り当て済みの名前付きデータ スロットをすべてのスレッドです。"
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定した名前の名前付きデータ スロットは既に存在します。"
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得または、このスレッドのアパートメント状態を設定します。"
  remarks: "**ApartmentState プロパティは、今後使用しません。**  旧式でない代替手段は、<xref:System.Threading.Thread.GetApartmentState%2A>アパートメント状態を取得する方法と<xref:System.Threading.Thread.SetApartmentState%2A>アパートメント状態を設定するメソッド</xref:System.Threading.Thread.SetApartmentState%2A></xref:System.Threading.Thread.GetApartmentState%2A>。       .NET Framework version 1.0 および 1.1 で、`ApartmentState`プロパティは、スレッドをシングル スレッドまたはマルチ スレッド アパートメントで実行することを示します。 スレッドがの場合、このプロパティを設定できます、`Unstarted`または`Running`スレッドの状態です。 ただし、設定できます&1; 回だけ、のスレッドにします。 プロパティが設定されていないかどうかそれを返します`Unknown`です。       アパートメント状態が既に設定されているスレッドのアパートメント状態を設定する ApartmentState プロパティを使用する試みは無視されます。 ただし、<xref:System.Threading.Thread.SetApartmentState%2A>メソッドがスローされます、<xref:System.InvalidOperationException>でも</xref:System.InvalidOperationException></xref:System.Threading.Thread.SetApartmentState%2A>。      > [!IMPORTANT] > で .NET Framework version 2.0、として、新しいスレッドが初期化される<xref:System.Threading.ApartmentState?displayProperty=fullName>が開始される前にそのアパートメント状態が設定されていないかどうか</xref:System.Threading.ApartmentState?displayProperty=fullName>。 メイン アプリケーション スレッドに初期化<xref:System.Threading.ApartmentState?displayProperty=fullName>既定</xref:System.Threading.ApartmentState?displayProperty=fullName>。 メイン アプリケーション スレッドを設定することができます不要になった<xref:System.Threading.ApartmentState?displayProperty=fullName>を設定して、<xref:System.Threading.ApartmentState?displayProperty=fullName>コードの最初の行のプロパティ</xref:System.Threading.ApartmentState?displayProperty=fullName></xref:System.Threading.ApartmentState?displayProperty=fullName>。 使用して、<xref:System.STAThreadAttribute>代わりにします</xref:System.STAThreadAttribute>。       .NET Framework version 2.0 では、COM スレッド モデルを使用する C++ アプリケーションを指定できます、 [/CLRTHREADATTRIBUTE (CLR スレッド属性を設定)](~/add/includes/ajax-current-ext-md.md)リンカー オプション。"
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "1 つ、 <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>値。 初期値は<xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "このプロパティは有効なアパートメント状態ではない状態に設定しようとしましたが (シングル スレッド アパートメント以外の状態 (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) またはマルチ スレッド アパートメント (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))。"
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "実行がコードのスレッドの中止または処理されない例外の影響がアプリケーション ドメインで他のタスクを損なう可能性の地域を入力しようとしていますが、ホストに通知します。"
  remarks: "Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でない領域でのエラーごとに異なるポリシーを確立できます。 重要な領域でのスレッドの中止または処理されない例外の影響できない可能性があります、現在のタスクに限定されます。 これに対し、中止またはエラー コードの重要ではない範囲でエラーが発生したタスクだけに影響します。       たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。 メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、<xref:System.AppDomain>存在できないため他のタスクは同じロックを待機しているドメイン内、</xref:System.AppDomain> 。 現在のタスクが終了した場合は、他のタスクがデッドロック可能性があります。       重要な領域で、障害が発生したときにホスト場合、全体をアンロード<xref:System.AppDomain>可能性のある不安定な状態で実行を継続する危険がかかるのではなく</xref:System.AppDomain>。 重要な領域が、コードを入力することをホストに通知をするには、BeginCriticalRegion を呼び出します。 呼び出す<xref:System.Threading.Thread.EndCriticalRegion%2A>実行が重大でない領域へのコードを返します</xref:System.Threading.Thread.EndCriticalRegion%2A>。       SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。"
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のオペレーティング システムの物理スレッドの id に依存する命令の実行をマネージ コードをホストに通知します。"
  remarks: "Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストは、独自のスレッド管理を提供します。 独自のスレッド管理を提供するホストに移動できます実行中のタスク&1; つのオペレーティング システムの物理スレッドから別いつでも。 ほとんどのタスクは、このを切り替えることによっては受けません。 ただし、一部のタスクはスレッド アフィニティを持つには、オペレーティング システムの物理スレッドの id に依存します。 これらのタスクは、切り替えてはいけないコードを実行するときをホストに通知する必要があります。       たとえば、アプリケーションが Win32 CRITICAL_SECTION などのスレッドの関係のあるオペレーティング システムのロックを取得するシステム API を呼び出す場合は、呼び出す必要があります BeginThreadAffinity、ロックを取得する前に、<xref:System.Threading.Thread.EndThreadAffinity%2A>ロックを解除した後</xref:System.Threading.Thread.EndThreadAffinity%2A>。       SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。"
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "スレッドを実行している現在のコンテキストを取得します。"
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "A <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref>の現在のスレッド コンテキストを表すです。"
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得または現在のスレッドのカルチャを設定します。"
  remarks: "<xref:System.Globalization.CultureInfo>に関連付けられたオブジェクトと共に、このプロパティによって返されるオブジェクトは、日付の既定の形式、時間、数値、通貨の値、テキストの順序を並べ替え、規則、大文字小文字の区別を特定し、文字列比較</xref:System.Globalization.CultureInfo>。 参照してください、<xref:System.Globalization.CultureInfo>カルチャ名と識別子、インバリアント、中間色、および特定のカルチャの違いについて学習するクラスおよびスレッドおよびアプリケーション ドメインに影響を与える方法カルチャ情報</xref:System.Globalization.CultureInfo>。 参照してください、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>スレッドの既定のカルチャを決定する方法、およびユーザーが自分のコンピューターのカルチャ情報を設定する方法を説明するプロパティ</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>。       以降で、 [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、ニュートラル カルチャを CurrentCulture プロパティを設定することができます。 これは、ための動作、<xref:System.Globalization.CultureInfo>クラスが変更された: ときに、ニュートラル カルチャをプロパティの値を表します (具体的には、 <xref:System.Globalization.CultureInfo.Calendar%2A>、 <xref:System.Globalization.CultureInfo.CompareInfo%2A>、 <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>、 <xref:System.Globalization.CultureInfo.NumberFormat%2A>、および<xref:System.Globalization.CultureInfo.TextInfo%2A>プロパティ)、ニュートラル カルチャに関連付けられている特定のカルチャを反映します</xref:System.Globalization.CultureInfo.TextInfo%2A></xref:System.Globalization.CultureInfo.NumberFormat%2A></xref:System.Globalization.CultureInfo.DateTimeFormat%2A></xref:System.Globalization.CultureInfo.CompareInfo%2A></xref:System.Globalization.CultureInfo.Calendar%2A></xref:System.Globalization.CultureInfo>。 .NET Framework の以前のバージョンで CurrentCulture プロパティがスローされました、<xref:System.NotSupportedException>がニュートラル カルチャの割り当てに例外が発生します</xref:System.NotSupportedException>。"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "現在のスレッドのカルチャを表すオブジェクト。"
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "プロパティに設定<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得または (ロール ベースのセキュリティに関する、スレッドの現在のプリンシパルを設定します。"
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "<xref:System.Security.Principal.IPrincipal>のセキュリティ コンテキストを表す値</xref:System.Security.Principal.IPrincipal>。"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、プリンシパルを設定するために必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在実行中のスレッドを取得します。"
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "A <xref href=&quot;System.Threading.Thread&quot;> </xref>を表す、現在実行中のスレッド。"
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得またはリソース マネージャーで実行時にカルチャ固有のリソースを検索するために使用する現在のカルチャを設定します。"
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "現在のカルチャを表すオブジェクト。"
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "プロパティに設定<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "リソース ファイルの検索に使用できないカルチャ名に設定されます。 リソース ファイル名には、文字、数字、ハイフンまたはアンダー スコアのみを含める必要があります。"
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のスレッドのランタイム呼び出し可能ラッパー (RCW) の自動クリーンアップをオフにします。"
  remarks: "既定では、共通言語ランタイム (CLR) をクリーンアップ ランタイム呼び出し可能ラッパーに自動的にします。 CLR は、次の特殊な条件を満たす、いくつかのアプリケーションの再入の問題が発生する可能性があります、クリーンアップ中にメッセージをポンプ:-アプリケーションが独自のメッセージ ポンプがします。      -アプリケーションがメッセージ ポンプが発生したときに正確に制御する必要があります。       このようなアプリケーションでは、CLR がランタイム呼び出し可能ラッパーの自動再生を実行するを防ぐため、DisableComObjectEagerCleanup メソッドを使用できます。       このメソッドは、スレッドで呼び出されると、自動クリーンアップがそのスレッドを再び有効にすることはできません。 使用して、アプリケーションのランタイム呼び出し可能ラッパーをクリーンアップする準備ができたら、<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>ランタイムが、現在のコンテキスト内のすべてのランタイム呼び出し可能ラッパーをクリーンアップするように命令する方法</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>。 メッセージ ポンプは、メソッドの実行中に発生します。"
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "実行スレッドの中止または処理されない例外の影響が現在のタスクだけにコードの地域を入力しようとしていますが、ホストに通知します。"
  remarks: "Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でない領域でのエラーごとに異なるポリシーを確立できます。 重要な領域でのスレッドの中止または処理されない例外の影響できない可能性があります、現在のタスクに限定されます。 これに対し、中止またはエラー コードの重要ではない範囲でエラーが発生したタスクだけに影響します。       たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。 メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、<xref:System.AppDomain>存在できないため他のタスクは同じロックを待機しているドメイン内、</xref:System.AppDomain> 。 現在のタスクが終了した場合は、他のタスクがデッドロック可能性があります。       重要な領域で、障害が発生したときにホスト場合、全体をアンロード<xref:System.AppDomain>可能性のある不安定な状態で実行を継続する危険がかかるのではなく</xref:System.AppDomain>。 重要な領域が、コードを入力することをホストに通知をするには、 <xref:System.Threading.Thread.BeginCriticalRegion%2A>。</xref:System.Threading.Thread.BeginCriticalRegion%2A>を呼び出す 重大でないコード領域に実行制御が戻るとき、EndCriticalRegion を呼び出します。       SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。"
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のオペレーティング システムの物理スレッドの id に依存する命令の実行が完了したマネージ コードをホストに通知します。"
  remarks: "Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストは、独自のスレッド管理を提供します。 独自のスレッド管理を提供するホストに移動できます実行中のタスク&1; つのオペレーティング システムの物理スレッドから別いつでも。 ほとんどのタスクは、このを切り替えることによっては受けません。 ただし、一部のタスクはスレッド アフィニティを持つには、オペレーティング システムの物理スレッドの id に依存します。 これらのタスクは、切り替えてはいけないコードを実行するときをホストに通知する必要があります。       たとえば、オペレーティング システムを取得する、アプリケーション呼び出しシステム API をロックする場合、Win32 CRITICAL_SECTION などのスレッドの関係のある呼び出す必要があります<xref:System.Threading.Thread.BeginThreadAffinity%2A>ロックを解放すた後ロック、および EndThreadAffinity を取得する前にします</xref:System.Threading.Thread.BeginThreadAffinity%2A>。       SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。"
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得、 <xref:System.Threading.ExecutionContext>、現在のスレッドのさまざまなコンテキストに関する情報を含むオブジェクトです</xref:System.Threading.ExecutionContext>。"
  remarks: "<xref:System.Threading.ExecutionContext>クラスは、すべての情報の論理的なスレッドに関連する実行の&1; つのコンテナーを提供します</xref:System.Threading.ExecutionContext>。 これには、セキュリティ コンテキスト、呼び出しコンテキスト、同期コンテキスト、ローカリゼーション コンテキスト、およびトランザクション コンテキストが含まれます。"
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "<xref:System.Threading.ExecutionContext>、現在のスレッドのコンテキスト情報を統合するオブジェクト</xref:System.Threading.ExecutionContext>。"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "リソースが解放され、ガベージ コレクターがクリアするときに他のクリーンアップ操作が実行されることにより、 <xref href=&quot;System.Threading.Thread&quot;> </xref>オブジェクト。"
  remarks: "ガベージ コレクターは、現在のオブジェクトが完了する準備ができたとき。"
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "名前と、プロセスのすべてのスレッドのスロットの関連付けを解除します。 パフォーマンス向上のためにマークされているフィールドを使用して、<xref:System.ThreadStaticAttribute>属性の代わりにします</xref:System.ThreadStaticAttribute>。"
  remarks: "> [!IMPORTANT]>、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット</xref:System.ThreadStaticAttribute>。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/add/includes/ajax-current-ext-md.md)です。       いずれかのスレッドの呼び出し後`FreeNamedDataSlot`、他のスレッドを呼び出す<xref:System.Threading.Thread.GetNamedDataSlot%2A>と同じ名前は、名前に関連付けられている新しいスロットを割り当てます</xref:System.Threading.Thread.GetNamedDataSlot%2A>。 後続の呼び出し`GetNamedDataSlot`任意のスレッドでは、新しいスロットを返します。 ただし、いずれかのスレッドをまだ、<xref:System.LocalDataStoreSlot?displayProperty=fullName>を以前の呼び出しによって返される`GetNamedDataSlot`引き続き古いスロットを使用できます</xref:System.LocalDataStoreSlot?displayProperty=fullName>。       名前に関連付けられているスロットが解放される場合にのみすべて`LocalDataStoreSlot`への呼び出しの前に取得された`FreeNamedDataSlot`リリースされ、ガベージ コレクションします。       スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "解放されるデータ スロットの名前。"
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "返します、 <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>アパートメント状態を示す値。"
  remarks: "このメソッドと共に、<xref:System.Threading.Thread.SetApartmentState%2A>メソッドおよび<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティ</xref:System.Threading.Thread.ApartmentState%2A></xref:System.Threading.Thread.TrySetApartmentState%2A></xref:System.Threading.Thread.SetApartmentState%2A>。"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "1 つ、 <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>マネージ スレッドのアパートメント状態を示す値。 既定値は<xref href=&quot;System.Threading.ApartmentState&quot;></xref>です。"
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "返します、 <xref href=&quot;System.Threading.CompressedStack&quot;> </xref>を現在のスレッドのスタックをキャプチャするために使用できるオブジェクト。"
  remarks: "このメソッドは現在サポートされていません。"
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "ありません。"
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "すべての場合。"
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "指定した現在のスレッドの現在のドメイン内の現在のスレッドのスロットから値を取得します。 パフォーマンス向上のためにマークされているフィールドを使用して、<xref:System.ThreadStaticAttribute>属性の代わりにします</xref:System.ThreadStaticAttribute>。"
  remarks: "> [!IMPORTANT]>、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット</xref:System.ThreadStaticAttribute>。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/add/includes/ajax-current-ext-md.md)です。       スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。      > [!NOTE] > GetData は、`Shared`を別のスレッドを表す変数を使用するメソッドを呼び出す場合でも常に現在実行中のスレッドに適用するメソッド。 混乱を避けるためには、クラス名を呼び出すときに使用`Shared`メソッド:`Dim test As Object = Thread.GetData(testSlot)`です。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref>元の値を取得します。"
    return:
      type: System.Object
      description: "取得された値。"
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のスレッドが実行されている現在のドメインを返します。"
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "<xref href=&quot;System.AppDomain&quot;> </xref>実行中のスレッドの現在のアプリケーション ドメインを表すです。"
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "一意のアプリケーション ドメイン識別子を返します。"
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "アプリケーション ドメインを一意に識別する 32 ビット符号付き整数。"
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のスレッドのハッシュ コードを返します。"
  remarks: "ハッシュ コードは一意であることは保証されません。 使用して、<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティのマネージ スレッドの一意の識別子が必要がある場合</xref:System.Threading.Thread.ManagedThreadId%2A>。"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "整数ハッシュ コード値。"
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "名前付きデータ スロットを検索します。 パフォーマンス向上のためにマークされているフィールドを使用して、<xref:System.ThreadStaticAttribute>属性の代わりにします</xref:System.ThreadStaticAttribute>。"
  remarks: "> [!IMPORTANT]>、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット</xref:System.ThreadStaticAttribute>。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/add/includes/ajax-current-ext-md.md)です。       スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。       名前付きスロットが存在しない場合は、新しいスロットが割り当てられます。 名前付きデータ スロットは、パブリックし、すべてのユーザーによって操作されることができます。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "ローカル データ スロットの名前。"
    return:
      type: System.LocalDataStoreSlot
      description: "A <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref>このスレッドに割り当てられます。"
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "内にあるスレッドに割り込む、 <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref>スレッドの状態。"
  remarks: "このスレッドが待機、スリープ状態または結合状態で現在ブロックされていない場合は、ブロックが次で開始したときに中断されます。       <xref:System.Threading.ThreadInterruptedException>スレッドがブロックされるが、中断されたスレッドでスローされます。</xref:System.Threading.ThreadInterruptedException> スレッドがブロックされない場合、例外がスローされず、ため、スレッドが中断されることがなく完了ことがあります。"
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元は、適切なありません<xref href=&quot;System.Security.Permissions.SecurityPermission&quot;></xref>です。"
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のスレッドの実行状態を示す値を取得します。"
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>このスレッドが起動していない場合、正常終了または中止されました。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得またはスレッドがバック グラウンド スレッドであるかどうかどうかを示す値を設定します。"
  remarks: "スレッドは、バック グラウンド スレッドまたはフォア グラウンド スレッドのいずれかです。 バック グラウンド スレッドは、バック グラウンド スレッドいなくても、プロセスが終了する点を除いて、フォア グラウンド スレッドと同じです。 プロセスに属するすべてのフォア グラウンド スレッドが終了すると、共通言語ランタイムは、プロセスを終了します。 残りのバック グラウンド スレッドは停止され、完了しません。       既定では、次のスレッドをフォア グラウンドで実行 (つまり、その IsBackground プロパティから返される`false`):-プライマリ スレッド (またはメイン アプリケーション スレッド)。      -すべてのスレッドを呼び出すことによって作成された、<xref:System.Threading.Thread>クラスのコンス トラクター</xref:System.Threading.Thread> 。       既定では、次のスレッドがバック グラウンドで実行 (つまり、その IsBackground プロパティから返される`true`): に、ランタイムによって保守されるワーカー スレッドのプールは、プールのスレッドのスレッドします。 <xref:System.Threading.ThreadPool>クラス</xref:System.Threading.ThreadPool>を使用して、スレッド プールのスレッドでスレッド プールとスケジュールの作業を構成することができます。          > [!NOTE] > スレッド プールのスレッドで自動的にタスク ベースの非同期操作を実行します。      -すべてのスレッドをアンマネージ コードからマネージ実行環境を入力します。"
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>このスレッドがまたはには、バック グラウンド スレッドになる場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドが動作しています。"
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "スレッドがマネージ スレッド プールに属しているかどうかを示す値を取得します。"
  remarks: "詳細については、次を参照してください。 [、マネージ スレッド プール](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>このスレッドがマネージ スレッド プールに属する場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "標準の COM の実行は継続中に、このインスタンスで表される、スレッドが終了するまで、呼び出し元のスレッドをブロックし、 <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref>ポンピングです。"
  remarks: "結合は、スレッドのメソッドが呼び出されたが結合が完了するまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドです。 このメソッドを使用して、スレッドが終了したことを確認してください。 スレッドが終了しない場合、呼び出し元が無期限にブロックされます。 次の例で、`Thread1`の結合メソッドを呼び出すスレッドは`Thread2`、これにより`Thread1`されるまでブロックする`Thread2`が完了しました。       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ]場合は、スレッドが終了時に既に<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します</xref:System.Threading.Thread.Join%2A>。        > [!WARNING] > の結合メソッドは呼び出さないで、<xref:System.Threading.Thread>を現在のスレッドから、現在のスレッドを表すオブジェクト</xref:System.Threading.Thread>。 これにより、ハング、現在のスレッド自体には無期限に待機、このメソッドが変更されたのためにアプリを<xref:System.Threading.ThreadState?displayProperty=fullName>。</xref:System.Threading.ThreadState?displayProperty=fullName>を含めるには、呼び出し元のスレッドの状態 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState?displayProperty=fullName>状態</xref:System.Threading.ThreadState?displayProperty=fullName>。"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "呼び出し元スレッドを結合しようとしました。、 <xref href=&quot;System.Threading.ThreadState&quot;> </xref>状態です。"
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "スレッドは待機中に中断されました。"
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "このインスタンスで表される、スレッドが終了するまで呼び出し元のスレッドまたは指定された時間が経過するまで、標準の COM および SendMessage ポンピングの実行は継続のブロックです。"
  remarks: "結合は、いずれかのスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されたが完了したか、タイムアウト間隔が経過します</xref:System.Threading.Thread.Join%2A>。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、これにより`Thread1`までいずれかをブロックする`Thread2`が完了した 2 秒が経過したか</xref:System.Threading.Thread.Join>。       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ]場合<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>が指定されて、`millisecondsTimeout`パラメーターでは、このメソッドの動作と同じように、<xref:System.Threading.Thread.Join>メソッドのオーバー ロードで戻り値を除く</xref:System.Threading.Thread.Join></xref:System.Threading.Timeout.Infinite?displayProperty=fullName>。         スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します</xref:System.Threading.Thread.Join%2A>。       このメソッドに含める<xref:System.Threading.ThreadState?displayProperty=fullName>。</xref:System.Threading.ThreadState?displayProperty=fullName>呼び出し元のスレッドの状態を変更します。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState?displayProperty=fullName>状態</xref:System.Threading.ThreadState?displayProperty=fullName>。"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "スレッドが終了するまで待機するミリ秒数。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、スレッドが終了します。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>スレッドがで指定された時間の経過後、終了していないかどうか、 <code> millisecondsTimeout </code>パラメーターが経過しました。"
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "値<code> millisecondsTimeout </code>が負の値と等しくない&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; (ミリ秒単位)。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドが開始されていません。"
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "このインスタンスで表される、スレッドが終了するまで呼び出し元のスレッドまたは指定された時間が経過するまで、標準の COM および SendMessage ポンピングの実行は継続のブロックです。"
  remarks: "結合は、いずれかのスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されたが完了したか、タイムアウト間隔が経過します</xref:System.Threading.Thread.Join%2A>。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、これにより`Thread1`までいずれかをブロックする`Thread2`が完了した 2 秒が経過したか</xref:System.Threading.Thread.Join>。       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ]場合<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>が指定されて`timeout`、このメソッドの動作と同じように、<xref:System.Threading.Thread.Join>メソッドのオーバー ロードで戻り値を除く</xref:System.Threading.Thread.Join></xref:System.Threading.Timeout.Infinite?displayProperty=fullName>。         スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します</xref:System.Threading.Thread.Join%2A>。       このメソッドを<xref:System.Threading.ThreadState>。</xref:System.Threading.ThreadState>を含めるには、現在のスレッドの状態を変更します。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState?displayProperty=fullName>状態</xref:System.Threading.ThreadState?displayProperty=fullName>。"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A<xref:System.TimeSpan>スレッドが終了するまで待機する時間に設定します</xref:System.TimeSpan>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、スレッドが終了します。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>スレッドがで指定された時間の経過後、終了していないかどうか、 <code> timeout </code>パラメーターが経過しました。"
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "値<code> timeout </code>が負の値と等しくない&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; (ミリ秒単位) より大きいまたは&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; (ミリ秒)。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "呼び出し元スレッドを結合しようとしました。、 <xref href=&quot;System.Threading.ThreadState&quot;> </xref>状態です。"
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のマネージ スレッドの一意の識別子を取得します。"
  remarks: "スレッドの ManagedThreadId プロパティの値は、そのプロセス内でそのスレッドを一意に識別するのには機能します。       ManagedThreadId プロパティの値は、共通言語ランタイムをホストするアンマネージ コードには、ファイバーとスレッドが実装されている場合でもに時間の経過と共に変わりません。"
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "このマネージ スレッドの一意の識別子を表す整数。"
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: '次のようにメモリ アクセスを同期: 現在のスレッドを実行中のプロセッサがなどの命令を並べ替えることはできません MemoryBarrier への呼び出しの後のメモリ アクセスより後にメモリが MemoryBarrier を呼び出す前にアクセスする方法が実行されます。'
  remarks: "脆弱なメモリが (たとえば、複数の Intel Itanium プロセッサを使用するシステム) の順序では、マルチプロセッサ システムでのみ MemoryBarrier が必要です。       ほとんどの目的で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、または<xref:System.Threading.Monitor>クラスは、データを同期する簡単な方法を提供します</xref:System.Threading.Monitor>。"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得またはスレッドの名前を設定します。"
  remarks: "このプロパティは書き込みの後です。 スレッドの名前プロパティの既定値があるため`null`、することができるかどうか、名前が既に割り当てられてを調べます明示的にスレッドと比較して`null`です。       Name プロパティに割り当てられた文字列は、任意の Unicode 文字を含めることができます。"
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "スレッドの名前を含む文字列または<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>名が設定されていない場合。"
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "設定操作が要求されましたが、 <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>プロパティは既に設定されています。"
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得またはスレッドのスケジューリング優先順位を示す値を設定します。"
  remarks: "次の優先度のいずれかのスレッドを割り当てることができる<xref:System.Threading.ThreadPriority>値:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest`オペレーティング システムが、スレッドの優先度を優先する必要はありません</xref:System.Threading.ThreadPriority>。"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "1 つ、 <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>値。 既定値は<xref href=&quot;System.Threading.ThreadPriority&quot;></xref>です。"
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "最終的な状態をなど、スレッドが<xref href=&quot;System.Threading.ThreadState&quot;></xref>です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定された設定操作が有効ではありません値<xref href=&quot;System.Threading.ThreadPriority&quot;></xref>値。"
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "キャンセル、 <xref:System.Threading.Thread.Abort*>、現在のスレッドを要求します</xref:System.Threading.Thread.Abort*>。"
  remarks: "このメソッドは、適切なアクセス許可を持つコードでのみ呼び出すことができます。       呼び出しが行われたときに`Abort`スレッドを終了、 <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException>がスローされます `ThreadAbortException`特別な例外があるが、アプリケーション コードでキャッチできますが、catch ブロックの最後に再スローされる場合を除き、`ResetAbort`と呼びます。 `ResetAbort`中止するには要求を取り消したになり、`ThreadAbortException`がスレッドを終了します。       参照してください<xref:System.Threading.ThreadAbortException>を呼び出すことを示す例については、`ResetAbort`メソッド</xref:System.Threading.ThreadAbortException>。"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>現在のスレッドで呼び出されませんでした。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元には、現在のスレッドの必要なセキュリティ アクセス許可がありません。"
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "中断されているスレッドを再開します。"
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドが開始されていない、または中断された状態ではありません。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元は、適切なありません<xref href=&quot;System.Security.Permissions.SecurityPermission&quot;></xref>です。"
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "開始される前に、スレッドのアパートメント状態を設定します。"
  remarks: "新しいスレッドとして初期化される<xref:System.Threading.ApartmentState?displayProperty=fullName>が開始される前にそのアパートメント状態が設定されていないかどうか</xref:System.Threading.ApartmentState?displayProperty=fullName>。 スレッドを開始する前に、アパートメントの状態を設定する必要があります。      > [!NOTE] > をメイン アプリケーション スレッドが初期化される<xref:System.Threading.ApartmentState?displayProperty=fullName>既定</xref:System.Threading.ApartmentState?displayProperty=fullName>。 アプリケーションのメイン スレッドのアパートメント状態を設定する唯一の方法<xref:System.Threading.ApartmentState?displayProperty=fullName>を適用する、<xref:System.STAThreadAttribute>属性をエントリ ポイント メソッドです</xref:System.STAThreadAttribute></xref:System.Threading.ApartmentState?displayProperty=fullName>。       SetApartmentState メソッドと共に、<xref:System.Threading.Thread.GetApartmentState%2A>メソッドおよび<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティ</xref:System.Threading.Thread.ApartmentState%2A></xref:System.Threading.Thread.TrySetApartmentState%2A></xref:System.Threading.Thread.GetApartmentState%2A>。"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "新しいアパートメント状態。"
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>有効なアパートメント状態ではありません。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドは既に開始されています。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "アパートメント状態は既に初期化されています。"
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "キャプチャした適用<xref href=&quot;System.Threading.CompressedStack&quot;></xref>現在のスレッドにします。"
  remarks: "このメソッドは現在サポートされていません。"
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "<xref href=&quot;System.Threading.CompressedStack&quot;> </xref>現在のスレッドに適用するオブジェクト。"
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "すべての場合。"
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "そのスレッドの現在のドメインの現在実行中のスレッドで指定されたスロット内のデータを設定します。 パフォーマンスを向上させるのでマークされたフィールドを使用して、<xref:System.ThreadStaticAttribute>属性の代わりにします</xref:System.ThreadStaticAttribute>。"
  remarks: "> [!IMPORTANT]>、.NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための&2; つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット</xref:System.ThreadStaticAttribute>。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/add/includes/ajax-current-ext-md.md)です。       スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッド プロシージャが終了した後、再利用するため、スロットを解放し、<xref:System.Threading.Thread>オブジェクトがガベージ コレクションによって解放された</xref:System.Threading.Thread>。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。      > [!NOTE] > SetData は、`Shared`を別のスレッドを表す変数を使用するメソッドを呼び出す場合でも常に現在実行中のスレッドに適用するメソッド。 混乱を避けるためには、クラス名を呼び出すときに使用`Shared`メソッド:`Thread.SetData(testSlot, &quot;test data&quot;)`です。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref>先となる値を設定します。"
    - id: data
      type: System.Object
      description: "設定する値。"
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "指定したミリ秒数の現在のスレッドを中断します。"
  remarks: "スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。 このメソッドに含める<xref:System.Threading.ThreadState>。</xref:System.Threading.ThreadState>スレッドの状態を変更します。       指定できます<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>の`millisecondsTimeout`を無期限にスレッドを中断するパラメーター</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> 。 ただし、使用ことお勧めするその他の<xref:System.Threading?displayProperty=fullName>などのクラス<xref:System.Threading.Mutex>、 <xref:System.Threading.Monitor>、 <xref:System.Threading.EventWaitHandle>、または<xref:System.Threading.Semaphore>代わりに「同期化スレッドにまたはリソースを管理します</xref:System.Threading.Semaphore></xref:System.Threading.EventWaitHandle></xref:System.Threading.Monitor></xref:System.Threading.Mutex></xref:System.Threading?displayProperty=fullName>。       特定のレートでシステム クロックのティックには、クロックの分解能が呼び出されます。 実際のタイムアウトできない可能性があります正確に指定されたタイムアウト、クロックのティックと一致するように指定したタイムアウト時間が調整されるためです。 クロックの分解能と待機時間の詳細については、次を参照してください。、[関数をスリープ状態](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)トピックです。 このメソッドは、[関数をスリープ状態](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)Windows システム Api からです。       このメソッドでは、標準の COM および&1; つは実行されません。      > [!NOTE] > かどうかのあるスレッドでスリープ状態にする必要があります<xref:System.STAThreadAttribute>、標準の COM および&1; つを実行するためのオーバー ロードのいずれかの使用を検討するが、<xref:System.Threading.Thread.Join%2A>タイムアウト間隔を指定するメソッド</xref:System.Threading.Thread.Join%2A></xref:System.STAThreadAttribute>。"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "スレッドが中断ブロックされるミリ秒数。 場合の値、`millisecondsTimeout`引数が&0; で、スレッドが実行する準備ができている同じ優先順位のスレッドに自らのタイム スライスの残りの部分を放棄します。 実行する準備ができている同じ優先順位の他のスレッドがない場合は、現在のスレッドの実行は中断されません。"
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "タイムアウト値が負の値と等しくない<xref:System.Threading.Timeout.Infinite>。</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "指定した時間数の現在のスレッドを中断します。"
  remarks: "スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。 このメソッドに含める<xref:System.Threading.ThreadState>。</xref:System.Threading.ThreadState>スレッドの状態を変更します。       指定できます<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>の`timeout`を無期限にスレッドを中断するパラメーター</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> 。 ただし、使用ことお勧めするその他の<xref:System.Threading?displayProperty=fullName>などのクラス<xref:System.Threading.Mutex>、 <xref:System.Threading.Monitor>、 <xref:System.Threading.EventWaitHandle>、または<xref:System.Threading.Semaphore>代わりに「同期化スレッドにまたはリソースを管理します</xref:System.Threading.Semaphore></xref:System.Threading.EventWaitHandle></xref:System.Threading.Monitor></xref:System.Threading.Mutex></xref:System.Threading?displayProperty=fullName>。       このオーバー ロード<xref:System.Threading.Thread.Sleep%2A>で整数のミリ秒単位の合計数を使用して`timeout`</xref:System.Threading.Thread.Sleep%2A>。 小数ミリ秒は破棄されます。       このメソッドでは、標準の COM および&1; つは実行されません。      > [!NOTE] > かどうかのあるスレッドでスリープ状態にする必要があります<xref:System.STAThreadAttribute>、標準の COM および&1; つを実行するためのオーバー ロードのいずれかの使用を検討するが、<xref:System.Threading.Thread.Join%2A>タイムアウト間隔を指定するメソッド</xref:System.Threading.Thread.Join%2A></xref:System.STAThreadAttribute>。"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "スレッドが中断される時間数。 場合の値、`millisecondsTimeout`引数は&lt;xref:System.TimeSpan?displayProperty=fullName&gt;スレッドが実行する準備ができている同じ優先順位のスレッドに自らのタイム スライスの残りの部分を放棄します。 実行する準備ができている同じ優先順位の他のスレッドがない場合は、現在のスレッドの実行は中断されません。"
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "値<code> timeout </code>が負の値と等しくない&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; (ミリ秒単位) より大きいまたは&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; (ミリ秒)。"
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "定義される時間だけ待機するスレッド、 <code> iterations </code>パラメーター。"
  remarks: "SpinWait メソッドは、ロックを実装するために便利です。 などの .NET framework クラス<xref:System.Threading.Monitor>と<xref:System.Threading.ReaderWriterLock>、このメソッドを内部的に使用します</xref:System.Threading.ReaderWriterLock></xref:System.Threading.Monitor>。 SpinWait 本質的には、プロセッサに非常に短いループで指定されたループ カウントと、`iterations`パラメーター。 そのため、待機時間は、プロセッサの速度に依存します。       これに対し、<xref:System.Threading.Thread.Sleep%2A>メソッド</xref:System.Threading.Thread.Sleep%2A>。 呼び出すスレッド<xref:System.Threading.Thread.Sleep%2A>、指定した間隔が&0; の場合でもプロセッサ時間の現在のスライスの残りの部分が得られます</xref:System.Threading.Thread.Sleep%2A>。 0 以外の間隔を指定する<xref:System.Threading.Thread.Sleep%2A>時間間隔が経過するまで、スレッド スケジューラによって考慮の対象からスレッドを削除します</xref:System.Threading.Thread.Sleep%2A>。       SpinWait は通常のアプリケーションの一般的に便利です。 ほとんどの場合は、.NET Framework によって提供される同期クラスを使用する必要があります。たとえば、呼び出す<xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>またはラップするステートメント<xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` (C#) または`SyncLock`Visual Basic で).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > わかっている場合、状態の変更が迫っていないかなどのコンテキストの切り替えを避けるためにメリットがあるまれなケースでは、ループで SpinWait メソッドへの呼び出しを確認します。 SpinWait を実行するコードは、複数のプロセッサを搭載したコンピューターで発生する可能性がある問題を防ぐために設計されています。 たとえば、ハイパー スレッディング テクノロジを採用すること、複数の Intel プロセッサを搭載したコンピューター SpinWait に特定の状況でプロセッサ スタベーションができないようにします。"
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "スレッドが待機する時間を定義する 32 ビット符号付き整数。"
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "により、オペレーティング システムに現在のインスタンスの状態を変更する<xref href=&quot;System.Threading.ThreadState&quot;></xref>です。"
  remarks: "スレッドが、<xref:System.Threading.ThreadState?displayProperty=fullName>状態にある場合、オペレーティング システムを使用すると実行をスケジュールできます</xref:System.Threading.ThreadState?displayProperty=fullName>。 によって表されるメソッドの最初の行で実行するスレッドを開始、<xref:System.Threading.ThreadStart>または<xref:System.Threading.ParameterizedThreadStart>スレッド コンス トラクターに渡されるデリゲート</xref:System.Threading.ParameterizedThreadStart></xref:System.Threading.ThreadStart>。 開始への呼び出しで、呼び出し元スレッドをブロックしないことに注意してください。      > [!NOTE] > を使用して作成されたスレッドでこのオーバー ロードが使用されるかどうか、<xref:System.Threading.ParameterizedThreadStart>デリゲート`null`スレッドによって実行されるメソッドに渡されます</xref:System.Threading.ParameterizedThreadStart>。       スレッドが終了すると、別の呼び出しでは再開できません`Start`です。"
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドは既に開始されています。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "このスレッドを開始するのに十分なメモリがありません。"
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "により、オペレーティング システムに現在のインスタンスの状態を変更する<xref href=&quot;System.Threading.ThreadState&quot;> </xref>、し、必要に応じて、スレッドが実行するメソッドによって使用されるデータを格納しているオブジェクトを提供します。"
  remarks: "スレッドが、<xref:System.Threading.ThreadState?displayProperty=fullName>状態にある場合、オペレーティング システムを使用すると実行をスケジュールできます</xref:System.Threading.ThreadState?displayProperty=fullName>。 によって表されるメソッドの最初の行で実行するスレッドを開始、<xref:System.Threading.ThreadStart>または<xref:System.Threading.ParameterizedThreadStart>スレッド コンス トラクターに渡されるデリゲート</xref:System.Threading.ParameterizedThreadStart></xref:System.Threading.ThreadStart>。 開始への呼び出しで、呼び出し元スレッドをブロックしないことに注意してください。       スレッドが終了すると、別の呼び出しでは再開できません`Start`です。       このオーバー ロードおよび<xref:System.Threading.ParameterizedThreadStart>デリゲート簡単にデータをスレッド プロシージャに渡すは手法を使用するタイプ セーフであるため、任意のオブジェクトは、このオーバー ロードに渡すことができます</xref:System.Threading.ParameterizedThreadStart>。 データをスレッド プロシージャに渡すより堅牢な方法は、ワーカーのオブジェクトをスレッド プロシージャと、データ フィールドの両方にです。 詳細については、次を参照してください。[スレッドの作成と開始時にデータを渡す](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "メソッドによって使用されるデータを格納しているオブジェクトのスレッドを実行します。"
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドは既に開始されています。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "このスレッドを開始するのに十分なメモリがありません。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "このスレッドが使用して作成された、 <xref href=&quot;System.Threading.ThreadStart&quot;> </xref>デリゲートの代わりに、 <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref>を委任します。"
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "スレッドを中断しますか、スレッドが既に中断されている場合も何も起こりません。"
  remarks: "スレッドが既に中断されている場合は、このメソッドに効果がありません。      > [!CAUTION] > サスペンドを使用しないと<xref:System.Threading.Thread.Resume%2A>スレッドの活動を同期する方法</xref:System.Threading.Thread.Resume%2A>。 中断した場合に実行されているコードのスレッドを知ることがあるありません。 その他のスレッドでのセキュリティ権限の評価中にロックを保持しているスレッドを中断した場合、<xref:System.AppDomain>ブロックされる可能性があります</xref:System.AppDomain>。 その他のスレッドでのクラスのコンス トラクターの実行中にスレッドを中断した場合、<xref:System.AppDomain>クラスがブロックされていることを使用しようとする</xref:System.AppDomain>。 デッドロックは、非常に簡単に発生することができます。"
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドは、開始されていないか、停止します。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼び出し元は、適切なありません<xref href=&quot;System.Security.Permissions.SecurityPermission&quot;></xref>です。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "一連の名前を対応する一連のディスパッチ識別子にマップします。"
  remarks: "このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。"
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "将来の使用のために予約されています。 Iid_ にする必要があります。"
    - id: rgszNames
      type: System.IntPtr
      description: "渡された配列名をマップできるのです。"
    - id: cNames
      type: System.UInt32
      description: "マップする、名前の数。"
    - id: lcid
      type: System.UInt32
      description: "名前を解釈するロケール コンテキスト。"
    - id: rgDispId
      type: System.IntPtr
      description: "名前に対応する Id を受け取る、呼び出し元が割り当てた配列。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM を使用して遅延バインディング アクセス`IDispatch`インターフェイスはサポートされていません。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "インターフェイスの型情報を取得するために使用するオブジェクトの型情報を取得します。"
  remarks: "このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。"
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "返される型情報。"
    - id: lcid
      type: System.UInt32
      description: "型情報のロケールの識別子です。"
    - id: ppTInfo
      type: System.IntPtr
      description: "要求された型情報オブジェクトへのポインターを受け取ります。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM を使用して遅延バインディング アクセス`IDispatch`インターフェイスはサポートされていません。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "オブジェクトが (0 または 1) を提供する型情報インターフェイスの数を取得します。"
  remarks: "このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。"
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "オブジェクトによって提供される型情報インターフェイスの数を受け取る場所へのポインター。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM を使用して遅延バインディング アクセス`IDispatch`インターフェイスはサポートされていません。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "プロパティとオブジェクトによって公開されたメソッドへのアクセスを提供します。"
  remarks: "このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。"
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "メンバーを識別します。"
    - id: riid
      type: System.Guid
      description: "将来の使用のために予約されています。 Iid_ にする必要があります。"
    - id: lcid
      type: System.UInt32
      description: "引数を解釈する対象のロケール コンテキスト。"
    - id: wFlags
      type: System.Int16
      description: "呼び出しのコンテキストを記述するフラグ。"
    - id: pDispParams
      type: System.IntPtr
      description: "引数の配列、名前付き引数、および各配列内の要素の数のカウントの引数 Dispid の配列を含む構造体へのポインター。"
    - id: pVarResult
      type: System.IntPtr
      description: "結果が格納される場所へのポインター。"
    - id: pExcepInfo
      type: System.IntPtr
      description: "例外情報を格納する構造体へのポインター。"
    - id: puArgErr
      type: System.IntPtr
      description: "エラーが発生した最初の引数のインデックス。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "COM を使用して遅延バインディング アクセス`IDispatch`インターフェイスはサポートされていません。"
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のスレッドの状態を示す値を取得します。"
  remarks: "ThreadState プロパティよりも詳細な情報を提供する、<xref:System.Threading.Thread.IsAlive%2A>プロパティ</xref:System.Threading.Thread.IsAlive%2A>。      > [!IMPORTANT] > スレッドの状態は、デバッグ シナリオに必要になります。 コードは、スレッドの活動を同期するためにスレッドの状態を使用する必要がありますしないでください。"
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "1 つ、 <xref href=&quot;System.Threading.ThreadState&quot;> </xref>現在のスレッドの状態を示す値。 初期値は<xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "開始される前に、スレッドのアパートメント状態を設定します。"
  remarks: "新しいスレッドとして初期化される<xref:System.Threading.ApartmentState?displayProperty=fullName>が開始される前にそのアパートメント状態が設定されていないかどうか</xref:System.Threading.ApartmentState?displayProperty=fullName>。 スレッドを開始する前に、アパートメントの状態を設定する必要があります。      > [!NOTE] > をメイン アプリケーション スレッドが初期化される<xref:System.Threading.ApartmentState?displayProperty=fullName>既定</xref:System.Threading.ApartmentState?displayProperty=fullName>。 アプリケーションのメイン スレッドのアパートメント状態を設定する唯一の方法<xref:System.Threading.ApartmentState?displayProperty=fullName>を適用する、<xref:System.STAThreadAttribute>属性をエントリ ポイント メソッドです</xref:System.STAThreadAttribute></xref:System.Threading.ApartmentState?displayProperty=fullName>。       TrySetApartmentState メソッドと共に、<xref:System.Threading.Thread.GetApartmentState%2A>メソッドおよび<xref:System.Threading.Thread.SetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティ</xref:System.Threading.Thread.ApartmentState%2A></xref:System.Threading.Thread.SetApartmentState%2A></xref:System.Threading.Thread.GetApartmentState%2A>。"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "新しいアパートメント状態。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>アパートメント状態が設定されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>有効なアパートメント状態ではありません。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "スレッドは既に開始されています。"
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "VolatileRead と<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムでは、VolatileRead は、いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システムでは、VolatileRead 上でもと<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを VolatileRead または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A>使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子 VolatileRead または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "読み取られるフィールド。"
    return:
      type: System.Byte
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "読み取られるフィールド。"
    return:
      type: System.Double
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "読み取られるフィールド。"
    return:
      type: System.Int16
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "読み取られるフィールド。"
    return:
      type: System.Int32
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "読み取られるフィールド。"
    return:
      type: System.Int64
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "読み取られるフィールド。"
    return:
      type: System.IntPtr
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "読み取られるフィールド。"
    return:
      type: System.Object
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "読み取られるフィールド。"
    return:
      type: System.SByte
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "読み取られるフィールド。"
    return:
      type: System.Single
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "読み取られるフィールド。"
    return:
      type: System.UInt16
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "読み取られるフィールド。"
    return:
      type: System.UInt32
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "読み取られるフィールド。"
    return:
      type: System.UInt64
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "フィールドの値を読み取ります。 値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新です。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します</xref:System.Threading.Thread.VolatileRead%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "読み取られるフィールド。"
    return:
      type: System.UIntPtr
      description: "いずれかのプロセッサによってフィールドに書き込まれた最新の値。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>VolatileWrite が同期の特殊なケース用です。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで VolatileWrite はメモリの場所に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>VolatileWrite ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされずします</xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または VolatileWrite</xref:System.Threading.Thread.VolatileRead%2A> 。      > [!NOTE] > に C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または VolatileWrite</xref:System.Threading.Thread.VolatileRead%2A> 。"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "値を書き込むフィールド。"
    - id: value
      type: System.Byte
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "値を書き込むフィールド。"
    - id: value
      type: System.Double
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "値を書き込むフィールド。"
    - id: value
      type: System.Int16
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "値を書き込むフィールド。"
    - id: value
      type: System.Int32
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "値を書き込むフィールド。"
    - id: value
      type: System.Int64
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "値を書き込むフィールド。"
    - id: value
      type: System.IntPtr
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "値を書き込むフィールド。"
    - id: value
      type: System.Object
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "値を書き込むフィールド。"
    - id: value
      type: System.SByte
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "値を書き込むフィールド。"
    - id: value
      type: System.Single
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "値を書き込むフィールド。"
    - id: value
      type: System.UInt16
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "値を書き込むフィールド。"
    - id: value
      type: System.UInt32
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "値を書き込むフィールド。"
    - id: value
      type: System.UInt64
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "値を書き込みますフィールドにすぐに、値が、コンピューター内のすべてのプロセッサに表示されるようにします。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>同期の特殊な場合は</xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileRead%2A> 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します</xref:System.Threading.Monitor>。       マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します</xref:System.Threading.Thread.VolatileWrite%2A>。 これにより、プロセッサ キャッシュのフラッシュが必要です。       ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。       このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するに<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 、フィールドへのすべてのアクセスを使用する必要があります。      > [!NOTE] > で c# を使用して、`volatile`フィールド修飾子<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A>フィールドへのすべてのアクセスを使用していることを保証"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "値を書き込むフィールド。"
    - id: value
      type: System.UIntPtr
      description: "書き込む値。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "現在のプロセッサで実行する準備が整っている別のスレッドに実行を譲渡して呼び出し元のスレッドをによりします。 オペレーティング システムでは、切り替え先のスレッドを選択します。"
  remarks: "このメソッドが成功した場合、スレッドの現在のタイム スライスの残りの部分が返されます。 オペレーティング システムでは、その優先順位と実行に使用できるその他のスレッドのステータスに応じて、別のタイム スライスの呼び出し元のスレッドをスケジュールします。       応答は、呼び出し元のスレッドを実行しているプロセッサに制限されます。 プロセッサがアイドル状態または優先順位の低いスレッドが実行されている場合でも、オペレーティング システムは、別のプロセッサに実行を切り替えられません。 現在のプロセッサで実行する準備ができている他のスレッドが存在しないかどうかは、オペレーティング システムでは、実行を生成しませんし、このメソッドが戻る`false`です。       このメソッドは、ネイティブ Win32 プラットフォームを使用して呼び出し`SwitchToThread`関数。 呼び出す必要がありますプラットフォームを使用する代わりにメソッドを呼び出す、Yield プラットフォーム呼び出しのバイパスのため、ホストが要求したカスタム スレッドの動作です。"
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>オペレーティング システムによって実行を別のスレッドに切り替えられた場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
