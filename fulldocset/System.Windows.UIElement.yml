### YamlMime:ManagedReference
items:
- uid: System.Windows.UIElement
  id: UIElement
  children:
  - System.Windows.UIElement.#ctor
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.UIElement.GetUIParentCore
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MeasureCore(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnCreateAutomationPeer
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  langs:
  - csharp
  name: UIElement
  nameWithType: UIElement
  fullName: System.Windows.UIElement
  type: Class
  summary: "Ui 要素は、WPF コア レベル実装構築の基本クラス[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]要素および基本表示特性です。"
  remarks: "Ui 要素は、要素のレイアウト特性、および派生クラス仮想メソッドをオーバーライドできる、表示、要素とその子の動作要素のレイアウトに影響を与える公開の開始点を提供します。       多くの入力や要素の動作を個別に一般的には、UIElement クラスも定義されています。 これには、キーボード、マウスとスタイラス入力、および関連するステータスのプロパティのイベントが含まれます。 ルーティングされたイベントは、これらのイベントの多くは、バブル、両方のルーティングの入力に関連するイベントの多くがあるバージョンだけでなく、イベントのトンネルのバージョン。 これらのイベントのペアは、通常、コントロールの作成者に最も関心のあるイベントです。       Ui 要素も含まれています。[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]以後に、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]イベント モデルでは、指定させることができるメソッドを含む要素のインスタンスが基づいているイベントをルーティングします。       アーキテクチャとしては、ui 要素と見なすのウィンドウ ハンドルとほぼ同等[!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)]プログラミング、または要素に[!INCLUDE[TLA#tla_dhtml](~/add/includes/tlasharptla-dhtml-md.md)]プログラミングします。 Ui 要素は、WPF コア レベルでの基本要素です。       UIElement が UIElement クラスによって明示的に定義されている次の機能: の子要素としてレンダリングできます (<xref:System.Windows.Media.Visual>から派生した ui 要素高レベルのグラフィックス クラス) のサイズおよび位置情報 (レイアウト システムによって解釈される) 場合、ui 要素の使用可能な子要素を使用するロジックが含まれています - (ここで入力の送信先にイベントのルーティングの処理を使用してのコントロールを含むユーザー入力に応答できます。、やコマンドのルーティング) の要素の論理ツリー内のルートに移動するルーティング イベントを発生させることができます、アニメーション システムの一部の機能をサポートしている<xref:System.Windows.FrameworkElement>uielement、ビルドされ、WPF フレームワーク レベルの特定の相互作用を追加する WPF フレームワーク レベルの実装クラスです。</xref:System.Windows.FrameworkElement> </xref:System.Windows.Media.Visual> <xref:System.Windows.FrameworkElement>追加し、次の機能を定義します - その他のフレームワーク固有のレイアウト特性のサポート - 豊富なメタデータがレポートのプロパティ - 特定のクラスに固有の実装を基底クラスとその添付プロパティを入力または添付イベントのスタイルのサポート、さらにアニメーションをサポートして別の関連のクラスが<xref:System.Windows.ContentElement>。</xref:System.Windows.ContentElement> 。</xref:System.Windows.FrameworkElement> <xref:System.Windows.ContentElement>クラスでは同じメンバーの多くが実装される ui 要素と、これら&2; つのクラス間の違いが、意図したものでは、全体的なコンテンツ モデルに配置する必要があります</xref:System.Windows.ContentElement>。 Ui 要素の派生クラスは、通常、比較的固定コンテンツ モデルが、マークアップ内の子要素をどのような要素がありますの制限があることを意味を定義します。 容量が指定されたコンテンツのプロパティで通常集中管理されているが、UIElement で制限の緩い子コンテンツを作成することの容量がかかることがあります。 A<xref:System.Windows.ContentElement>派生クラスは通常フロー形式のドキュメントなどのシナリオをサポートするために、コンテンツに関する制限の厳しい</xref:System.Windows.ContentElement>。      > [!IMPORTANT] ><xref:System.Windows.UIElement.Visibility%2A>状態その要素ですべての入力の処理に影響します</xref:System.Windows.UIElement.Visibility%2A>。 表示されていない要素がヒット テストに参加していないと、上にマウスが境界要素がある場合でも、入力イベントを受け取りません場合に表示されていた。"
  syntax:
    content: >-
      [System.Windows.Markup.UidProperty("Uid")]

      public class UIElement : System.Windows.Media.Visual, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  implements:
  - System.Windows.IInputElement
  - System.Windows.Media.Animation.IAnimatable
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.GetVisualChild(System.Int32)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualChildrenCount
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.UIElement.#ctor
  id: '#ctor'
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: UIElement()
  nameWithType: UIElement.UIElement()
  fullName: System.Windows.UIElement.UIElement()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Windows.UIElement&quot;> </xref>クラスです。"
  remarks: "型の新しいインスタンスを作成するが、実際<xref:System.Windows.UIElement>アプリケーション コードでは一般的ではありませんので<xref:System.Windows.UIElement>は基本要素です</xref:System.Windows.UIElement></xref:System.Windows.UIElement>。 参照してください[要素の概要を基本](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public UIElement ();
    parameters: []
  overload: System.Windows.UIElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  id: AddHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AddHandler(RoutedEvent,Delegate)
  nameWithType: UIElement.AddHandler(RoutedEvent,Delegate)
  fullName: System.Windows.UIElement.AddHandler(RoutedEvent,Delegate)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "現在の要素のハンドラー コレクションにハンドラーを追加する、指定したルーティング イベントのルーティング イベント ハンドラーを追加します。"
  remarks: "例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。       通常、&quot;add&quot;アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。"
  syntax:
    content: public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "ルーティング イベントを処理するための識別子です。"
    - id: handler
      type: System.Delegate
      description: "ハンドラーの実装への参照。"
  overload: System.Windows.UIElement.AddHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  id: AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AddHandler(RoutedEvent,Delegate,Boolean)
  nameWithType: UIElement.AddHandler(RoutedEvent,Delegate,Boolean)
  fullName: System.Windows.UIElement.AddHandler(RoutedEvent,Delegate,Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "現在の要素のハンドラー コレクションにハンドラーを追加する、指定したルーティング イベントのルーティング イベント ハンドラーを追加します。 指定<code> handledEventsToo </code>として<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>イベント ルート上の別の要素によって処理されるように既にマークされているルーティング イベントのために呼び出される、指定したハンドラーがします。"
  remarks: "複雑なタスクは、実用的な方法で低レベルの入力イベントを処理します。 多くのコントロールと、特定のイベントが処理される、マークされた、別のより直観的なイベントに置き換えの動作を実装します。 一般に、これを行うための設計上の意図がある場合を処理済みとして、コントロールは、プラットフォームの入力イベントをマークだけです。 特定のシナリオでこれらの設計上の意図できない可能性があります、特定の入力イベントの処理が必要です。 これらのシナリオを登録するハンドラーの`handledEventsToo`として`true`が適切です。 実行しないでこの日常的にします。 処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベントを処理ロジックが複雑になります。 ハンドラーのロジックは大きな場合は、パフォーマンスの低下を参照してください可能性があります。 ここで、検出済みの特定のコントロールは、アプリケーション ロジックで処理するイベントを処理は、開発プロセス中にある場合の処理済みのイベントのハンドラーをアタッチの使用を予約する必要があります。       クラスの処理を特定のイベントとコントロールの組み合わせの動作を回避するためのもう&1; つの方法では、そのイベントのプレビューの代替手段を使用します。 たとえば場合、<xref:System.Windows.UIElement.MouseLeftButtonDown>処理済みとしてマークは、クラス処理によってことができますのハンドラーを追加する<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>代わりにします</xref:System.Windows.UIElement.PreviewMouseLeftButtonDown></xref:System.Windows.UIElement.MouseLeftButtonDown>。       例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。       通常、&quot;add&quot;アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。"
  example:
  - "The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`. This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.  \n  \n [!code-cs[EventOvwSupport#AddHandlerHandledToo](~/add/codesnippet/csharp/EventOvwSupport/page2.xaml.cs#addhandlerhandledtoo)]\n [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/add/codesnippet/visualbasic/eventovwsupport/page2.xaml.vb#addhandlerhandledtoo)]"
  syntax:
    content: public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "ルーティング イベントを処理するための識別子です。"
    - id: handler
      type: System.Delegate
      description: "ハンドラーの実装への参照。"
    - id: handledEventsToo
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>そのイベント データで処理されるルーティング イベントがマークされている場合でも呼び出されるようにハンドラーを登録するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>ことがない既定の条件に、ハンドラーを登録するルーティング イベントは既に設定されて処理される場合に呼び出されます。       既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。       定期的にメッセージを表示しないルーティング イベントを再処理をします。 詳細については、「解説」を参照してください。"
  overload: System.Windows.UIElement.AddHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  id: AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AddToEventRoute(EventRoute,RoutedEventArgs)
  nameWithType: UIElement.AddToEventRoute(EventRoute,RoutedEventArgs)
  fullName: System.Windows.UIElement.AddToEventRoute(EventRoute,RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "指定したハンドラーを追加する<xref href=&quot;System.Windows.EventRoute&quot;></xref>現在の<xref href=&quot;System.Windows.UIElement&quot;></xref>イベント ハンドラーのコレクション。"
  remarks: "このメソッドは、コンテンツ ホスト要素で使用できます (いずれかを実装するもの<xref:System.Windows.IContentHost>またはいない場合は) <xref:System.Windows.EventRoute>.</xref:System.Windows.EventRoute>に子要素のハンドラーを追加する</xref:System.Windows.IContentHost> 通常、これは必要ありませんの<xref:System.Windows.UIElement>、ハンドラーが完了した論理ツリー内で見つかったすべての要素を自動的に追加します</xref:System.Windows.UIElement>。 ただし、いくつかのケースでは、ここで<xref:System.Windows.ContentElement>と<xref:System.Windows.UIElement>が混在しているルートに追加するテンプレートの必要性から得られた要素の介在するテンプレートのツリー内</xref:System.Windows.UIElement></xref:System.Windows.ContentElement>。 両方<xref:System.Windows.ContentElement>と<xref:System.Windows.UIElement>このメソッドのバージョンをサポートします</xref:System.Windows.UIElement></xref:System.Windows.ContentElement>。"
  syntax:
    content: public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);
    parameters:
    - id: route
      type: System.Windows.EventRoute
      description: "イベント ルート ハンドラーに追加されます。"
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "イベントのデータ ハンドラーを追加するために使用されます。 このメソッドを使用して、<xref:System.Windows.RoutedEventArgs.RoutedEvent*>ハンドラーを作成するイベント データのプロパティ</xref:System.Windows.RoutedEventArgs.RoutedEvent*>。"
  overload: System.Windows.UIElement.AddToEventRoute*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AllowDrop
  id: AllowDrop
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AllowDrop
  nameWithType: UIElement.AllowDrop
  fullName: System.Windows.UIElement.AllowDrop
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素をドラッグ アンド ドロップ操作の対象として使用できるかどうかを示す値を設定します。  これは、依存関係プロパティです。"
  remarks: "ドラッグ アンド ドロップ操作が既定では、無効になってし、AllowDrop に設定して意図的に有効にする必要があります`true`です。 この基本的な設定を超えるドラッグ アンド ドロップの動作は完全に特定の実装、<xref:System.Windows.UIElement>またはその他の要素の基本クラス</xref:System.Windows.UIElement>によって定義されていません。 たとえば、特定のコントロール<xref:System.Windows.Controls.RichTextBox>、既定の動作を持っています</xref:System.Windows.Controls.RichTextBox>。 ドラッグ アンド ドロップの詳細については、次を参照してください。[ドラッグ アンド ドロップの概要](~/add/includes/ajax-current-ext-md.md)です。       <xref:System.Windows.FrameworkElement>実装では、この依存関係プロパティのメタデータをオーバーライドします。</xref:System.Windows.FrameworkElement> 具体的には、<xref:System.Windows.FrameworkElement>プロパティ値の継承を有効にするには、このプロパティを指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータで).</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement> このコンテキストでプロパティ値の継承は、ある値を持たない他のローカル値またはスタイルを使用して割り当てる AllowDrop の子要素がある場合は、し、この値は割り当てられます (ここでものいずれか既定値、またはローカルの値、スタイル)、最も近い親要素の値、親要素から値に割り当てられるすべての以前の未使用の子要素プロパティ システムによってを意味します。 実際にはつまり、ルート要素でドロップ操作を許可するかどうかを指定することができます、として割り当てられている値は、特にされているすべての子要素に反映されます`false`です。      <a name=&quot;dependencyPropertyInfo_AllowDrop&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.AllowDropProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.AllowDropProperty>"
  example:
  - "The following markup example sets the AllowDrop property `true` using an attribute on a <xref:System.Windows.Controls.TextBox>, as well as setting some other related properties that in aggregate enable that <xref:System.Windows.Controls.TextBox> to be the target of a multiline text data object when it is dragged in. For the complete sample, see [Load a Dropped File Sample](http://msdn.microsoft.com/en-us/be90d645-dd61-4f53-93bb-87902d086ef7).  \n  \n [!code-xml[DragDrop_DropOpenTextFile#UIElementAllowDrop](~/add/codesnippet/xaml/dropopentextfile/window1.xaml#uielementallowdrop)]"
  syntax:
    content: public bool AllowDrop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素をドラッグ アンド ドロップ操作のターゲットとして使用できる場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.AllowDrop*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AllowDropProperty
  id: AllowDropProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AllowDropProperty
  nameWithType: UIElement.AllowDropProperty
  fullName: System.Windows.UIElement.AllowDropProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.AllowDrop*>依存関係プロパティ</xref:System.Windows.UIElement.AllowDrop*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AllowDropProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素で指定した依存関係プロパティをアニメーションを適用します。 既存のアニメーションが停止され、新しいアニメーションに置き換えられます。"
  remarks: "アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。 これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 その他のクロックに割り当てられているアニメーションを実行し続けます。"
  example:
  - "In the following example, a <xref:System.Windows.Shapes.Rectangle> `myAnimatedRectangle` has a particular timing animation applied to it by calling ApplyAnimationClock .  \n  \n [!code-cs[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/add/codesnippet/csharp/TimingBehavior_csharp/ClockControllerSpeedRatioExample.cs#uielementapplyanimationclock)]\n [!code-vb[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/add/codesnippet/visualbasic/timingbehavior_vb/clockcontrollerspeedratioexample.vb#uielementapplyanimationclock)]"
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "アニメーション化するプロパティの識別子。"
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "コントロールして宣言するアニメーション クロック。"
  overload: System.Windows.UIElement.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素で指定した依存関係プロパティをアニメーションを適用、対処方法を指定することはどうプロパティは既に実行中のアニメーション。"
  remarks: "アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。 これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 その他のクロックに割り当てられているアニメーションを実行し続けます。"
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "アニメーション化するプロパティです。"
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "コントロールして宣言するアニメーション クロック。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "列挙体の値です。 既定値は<xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref>、する既存のアニメーションを停止し、新しいものに置き換えます。"
  overload: System.Windows.UIElement.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesCaptured
  id: AreAnyTouchesCaptured
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesCaptured
  nameWithType: UIElement.AreAnyTouchesCaptured
  fullName: System.Windows.UIElement.AreAnyTouchesCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に、少なくとも&1; つのタッチがキャプチャされるかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesCaptured { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>タッチを少なくとも&1; つがキャプチャされます。 この要素にそれ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.AreAnyTouchesCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesCapturedProperty
  id: AreAnyTouchesCapturedProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesCapturedProperty
  nameWithType: UIElement.AreAnyTouchesCapturedProperty
  fullName: System.Windows.UIElement.AreAnyTouchesCapturedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.AreAnyTouchesCaptured*>依存関係プロパティ</xref:System.Windows.UIElement.AreAnyTouchesCaptured*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesCapturedWithin
  id: AreAnyTouchesCapturedWithin
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesCapturedWithin
  nameWithType: UIElement.AreAnyTouchesCapturedWithin
  fullName: System.Windows.UIElement.AreAnyTouchesCapturedWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素またはそのビジュアル ツリー内のすべての子要素には、少なくとも&1; つのタッチがキャプチャされるかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesCapturedWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>少なくとも&1; つにタッチがキャプチャをこの要素またはそのビジュアル ツリー内のすべての子要素それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.AreAnyTouchesCapturedWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  id: AreAnyTouchesCapturedWithinProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesCapturedWithinProperty
  nameWithType: UIElement.AreAnyTouchesCapturedWithinProperty
  fullName: System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.AreAnyTouchesCapturedWithin*>依存関係プロパティ</xref:System.Windows.UIElement.AreAnyTouchesCapturedWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesDirectlyOver
  id: AreAnyTouchesDirectlyOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesDirectlyOver
  nameWithType: UIElement.AreAnyTouchesDirectlyOver
  fullName: System.Windows.UIElement.AreAnyTouchesDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上には、少なくとも&1; つのタッチが押されたかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesDirectlyOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素上には、少なくとも&1; つのタッチが押された場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.AreAnyTouchesDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  id: AreAnyTouchesDirectlyOverProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesDirectlyOverProperty
  nameWithType: UIElement.AreAnyTouchesDirectlyOverProperty
  fullName: System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.AreAnyTouchesDirectlyOver*>依存関係プロパティ</xref:System.Windows.UIElement.AreAnyTouchesDirectlyOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesOver
  id: AreAnyTouchesOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesOver
  nameWithType: UIElement.AreAnyTouchesOver
  fullName: System.Windows.UIElement.AreAnyTouchesOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも&1; つのタッチが押されたかどうかを示す値を取得します。"
  syntax:
    content: public bool AreAnyTouchesOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素またはそのビジュアル ツリー内のすべての子要素の上には、少なくとも&1; つのタッチが押された場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.AreAnyTouchesOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.AreAnyTouchesOverProperty
  id: AreAnyTouchesOverProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: AreAnyTouchesOverProperty
  nameWithType: UIElement.AreAnyTouchesOverProperty
  fullName: System.Windows.UIElement.AreAnyTouchesOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.AreAnyTouchesOver*>依存関係プロパティ</xref:System.Windows.UIElement.AreAnyTouchesOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Arrange(System.Windows.Rect)
  id: Arrange(System.Windows.Rect)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Arrange(Rect)
  nameWithType: UIElement.Arrange(Rect)
  fullName: System.Windows.UIElement.Arrange(Rect)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "子要素を配置しのサイズを決定する<xref href=&quot;System.Windows.UIElement&quot;></xref>です。 親要素からこのメソッドを呼び出して、<xref:System.Windows.UIElement.ArrangeCore*>実装 (または WPF フレームワーク レベルの同等) を再帰的なレイアウトの更新を形成します</xref:System.Windows.UIElement.ArrangeCore*>。 このメソッドは、レイアウト更新の&2; 番目のパスを構成します。"
  remarks: "WPF フレームワーク レベルの要素が派生シナリオ、配置の動作しないように (およびできません、シャドウする場合を除き) 変更。 代わりに、 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>、クラスの実装</xref:System.Windows.FrameworkElement.ArrangeOverride%2A>をオーバーライドする必要があります。 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>実装配置によって既定の WPF フレームワーク レベルのレイアウトの操作の一部としては、内部的に呼び出さ</xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。 <xref:System.Windows.UIElement.ArrangeCore%2A>実装を呼び出す必要がありますも<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>子要素がある場合、各子要素です</xref:System.Windows.FrameworkElement.ArrangeOverride%2A></xref:System.Windows.UIElement.ArrangeCore%2A>。       WPF コア レベルの要素が派生シナリオ、配置の動作しないように (およびできません、シャドウする場合を除き) 変更。 代わりに<xref:System.Windows.UIElement.ArrangeCore%2A>、クラスで</xref:System.Windows.UIElement.ArrangeCore%2A>オーバーライドする必要があります。 <xref:System.Windows.UIElement.ArrangeCore%2A>実装配置によって既定の WPF フレームワーク レベルのレイアウトの操作の一部としては、内部的に呼び出さ</xref:System.Windows.UIElement.ArrangeCore%2A>。 ただし、この前提としています WPF フレームワーク レベルのレイアウトとは多くの場合、ない場合、<xref:System.Windows.UIElement>要素の基本クラス</xref:System.Windows.UIElement>から WPF コア レベルにある要素を具体的には派生する場合、レイアウト システムを使用しています。 <xref:System.Windows.UIElement.ArrangeCore%2A>実装も、子要素がある場合、各子要素の配置を呼び出す必要があります</xref:System.Windows.UIElement.ArrangeCore%2A>。 注 WPF コア レベルのシナリオは、使用しないことを意味する<xref:System.Windows.FrameworkElement>ために、派生クラスに<xref:System.Windows.FrameworkElement>シール<xref:System.Windows.FrameworkElement.ArrangeCore%2A>.</xref:System.Windows.FrameworkElement.ArrangeCore%2A> </xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement>       WPF フレームワーク レベルのレイアウトの配置の計算[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]から成る、<xref:System.Windows.UIElement.Measure%2A>配置呼び出しと呼び出し</xref:System.Windows.UIElement.Measure%2A>。 中に、<xref:System.Windows.UIElement.Measure%2A>呼び出し、レイアウト システムが提供されたを使用して要素のサイズ要件を決定する<xref:System.Windows.Size>(`availableSize`) 引数</xref:System.Windows.Size></xref:System.Windows.UIElement.Measure%2A>。 配置の呼び出し中には、レイアウト システムは、要素の境界ボックスの位置とサイズを終了します。  詳細については、次を参照してください。[レイアウト](~/add/includes/ajax-current-ext-md.md)です。       `availableSize`0 から無限大までの任意の数を指定できます。 要素をレイアウトするのには、最小値を返す<xref:System.Windows.Size>を必要とする、`availableSize`パラメーター</xref:System.Windows.Size> 。       常に受信レイアウトが最初にインスタンス化されるとき、<xref:System.Windows.UIElement.Measure%2A>配置する前に呼び出します</xref:System.Windows.UIElement.Measure%2A>。 ただし、最初のレイアウト パスの後にそのことがあります配置の呼び出しを受信せず、<xref:System.Windows.UIElement.Measure%2A>これは、(などの配置)、配置のみに影響するプロパティが変更されたとき、または親受信<xref:System.Windows.UIElement.Measure%2A>。</xref:System.Windows.UIElement.Measure%2A>せず、配置に発生することができます。</xref:System.Windows.UIElement.Measure%2A> A<xref:System.Windows.UIElement.Measure%2A>呼び出しは、配置の呼び出しを自動的に無効にします</xref:System.Windows.UIElement.Measure%2A>。       レイアウトの更新は、通常、非同期的に (レイアウト システムによって決定時) に発生します。 要素は要素のサイズ設定に影響を与えるプロパティの変更をすぐに反映されない可能性があります (など<xref:System.Windows.FrameworkElement.Width%2A>).</xref:System.Windows.FrameworkElement.Width%2A>      > [!NOTE] > を使用してレイアウトの更新を強制することができます、<xref:System.Windows.UIElement.UpdateLayout%2A>メソッドですただし、この関数を呼び出すことは推奨されていません、通常は必要であり、パフォーマンスの低下が発生することができます。</xref:System.Windows.UIElement.UpdateLayout%2A> 。 多くの状況で呼び出して、<xref:System.Windows.UIElement.UpdateLayout%2A>適切な場合があります、レイアウト システムおそらく既に処理する更新プログラム</xref:System.Windows.UIElement.UpdateLayout%2A>。 レイアウト システムは、パッケージの一部としてすべての必要な更新プログラムを最適化する方法のレイアウトの変更を処理できます。       レイアウト システムは無効なレイアウトのいずれかの&2; つの異なるキュー<xref:System.Windows.UIElement.Measure%2A>と配置の&1; つ</xref:System.Windows.UIElement.Measure%2A>。 レイアウトのキューは、ビジュアル ツリー内の要素の順序に基づいて並べ替えられます。 ツリーの上位の要素は、親の変更を繰り返すことによって、冗長なレイアウトを回避するために、キューの上部にあるがします。 重複するエントリは、キューから自動的に削除されが既に有効である要素も、キューから自動的に削除します。       レイアウトを更新するときに、<xref:System.Windows.UIElement.Measure%2A>キューが空に最初に、配置キュー続く</xref:System.Windows.UIElement.Measure%2A>。 内の要素がある場合、配置キュー内の要素を配置しないされます、<xref:System.Windows.UIElement.Measure%2A>キュー</xref:System.Windows.UIElement.Measure%2A> 。"
  syntax:
    content: public void Arrange (System.Windows.Rect finalRect);
    parameters:
    - id: finalRect
      type: System.Windows.Rect
      description: "親として指定された、子要素に対して計算される最終的なサイズ、 <xref href=&quot;System.Windows.Rect&quot;> </xref>インスタンス。"
  overload: System.Windows.UIElement.Arrange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ArrangeCore(System.Windows.Rect)
  id: ArrangeCore(System.Windows.Rect)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ArrangeCore(Rect)
  nameWithType: UIElement.ArrangeCore(Rect)
  fullName: System.Windows.UIElement.ArrangeCore(Rect)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "WPF コア レベルの配置レイアウト定義のテンプレートを定義します。"
  remarks: >-
    > [!NOTE]

    >  Overriding this method is only appropriate if you are deriving at the WPF core-level, and you are not using the WPF framework-level layout system and <xref:System.Windows.FrameworkElement> derived class, because <xref:System.Windows.FrameworkElement> seals <xref:System.Windows.FrameworkElement.ArrangeCore%2A>. If you are using the WPF framework-level layout system, the appropriate method to override for class-specific layout arrange behavior is <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.
  example:
  - "ArrangeCore implementations should call the base implementation to return a size, then call the <xref:System.Windows.UIElement.Arrange%2A> method of each visible child element, and reconcile the sizes returned by these <xref:System.Windows.UIElement.Arrange%2A> calls with the size of the base implementation. The logic for the reconciliation aspect of a ArrangeCore implementation might vary, depending on the layout characteristics of your element. In the following example template, `VisualChildren` is a hypothetical property that your element might define to help enumerate its content; <xref:System.Windows.UIElement> does not define content collections at this level, the WPF framework-level architecture defers content behavior to derived elements such as specific controls or control base classes.  \n  \n [!code-cs[CorePseudocode#UIElementArrangeOverride](~/add/codesnippet/csharp/CorePseudocode/corepseudocode.cs#uielementarrangeoverride)]\n [!code-vb[CorePseudocode#UIElementArrangeOverride](~/add/codesnippet/visualbasic/corepseudocode/corepseudocode.vb#uielementarrangeoverride)]"
  syntax:
    content: protected virtual void ArrangeCore (System.Windows.Rect finalRect);
    parameters:
    - id: finalRect
      type: System.Windows.Rect
      description: "その要素の親の末尾の領域自体とその子要素を配置に使用してください。"
  overload: System.Windows.UIElement.ArrangeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: UIElement.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.UIElement.BeginAnimation(DependencyProperty,AnimationTimeline)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素で指定したプロパティのアニメーションを開始します。"
  remarks: "プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。       場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されている</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>。       場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 タイムラインに割り当てられているその他のアニメーションを実行し続けます。"
  example:
  - "The following example creates an animation, assigns it, and then calls BeginAnimation to start it.  \n  \n [!code-cs[timingbehaviors_procedural_snip#BeginAnimation](~/add/codesnippet/csharp/TimingBehavior_csharp/GetAnimationBaseValueExample.cs#beginanimation)]\n [!code-vb[timingbehaviors_procedural_snip#BeginAnimation](~/add/codesnippet/visualbasic/timingbehavior_vb/getanimationbasevalueexample.vb#beginanimation)]"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子として指定する、アニメーション化するプロパティです。"
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "開始するアニメーションのタイムラインになります。"
  overload: System.Windows.UIElement.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: UIElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.UIElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "新機能を指定するオプションを使用して、この要素で指定したアニメーション化されたプロパティの特定のアニメーションの場合は、プロパティは既に実行中のアニメーションを開始します。"
  remarks: "プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。       場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されている</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>。       場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 タイムラインに割り当てられているその他のアニメーションを実行し続けます。"
  example:
  - "The following example implements a handler that obtains an existing animation from a resource and then calls BeginAnimation with a specified handoff behavior.  \n  \n [!code-cs[BrushesIntroduction#BeginAnimationHandoff](~/add/codesnippet/csharp/BrushesIntroduction.BrushesIntroduction/SampleViewer.xaml.cs#beginanimationhandoff)]\n [!code-vb[BrushesIntroduction#BeginAnimationHandoff](~/add/codesnippet/visualbasic/brushesintroduction/sampleviewer.xaml.vb#beginanimationhandoff)]"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "依存関係プロパティの識別子として指定する、アニメーション化するプロパティです。"
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "適用されるアニメーションのタイムラインになります。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "新しいアニメーションがプロパティの値が既に影響を受けている現在の (実行中) アニメーションとやり取りする方法を指定する列挙体の値です。"
  overload: System.Windows.UIElement.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.BitmapEffect
  id: BitmapEffect
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: BitmapEffect
  nameWithType: UIElement.BitmapEffect
  fullName: System.Windows.UIElement.BitmapEffect
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素に描画された内容に直接適用するビットマップ効果を設定します。  これは、依存関係プロパティです。"
  remarks: "<xref:System.Windows.Media.Effects.BitmapEffect>そのため、抽象型は、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]使用状況の実装の派生クラスを必要と<xref:System.Windows.Media.Effects.BitmapEffect>、 <xref:System.Windows.Media.Effects.OuterGlowBitmapEffect>.</xref:System.Windows.Media.Effects.OuterGlowBitmapEffect>など</xref:System.Windows.Media.Effects.BitmapEffect></xref:System.Windows.Media.Effects.BitmapEffect> 派生したクラスが実装されている&1; つはシーケンシャルを使用すると、複数のいずれかを指定するコレクション型<xref:System.Windows.Media.Effects.BitmapEffect>、入れ子になったタグの構文を使用します</xref:System.Windows.Media.Effects.BitmapEffect>。       既存のクラスの派生できない<xref:System.Windows.Media.Effects.BitmapEffect>型コンバーターをサポートしているため、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]このプロパティを使用する構文は、プロパティ要素構文では、通常、</xref:System.Windows.Media.Effects.BitmapEffect> 。      <a name=&quot;dependencyPropertyInfo_BitmapEffect&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.BitmapEffectProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.BitmapEffectProperty>"
  example:
  - "The following example sets a bitmap effect, using <xref:System.Windows.Media.Effects.BlurBitmapEffect>.  \n  \n [!code-cs[EffectsGallery_snip#CodeBehindBlurCodeBehindExampleInline](~/add/codesnippet/csharp/EffectsGallery/blurcodebehindexample.xaml.cs#codebehindblurcodebehindexampleinline)]"
  syntax:
    content: public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }
    return:
      type: System.Windows.Media.Effects.BitmapEffect
      description: "適用するビットマップ効果。"
  overload: System.Windows.UIElement.BitmapEffect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.BitmapEffectInput
  id: BitmapEffectInput
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: BitmapEffectInput
  nameWithType: UIElement.BitmapEffectInput
  fullName: System.Windows.UIElement.BitmapEffectInput
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素に描画された内容に直接適用するビットマップ効果用の入力ソースを設定します。  これは、依存関係プロパティです。"
  remarks: "<a name=&quot;dependencyPropertyInfo_BitmapEffectInput&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.BitmapEffectInputProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.BitmapEffectInputProperty>"
  syntax:
    content: public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }
    return:
      type: System.Windows.Media.Effects.BitmapEffectInput
      description: "ビットマップ効果のソース。"
  overload: System.Windows.UIElement.BitmapEffectInput*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.BitmapEffectInputProperty
  id: BitmapEffectInputProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: BitmapEffectInputProperty
  nameWithType: UIElement.BitmapEffectInputProperty
  fullName: System.Windows.UIElement.BitmapEffectInputProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.BitmapEffectInput*>依存関係プロパティ</xref:System.Windows.UIElement.BitmapEffectInput*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BitmapEffectInputProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.BitmapEffectProperty
  id: BitmapEffectProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: BitmapEffectProperty
  nameWithType: UIElement.BitmapEffectProperty
  fullName: System.Windows.UIElement.BitmapEffectProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.BitmapEffect*>依存関係プロパティ</xref:System.Windows.UIElement.BitmapEffect*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BitmapEffectProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.CacheMode
  id: CacheMode
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: CacheMode
  nameWithType: UIElement.CacheMode
  fullName: System.Windows.UIElement.CacheMode
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または設定のキャッシュされた表現、 <xref href=&quot;System.Windows.UIElement&quot;></xref>です。"
  remarks: "表示するために時間がかかるがコンテンツのパフォーマンスを向上させる必要がある場合は、CacheMode プロパティを設定します。 詳細については、 <xref:System.Windows.Media.BitmapCache>。</xref:System.Windows.Media.BitmapCache>を参照してください。"
  syntax:
    content: public System.Windows.Media.CacheMode CacheMode { get; set; }
    return:
      type: System.Windows.Media.CacheMode
      description: "A <xref href=&quot;System.Windows.Media.CacheMode&quot;> </xref>のキャッシュされた表現を保持する、 <xref href=&quot;System.Windows.UIElement&quot;></xref>です。"
  overload: System.Windows.UIElement.CacheMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.CacheModeProperty
  id: CacheModeProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: CacheModeProperty
  nameWithType: UIElement.CacheModeProperty
  fullName: System.Windows.UIElement.CacheModeProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.CacheMode*>依存関係プロパティ</xref:System.Windows.UIElement.CacheMode*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CacheModeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.CaptureMouse
  id: CaptureMouse
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: CaptureMouse()
  nameWithType: UIElement.CaptureMouse()
  fullName: System.Windows.UIElement.CaptureMouse()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にマウスのキャプチャを強制しようとしています。"
  remarks: "キャプチャするのには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.UIElement.IsEnabled%2A>は`true`ことでを呼び出す前にします</xref:System.Windows.UIElement.IsEnabled%2A>。       呼び出すことで返されます場合`true`、し<xref:System.Windows.UIElement.IsMouseCaptured%2A>も`true`</xref:System.Windows.UIElement.IsMouseCaptured%2A>。       呼び出すことで返す場合`true`、<xref:System.Windows.UIElement.GotMouseCapture>と<xref:System.Windows.UIElement.IsMouseCapturedChanged>イベントが発生すると<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=fullName>ことでメソッドが呼び出された場合、要素としてデータを報告するイベントです</xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=fullName></xref:System.Windows.UIElement.IsMouseCapturedChanged></xref:System.Windows.UIElement.GotMouseCapture>。 既存のキャプチャと干渉する可能性のキャプチャを強制した場合、特にのマウスでドラッグ アンド ドロップに関連するキャプチャします。       すべての要素からマウスのキャプチャをクリアする呼び出し<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName>で、`element`として指定されたパラメーター `null`</xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName> 。"
  example:
  - "The following example implements a pair of handlers for mouse and key input combination that capture (and uncapture) the mouse and enable a special mouse mode for viewing a 3D model.  \n  \n [!code-cs[CubeAnimation#UIElementMouseCapture](~/add/codesnippet/csharp/CubeAnimation_XBAP/Trackball.cs#uielementmousecapture)]\n [!code-vb[CubeAnimation#UIElementMouseCapture](~/add/codesnippet/visualbasic/cubeanimation_xbap/trackball.vb#uielementmousecapture)]"
  syntax:
    content: public bool CaptureMouse ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マウスが正常にキャプチャされた場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.CaptureMouse*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.CaptureStylus
  id: CaptureStylus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: CaptureStylus()
  nameWithType: UIElement.CaptureStylus()
  fullName: System.Windows.UIElement.CaptureStylus()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にスタイラスのキャプチャを強制しようとしています。"
  remarks: "既定の実装を常に基になる既定のスタイラス デバイスに基づいて`true`です。 ただし、入力システムのデバイスの実装を提供する入力デバイスを拡張する場合、異なる結果を返す可能性のある代替のスタイラス デバイスの実装と、システムを作成することはできます。       要素がスタイラスをキャプチャ、ときに、スタイラスが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。       基になる静的<xref:System.Windows.Input.Stylus><xref:System.Windows.Input.Stylus.Capture%2A>。</xref:System.Windows.Input.Stylus.Capture%2A>メソッド</xref:System.Windows.Input.Stylus>を呼び出すこのメソッドを呼び出す 実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。       キャプチャするのには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.UIElement.IsEnabled%2A>は`true`CaptureStylus を呼び出す前に戻ります</xref:System.Windows.UIElement.IsEnabled%2A>。       CaptureStylus 返しますを呼び出している場合は`true`、<xref:System.Windows.UIElement.IsStylusCaptured%2A>も`true`</xref:System.Windows.UIElement.IsStylusCaptured%2A>。"
  syntax:
    content: public bool CaptureStylus ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スタイラスが正常にキャプチャされた場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.CaptureStylus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  id: CaptureTouch(System.Windows.Input.TouchDevice)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: CaptureTouch(TouchDevice)
  nameWithType: UIElement.CaptureTouch(TouchDevice)
  fullName: System.Windows.UIElement.CaptureTouch(TouchDevice)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に強制的にタッチをキャプチャしようとしています。"
  remarks: "CaptureTouch が返されます`false`場合、<xref:System.Windows.Input.TouchDevice>別の要素に現在キャプチャされています</xref:System.Windows.Input.TouchDevice>。       CaptureTouch を返す場合`true`、続いて、<xref:System.Windows.UIElement.GotTouchCapture>イベントが発生します</xref:System.Windows.UIElement.GotTouchCapture>。       解放するにはこの要素から&1; つのタッチのキャプチャを使用して、<xref:System.Windows.UIElement.ReleaseTouchCapture%2A>メソッドを解放する、タッチ デバイスを指定します</xref:System.Windows.UIElement.ReleaseTouchCapture%2A>。 解放するにはこの要素からすべての調整を使用して、<xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A>メソッド</xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A>。"
  syntax:
    content: public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);
    parameters:
    - id: touchDevice
      type: System.Windows.Input.TouchDevice
      description: "キャプチャするデバイスです。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素に指定したタッチがキャプチャされる場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.CaptureTouch*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>touchDevice</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.UIElement.Clip
  id: Clip
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Clip
  nameWithType: UIElement.Clip
  fullName: System.Windows.UIElement.Clip
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または要素の内容の輪郭の定義に使用されるジオメトリを設定します。  これは、依存関係プロパティです。"
  remarks: "ジオメトリ外側にある要素は、レンダリングされたレイアウトで視覚的にクリッピングされます。 ジオメトリを四角形にする必要はありません。      <a name=&quot;dependencyPropertyInfo_Clip&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ClipProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.ClipProperty>"
  example:
  - "This example shows how to define a framework element'sClipregion. To define a clip, use a <xref:System.Windows.Media.Geometry> (for example, an <xref:System.Windows.Media.EllipseGeometry>to set the element's Clipproperty. Only the area that is within the region of the geometry will be visible.  \n  \n The following example shows an <xref:System.Windows.Controls.Image>element without a defined clip region. Because no clip region is defined, the entire image is displayed.  \n  \n [!code-xml[ClipPathExample#2](~/add/codesnippet/xaml/ClipPathExample/ClipExample.xaml#2)]  \n  \n ![An object before applying a clip region](~/add/media/mil-task-clip-region-noclip.png \"An object before applying a clip region\")  \nImage with No Clip Region  \n  \n In the next example, an identical Image is created, except that it has a defined clip region. Only the part of the image that is within the area the <xref:System.Windows.Media.EllipseGeometry>will be displayed.  \n  \n [!code-xml[ClipPathExample#4](~/add/codesnippet/xaml/ClipPathExample/ClipExample.xaml#4)]  \n  \n ![A clipped object](~/add/media/mil-task-clip-region-ellispe.PNG \"A clipped object\")  \nImage with an Elliptical Clip Region  \n  \n The following example shows how animate a framework element's Clip region. In this example, an <xref:System.Windows.Media.EllipseGeometry> is used to define an elliptical clip region for an <xref:System.Windows.Controls.Image> element. A <xref:System.Windows.Media.Animation.PointAnimation> animates the ellipse geometry's <xref:System.Windows.Media.EllipseGeometry.Center%2A> property from (0, 0) to (200, 150). The animation starts playing after the image is loaded and repeats indefinitely.  \n  \n [!code-xml[ClipPathExample#5](~/add/codesnippet/xaml/ClipPathExample/ClipExample.xaml#5)]  \n  \n For the full sample, see the [Clip Region Sample](http://msdn.microsoft.com/en-us/83043a0b-f824-445f-9675-103280c5ca67)."
  syntax:
    content: public System.Windows.Media.Geometry Clip { get; set; }
    return:
      type: System.Windows.Media.Geometry
      description: "クリッピング領域のサイズ設定に使用するジオメトリ。 既定値は null <xref href=&quot;System.Windows.Media.Geometry&quot;></xref>です。"
  overload: System.Windows.UIElement.Clip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ClipProperty
  id: ClipProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ClipProperty
  nameWithType: UIElement.ClipProperty
  fullName: System.Windows.UIElement.ClipProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.Clip*>依存関係プロパティ</xref:System.Windows.UIElement.Clip*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ClipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ClipToBounds
  id: ClipToBounds
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ClipToBounds
  nameWithType: UIElement.ClipToBounds
  fullName: System.Windows.UIElement.ClipToBounds
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはコンテナーの要素のサイズに収まるようにこの要素 (またはこの要素の子要素) のコンテンツをクリップするかどうかを示す値を設定します。   これは、依存関係プロパティです。"
  remarks: "子要素、ClipToBounds があるかどうか、親要素の幅と高さはされているによって決まりますによってレイアウト動作にさまざまな影響<xref:System.Windows.FrameworkElement.Height%2A>/<xref:System.Windows.FrameworkElement.Width%2A>または<xref:System.Windows.FrameworkElement.MaxHeight%2A>/ <xref:System.Windows.FrameworkElement.MaxWidth%2A>.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.FrameworkElement.MaxHeight%2A>/<xref:System.Windows.FrameworkElement.MaxWidth%2A>親の要素が常に守られて ClipToBounds の値に関係なく、効果的な領域はこれらの最大値に基づいて、コンテンツをクリップします常にします。</xref:System.Windows.FrameworkElement.MaxWidth%2A> 。</xref:System.Windows.FrameworkElement.MaxHeight%2A> 親の<xref:System.Windows.FrameworkElement.Height%2A>/ <xref:System.Windows.FrameworkElement.Width%2A>ClipToBounds は、ときに、設定に、コンテンツはクリップされません`false`、ClipToBounds は場合、コンテンツがクリップされますが、 `true`</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A> 。       その既定値に注意してください`false`<xref:System.Windows.UIElement>クラス</xref:System.Windows.UIElement>に実装されている一般的な動作は、 派生した任意の要素のことが<xref:System.Windows.UIElement>このプロパティに既定値には、そのインスタンス内の依存関係プロパティのメタデータをオーバーライドする`true`代わりにします</xref:System.Windows.UIElement>。 いくつかの既存の派生クラスでは、このメタデータをオーバーライドまたは依存関係プロパティの既定値を調整します。       <xref:System.Windows.Controls.InkCanvas>、 <xref:System.Windows.Controls.InkPresenter>、および<xref:System.Windows.Controls.Primitives.Popup>既定値をそれぞれオーバーライド`true`。</xref:System.Windows.Controls.Primitives.Popup> </xref:System.Windows.Controls.InkPresenter></xref:System.Windows.Controls.InkCanvas>       <xref:System.Windows.FrameworkElement>この依存関係プロパティのメタデータをオーバーライドします。</xref:System.Windows.FrameworkElement> 具体的には、<xref:System.Windows.FrameworkElement>プロパティ値の継承を有効にするには、このプロパティを指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータで).</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement> このコンテキストでプロパティ値の継承は、値を持たない他のローカル値またはスタイルを使用して割り当てる ClipToBounds の子要素がある場合は、この値を持つ最も近い親要素の値割り当てられていることを意味 (スタイルは、既定値のいずれか、またはローカル値)、プロパティ システムによって、すべての未使用の子要素に親要素から値が割り当てられる、します。 実際にはつまり、ルート要素の境界にクリップを許可するかどうかを指定することができます、として割り当てられている値は、特にされているすべての子要素に反映されます`false`です。      <a name=&quot;dependencyPropertyInfo_ClipToBounds&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ClipToBoundsProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.ClipToBoundsProperty>"
  syntax:
    content: public bool ClipToBounds { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、コンテンツをクリップする必要があります。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.ClipToBounds*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ClipToBoundsProperty
  id: ClipToBoundsProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ClipToBoundsProperty
  nameWithType: UIElement.ClipToBoundsProperty
  fullName: System.Windows.UIElement.ClipToBoundsProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.ClipToBounds*>依存関係プロパティ</xref:System.Windows.UIElement.ClipToBounds*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ClipToBoundsProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.CommandBindings
  id: CommandBindings
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: CommandBindings
  nameWithType: UIElement.CommandBindings
  fullName: System.Windows.UIElement.CommandBindings
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "コレクションを取得<xref href=&quot;System.Windows.Input.CommandBinding&quot;></xref>この要素に関連付けられているオブジェクト。 A <xref href=&quot;System.Windows.Input.CommandBinding&quot;> </xref>この要素のコマンドの処理を有効にし、コマンド、そのイベントでは、この要素にアタッチされたハンドラー間のリンケージが宣言されます。"
  remarks: "踏み込んで言うとコレクションを設定するもう&1; つの一般的な方法を使用して<xref:System.Windows.Input.CommandManager>メソッド プログラムによって</xref:System.Windows.Input.CommandManager>。      <a name=&quot;xamlPropertyElementUsage_CommandBindings&quot;></a>## XAML プロパティ要素の使用```   <object>     <object.CommandBindings>       oneOrMoreCommandBindings     </object.CommandBindings>   </object>   ``` <a name=&quot;xamlValues_CommandBindings&quot;> </a> ## XAML 値*oneOrMoreCommandBindings*&1; つまたは複数<xref:System.Windows.Input.CommandBinding>要素</xref:System.Windows.Input.CommandBinding>。       これらの各が必要、<xref:System.Windows.Input.CommandBinding.Command%2A>既知のコマンドに属性が設定され、に対して属性が設定、<xref:System.Windows.Input.CommandBinding.CanExecute>と<xref:System.Windows.Input.CommandBinding.Executed>ハンドラーの実装</xref:System.Windows.Input.CommandBinding.Executed></xref:System.Windows.Input.CommandBinding.CanExecute></xref:System.Windows.Input.CommandBinding.Command%2A>。 詳細については、 <xref:System.Windows.Input.CommandBinding>。</xref:System.Windows.Input.CommandBinding>を参照してください。"
  example:
  - "The following example adds a <xref:System.Windows.Input.CommandBinding> to a window using markup. Note that in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], the <xref:System.Windows.Input.CommandBindingCollection> is not declared in the markup as an element; the collection object is inferred by the type that the property takes, and you populate the property element with one or more <xref:System.Windows.Input.CommandBinding> elements:  \n  \n [!code-xml[commandWithHandler#CommandHandlerCommandBinding](~/add/codesnippet/xaml/commandWithHandler/Window1.xaml#commandhandlercommandbinding)]  \n  \n For more information about the [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax for collections, see [XAML Syntax In Detail](~/add/includes/ajax-current-ext-md.md).  \n  \n The following example does essentially the same thing in code:  \n  \n [!code-cs[CommandHandlerProcedural#CommandHandlerBindingInit](~/add/codesnippet/csharp/CommandHandlerProcedural/Window1.xaml.cs#commandhandlerbindinginit)]\n [!code-vb[CommandHandlerProcedural#CommandHandlerBindingInit](~/add/codesnippet/visualbasic/commandhandlerprocedural/window1.xaml.vb#commandhandlerbindinginit)]"
  syntax:
    content: public System.Windows.Input.CommandBindingCollection CommandBindings { get; }
    return:
      type: System.Windows.Input.CommandBindingCollection
      description: "すべてのコレクション<xref href=&quot;System.Windows.Input.CommandBinding&quot;></xref>オブジェクト。"
  overload: System.Windows.UIElement.CommandBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DesiredSize
  id: DesiredSize
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DesiredSize
  nameWithType: UIElement.DesiredSize
  fullName: System.Windows.UIElement.DesiredSize
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素が測定パス レイアウト処理の中に計算されたサイズを取得します。"
  remarks: "場合は、このプロパティによって返される値に有効な測定にのみの値、<xref:System.Windows.UIElement.IsMeasureValid%2A>プロパティは`true`</xref:System.Windows.UIElement.IsMeasureValid%2A>。       レイアウトの動作を実装するときに測定要因の&1; つをオーバーライドなど、DesiredSize がチェック通常<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>、 <xref:System.Windows.FrameworkElement.MeasureOverride%2A>、または<xref:System.Windows.UIElement.OnRender%2A>(で、<xref:System.Windows.UIElement.OnRender%2A>大文字と小文字、チェックする可能性があります<xref:System.Windows.UIElement.RenderSize%2A>代わりに、実装によって異なりますが、).</xref:System.Windows.UIElement.RenderSize%2A> </xref:System.Windows.UIElement.OnRender%2A> </xref:System.Windows.UIElement.OnRender%2A> </xref:System.Windows.FrameworkElement.MeasureOverride%2A> </xref:System.Windows.FrameworkElement.ArrangeOverride%2A> シナリオによって実装ロジックによって、DesiredSize を完全に遵守する可能性があります、DesiredSize に対する制約を適用することが、このような制約も変更されていたり親要素または子要素のいずれかの他の特性。 たとえば、コントロールをスクロール可能な領域をサポートしています (ただし、スクロール可能な領域を既に有効にする WPF フレームワーク レベル コントロールから派生していないことを選択) は、DesiredSize に利用可能なサイズを比較することもします。 コントロールのスクロール バーを有効になっている内部の状態を設定し、でした、[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]を制御するためです。 または、DesiredSize が可能性がある可能性がありますも特定のシナリオでは無視されます。"
  example:
  - "The following example shows DesiredSize as part of a <xref:System.Windows.FrameworkElement.MeasureOverride%2A> implementation. Notice how <xref:System.Windows.UIElement.Measure%2A> is called immediately prior to obtaining DesiredSize. This assures that DesiredSize holds a legitimate value.  \n  \n [!code-cs[PlotPanel#2](~/add/codesnippet/csharp/PlotPanel_csharp/PlotPanel.cs#2)]\n [!code-cpp[PlotPanel#2](~/add/codesnippet/cpp/plotpanel/PlotPanel.cpp#2)]\n [!code-vb[PlotPanel#2](~/add/codesnippet/visualbasic/PlotPanel/PlotPanel.vb#2)]"
  syntax:
    content: public System.Windows.Size DesiredSize { get; }
    return:
      type: System.Windows.Size
      description: "配置パスの目的のサイズになります計算されたサイズ。"
  overload: System.Windows.UIElement.DesiredSize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DragEnter
  id: DragEnter
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DragEnter
  nameWithType: UIElement.DragEnter
  fullName: System.Windows.UIElement.DragEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ先と、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>DragEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>。 DragEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName>。      <a name=&quot;routedEventInfo_DragEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.DragEnterEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewDragEnter>.</xref:System.Windows.UIElement.PreviewDragEnter> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.DragEnterEvent>      -オーバーライド<xref:System.Windows.UIElement.OnDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnDragEnter%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler DragEnter;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DragEnterEvent
  id: DragEnterEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DragEnterEvent
  nameWithType: UIElement.DragEnterEvent
  fullName: System.Windows.UIElement.DragEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.DragEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DragEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DragLeave
  id: DragLeave
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DragLeave
  nameWithType: UIElement.DragLeave
  fullName: System.Windows.UIElement.DragLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ元に、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>いくつかが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>。 いくつかのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName>。      <a name=&quot;routedEventInfo_DragLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.DragLeaveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.DragDrop.PreviewDragLeave>.</xref:System.Windows.DragDrop.PreviewDragLeave> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.DragLeaveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnDragLeave%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler DragLeave;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DragLeaveEvent
  id: DragLeaveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DragLeaveEvent
  nameWithType: UIElement.DragLeaveEvent
  fullName: System.Windows.UIElement.DragLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.DragLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DragLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DragOver
  id: DragOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DragOver
  nameWithType: UIElement.DragOver
  fullName: System.Windows.UIElement.DragOver
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムが潜在的なドロップ ターゲットとしてこの要素で、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントは、要素の境界のドラッグを開始した場合でも発生します。 ドラッグ アンドが境界の外側を開始し、このイベントを発生すると、内側、移動だけでなく<xref:System.Windows.UIElement.DragEnter>とプレビュー イベントを関連</xref:System.Windows.UIElement.DragEnter>。       このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>ドラッグされたが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>。 ドラッグされたイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.DragOver?displayProperty=fullName>。      <a name=&quot;routedEventInfo_DragOver&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.DragOverEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.DragDrop.PreviewDragOver>.</xref:System.Windows.DragDrop.PreviewDragOver> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.DragOverEvent>      -オーバーライド<xref:System.Windows.UIElement.OnDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnDragOver%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler DragOver;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DragOverEvent
  id: DragOverEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DragOverEvent
  nameWithType: UIElement.DragOverEvent
  fullName: System.Windows.UIElement.DragOverEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.DragOver&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DragOverEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Drop
  id: Drop
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Drop
  nameWithType: UIElement.Drop
  fullName: System.Windows.UIElement.Drop
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.Drop?displayProperty=fullName>添付イベントをドロップ一部であるため、このクラスのクラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.Drop?displayProperty=fullName>。 ドロップのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.Drop?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.Drop?displayProperty=fullName>。      <a name=&quot;routedEventInfo_Drop&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.DropEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewDrop>.</xref:System.Windows.UIElement.PreviewDrop> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.DropEvent>      -オーバーライド<xref:System.Windows.UIElement.OnDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnDrop%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler Drop;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.DropEvent
  id: DropEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: DropEvent
  nameWithType: UIElement.DropEvent
  fullName: System.Windows.UIElement.DropEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.Drop&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent DropEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Effect
  id: Effect
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Effect
  nameWithType: UIElement.Effect
  fullName: System.Windows.UIElement.Effect
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または設定を適用するビットマップ効果、 <xref href=&quot;System.Windows.UIElement&quot;></xref>です。 これは、依存関係プロパティです。"
  remarks: "<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>ビットマップ効果を適用する効果プロパティを使用してください。      <a name=&quot;dependencyPropertyInfo_Effect&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.EffectProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.EffectProperty>"
  example:
  - "The following XAML shows how to assign a custom <xref:System.Windows.Media.Effects.ShaderEffect> to the Effect property.  \n  \n [!code-xml[System.Windows.Media.Effects.ShaderEffect#1000](~/add/codesnippet/xaml/ShaderEffectDemo/Window1.xaml#1000)]"
  syntax:
    content: public System.Windows.Media.Effects.Effect Effect { get; set; }
    return:
      type: System.Windows.Media.Effects.Effect
      description: "<xref href=&quot;System.Windows.Media.Effects.Effect&quot;> </xref>を表すビットマップ効果。"
  overload: System.Windows.UIElement.Effect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.EffectProperty
  id: EffectProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: EffectProperty
  nameWithType: UIElement.EffectProperty
  fullName: System.Windows.UIElement.EffectProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.Effect*>依存関係プロパティ</xref:System.Windows.UIElement.Effect*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty EffectProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Focus
  id: Focus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Focus()
  nameWithType: UIElement.Focus()
  fullName: System.Windows.UIElement.Focus()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスを設定しようとしています。"
  remarks: "フォーカスを<xref:System.Windows.UIElement.Focusable%2A>と<xref:System.Windows.UIElement.IsEnabled%2A>両方必要があります`true`</xref:System.Windows.UIElement.IsEnabled%2A></xref:System.Windows.UIElement.Focusable%2A>。       場合でも、要素は、特定のツリー内でフォーカスを設定し、有効なイベント処理が、フォーカスがある、許可しないことによって、プレビューのフォーカス イベントに応答 (複合コントロールなど) ためこのメソッドは`false`します。       一般にフォーカスが&2; つの異なる概念によって拘束されます: キーボード フォーカスと論理フォーカスが常に一致しません。  詳細については、次を参照してください。[フォーカス概要](~/add/includes/ajax-current-ext-md.md)または[入力概要](~/add/includes/ajax-current-ext-md.md)です。       フォーカスを返しますを呼び出している場合は`true`、<xref:System.Windows.UIElement.IsKeyboardFocused%2A>と<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>も`true`</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A></xref:System.Windows.UIElement.IsKeyboardFocused%2A>。       場合は、関連するプロパティは、既に`true`、フォーカスを呼び出すときに、次の順序で発生するか、次のイベントの&1; つ以上: <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>、 <xref:System.Windows.UIElement.PreviewGotKeyboardFocus>(ソースは、新しいフォーカス ターゲット)、 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged>、 <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>、 <xref:System.Windows.UIElement.LostKeyboardFocus>、 <xref:System.Windows.UIElement.GotKeyboardFocus>(ソースは、新しいフォーカス ターゲット).</xref:System.Windows.UIElement.GotKeyboardFocus> </xref:System.Windows.UIElement.LostKeyboardFocus> </xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> </xref:System.Windows.UIElement.IsKeyboardFocusedChanged> </xref:System.Windows.UIElement.PreviewGotKeyboardFocus> </xref:System.Windows.UIElement.PreviewLostKeyboardFocus>       この呼び出しを成功させるためには、以前にフォーカスがあることをアプリケーションでその他の要素が必要です。"
  example:
  - "The following example sets focus to a <xref:System.Windows.Controls.TextBox> referenced by <xref:System.Windows.FrameworkElement.Name%2A>, and then adjusts the position of the cursor within the <xref:System.Windows.Controls.TextBox>.  \n  \n [!code-cs[TextBox_CursorToEnd#UIElementFocus](~/add/codesnippet/csharp/CursorToEnd/Window1.xaml.cs#uielementfocus)]\n [!code-vb[TextBox_CursorToEnd#UIElementFocus](~/add/codesnippet/visualbasic/CursorToEnd/Window1.xaml.vb#uielementfocus)]"
  syntax:
    content: public bool Focus ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素にキーボード フォーカスと論理フォーカスが設定されている場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>またはこの要素に論理フォーカスが設定されただけの場合、このメソッドを呼び出すが、フォーカスの変更が強制されない場合。"
  overload: System.Windows.UIElement.Focus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Focusable
  id: Focusable
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Focusable
  nameWithType: UIElement.Focusable
  fullName: System.Windows.UIElement.Focusable
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または要素がフォーカスを受け取るかどうかを示す値を設定します。  これは、依存関係プロパティです。"
  remarks: "フォーカスのある要素のみでは、キーボード入力を受け取ります。       フォーカスを設定できるは、[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]新機能は、実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、見かけ上の「既定」値がコントロールに特に、派生した要素のクラスに異なる設定がよくあります。 これは、問題は&2; つの方法のいずれかで発生します。 - 依存関係プロパティが特定の派生クラスで継承されたが、その派生クラスは、依存関係プロパティのメタデータをオーバーライドし、プロパティの既定値を変更します。      スタイルまたはテンプレートは、その依存関係プロパティの値を異なる方法で設定する要素に適用されます。       たとえば、明らかな「既定」の Focusable の<xref:System.Windows.Controls.Button>コントロールになります`true`場合でも、<xref:System.Windows.Controls.Button>として Focusable の継承、 [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] <xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>から直接プロパティ</xref:System.Windows.Controls.Button></xref:System.Windows.Controls.Button> これは、フォーカス可能な依存関係プロパティの適用されているメタデータの値がの静的コンス トラクター内でオーバーライドされたため、<xref:System.Windows.Controls.Control>基底クラスで、間に置か<xref:System.Windows.Controls.Button>と<xref:System.Windows.UIElement>クラス階層</xref:System.Windows.UIElement></xref:System.Windows.Controls.Button></xref:System.Windows.Controls.Control>。       継承<xref:System.Windows.Controls.Control>またはその派生クラスでは、<xref:System.Windows.Controls.Control>にするには、このプロパティの既定値を再定義`true`</xref:System.Windows.Controls.Control></xref:System.Windows.Controls.Control>。       継承された場合<xref:System.Windows.Controls.Label>(これは、<xref:System.Windows.Controls.Control>派生クラス)、既定値がもう一度再定義する`false`</xref:System.Windows.Controls.Control></xref:System.Windows.Controls.Label>。      <a name=&quot;dependencyPropertyInfo_Focusable&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.FocusableProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.FocusableProperty>"
  example:
  - "The following example code illustrates a control template for a particular custom control, which sets Focusable `false` on one of the elements within the template.  \n  \n [!code-xml[RichTextBox_NoScrollViewer#_ControlTemplate](~/add/codesnippet/xaml/richtextbox_noscrollviewer/window1.xaml#_controltemplate)]\n [!code-xml[RichTextBox_NoScrollViewer#_ControlTemplate](~/add/codesnippet/xaml/p-system.windows.uieleme_9_1.xaml)]"
  syntax:
    content: public bool Focusable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素がフォーカスを設定できる場合それ以外の場合<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>は、「解説」を参照してください。"
  overload: System.Windows.UIElement.Focusable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.FocusableChanged
  id: FocusableChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: FocusableChanged
  nameWithType: UIElement.FocusableChanged
  fullName: System.Windows.UIElement.FocusableChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.Focusable*>プロパティが変更された</xref:System.Windows.UIElement.Focusable*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.FocusableProperty
  id: FocusableProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: FocusableProperty
  nameWithType: UIElement.FocusableProperty
  fullName: System.Windows.UIElement.FocusableProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.Focusable*>依存関係プロパティ</xref:System.Windows.UIElement.Focusable*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusableProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  id: GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: UIElement.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.UIElement.GetAnimationBaseValue(DependencyProperty)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の可能性のあるすべての指定したプロパティの基本プロパティ値が、実行中の値をアニメーション化または停止済みのアニメーションを返します。"
  remarks: "プロパティのアニメーションが添付されていないかどうかは、GetAnimationBaseValue 戻り値は常に、<xref:System.Windows.DependencyObject.GetValue%2A>値を返します</xref:System.Windows.DependencyObject.GetValue%2A>。 添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始を含む値を派生し、停止の値は無視され、プロパティの値はその他のすべての可能な入力に基づいて決定されます。 詳細については、次を参照してください。[依存関係プロパティの値の優先順位](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example implements a handler that reports the base value of an animated <xref:System.Windows.FrameworkElement.Width%2A> property on a <xref:System.Windows.Controls.Button>, as well as the base value of a transform.  \n  \n [!code-cs[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/add/codesnippet/csharp/TimingBehavior_csharp/GetAnimationBaseValueExample.cs#getanimationbasevalue)]\n [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/add/codesnippet/visualbasic/timingbehavior_vb/getanimationbasevalueexample.vb#getanimationbasevalue)]"
  syntax:
    content: public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "確認する依存関係プロパティ。"
    return:
      type: System.Object
      description: "プロパティ値の指定した依存関係プロパティにアニメーションが添付されていないかのようです。"
  overload: System.Windows.UIElement.GetAnimationBaseValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GetLayoutClip(System.Windows.Size)
  id: GetLayoutClip(System.Windows.Size)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GetLayoutClip(Size)
  nameWithType: UIElement.GetLayoutClip(Size)
  fullName: System.Windows.UIElement.GetLayoutClip(Size)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "場合、クリッピングされる領域を表す代替クリッピング ジオメトリを返します<xref:System.Windows.UIElement.ClipToBounds*>に設定された<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Windows.UIElement.ClipToBounds*> 。"
  remarks: "既定の実装は、正規の値が返されますが、使用しない、`layoutSlotSize`計算内のパラメーターです。 代わりに<xref:System.Windows.UIElement.RenderSize%2A>。</xref:System.Windows.UIElement.RenderSize%2A>の値を使用して       このメソッドはオーバーライド大幅にすぐに派生して<xref:System.Windows.FrameworkElement>クラス、および<xref:System.Windows.FrameworkElement>一般的な WPF フレームワーク レベルの要素のより高度な動作が生成される上書き</xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement>。 詳細については、 <xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=fullName>。</xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=fullName>を参照してください。"
  syntax:
    content: protected virtual System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);
    parameters:
    - id: layoutSlotSize
      type: System.Windows.Size
      description: "要素によって提供される使用可能なサイズです。"
    return:
      type: System.Windows.Media.Geometry
      description: "潜在的なクリッピング ジオメトリ。"
  overload: System.Windows.UIElement.GetLayoutClip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: UIElement.GetUIParentCore()
  fullName: System.Windows.UIElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、返す代わりに[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]ビジュアル親が存在しない場合、この要素の親です。"
  remarks: "このメソッドの既定の仮想実装`null`です。 <xref:System.Windows.FrameworkElement>実際の実装を提供します。</xref:System.Windows.FrameworkElement>       別の親は、できるように、そのイベントは、標準の親のビジュアル ツリーをルーティングの標準的なパターンから逸脱した方法でルーティングまたはプレビューのルーティング方法で下方向に要素が代替の親構造体を作成する場所の場合、イベントのルーティングに使用されます。"
  syntax:
    content: protected virtual System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "派生クラスの実装がレポートに代替の親接続を持つ場合のオブジェクト。"
  overload: System.Windows.UIElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GiveFeedback
  id: GiveFeedback
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GiveFeedback
  nameWithType: UIElement.GiveFeedback
  fullName: System.Windows.UIElement.GiveFeedback
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素は、基になるドラッグ アンド ドロップ イベントを報告したときに発生します。"
  remarks: "GiveFeedback イベントは、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソースを使用します。 視覚的なフィードバックは、ドラッグ アンド ドロップ操作が、プロセスを助けます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>GiveFeedback が一部になるように、このクラスのイベントを接続されているクラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>。 GiveFeedback イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GiveFeedback&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.GiveFeedbackEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.GiveFeedbackEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewGiveFeedback>.</xref:System.Windows.UIElement.PreviewGiveFeedback> </xref:System.Windows.GiveFeedbackEventHandler> </xref:System.Windows.UIElement.GiveFeedbackEvent>      -オーバーライド<xref:System.Windows.UIElement.OnGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnGiveFeedback%2A>。"
  syntax:
    content: public event System.Windows.GiveFeedbackEventHandler GiveFeedback;
    return:
      type: System.Windows.GiveFeedbackEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GiveFeedbackEvent
  id: GiveFeedbackEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GiveFeedbackEvent
  nameWithType: UIElement.GiveFeedbackEvent
  fullName: System.Windows.UIElement.GiveFeedbackEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.GiveFeedback&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotFocus
  id: GotFocus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotFocus
  nameWithType: UIElement.GotFocus
  fullName: System.Windows.UIElement.GotFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素が論理フォーカスを取得したときに発生します。"
  remarks: "フォーカスがメソッド呼び出しを使用して強制的に意図的には、直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、要素にキーボード フォーカスが残り、このシナリオで場所、<xref:System.Windows.UIElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します</xref:System.Windows.UIElement.Focus%2A>。       このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.UIElement.IsFocused%2A>からルート内の要素のプロパティが変更された`false`に`true`</xref:System.Windows.UIElement.IsFocused%2A>。       このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。      <a name=&quot;routedEventInfo_GotFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.GotFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.RoutedEventHandler>|     イベントはありません対応するトンネリング</xref:System.Windows.RoutedEventHandler></xref:System.Windows.UIElement.GotFocusEvent>。      -オーバーライド<xref:System.Windows.UIElement.OnGotFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnGotFocus%2A>。"
  syntax:
    content: public event System.Windows.RoutedEventHandler GotFocus;
    return:
      type: System.Windows.RoutedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotFocusEvent
  id: GotFocusEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotFocusEvent
  nameWithType: UIElement.GotFocusEvent
  fullName: System.Windows.UIElement.GotFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.GotFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotKeyboardFocus
  id: GotKeyboardFocus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotKeyboardFocus
  nameWithType: UIElement.GotKeyboardFocus
  fullName: System.Windows.UIElement.GotKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスがあるときに発生します。"
  remarks: "<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>類似するイベントです。 要素のフォーカス状態を保持するプロパティで状態の変更を追跡します。GotKeyboardFocus イベントです。</xref:System.Windows.UIElement.IsKeyboardFocusedChanged>       このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>GotKeyboardFocus が一部になるように、このクラスのイベントを接続されているクラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>。 GotKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GotKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.GotKeyboardFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>.</xref:System.Windows.UIElement.PreviewGotKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.UIElement.GotKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.UIElement.OnGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnGotKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotKeyboardFocusEvent
  id: GotKeyboardFocusEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotKeyboardFocusEvent
  nameWithType: UIElement.GotKeyboardFocusEvent
  fullName: System.Windows.UIElement.GotKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.GotKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotMouseCapture
  id: GotMouseCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotMouseCapture
  nameWithType: UIElement.GotMouseCapture
  fullName: System.Windows.UIElement.GotMouseCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がマウスをキャプチャしたときに発生します。"
  remarks: "要素がマウスをキャプチャは、境界外にマウス ポインターがあってもマウス入力を受け取ります。 マウスでは、ドラッグ アンド ドロップ操作中にのみがキャプチャ通常され、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされたままです。       このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>マウスのある実際の要素を決定するデータのキャプチャのイベント</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>GotMouseCapture が一部になるように、このクラスのイベントを接続されているクラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>。 GotMouseCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GotMouseCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.GotMouseCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.UIElement.GotMouseCaptureEvent>。      -オーバーライド<xref:System.Windows.UIElement.OnGotMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnGotMouseCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler GotMouseCapture;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotMouseCaptureEvent
  id: GotMouseCaptureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotMouseCaptureEvent
  nameWithType: UIElement.GotMouseCaptureEvent
  fullName: System.Windows.UIElement.GotMouseCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.GotMouseCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotStylusCapture
  id: GotStylusCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotStylusCapture
  nameWithType: UIElement.GotStylusCapture
  fullName: System.Windows.UIElement.GotStylusCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がスタイラスをキャプチャしたときに発生します。"
  remarks: "要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャを保持します。       このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、 <xref:System.Windows.RoutedEventArgs.Source%2A>、イベント データを実際のキャプチャを持つ要素を決定します</xref:System.Windows.RoutedEventArgs.Source%2A>。       GotStylusCapture が一部になるように、このイベントがこのクラスの添付イベントのエイリアスを作成、クラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement>。 GotStylusCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_GotStylusCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.GotStylusCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.UIElement.GotStylusCaptureEvent>。      -オーバーライド<xref:System.Windows.UIElement.OnGotStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnGotStylusCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler GotStylusCapture;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotStylusCaptureEvent
  id: GotStylusCaptureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotStylusCaptureEvent
  nameWithType: UIElement.GotStylusCaptureEvent
  fullName: System.Windows.UIElement.GotStylusCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.GotStylusCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotTouchCapture
  id: GotTouchCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotTouchCapture
  nameWithType: UIElement.GotTouchCapture
  fullName: System.Windows.UIElement.GotTouchCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にタッチがキャプチャされるときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_GotTouchCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.GotTouchCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.UIElement.OnGotTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnGotTouchCapture%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.GotTouchCaptureEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> GotTouchCapture;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.GotTouchCaptureEvent
  id: GotTouchCaptureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: GotTouchCaptureEvent
  nameWithType: UIElement.GotTouchCaptureEvent
  fullName: System.Windows.UIElement.GotTouchCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.GotTouchCapture&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.HasAnimatedProperties
  id: HasAnimatedProperties
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: HasAnimatedProperties
  nameWithType: UIElement.HasAnimatedProperties
  fullName: System.Windows.UIElement.HasAnimatedProperties
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がアニメーション化されたプロパティを持つかどうかを示す値を取得します。"
  remarks: "このプロパティを返します`true`(ロック、常に実行されている) のアニメーションの永続的なまたは特定のタイムラインのアニメーションのいずれか。"
  syntax:
    content: public bool HasAnimatedProperties { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素があるアニメーションのプロパティのいずれかに接続されている場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.HasAnimatedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.HasEffectiveKeyboardFocus
  id: HasEffectiveKeyboardFocus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: HasEffectiveKeyboardFocus
  nameWithType: UIElement.HasEffectiveKeyboardFocus
  fullName: System.Windows.UIElement.HasEffectiveKeyboardFocus
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "示す値を取得するかどうか、 <xref href=&quot;System.Windows.UIElement&quot;> </xref>にフォーカスがあります。"
  remarks: "サブクラスは、要素にキーボード フォーカスがあるときに指定するには、このプロパティをオーバーライドできます。  これが役ときに、<xref:System.Windows.UIElement>キーボード フォーカスを持つことができる要素を含む要素にフォーカスがあるレポートをして</xref:System.Windows.UIElement>。"
  syntax:
    content: protected virtual bool HasEffectiveKeyboardFocus { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、 <xref href=&quot;System.Windows.UIElement&quot;> </xref>フォーカスがある、それ以外の<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.HasEffectiveKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  id: HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: HitTestCore(GeometryHitTestParameters)
  nameWithType: UIElement.HitTestCore(GeometryHitTestParameters)
  fullName: System.Windows.UIElement.HitTestCore(GeometryHitTestParameters)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "実装して&lt;xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=fullName&gt; base を指定する要素のヒット テスト動作 (返す<xref href=&quot;System.Windows.Media.GeometryHitTestResult&quot;> </xref>)。"
  remarks: "元の仮想メソッドを参照してください<xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=fullName>についてはさらにこのメソッドをオーバーライドする派生クラス</xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=fullName>。 なおいくつかの特定のコントロール (<xref:System.Windows.Controls.TextBlock>、たとえば) が個別の実装は、この&1; つをオーバーライドします</xref:System.Windows.Controls.TextBlock>。       このメソッドは、アプリケーション コードから呼び出すものではありません。 このメソッドは、(にマウス ポインターが要素上など) かどうかは、入力のシステムのさまざまな側面によって公開される内部のヒット テストの動作をサポートします。"
  syntax:
    content: protected override System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);
    parameters:
    - id: hitTestParameters
      type: System.Windows.Media.GeometryHitTestParameters
      description: "初期ヒット ポイントなどを実行するヒット テストをについて説明します。"
    return:
      type: System.Windows.Media.GeometryHitTestResult
      description: "評価されたジオメトリを含むテストの結果。"
  overload: System.Windows.UIElement.HitTestCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  id: HitTestCore(System.Windows.Media.PointHitTestParameters)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: HitTestCore(PointHitTestParameters)
  nameWithType: UIElement.HitTestCore(PointHitTestParameters)
  fullName: System.Windows.UIElement.HitTestCore(PointHitTestParameters)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "実装して<xref:System.Windows.Media.Visual.HitTestCore*>base を指定する要素のヒット テスト動作 (返す<xref href=&quot;System.Windows.Media.HitTestResult&quot;> </xref>).</xref:System.Windows.Media.Visual.HitTestCore*>"
  remarks: "元の仮想メソッドを参照してください<xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=fullName>についてはさらにこのメソッドをオーバーライドする派生クラス</xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=fullName>。 いくつかの特定のコントロール (<xref:System.Windows.Controls.TextBlock>、たとえば) <xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>で定義されている HitTestCore をオーバーライドする個別の実装にが</xref:System.Windows.Controls.TextBlock>       このメソッドは、アプリケーション コードから呼び出すものではありません。 このメソッドは、(にマウス ポインターが要素上など) かどうかは、入力のシステムのさまざまな側面によって公開される内部のヒット テストの動作をサポートします。"
  syntax:
    content: protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);
    parameters:
    - id: hitTestParameters
      type: System.Windows.Media.PointHitTestParameters
      description: "初期ヒット ポイントなどを実行するヒット テストをについて説明します。"
    return:
      type: System.Windows.Media.HitTestResult
      description: "評価されたポイントを含むテストの結果。"
  overload: System.Windows.UIElement.HitTestCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.InputBindings
  id: InputBindings
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: InputBindings
  nameWithType: UIElement.InputBindings
  fullName: System.Windows.UIElement.InputBindings
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に関連付けられている入力バインドのコレクションを取得します。"
  remarks: "入力バインディングは、コマンド入力デバイスへのバインディングをサポートします。 たとえば、<xref:System.Windows.Input.MouseBinding>を実装して入力をマウス デバイスに特定のプロパティを含むバインド</xref:System.Windows.Input.MouseBinding>。       両方の型に関連するだけでなく、インスタンスで宣言されている入力バインド入力バインドのコレクションが含まれます。       関連するプロパティ、 <xref:System.Windows.UIElement.CommandBindings%2A>、コマンドのショートカット キーのコレクションを保持します</xref:System.Windows.UIElement.CommandBindings%2A>。 これらとは異なり、入力バインディングとコマンドの処理 - 既知のコマンドに関連付けられているアクションの下の次のレベルを表しています。      <a name=&quot;xamlPropertyElementUsage_InputBindings&quot;></a>## XAML プロパティ要素の使用```   <object>     <object.InputBindings>       oneOrMoreInputBindings     </object.InputBindings>   </object>   ``` <a name=&quot;xamlValues_InputBindings&quot;> </a> ## XAML 値*oneOrMoreInputBindings*&1; つまたは複数<xref:System.Windows.Input.InputBinding>要素 (通常、<xref:System.Windows.Input.KeyBinding>または<xref:System.Windows.Input.MouseBinding>派生クラス).</xref:System.Windows.Input.MouseBinding> </xref:System.Windows.Input.KeyBinding> </xref:System.Windows.Input.InputBinding>       これらの各が予期、<xref:System.Windows.Input.InputBinding.Command%2A>と<xref:System.Windows.Input.InputBinding.Gesture%2A>属性が設定されます</xref:System.Windows.Input.InputBinding.Gesture%2A></xref:System.Windows.Input.InputBinding.Command%2A>。"
  example:
  - "The following example populates this property on a <xref:System.Windows.Window>, with a single <xref:System.Windows.Input.KeyBinding>.  \n  \n [!code-xml[CommandingOverviewSnippets#CommandingOverviewXAMLKeyBinding](~/add/codesnippet/xaml/CommandingOverviewSnippets/Window1.xaml#commandingoverviewxamlkeybinding)]  \n  \n For more information about the [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax for collections, see [XAML Syntax In Detail](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.Input.InputBindingCollection InputBindings { get; }
    return:
      type: System.Windows.Input.InputBindingCollection
      description: "入力バインドのコレクション。"
  overload: System.Windows.UIElement.InputBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.InputHitTest(System.Windows.Point)
  id: InputHitTest(System.Windows.Point)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: InputHitTest(Point)
  nameWithType: UIElement.InputHitTest(Point)
  fullName: System.Windows.UIElement.InputHitTest(Point)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "現在の要素の原点に対する、指定した座標には、現在の要素内の入力要素を返します。"
  remarks: "<xref:System.Windows.IInputElement>その型は両方<xref:System.Windows.UIElement>と<xref:System.Windows.ContentElement>。</xref:System.Windows.ContentElement></xref:System.Windows.UIElement>の共通のインターフェイスであるため、戻り値の型として返されます</xref:System.Windows.IInputElement> 戻り値の型を適切にキャストまたはがインターフェイスのインスタンスで定義されている特定のメンバーを使用することができますし、<xref:System.Windows.IInputElement>インターフェイス</xref:System.Windows.IInputElement>。       このメソッドは、通常、アプリケーション コードからは呼び出されません。 このメソッドを呼び出すことは、かなりの低レベルの入力機能が既に存在し、マウス デバイス ロジックを再作成などを再実装する場合に適してはのみです。       <xref:System.Windows.IContentHost>コントラクト、<xref:System.Windows.IContentHost.InputHitTest%2A>明示的に実装を選択するいくつかの要素が同じシグネチャを持つメソッドです</xref:System.Windows.IContentHost.InputHitTest%2A>。</xref:System.Windows.IContentHost>"
  syntax:
    content: public System.Windows.IInputElement InputHitTest (System.Windows.Point point);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "この要素内のオフセットを調整します。"
    return:
      type: System.Windows.IInputElement
      description: "指定された位置にある子要素です。"
  overload: System.Windows.UIElement.InputHitTest*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.InvalidateArrange
  id: InvalidateArrange
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: InvalidateArrange()
  nameWithType: UIElement.InvalidateArrange()
  fullName: System.Windows.UIElement.InvalidateArrange()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "要素の配置状態 (レイアウト) を無効にします。 無効化、要素が得られます、レイアウト更新<xref:System.Windows.UIElement.UpdateLayout*>。</xref:System.Windows.UIElement.UpdateLayout*>によって強制されない限り非同期に行われます"
  remarks: "頻繁に使用する呼び出し InvalidateArrange になどに特に<xref:System.Windows.UIElement.UpdateLayout%2A>大幅なパフォーマンスに影響があります</xref:System.Windows.UIElement.UpdateLayout%2A>。 したがって、他の後続の呼び出しの状態の正確なレイアウトを絶対に必要ない限り、このメソッドを呼び出す[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]コードにします。 高度なシナリオ InvalidateArrange を呼び出すことができますが、作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback>on ではない依存関係プロパティの<xref:System.Windows.Freezable>または<xref:System.Windows.FrameworkElement>が変更されたときのレイアウトの配置パスに影響を与えるまだクラスを派生します</xref:System.Windows.FrameworkElement></xref:System.Windows.Freezable></xref:System.Windows.PropertyChangedCallback>。"
  syntax:
    content: public void InvalidateArrange ();
    parameters: []
  overload: System.Windows.UIElement.InvalidateArrange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.InvalidateMeasure
  id: InvalidateMeasure
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: InvalidateMeasure()
  nameWithType: UIElement.InvalidateMeasure()
  fullName: System.Windows.UIElement.InvalidateMeasure()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "要素の測定状態 (レイアウト) を無効にします。"
  remarks: "また呼び出しでこのメソッドを呼び出す<xref:System.Windows.UIElement.InvalidateArrange%2A>内部的には、代わりに必要はありませんし<xref:System.Windows.UIElement.InvalidateArrange%2A>続けて</xref:System.Windows.UIElement.InvalidateArrange%2A></xref:System.Windows.UIElement.InvalidateArrange%2A>。 無効化、後に要素がレイアウト更新しない限り、非同期的に行われます<xref:System.Windows.UIElement.UpdateLayout%2A>同期レイアウト変更を強制すると呼びます</xref:System.Windows.UIElement.UpdateLayout%2A>。       WPF フレームワーク レベルのレイアウト システムは、要素のビジュアル ツリー内の変更の処理を行い、レイアウト システムが必要な場合に、このメソッドの該当するショートカットを呼び出して最も一般的なレイアウトの無効化の場合。 直接操作する、要素ツリーのまたは類似したシナリオを高度なレイアウトを完全な実装を作成する場合にのみ、このメソッドを呼び出す必要があります。 このような高度なシナリオの&1; つは、作成するかどうかは、<xref:System.Windows.PropertyChangedCallback>に含まれていない依存関係プロパティの<xref:System.Windows.Freezable>または<xref:System.Windows.FrameworkElement>派生クラスで、まだが変更されたときのレイアウトの測定パスに影響を与えます</xref:System.Windows.FrameworkElement></xref:System.Windows.Freezable></xref:System.Windows.PropertyChangedCallback>。       代わりに特定の呼び出しを頻繁に<xref:System.Windows.UIElement.UpdateLayout%2A>大幅なパフォーマンスに影響があります</xref:System.Windows.UIElement.UpdateLayout%2A>。 したがって、他の後続の呼び出しの状態の正確なレイアウトを絶対に必要ない限り、このメソッドを呼び出す[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]コードにします。"
  syntax:
    content: public void InvalidateMeasure ();
    parameters: []
  overload: System.Windows.UIElement.InvalidateMeasure*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.InvalidateVisual
  id: InvalidateVisual
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: InvalidateVisual()
  nameWithType: UIElement.InvalidateVisual()
  fullName: System.Windows.UIElement.InvalidateVisual()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "要素のレンダリングを無効にし、完全な新しいレイアウト パスを強制します。 <xref:System.Windows.UIElement.OnRender*>レイアウト サイクルが完了した後は呼び出されます。</xref:System.Windows.UIElement.OnRender*>"
  remarks: "このメソッドを呼び出す<xref:System.Windows.UIElement.InvalidateArrange%2A>内部的にします</xref:System.Windows.UIElement.InvalidateArrange%2A>。       一般に、このメソッドは、アプリケーション コードからは呼び出されません。 WPF フレームワーク レベルのレイアウト システムは、要素のビジュアル ツリー内の変更の処理、必要な場合に、このメソッドの該当するショートカットを呼び出すことが既にです。 このメソッドを呼び出すことは、高度なシナリオでのみ必要があります。 このような高度なシナリオの&1; つは、作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback>on ではない依存関係プロパティの<xref:System.Windows.Freezable>または<xref:System.Windows.FrameworkElement>を変更するとき、レイアウトに影響を与えるまだクラスを派生します</xref:System.Windows.FrameworkElement></xref:System.Windows.Freezable></xref:System.Windows.PropertyChangedCallback>。"
  syntax:
    content: public void InvalidateVisual ();
    parameters: []
  overload: System.Windows.UIElement.InvalidateVisual*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsArrangeValid
  id: IsArrangeValid
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsArrangeValid
  nameWithType: UIElement.IsArrangeValid
  fullName: System.Windows.UIElement.IsArrangeValid
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素のレイアウト内の子要素の位置とサイズの計算が有効かどうかを示す値を取得します。"
  remarks: "呼び出すことによって無効にする方法を強制する<xref:System.Windows.UIElement.InvalidateArrange%2A>この要素 (またはその親) にします</xref:System.Windows.UIElement.InvalidateArrange%2A>。 フラグを設定のレイアウトを再構成するタイミングで、レイアウト システムを決定します。 またはを即時に呼び出す<xref:System.Windows.UIElement.UpdateLayout%2A>できても、これは、これ以上の無効化が保留になっていないことが確実である場合にのみ実行してありますが、(多数の強制が不必要に更新は、パフォーマンスへの影響を持つ).</xref:System.Windows.UIElement.UpdateLayout%2A>       IsArrangeValid をすることはできません`true`しない限り、<xref:System.Windows.UIElement.IsMeasureValid%2A>も`true`(レイアウト プロセスで配置することはできません有効な最初される有効な測定値なし).</xref:System.Windows.UIElement.IsMeasureValid%2A>"
  syntax:
    content: public bool IsArrangeValid { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合は、サイズとレイアウトの位置が無効です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsArrangeValid*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsEnabled
  id: IsEnabled
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsEnabled
  nameWithType: UIElement.IsEnabled
  fullName: System.Windows.UIElement.IsEnabled
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または設定でこの要素が有効になっているかどうかを示す値、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]です。  これは、依存関係プロパティです。"
  remarks: "このプロパティがクラスに固有の実装によって影響を受けることに注意してください<xref:System.Windows.UIElement.IsEnabledCore%2A>、特定の要素、実行時に多くの場合</xref:System.Windows.UIElement.IsEnabledCore%2A>。 したがって、ここで示されている既定値がありますいない効果的です。 インスタンス、 <xref:System.Windows.Controls.Primitives.ScrollBar>IsEnabled なります`false`スクロール バーをサポートする必要がないと判断されたときにします</xref:System.Windows.Controls.Primitives.ScrollBar>。 この値を設定しようとしても可能性があるとオーバーライドされます<xref:System.Windows.UIElement.IsEnabledCore%2A>。</xref:System.Windows.UIElement.IsEnabledCore%2A>によって返される値       有効になっていない要素は、ヒット テストやフォーカスに参加していないと、そのため、入力イベントのソースはできません。      <a name=&quot;dependencyPropertyInfo_IsEnabled&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsEnabledProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsEnabledProperty>"
  example:
  - "The following example shows a handler on one button that when executed will set IsEnabled `false` on another named button `b1`.  \n  \n [!code-cs[RoutedEventAddRemoveHandler#Handler](~/add/codesnippet/csharp/RoutedEventAddRemoveHandler/default.xaml.cs#handler)]\n [!code-vb[RoutedEventAddRemoveHandler#Handler](~/add/codesnippet/visualbasic/RoutedEventAddRemoveHandler/default.xaml.vb#handler)]"
  syntax:
    content: public bool IsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素が有効である場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsEnabledChanged
  id: IsEnabledChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsEnabledChanged
  nameWithType: UIElement.IsEnabledChanged
  fullName: System.Windows.UIElement.IsEnabledChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsEnabled*>プロパティをこの要素を変更します</xref:System.Windows.UIElement.IsEnabled*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsEnabledCore
  id: IsEnabledCore
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsEnabledCore
  nameWithType: UIElement.IsEnabledCore
  fullName: System.Windows.UIElement.IsEnabledCore
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "戻り値になる値を取得<xref:System.Windows.UIElement.IsEnabled*>派生クラス</xref:System.Windows.UIElement.IsEnabled*>。"
  syntax:
    content: protected virtual bool IsEnabledCore { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素が有効である場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsEnabledCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsEnabledProperty
  id: IsEnabledProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsEnabledProperty
  nameWithType: UIElement.IsEnabledProperty
  fullName: System.Windows.UIElement.IsEnabledProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsEnabled*>依存関係プロパティ</xref:System.Windows.UIElement.IsEnabled*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsEnabledProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsFocused
  id: IsFocused
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsFocused
  nameWithType: UIElement.IsFocused
  fullName: System.Windows.UIElement.IsFocused
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に論理フォーカスがあるかどうかを決定する値を取得します。  これは、依存関係プロパティです。"
  remarks: "アプリケーションは、複数のフォーカス区分をなど、メニューの内容と、アプリケーションの残りの部分の間に、論理フォーカスはキーボード フォーカスと異なる可能性があります。 このシナリオでは、アプリケーションの UI の&1; つの要素にキーボード フォーカスが設定できるだけ、ただし、他のフォーカス区分の特定の要素も保持したまま論理フォーカスします。 論理フォーカスの詳細については、次を参照してください。[フォーカス概要](~/add/includes/ajax-current-ext-md.md)です。       (これは読み取り専用)、このプロパティを設定してフォーカスを設定しないとします。 このプロパティの典型的な使用は、<xref:System.Windows.Setter>または<xref:System.Windows.EventTrigger>。</xref:System.Windows.EventTrigger></xref:System.Windows.Setter>の依存関係プロパティとして使用するには フォーカスをプログラムで設定するには、呼び出す<xref:System.Windows.UIElement.Focus%2A>。</xref:System.Windows.UIElement.Focus%2A> ユーザーの操作によって、またはコントロールの実装は、マウスのキャプチャの動作を含む可能性が、フォーカスを設定もできます。      <a name=&quot;dependencyPropertyInfo_IsFocused&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsFocusedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsFocusedProperty>"
  example:
  - "The following example is a code handler that changes the background of a control when it is focused.  \n  \n [!code-cs[PopupSimple#IsFocused](~/add/codesnippet/csharp/PopupPropertiesSample/Window1.xaml.cs#isfocused)]  \n  \n Another common way to achieve this same effect is to place a <xref:System.Windows.Trigger> in the <xref:System.Windows.Style> of a control; this approach does not require handling specific events with code-behind and allows designers greater access to the interactive and graphical nature of the [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]. For an example, see [How to: Create an Outer Glow Effect](http://msdn.microsoft.com/en-us/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1)."
  syntax:
    content: public bool IsFocused { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素が論理フォーカスがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsFocused*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsFocusedProperty
  id: IsFocusedProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsFocusedProperty
  nameWithType: UIElement.IsFocusedProperty
  fullName: System.Windows.UIElement.IsFocusedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsFocused*>依存関係プロパティ</xref:System.Windows.UIElement.IsFocused*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsFocusedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsHitTestVisible
  id: IsHitTestVisible
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsHitTestVisible
  nameWithType: UIElement.IsHitTestVisible
  fullName: System.Windows.UIElement.IsHitTestVisible
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素ができる、表示される内容の一部からヒット テストの結果として可能性のある返されるかどうかを示す値を設定します。 これは、依存関係プロパティです。"
  remarks: "このプロパティの有効な値は、ヒット テスト可能な要素の論理ツリー内の相対位置に影響されます。 たとえば、要素の子要素にある要素のないヒット テストの表示、子のプロパティの有効な値は残ります`false`場合でも、その値をローカルに設定しようとしています。 このため、ことが重要 IsHitTestVisible を設定しないでください`false`複合コントロールで任意の入力を必要またはそのコントロールのヒット テストしない限り、します。 ヒット テストの詳細については、次を参照してください。[ビジュアルの層でのテスト ヒット](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsHitTestVisible&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsHitTestVisibleProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsHitTestVisibleProperty>"
  syntax:
    content: public bool IsHitTestVisible { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素は、少なくとも&1; つの点からヒット テストの結果として返される可能性があります場合、それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsHitTestVisible*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsHitTestVisibleChanged
  id: IsHitTestVisibleChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsHitTestVisibleChanged
  nameWithType: UIElement.IsHitTestVisibleChanged
  fullName: System.Windows.UIElement.IsHitTestVisibleChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsHitTestVisible*>この要素に依存関係プロパティの変更</xref:System.Windows.UIElement.IsHitTestVisible*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsHitTestVisibleProperty
  id: IsHitTestVisibleProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsHitTestVisibleProperty
  nameWithType: UIElement.IsHitTestVisibleProperty
  fullName: System.Windows.UIElement.IsHitTestVisibleProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsHitTestVisible*>依存関係プロパティ</xref:System.Windows.UIElement.IsHitTestVisible*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsInputMethodEnabled
  id: IsInputMethodEnabled
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsInputMethodEnabled
  nameWithType: UIElement.IsInputMethodEnabled
  fullName: System.Windows.UIElement.IsInputMethodEnabled
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力方式システムかどうかを示す値を取得など、 [!INCLUDE[TLA#tla_ime](~/add/includes/ajax-current-ext-md.md)]、この要素への入力の処理が有効になっています。"
  remarks: "このプロパティが添付プロパティによって返される値を返します<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=fullName>現在有効な入力メソッドでは (キーボード、音声、およびその他の入力デバイス).</xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=fullName>"
  syntax:
    content: public bool IsInputMethodEnabled { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>入力方式がアクティブである場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 基になる添付プロパティの既定値は<xref uid=&quot;langword_csharp_true;&quot; name=&quot;true;&quot; href=&quot;&quot;></xref>ただし、これが影響を受けること実行時に入力方式の実際の状態。"
  overload: System.Windows.UIElement.IsInputMethodEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsKeyboardFocused
  id: IsKeyboardFocused
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsKeyboardFocused
  nameWithType: UIElement.IsKeyboardFocused
  fullName: System.Windows.UIElement.IsKeyboardFocused
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にキーボード フォーカスがあるかどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "フォーカスに関連するイベントは、このプロパティの値への変更を伴うことができます。       IsKeyboardFocused と<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>でよく使われるクラスのイベント ハンドラー内の他の入力に関連するイベント、インスタンスの要素にキーボード フォーカスは既にまたはときにマウスを決定するイベントとキーボード イベントが発生する組み合わせてかどうかを判断します</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>。      <a name=&quot;dependencyPropertyInfo_IsKeyboardFocused&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsKeyboardFocusedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsKeyboardFocusedProperty>"
  syntax:
    content: public bool IsKeyboardFocused { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素がキーボード フォーカスがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsKeyboardFocused*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsKeyboardFocusedChanged
  id: IsKeyboardFocusedChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsKeyboardFocusedChanged
  nameWithType: UIElement.IsKeyboardFocusedChanged
  fullName: System.Windows.UIElement.IsKeyboardFocusedChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsKeyboardFocused*>この要素でプロパティが変更された</xref:System.Windows.UIElement.IsKeyboardFocused*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsKeyboardFocusedProperty
  id: IsKeyboardFocusedProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsKeyboardFocusedProperty
  nameWithType: UIElement.IsKeyboardFocusedProperty
  fullName: System.Windows.UIElement.IsKeyboardFocusedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsKeyboardFocused*>依存関係プロパティ</xref:System.Windows.UIElement.IsKeyboardFocused*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsKeyboardFocusWithin
  id: IsKeyboardFocusWithin
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsKeyboardFocusWithin
  nameWithType: UIElement.IsKeyboardFocusWithin
  fullName: System.Windows.UIElement.IsKeyboardFocusWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボード フォーカスが要素またはそのビジュアル ツリーの子要素内の任意の場所かどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "このプロパティの値に変更が通常発生させる、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>イベント、派生クラスがオーバーライドしない限り、<xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A>を抑制する状況イベント</xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A></xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>。       このプロパティを直接設定しないが、要素にフォーカスを設定するには呼び出すことによって<xref:System.Windows.UIElement.Focus%2A>、またはすることにより、<xref:System.Windows.UIElement.MoveFocus%2A>要求</xref:System.Windows.UIElement.MoveFocus%2A></xref:System.Windows.UIElement.Focus%2A>。 このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。       <xref:System.Windows.UIElement.IsKeyboardFocused%2A>IsKeyboardFocusWithin 用いられますクラスのイベント ハンドラー内で他の入力に関連するイベントのインスタンスの要素にキーボード フォーカスは既にまたはときにマウスを決定するイベントとキーボード イベントが発生する組み合わせてかどうかを判断します。</xref:System.Windows.UIElement.IsKeyboardFocused%2A>      <a name=&quot;dependencyPropertyInfo_IsKeyboardFocusWithin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsKeyboardFocusWithinProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsKeyboardFocusWithinProperty>"
  syntax:
    content: public bool IsKeyboardFocusWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素またはその子要素にキーボード フォーカスがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsKeyboardFocusWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsKeyboardFocusWithinChanged
  id: IsKeyboardFocusWithinChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsKeyboardFocusWithinChanged
  nameWithType: UIElement.IsKeyboardFocusWithinChanged
  fullName: System.Windows.UIElement.IsKeyboardFocusWithinChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の IsKeyboardFocusWithinChanged プロパティの値が変更されたときに発生します。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsKeyboardFocusWithinProperty
  id: IsKeyboardFocusWithinProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsKeyboardFocusWithinProperty
  nameWithType: UIElement.IsKeyboardFocusWithinProperty
  fullName: System.Windows.UIElement.IsKeyboardFocusWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsKeyboardFocusWithin*>依存関係プロパティ</xref:System.Windows.UIElement.IsKeyboardFocusWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsManipulationEnabled
  id: IsManipulationEnabled
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsManipulationEnabled
  nameWithType: UIElement.IsManipulationEnabled
  fullName: System.Windows.UIElement.IsManipulationEnabled
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この操作のイベントを有効にするかどうかを示す値を取得または<xref href=&quot;System.Windows.UIElement&quot;></xref>です。"
  remarks: 'このプロパティは、する場合は true に設定、<xref:System.Windows.UIElement>を受信する、 <xref:System.Windows.UIElement.ManipulationStarting>、 <xref:System.Windows.UIElement.ManipulationStarted>、 <xref:System.Windows.UIElement.ManipulationDelta>、 <xref:System.Windows.UIElement.ManipulationInertiaStarting>、 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>、および<xref:System.Windows.UIElement.ManipulationCompleted>イベント</xref:System.Windows.UIElement.ManipulationCompleted></xref:System.Windows.UIElement.ManipulationBoundaryFeedback></xref:System.Windows.UIElement.ManipulationInertiaStarting></xref:System.Windows.UIElement.ManipulationDelta></xref:System.Windows.UIElement.ManipulationStarted></xref:System.Windows.UIElement.ManipulationStarting></xref:System.Windows.UIElement>。 操作の詳細については、次を参照してください。、[入力概要](~/add/includes/ajax-current-ext-md.md)です。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル: 初めて、タッチ アプリケーションの作成](~/add/includes/ajax-current-ext-md.md)です。'
  example:
  - "The following example creates an application that has a red Rectangle.  The IsManipulationEnabled property of the Rectangle is set to true and the application's window subscribes to the <xref:System.Windows.UIElement.ManipulationStarting>, <xref:System.Windows.UIElement.ManipulationDelta>, and <xref:System.Windows.UIElement.ManipulationInertiaStarting> events. This example is part of a larger example in [Walkthrough: Creating Your First Touch Application](../Topic/Walkthrough:%20Creating%20Your%20First%20Touch%20Application.md).  \n  \n [!code-xml[BasicManipulation#UI](~/add/codesnippet/xaml/basicmanipulation/mainwindow.xaml#ui)]"
  syntax:
    content: public bool IsManipulationEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この操作のイベントが有効になっている場合<xref href=&quot;System.Windows.UIElement&quot;> </xref>、それ以外の<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsManipulationEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsManipulationEnabledProperty
  id: IsManipulationEnabledProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsManipulationEnabledProperty
  nameWithType: UIElement.IsManipulationEnabledProperty
  fullName: System.Windows.UIElement.IsManipulationEnabledProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsManipulationEnabled*>依存関係プロパティ</xref:System.Windows.UIElement.IsManipulationEnabled*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsManipulationEnabledProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMeasureValid
  id: IsMeasureValid
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMeasureValid
  nameWithType: UIElement.IsMeasureValid
  fullName: System.Windows.UIElement.IsMeasureValid
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "レイアウト メジャーによって返される現在のサイズが有効かどうかを示す値を取得します。"
  remarks: "測定と配置を呼び出すことによって無効化を強制する<xref:System.Windows.UIElement.InvalidateMeasure%2A>この要素 (またはビジュアル ツリーの親要素).</xref:System.Windows.UIElement.InvalidateMeasure%2A> これにより、レイアウト再構成されるように、非同期的にレイアウト システムによって決定時に発生します。 代わりに、行うことができる<xref:System.Windows.UIElement.UpdateLayout%2A>。</xref:System.Windows.UIElement.UpdateLayout%2A>への直接呼び出し だけに呼び出す必要がありますただし、する<xref:System.Windows.UIElement.UpdateLayout%2A>かどうかそれ以上の無効化が保留になっていないことが可能性があります (強制不必要に更新プログラムの数が多いはパフォーマンスの結果になります).</xref:System.Windows.UIElement.UpdateLayout%2A>       IsMeasureValid 場合`false`、<xref:System.Windows.UIElement.IsArrangeValid%2A>必要もあります`false`(レイアウト処理の実施、ロジックで配置することはできません有効な最初される有効な測定値なし).</xref:System.Windows.UIElement.IsArrangeValid%2A>"
  syntax:
    content: public bool IsMeasureValid { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>測定パス レイアウト場合、有効なと現在の値です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsMeasureValid*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseCaptured
  id: IsMouseCaptured
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseCaptured
  nameWithType: UIElement.IsMouseCaptured
  fullName: System.Windows.UIElement.IsMouseCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にマウスがキャプチャされるかどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "マウスのキャプチャ状態は、インプロセスのドラッグ アンド ドロップ操作に関連付けられます。      <a name=&quot;dependencyPropertyInfo_IsMouseCaptured&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsMouseCapturedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsMouseCapturedProperty>"
  example:
  - "The following example turns the mouse capture state on or off based on whether the mouse is already captured for the element.  \n  \n If mouse capture is elsewhere, the mouse capture is set to that element. If the element had mouse capture, it is cleared by calling <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=fullName> with a null input.  \n  \n [!code-vb[MouseSnippetSample#IsMouseCaptured](~/add/codesnippet/visualbasic/mousesnippetsample/window1.xaml.vb#ismousecaptured)]\n [!code-cs[MouseSnippetSample#IsMouseCaptured](~/add/codesnippet/csharp/MouseSnippetSample/Window1.xaml.cs#ismousecaptured)]"
  syntax:
    content: public bool IsMouseCaptured { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素がマウス キャプチャがある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsMouseCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseCapturedChanged
  id: IsMouseCapturedChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseCapturedChanged
  nameWithType: UIElement.IsMouseCapturedChanged
  fullName: System.Windows.UIElement.IsMouseCapturedChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsMouseCaptured*>この要素でプロパティが変更された</xref:System.Windows.UIElement.IsMouseCaptured*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseCapturedProperty
  id: IsMouseCapturedProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseCapturedProperty
  nameWithType: UIElement.IsMouseCapturedProperty
  fullName: System.Windows.UIElement.IsMouseCapturedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsMouseCaptured*>依存関係プロパティ</xref:System.Windows.UIElement.IsMouseCaptured*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseCaptureWithin
  id: IsMouseCaptureWithin
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseCaptureWithin
  nameWithType: UIElement.IsMouseCaptureWithin
  fullName: System.Windows.UIElement.IsMouseCaptureWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素またはそのビジュアル ツリー内の子要素にマウスのキャプチャを保持するかどうかを決定する値を取得します。 これは、依存関係プロパティです。"
  remarks: "<a name=&quot;dependencyPropertyInfo_IsMouseCaptureWithin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsMouseCaptureWithinProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsMouseCaptureWithinProperty>"
  syntax:
    content: public bool IsMouseCaptureWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素または格納されている要素がマウス キャプチャを持つ場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsMouseCaptureWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseCaptureWithinChanged
  id: IsMouseCaptureWithinChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseCaptureWithinChanged
  nameWithType: UIElement.IsMouseCaptureWithinChanged
  fullName: System.Windows.UIElement.IsMouseCaptureWithinChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、 <xref href=&quot;System.Windows.UIElement.IsMouseCaptureWithinProperty&quot;> </xref>この要素に変更します。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseCaptureWithinProperty
  id: IsMouseCaptureWithinProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseCaptureWithinProperty
  nameWithType: UIElement.IsMouseCaptureWithinProperty
  fullName: System.Windows.UIElement.IsMouseCaptureWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsMouseCaptureWithin*>依存関係プロパティ</xref:System.Windows.UIElement.IsMouseCaptureWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseDirectlyOver
  id: IsMouseDirectlyOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseDirectlyOver
  nameWithType: UIElement.IsMouseDirectlyOver
  fullName: System.Windows.UIElement.IsMouseDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターの位置がヒット テストの結果は、要素の構成を考慮に対応しているかどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "異なり<xref:System.Windows.UIElement.IsMouseOver%2A>、のみ、このプロパティは`true`literal 要素上にマウス ポインターが場合などはヒット テストの</xref:System.Windows.UIElement.IsMouseOver%2A> 子要素の上にマウス ポインターが代わりに場合、具体的には要素のより深いテンプレートおよび複合の一部である要素をこのプロパティはなります`false`です。 コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.UIElement.IsMouseOver%2A>代わりにします</xref:System.Windows.UIElement.IsMouseOver%2A>。       この要素にマウスがキャプチャされるかどうかと、このプロパティは、`true`のキャプチャ時に、このプロパティを返し続けます`true`までマウスのキャプチャが失われ、その境界上にポインターがありません。      <a name=&quot;dependencyPropertyInfo_IsMouseDirectlyOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsMouseDirectlyOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsMouseDirectlyOverProperty>"
  syntax:
    content: public bool IsMouseDirectlyOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マウス ポインターがヒット テストと同じ要素結果の上にある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsMouseDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseDirectlyOverChanged
  id: IsMouseDirectlyOverChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseDirectlyOverChanged
  nameWithType: UIElement.IsMouseDirectlyOverChanged
  fullName: System.Windows.UIElement.IsMouseDirectlyOverChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsMouseDirectlyOver*>この要素でプロパティが変更された</xref:System.Windows.UIElement.IsMouseDirectlyOver*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseDirectlyOverProperty
  id: IsMouseDirectlyOverProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseDirectlyOverProperty
  nameWithType: UIElement.IsMouseDirectlyOverProperty
  fullName: System.Windows.UIElement.IsMouseDirectlyOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsMouseDirectlyOver*>依存関係プロパティ</xref:System.Windows.UIElement.IsMouseDirectlyOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseOver
  id: IsMouseOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseOver
  nameWithType: UIElement.IsMouseOver
  fullName: System.Windows.UIElement.IsMouseOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素 (ビジュアル ツリー内の子要素を含む) 上にあるかどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "通常、(ビジュアル ツリーを)、コントロール内のさまざまな要素はすべて報告コンテナー コントロールのマウスの状態になるようコントロールは複合コントロール。 たとえば、<xref:System.Windows.Controls.ListBox>スタイルのコントロールとして IsMouseOver が報告されます`true`の geometry 上にマウスが任意の場所も含める場合は、 <xref:System.Windows.Controls.ListBoxItem>.</xref:System.Windows.Controls.ListBoxItem> </xref:System.Windows.Controls.ListBox>       類似しています&quot;IsMouseOverChanged&quot;イベントが存在しないいくつかの類似イベントを行います。 たとえば、処理<xref:System.Windows.UIElement.MouseEnter>、 <xref:System.Windows.UIElement.MouseMove>、 <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged></xref:System.Windows.UIElement.IsMouseDirectlyOverChanged> </xref:System.Windows.UIElement.MouseMove> </xref:System.Windows.UIElement.MouseEnter> 。       この要素がマウスをキャプチャする場合に、このプロパティが残ります`true`マウスのキャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。       一部のコントロールは、意図的がマウスに直接関係しない特定の操作上にマウス ポインターをキャプチャします。 IsMouseOver になるようにつながります`true`場合でも、マウスが移動明らかです。      <a name=&quot;dependencyPropertyInfo_IsMouseOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsMouseOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsMouseOverProperty>"
  example:
  - "The following example references this property as the property type of a <xref:System.Windows.Trigger>, part of a \\<Style.Triggers> block. If the mouse is over the control, the control text turns blue and the cursor becomes a hand.  \n  \n [!code-xml[ListViewCheckBox#Trigger](~/add/codesnippet/xaml/p-system.windows.uieleme_12_1.xaml)]\n [!code-xml[ListViewCheckBox#Trigger](~/add/codesnippet/xaml/p-system.windows.uieleme_12_1.xaml)]"
  syntax:
    content: public bool IsMouseOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マウス ポインターが要素またはその子要素の上にある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsMouseOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsMouseOverProperty
  id: IsMouseOverProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsMouseOverProperty
  nameWithType: UIElement.IsMouseOverProperty
  fullName: System.Windows.UIElement.IsMouseOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsMouseOver*>依存関係プロパティ</xref:System.Windows.UIElement.IsMouseOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsMouseOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusCaptured
  id: IsStylusCaptured
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusCaptured
  nameWithType: UIElement.IsStylusCaptured
  fullName: System.Windows.UIElement.IsStylusCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素によってスタイラスがキャプチャされるかどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusCaptured&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsStylusCapturedProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsStylusCapturedProperty>"
  syntax:
    content: public bool IsStylusCaptured { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素がスタイラス キャプチャを持つ場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsStylusCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusCapturedChanged
  id: IsStylusCapturedChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusCapturedChanged
  nameWithType: UIElement.IsStylusCapturedChanged
  fullName: System.Windows.UIElement.IsStylusCapturedChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsStylusCaptured*>この要素でプロパティが変更された</xref:System.Windows.UIElement.IsStylusCaptured*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusCapturedProperty
  id: IsStylusCapturedProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusCapturedProperty
  nameWithType: UIElement.IsStylusCapturedProperty
  fullName: System.Windows.UIElement.IsStylusCapturedProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsStylusCaptured*>依存関係プロパティ</xref:System.Windows.UIElement.IsStylusCaptured*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusCaptureWithin
  id: IsStylusCaptureWithin
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusCaptureWithin
  nameWithType: UIElement.IsStylusCaptureWithin
  fullName: System.Windows.UIElement.IsStylusCaptureWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスをキャプチャするかどうかを決定する値の保持がこの要素または要素の境界とそのビジュアル ツリー内の要素を取得します。 これは、依存関係プロパティです。"
  remarks: "タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Windows Vista でタッチ入力サポート](http://msdn.microsoft.com/en-us/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)と[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusCaptureWithin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsStylusCaptureWithinProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsStylusCaptureWithinProperty>"
  syntax:
    content: public bool IsStylusCaptureWithin { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>この要素または格納されている要素がスタイラス キャプチャを持つ場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsStylusCaptureWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusCaptureWithinChanged
  id: IsStylusCaptureWithinChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusCaptureWithinChanged
  nameWithType: UIElement.IsStylusCaptureWithinChanged
  fullName: System.Windows.UIElement.IsStylusCaptureWithinChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsStylusCaptureWithin*>この要素でプロパティが変更された</xref:System.Windows.UIElement.IsStylusCaptureWithin*>。"
  remarks: "これは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusCaptureWithinProperty
  id: IsStylusCaptureWithinProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusCaptureWithinProperty
  nameWithType: UIElement.IsStylusCaptureWithinProperty
  fullName: System.Windows.UIElement.IsStylusCaptureWithinProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsStylusCaptureWithin*>依存関係プロパティ</xref:System.Windows.UIElement.IsStylusCaptureWithin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusDirectlyOver
  id: IsStylusDirectlyOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusDirectlyOver
  nameWithType: UIElement.IsStylusDirectlyOver
  fullName: System.Windows.UIElement.IsStylusDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスの位置がヒット テストの結果は、要素の構成を考慮に対応しているかどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "異なり<xref:System.Windows.UIElement.IsStylusOver%2A>、のみ、このプロパティは`true`要素の上にスタイラスがある場合</xref:System.Windows.UIElement.IsStylusOver%2A>。 スタイラスが代わりに子要素上、または要素は要素のより深い複合 (ビジュアル ツリー) の一部である場合、このプロパティはなって`false`です。       コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.UIElement.IsStylusOver%2A>代わりにします</xref:System.Windows.UIElement.IsStylusOver%2A>。       この要素がスタイラス キャプチャを持つプロパティは、この場合`true`のキャプチャ時に、このプロパティの値`true`までスタイラスのキャプチャが失われ、その境界上にスタイラスがありません。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusDirectlyOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsStylusDirectlyOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsStylusDirectlyOverProperty>"
  syntax:
    content: public bool IsStylusDirectlyOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スタイラス ポインターがヒット テストと同じ要素結果の上にある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsStylusDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusDirectlyOverChanged
  id: IsStylusDirectlyOverChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusDirectlyOverChanged
  nameWithType: UIElement.IsStylusDirectlyOverChanged
  fullName: System.Windows.UIElement.IsStylusDirectlyOverChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsStylusDirectlyOver*>この要素でプロパティが変更された</xref:System.Windows.UIElement.IsStylusDirectlyOver*>。"
  remarks: "このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusDirectlyOverProperty
  id: IsStylusDirectlyOverProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusDirectlyOverProperty
  nameWithType: UIElement.IsStylusDirectlyOverProperty
  fullName: System.Windows.UIElement.IsStylusDirectlyOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsStylusDirectlyOver*>依存関係プロパティ</xref:System.Windows.UIElement.IsStylusDirectlyOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusOver
  id: IsStylusOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusOver
  nameWithType: UIElement.IsStylusOver
  fullName: System.Windows.UIElement.IsStylusOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスのカーソルがこの要素 (子ビジュアル要素を含む) 上にあるかどうかを示す値を取得します。  これは、依存関係プロパティです。"
  remarks: "この要素にスタイラスのキャプチャがある場合は、このプロパティは返す引き続き`true`スタイラスのキャプチャが失われ、ポインターがその範囲外になるまでです。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_IsStylusOver&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsStylusOverProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsStylusOverProperty>"
  syntax:
    content: public bool IsStylusOver { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>スタイラスのカーソルが要素またはその子要素の上にある場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsStylusOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsStylusOverProperty
  id: IsStylusOverProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsStylusOverProperty
  nameWithType: UIElement.IsStylusOverProperty
  fullName: System.Windows.UIElement.IsStylusOverProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsStylusOver*>依存関係プロパティ</xref:System.Windows.UIElement.IsStylusOver*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsStylusOverProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsVisible
  id: IsVisible
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsVisible
  nameWithType: UIElement.IsVisible
  fullName: System.Windows.UIElement.IsVisible
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素をで表示するかどうかを示す値を取得、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]です。  これは、依存関係プロパティです。"
  remarks: "IsVisible 値の決定は、レイアウトのすべての要因は考慮します。 これに対し、 <xref:System.Windows.UIElement.Visibility%2A>、プログラムによって、要素を表示または非表示の目的は、これは、設定可能なプロパティのみを示します</xref:System.Windows.UIElement.Visibility%2A>。       要素の IsVisible は`false`いない入力イベント (またはコマンド) に参加での操作を行っていないか、メジャーに影響を与えるまたは配置レイアウトのパス、フォーカスを設定していない、タブの順序ではありませんおよびヒット テストで報告されません。 要素とは異なり、ここで<xref:System.Windows.UIElement.IsEnabled%2A>は`false`イベントおよびコマンド、およびヒット テストには参加してこれにフォーカスを設定します</xref:System.Windows.UIElement.IsEnabled%2A>。      <a name=&quot;dependencyPropertyInfo_IsVisible&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.IsVisibleProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.IsVisibleProperty>"
  syntax:
    content: public bool IsVisible { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要素を表示する場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.IsVisible*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsVisibleChanged
  id: IsVisibleChanged
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsVisibleChanged
  nameWithType: UIElement.IsVisibleChanged
  fullName: System.Windows.UIElement.IsVisibleChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生したときの値、<xref:System.Windows.UIElement.IsVisible*>この要素でプロパティが変更された</xref:System.Windows.UIElement.IsVisible*>。"
  remarks: "要素はレイアウト システムの値以外の理由でレンダリングされていない場合、このイベントは発生しませんが、<xref:System.Windows.UIElement.IsVisible%2A>プロパティ</xref:System.Windows.UIElement.IsVisible%2A>。 たとえば、要素には必要ビジュアルが関連付けられていない場合があります。       このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.IsVisibleProperty
  id: IsVisibleProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: IsVisibleProperty
  nameWithType: UIElement.IsVisibleProperty
  fullName: System.Windows.UIElement.IsVisibleProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.IsVisible*>依存関係プロパティ</xref:System.Windows.UIElement.IsVisible*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsVisibleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.KeyDown
  id: KeyDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: KeyDown
  nameWithType: UIElement.KeyDown
  fullName: System.Windows.UIElement.KeyDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスがあるときにキーが押されると発生します。"
  remarks: "キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 KeyDown イベントは使用する低レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>KeyDown が一部になるように、このクラスのイベントを接続されているクラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>。 KeyDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName>。      <a name=&quot;routedEventInfo_KeyDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.KeyDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewKeyDown>.</xref:System.Windows.UIElement.PreviewKeyDown> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.UIElement.KeyDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnKeyDown%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler KeyDown;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.KeyDownEvent
  id: KeyDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: KeyDownEvent
  nameWithType: UIElement.KeyDownEvent
  fullName: System.Windows.UIElement.KeyDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.KeyDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent KeyDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.KeyUp
  id: KeyUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: KeyUp
  nameWithType: UIElement.KeyUp
  fullName: System.Windows.UIElement.KeyUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスがあるときにキーが離されると発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>KeyUp が一部になるように、このクラスのイベントを接続されているクラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>。 KeyUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName>。      <a name=&quot;routedEventInfo_KeyUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.KeyUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewKeyUp>.</xref:System.Windows.UIElement.PreviewKeyUp> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.UIElement.KeyUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnKeyUp%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler KeyUp;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.KeyUpEvent
  id: KeyUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: KeyUpEvent
  nameWithType: UIElement.KeyUpEvent
  fullName: System.Windows.UIElement.KeyUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.KeyUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent KeyUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LayoutUpdated
  id: LayoutUpdated
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LayoutUpdated
  nameWithType: UIElement.LayoutUpdated
  fullName: System.Windows.UIElement.LayoutUpdated
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "さまざまな視覚的な要素のレイアウトに現在関連付けられているときに発生<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>変更します。"
  remarks: "レイアウトの更新は、プロパティの変更、ウィンドウ サイズの変更、または明示的なユーザー要求の結果として発生します。       このメンバーは、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。"
  syntax:
    content: public event EventHandler LayoutUpdated;
    return:
      type: System.EventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostFocus
  id: LostFocus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostFocus
  nameWithType: UIElement.LostFocus
  fullName: System.Windows.UIElement.LostFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素が論理フォーカスを失ったときに発生します。"
  remarks: "フォーカスが意図的に外してメソッド呼び出しを使用しているにもかかわらず直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、キーボード フォーカスは残りますが、および要素の位置、<xref:System.Windows.UIElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します</xref:System.Windows.UIElement.Focus%2A>。       このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.UIElement.IsFocused%2A>からルート内の要素のプロパティが変更される`true`に`false`</xref:System.Windows.UIElement.IsFocused%2A>。       このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。      <a name=&quot;routedEventInfo_LostFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.LostFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.RoutedEventHandler>|     イベントはありません対応するトンネリング</xref:System.Windows.RoutedEventHandler></xref:System.Windows.UIElement.LostFocusEvent>。      -オーバーライド<xref:System.Windows.UIElement.OnLostFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnLostFocus%2A>。"
  syntax:
    content: public event System.Windows.RoutedEventHandler LostFocus;
    return:
      type: System.Windows.RoutedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostFocusEvent
  id: LostFocusEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostFocusEvent
  nameWithType: UIElement.LostFocusEvent
  fullName: System.Windows.UIElement.LostFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.LostFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostKeyboardFocus
  id: LostKeyboardFocus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostKeyboardFocus
  nameWithType: UIElement.LostKeyboardFocus
  fullName: System.Windows.UIElement.LostKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスが離れたときに発生します。"
  remarks: "このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>LostKeyboardFocus が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>。 LostKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_LostKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.LostKeyboardFocusEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>.</xref:System.Windows.UIElement.PreviewLostKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.UIElement.LostKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.UIElement.OnLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnLostKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostKeyboardFocusEvent
  id: LostKeyboardFocusEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostKeyboardFocusEvent
  nameWithType: UIElement.LostKeyboardFocusEvent
  fullName: System.Windows.UIElement.LostKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.LostKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostMouseCapture
  id: LostMouseCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostMouseCapture
  nameWithType: UIElement.LostMouseCapture
  fullName: System.Windows.UIElement.LostMouseCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がマウス キャプチャを失ったときに発生します。"
  remarks: "要素がマウスをキャプチャは、境界外にポインターがあってもマウス入力を受け取ります。 マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。       このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>キャプチャを失った実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>LostMouseCapture が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>。 LostMouseCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_LostMouseCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.LostMouseCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.UIElement.LostMouseCaptureEvent>。      -オーバーライド<xref:System.Windows.UIElement.OnLostMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnLostMouseCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler LostMouseCapture;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostMouseCaptureEvent
  id: LostMouseCaptureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostMouseCaptureEvent
  nameWithType: UIElement.LostMouseCaptureEvent
  fullName: System.Windows.UIElement.LostMouseCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.LostMouseCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostStylusCapture
  id: LostStylusCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostStylusCapture
  nameWithType: UIElement.LostStylusCapture
  fullName: System.Windows.UIElement.LostStylusCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素がスタイラス キャプチャを失ったときに発生します。"
  remarks: "要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。       このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>LostStylusCapture が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>。 LostStylusCapture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName>。      <a name=&quot;routedEventInfo_LostStylusCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.LostStylusCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.UIElement.LostStylusCaptureEvent>。      -オーバーライド<xref:System.Windows.UIElement.OnLostStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnLostStylusCapture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler LostStylusCapture;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostStylusCaptureEvent
  id: LostStylusCaptureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostStylusCaptureEvent
  nameWithType: UIElement.LostStylusCaptureEvent
  fullName: System.Windows.UIElement.LostStylusCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.LostStylusCapture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostTouchCapture
  id: LostTouchCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostTouchCapture
  nameWithType: UIElement.LostTouchCapture
  fullName: System.Windows.UIElement.LostTouchCapture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素は、タッチのキャプチャを失ったときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_LostTouchCapture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.LostTouchCaptureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.UIElement.OnLostTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnLostTouchCapture%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.LostTouchCaptureEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> LostTouchCapture;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.LostTouchCaptureEvent
  id: LostTouchCaptureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: LostTouchCaptureEvent
  nameWithType: UIElement.LostTouchCaptureEvent
  fullName: System.Windows.UIElement.LostTouchCaptureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.LostTouchCapture&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationBoundaryFeedback
  id: ManipulationBoundaryFeedback
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationBoundaryFeedback
  nameWithType: UIElement.ManipulationBoundaryFeedback
  fullName: System.Windows.UIElement.ManipulationBoundaryFeedback
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "操作は、境界を検出したときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_ManipulationBoundaryFeedback&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601> of type <xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>.|</xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent>"
  syntax:
    content: public event EventHandler<System.Windows.Input.ManipulationBoundaryFeedbackEventArgs> ManipulationBoundaryFeedback;
    return:
      type: System.EventHandler{System.Windows.Input.ManipulationBoundaryFeedbackEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  id: ManipulationBoundaryFeedbackEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationBoundaryFeedbackEvent
  nameWithType: UIElement.ManipulationBoundaryFeedbackEvent
  fullName: System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.ManipulationBoundaryFeedback&quot;> </xref>イベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationCompleted
  id: ManipulationCompleted
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationCompleted
  nameWithType: UIElement.ManipulationCompleted
  fullName: System.Windows.UIElement.ManipulationCompleted
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "操作と慣性のときに発生、 <xref href=&quot;System.Windows.UIElement&quot;> </xref>オブジェクトが完了しました。"
  remarks: "このイベントを使用すると、完了時に操作に関する情報を取得します。  たとえば、使用することができます、<xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=fullName>合計量操作の位置を決定するプロパティを変更します</xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=fullName>。       操作の詳細については、次を参照してください。、[入力概要](~/add/includes/ajax-current-ext-md.md)です。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル: 初めて、タッチ アプリケーションの作成](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_ManipulationCompleted&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ManipulationCompletedEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601> of type <xref:System.Windows.Input.ManipulationCompletedEventArgs>.|</xref:System.Windows.Input.ManipulationCompletedEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.ManipulationCompletedEvent>"
  syntax:
    content: public event EventHandler<System.Windows.Input.ManipulationCompletedEventArgs> ManipulationCompleted;
    return:
      type: System.EventHandler{System.Windows.Input.ManipulationCompletedEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationCompletedEvent
  id: ManipulationCompletedEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationCompletedEvent
  nameWithType: UIElement.ManipulationCompletedEvent
  fullName: System.Windows.UIElement.ManipulationCompletedEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.ManipulationCompleted&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ManipulationCompletedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationDelta
  id: ManipulationDelta
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationDelta
  nameWithType: UIElement.ManipulationDelta
  fullName: System.Windows.UIElement.ManipulationDelta
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力デバイス操作中の位置が変更されたときに発生します。"
  remarks: "ManipulationDelta イベントは、ときに、ユーザーがドラッグ指が画面上で操作中に、もう一度慣性が発生したときに、複数回を発生します。  使用することができます、<xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A>慣性中に、イベントが発生しているかどうかを確認するプロパティ</xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A>。       イベントが発生した ManipulationDelta で上にある要素は、イベントが発生したときに任意の方法に影響はありません。  操作される要素にロジックを提供する必要があります。  <xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A>と<xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>のプロパティの型は<xref:System.Windows.Input.ManipulationDelta>操作の位置の変更に関するデータを含む、移動、サイズ変更、またはオブジェクトの回転として解釈されます</xref:System.Windows.Input.ManipulationDelta></xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A></xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A>。  操作される要素には、その情報を適用します。       操作の詳細については、次を参照してください。、[入力概要](~/add/includes/ajax-current-ext-md.md)です。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル: 初めて、タッチ アプリケーションの作成](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_ManipulationDelta&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ManipulationDeltaEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601> of type <xref:System.Windows.Input.ManipulationDeltaEventArgs>.|</xref:System.Windows.Input.ManipulationDeltaEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.ManipulationDeltaEvent>"
  example:
  - "The following example shows an event handler for the ManipulationDelta event. The example uses the <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> property to move, resize, and rotate a <xref:System.Windows.Shapes.Rectangle>.  The example also checks whether the ManipulationDelta event occurred during inertia and whether the rectangle is touching the edge of a window.  If those cases are true, the application stops the manipulation to prevent the rectangle from leaving the visible area of the application. This example is part of a larger example in [Walkthrough: Creating Your First Touch Application](../Topic/Walkthrough:%20Creating%20Your%20First%20Touch%20Application.md).  \n  \n [!code-cs[BasicManipulation#ManipulationDelta](~/add/codesnippet/csharp/basicmanipulation/mainwindow.xaml.cs#manipulationdelta)]\n [!code-vb[BasicManipulation#ManipulationDelta](~/add/codesnippet/visualbasic/basicmanipulation/mainwindow.xaml.vb#manipulationdelta)]"
  syntax:
    content: public event EventHandler<System.Windows.Input.ManipulationDeltaEventArgs> ManipulationDelta;
    return:
      type: System.EventHandler{System.Windows.Input.ManipulationDeltaEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationDeltaEvent
  id: ManipulationDeltaEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationDeltaEvent
  nameWithType: UIElement.ManipulationDeltaEvent
  fullName: System.Windows.UIElement.ManipulationDeltaEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.ManipulationDelta&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ManipulationDeltaEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationInertiaStarting
  id: ManipulationInertiaStarting
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationInertiaStarting
  nameWithType: UIElement.ManipulationInertiaStarting
  fullName: System.Windows.UIElement.ManipulationInertiaStarting
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力デバイスとの接続を失ったときに発生、 <xref href=&quot;System.Windows.UIElement&quot;> </xref>操作と慣性の中にオブジェクトを開始します。"
  remarks: "ManipulationInertiaStarting イベントは、ユーザーが操作中のすべての画面から指を離したときに発生します。 たとえば、ユーザー「をスロー」<xref:System.Windows.UIElement>サーフェス全体で、ユーザーはタッチ<xref:System.Windows.UIElement>アクションを開始する短い距離では、画面上で指を移動し<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>をリリース</xref:System.Windows.UIElement></xref:System.Windows.UIElement> ユーザーは、要素をリリースするときは、慣性開始し、ManipulationInertiaStarting イベントが発生します。  <xref:System.Windows.UIElement>の受信を継続<xref:System.Windows.UIElement.ManipulationDelta>慣性が要素で発生していることを通知するイベントです</xref:System.Windows.UIElement.ManipulationDelta></xref:System.Windows.UIElement>。       このイベントを使用して、慣性の動作を指定することができます。  たとえば、慣性が開始されるときに使用される初期速度を設定できます。  必要な減速を設定するか、目的の配置を設定しても、慣性の量を指定できます。  これらの値 (変換、拡張、または回転) 操作の種類ごとに個別に設定できます。  詳細については、 <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>。</xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>を参照してください。       操作の詳細については、次を参照してください。、[入力概要](~/add/includes/ajax-current-ext-md.md)です。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル: 初めて、タッチ アプリケーションの作成](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_ManipulationInertiaStarting&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ManipulationInertiaStartingEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601> of type <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>.|</xref:System.Windows.Input.ManipulationInertiaStartingEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.ManipulationInertiaStartingEvent>"
  example:
  - "The following example shows the ManipulationInertiaStarting event handler and sets the desired deceleration for translation, expansion, and rotation that is used during inertia. This example is part of a larger example in [Walkthrough: Creating Your First Touch Application](../Topic/Walkthrough:%20Creating%20Your%20First%20Touch%20Application.md).  \n  \n [!code-cs[BasicManipulation#ManipulationInertiaStarting](~/add/codesnippet/csharp/basicmanipulation/mainwindow.xaml.cs#manipulationinertiastarting)]\n [!code-vb[BasicManipulation#ManipulationInertiaStarting](~/add/codesnippet/visualbasic/basicmanipulation/mainwindow.xaml.vb#manipulationinertiastarting)]"
  syntax:
    content: public event EventHandler<System.Windows.Input.ManipulationInertiaStartingEventArgs> ManipulationInertiaStarting;
    return:
      type: System.EventHandler{System.Windows.Input.ManipulationInertiaStartingEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationInertiaStartingEvent
  id: ManipulationInertiaStartingEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationInertiaStartingEvent
  nameWithType: UIElement.ManipulationInertiaStartingEvent
  fullName: System.Windows.UIElement.ManipulationInertiaStartingEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.ManipulationInertiaStarting&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ManipulationInertiaStartingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationStarted
  id: ManipulationStarted
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationStarted
  nameWithType: UIElement.ManipulationStarted
  fullName: System.Windows.UIElement.ManipulationStarted
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力デバイスの操作を開始するときに発生、 <xref href=&quot;System.Windows.UIElement&quot;> </xref>オブジェクト。"
  remarks: "ManipulationStarted イベントが発生した後、<xref:System.Windows.UIElement.ManipulationStarting>イベント</xref:System.Windows.UIElement.ManipulationStarting>。  使用して、次を行うことができます、 <xref:System.Windows.Input.ManipulationStartedEventArgs>: のある操作の位置に対して相対的なを使用して要素を取得、<xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A>プロパティ</xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A></xref:System.Windows.Input.ManipulationStartedEventArgs>。      -を使用して、操作の始点を取得、<xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A>プロパティ</xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A>。      -を呼び出して、操作を取り消す、<xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A>メソッド</xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A>。       操作の詳細については、次を参照してください。、[入力概要](~/add/includes/ajax-current-ext-md.md)です。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル: 初めて、タッチ アプリケーションの作成](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_ManipulationStarted&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ManipulationStartedEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601> of type <xref:System.Windows.Input.ManipulationStartedEventArgs>.|</xref:System.Windows.Input.ManipulationStartedEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.ManipulationStartedEvent>"
  syntax:
    content: public event EventHandler<System.Windows.Input.ManipulationStartedEventArgs> ManipulationStarted;
    return:
      type: System.EventHandler{System.Windows.Input.ManipulationStartedEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationStartedEvent
  id: ManipulationStartedEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationStartedEvent
  nameWithType: UIElement.ManipulationStartedEvent
  fullName: System.Windows.UIElement.ManipulationStartedEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.ManipulationStarted&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ManipulationStartedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationStarting
  id: ManipulationStarting
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationStarting
  nameWithType: UIElement.ManipulationStarting
  fullName: System.Windows.UIElement.ManipulationStarting
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "操作プロセッサが最初に作成したときに発生します。"
  remarks: "ManipulationStarting イベントを持つ要素で発生する、<xref:System.Windows.UIElement.IsManipulationEnabled%2A>プロパティに設定`true`でユーザーが指を配置するときに</xref:System.Windows.UIElement.IsManipulationEnabled%2A> 既定では、後続の操作イベントを持つ要素を基準とした操作の位置をレポート<xref:System.Windows.UIElement.IsManipulationEnabled%2A>&quot;éý&quot; `true`</xref:System.Windows.UIElement.IsManipulationEnabled%2A> 。  設定して別の要素に相対的な位置をする必要がありますを指定することができます、<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>プロパティ</xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>。 たとえば、要素の親を基準とした操作を行うことができます。       ManipulationStarting のイベント ハンドラーでは、次を行うことができます:-ユーザーに設定して、操作を実行する&1; つ以上の本の指が必要かどうかを指定して、<xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=fullName>プロパティ</xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=fullName>。      指定を設定して操作の種類が有効になっている、<xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=fullName>プロパティを<xref:System.Windows.Input.ManipulationModes>列挙体です</xref:System.Windows.Input.ManipulationModes></xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=fullName>。      -1 本指の回転の中心を設定して指定、<xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=fullName>プロパティ</xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=fullName>。      -を呼び出して、操作を取り消す、<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=fullName>メソッド</xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=fullName>。       操作の詳細については、次を参照してください。、[入力概要](~/add/includes/ajax-current-ext-md.md)です。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル: 初めて、タッチ アプリケーションの作成](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_ManipulationStarting&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.ManipulationStartingEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601> of type <xref:System.Windows.Input.ManipulationStartingEventArgs>.|</xref:System.Windows.Input.ManipulationStartingEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.ManipulationStartingEvent>"
  example:
  - "The following example shows the event handler for the ManipulationStarting event and sets the <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> to the parent element that receives the manipulation events so that the coordinates of the manipulation are relative to the parent element.  This example is part of a larger example in [Walkthrough: Creating Your First Touch Application](../Topic/Walkthrough:%20Creating%20Your%20First%20Touch%20Application.md).  \n  \n [!code-cs[BasicManipulation#ManipulationStarting](~/add/codesnippet/csharp/basicmanipulation/mainwindow.xaml.cs#manipulationstarting)]\n [!code-vb[BasicManipulation#ManipulationStarting](~/add/codesnippet/visualbasic/basicmanipulation/mainwindow.xaml.vb#manipulationstarting)]"
  syntax:
    content: public event EventHandler<System.Windows.Input.ManipulationStartingEventArgs> ManipulationStarting;
    return:
      type: System.EventHandler{System.Windows.Input.ManipulationStartingEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ManipulationStartingEvent
  id: ManipulationStartingEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ManipulationStartingEvent
  nameWithType: UIElement.ManipulationStartingEvent
  fullName: System.Windows.UIElement.ManipulationStartingEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.ManipulationStarting&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ManipulationStartingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Measure(System.Windows.Size)
  id: Measure(System.Windows.Size)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Measure(Size)
  nameWithType: UIElement.Measure(Size)
  fullName: System.Windows.UIElement.Measure(Size)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "Updates the <>*> of a <xref href=&quot;System.Windows.UIElement&quot;></xref>.親要素では、このメソッドを呼び出す独自から<> *> レイアウトを再帰的に実装を更新します。 このメソッドを呼び出すと、レイアウト更新の最初のパス (「メジャー」パス) が構成されます。"
  remarks: "レイアウトの配置で計算[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]で構成されていますメジャー呼び出しのおよび<xref:System.Windows.UIElement.Arrange%2A>呼び出します</xref:System.Windows.UIElement.Arrange%2A>。 メジャーの呼び出し中に、要素を使用してそのサイズ要件を決定する`availableSize`入力します。 中に、<xref:System.Windows.UIElement.Arrange%2A>呼び出し、要素のサイズが終了します</xref:System.Windows.UIElement.Arrange%2A>。       `availableSize`無制限にゼロから任意の数を指定できます。 レイアウトに参加している要素は、最小値を返す必要があります<xref:System.Windows.Size>の必要な指定された`availableSize`</xref:System.Windows.Size>。       <xref:System.Windows.UIElement.Arrange%2A>。</xref:System.Windows.UIElement.Arrange%2A>の前にメジャー呼び出しを常に受信レイアウトが最初にインスタンス化されるとき ただし、最初のレイアウト パスに受け取ることがあります、<xref:System.Windows.UIElement.Arrange%2A>メジャーせずに呼び出す以外の場合のみに影響を与えるプロパティ<xref:System.Windows.UIElement.Arrange%2A>(配置) などが変更された親を受け取ったとき、または、<xref:System.Windows.UIElement.Arrange%2A>メジャーなし</xref:System.Windows.UIElement.Arrange%2A></xref:System.Windows.UIElement.Arrange%2A></xref:System.Windows.UIElement.Arrange%2A>。 メジャーの呼び出しが自動的に無効になり、<xref:System.Windows.UIElement.Arrange%2A>呼び出します</xref:System.Windows.UIElement.Arrange%2A>。       レイアウトの更新は、あらゆるレイアウトの変更のメイン スレッドが待機していないように、非同期的に発生します。 分離コードのプロパティの値のチェックを使用して要素のクエリを実行しても、そのサイズ変更、またはレイアウトの特性を持つ対話プロパティへの変更がすぐに反映可能性がありますされない (、<xref:System.Windows.FrameworkElement.Width%2A>プロパティなど).</xref:System.Windows.FrameworkElement.Width%2A>      > [!NOTE] > を使用してレイアウトの更新を強制することができます、<xref:System.Windows.UIElement.UpdateLayout%2A>メソッド</xref:System.Windows.UIElement.UpdateLayout%2A>。 ただし、このメソッドを呼び出すことは通常必要はありません、パフォーマンスの低下が発生することができます。       レイアウト システムはメジャー用と<xref:System.Windows.UIElement.Arrange%2A>。</xref:System.Windows.UIElement.Arrange%2A>の無効なレイアウトの&2; つの異なるキュー レイアウトのキューはレイアウトを実行する要素のビジュアル ツリー内の要素の順序に基づいて並べ替えられますツリーの上位の要素は、親の変更を繰り返すことによって、冗長なレイアウトを避けるために、キューの上部にあるがします。 重複するエントリは、キューから自動的に削除され、レイアウト検証はすでに要素も、キューから自動的に削除します。       レイアウトを更新するときに、メジャー キューが空に最初に、続けて、<xref:System.Windows.UIElement.Arrange%2A>キュー</xref:System.Windows.UIElement.Arrange%2A> 。 内の要素、<xref:System.Windows.UIElement.Arrange%2A>メジャー キュー内の要素がある場合、キューは配置されません</xref:System.Windows.UIElement.Arrange%2A>。"
  syntax:
    content: public void Measure (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "使用可能な領域は親要素が子要素を割り当てることができます。 子要素は、新機能が利用できるよりも大きな空間を要求できます。スクロール可能な場合は、現在の要素のコンテンツ モデルでは、指定されたサイズを対応可能性があります。"
  overload: System.Windows.UIElement.Measure*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MeasureCore(System.Windows.Size)
  id: MeasureCore(System.Windows.Size)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MeasureCore(Size)
  nameWithType: UIElement.MeasureCore(Size)
  fullName: System.Windows.UIElement.MeasureCore(Size)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされるの任意の子要素の内容のサイズも考慮して、この要素を適切にサイズ調整測定ロジックを提供します。"
  remarks: "一般的<xref:System.Windows.FrameworkElement>ではなく<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement></xref:System.Windows.FrameworkElement>から要素を派生させる 派生する場合<xref:System.Windows.FrameworkElement>、なおで MeasureCore のオーバーライド<xref:System.Windows.FrameworkElement>MeasureCore メソッドをシールします</xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement>。 したがって、のみをオーバーライドする MeasureCore <xref:System.Windows.UIElement> <xref:System.Windows.FrameworkElement>。</xref:System.Windows.FrameworkElement>が含まれていない、継承によって</xref:System.Windows.UIElement>から派生した場合は、レイアウトのメジャーの特性を変更するための手段として これがある場合、独自の実装を構築しようとしている場合、[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]コア レベル。 それ以外の場合から派生した<xref:System.Windows.FrameworkElement>、メジャーの動作の実装のテンプレートは、<xref:System.Windows.FrameworkElement>の実装<xref:System.Windows.FrameworkElement.MeasureOverride%2A>。</xref:System.Windows.FrameworkElement.MeasureOverride%2A> </xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement> 。       子要素を含む親要素を呼び出す必要があります<xref:System.Windows.UIElement.Measure%2A>、それぞれの子にそれ以外の場合これらの子要素またはされていないサイズの配置とはレイアウトから効果的に表示されなくなります</xref:System.Windows.UIElement.Measure%2A>。"
  example:
  - "A typical override of MeasureCore follows this approximate pattern (there is not a built-in collection called `VisualChildren`; `VisualChildren` is a  placeholder that represents whatever child collection your element maintains).  \n  \n [!code-cs[CorePseudocode#UIElementMeasureOverride](~/add/codesnippet/csharp/CorePseudocode/corepseudocode.cs#uielementmeasureoverride)]\n [!code-vb[CorePseudocode#UIElementMeasureOverride](~/add/codesnippet/visualbasic/corepseudocode/corepseudocode.vb#uielementmeasureoverride)]  \n  \n-   You must call <xref:System.Windows.UIElement.Measure%2A> on each child element.  \n  \n-   Generally, your implementation should cache measurement information between the MeasureCore and <xref:System.Windows.UIElement.ArrangeCore%2A> method calls in the same element.  \n  \n-   Calling base implementations of MeasureCore is not required, but might be appropriate if the base implementation provides a desired layout capability.  \n  \n-   Calls to <xref:System.Windows.UIElement.Measure%2A> on child elements should pass either the same `availableSize` as the parent, or a subset of the area, depending on the type of layout the parent element supports. For example, it would be valid to remove the area for an element-specific border or padding, a scrollbar, or a custom control."
  syntax:
    content: protected virtual System.Windows.Size MeasureCore (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "親要素が子に割り当てることが使用可能なサイズです。"
    return:
      type: System.Windows.Size
      description: "この要素のレイアウトでの目的のサイズ。"
  overload: System.Windows.UIElement.MeasureCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseDown
  id: MouseDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseDown
  nameWithType: UIElement.MouseDown
  fullName: System.Windows.UIElement.MouseDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にポインターが、任意のマウス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>MouseDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 MouseDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。       いずれかと共に MouseDown イベントが発生した多くの場合、<xref:System.Windows.UIElement.MouseLeftButtonDown>または<xref:System.Windows.UIElement.MouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応する</xref:System.Windows.UIElement.MouseRightButtonDown></xref:System.Windows.UIElement.MouseLeftButtonDown>。 <xref:System.Windows.UIElement.MouseLeftButtonDown><xref:System.Windows.UIElement.MouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.UIElement.MouseRightButtonDown>。</xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonDown>または<xref:System.Windows.UIElement.MouseRightButtonDown>。</xref:System.Windows.UIElement.MouseRightButtonDown></xref:System.Windows.UIElement.MouseLeftButtonDown>の「解説」を参照してください      > [!IMPORTANT] > 一部のコントロールは、固有のクラスのマウス ボタンのイベント処理を必要があります。 イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します</xref:System.Windows.Input.Mouse>。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。       前の「重要に記載されているしマウスの左ボタンを押すをこれらのソリューションのいずれかを使用処理するクラスを持つ派生クラスでイベント MouseDown イベントいる問題を解決することができます:-ハンドラーのアタッチ、<xref:System.Windows.UIElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント</xref:System.Windows.UIElement.PreviewMouseDown>。 これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。      ハンドラーを登録コントロールの手続きを呼び出して<xref:System.Windows.UIElement.AddHandler%2A>により、ルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンするハンドラーの署名オプションを選択します</xref:System.Windows.UIElement.AddHandler%2A>。      <a name=&quot;routedEventInfo_MouseDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewMouseDown>.</xref:System.Windows.UIElement.PreviewMouseDown> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.UIElement.MouseDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseDown%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseDownEvent
  id: MouseDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseDownEvent
  nameWithType: UIElement.MouseDownEvent
  fullName: System.Windows.UIElement.MouseDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseEnter
  id: MouseEnter
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseEnter
  nameWithType: UIElement.MouseEnter
  fullName: System.Windows.UIElement.MouseEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素の境界に入ったときに発生します。"
  remarks: "MouseEnter は、直接のイベントを処理ルーティング方法を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       MouseEnter を追跡、マウス ポインターが要素の境界に入ったときに、このイベントよりリテラルを報告している、<xref:System.Windows.UIElement.IsMouseOver%2A>からプロパティ値が変更された`false`に`true`この要素上です</xref:System.Windows.UIElement.IsMouseOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>MouseEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>。 MouseEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName>。       A <xref:System.Windows.Controls.Button>(または any<xref:System.Windows.Controls.Primitives.ButtonBase>派生クラス) は<xref:System.Windows.UIElement.KeyDown>、ボタンにフォーカスおよび押されたキーは、容量バーしたときにイベント</xref:System.Windows.UIElement.KeyDown>の処理をネイティブ</xref:System.Windows.Controls.Primitives.ButtonBase></xref:System.Windows.Controls.Button> ネイティブの処理が発生し、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント ソースとして、ボタンも移動するにマウス ポインターがない場合でも、マウスをキャプチャし、</xref:System.Windows.Controls.Primitives.ButtonBase.Click> 。 マウスのキャプチャの結果として、MouseEnter もイベントはボタンで、ソースとして。 一般に、要素がマウスをキャプチャする場合は、MouseEnter が発生、だけでなく<xref:System.Windows.UIElement.GotMouseCapture>およびその他のコントロールに固有のイベント可能性があります</xref:System.Windows.UIElement.GotMouseCapture>。      <a name=&quot;routedEventInfo_MouseEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseEnterEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnMouseEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseEnter%2A></xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.UIElement.MouseEnterEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler MouseEnter;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseEnterEvent
  id: MouseEnterEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseEnterEvent
  nameWithType: UIElement.MouseEnterEvent
  fullName: System.Windows.UIElement.MouseEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseLeave
  id: MouseLeave
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseLeave
  nameWithType: UIElement.MouseLeave
  fullName: System.Windows.UIElement.MouseLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素の境界から出たときに発生します。"
  remarks: "MouseLeave は、直接のイベントを処理ルーティング方法を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       MouseLeave を追跡、マウスが要素を離れると、このイベントよりリテラルを報告している、<xref:System.Windows.UIElement.IsMouseOver%2A>からプロパティ値が変更された`true`に`false`この要素上です</xref:System.Windows.UIElement.IsMouseOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>MouseLeave が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>。 MouseLeave イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName>。      <a name=&quot;routedEventInfo_MouseLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseLeaveEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnMouseLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseLeave%2A></xref:System.Windows.Input.MouseEventHandler></xref:System.Windows.UIElement.MouseLeaveEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler MouseLeave;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseLeaveEvent
  id: MouseLeaveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseLeaveEvent
  nameWithType: UIElement.MouseLeaveEvent
  fullName: System.Windows.UIElement.MouseLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseLeftButtonDown
  id: MouseLeftButtonDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseLeftButtonDown
  nameWithType: UIElement.MouseLeftButtonDown
  fullName: System.Windows.UIElement.MouseLeftButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが押されたときに発生します。"
  remarks: "要素ツリーを通じてバブルのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 処理 MouseLeftButtonDown をマークする場合は、マークしている本質的に<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 これは、可能性のある<xref:System.Windows.Controls.Control.MouseDoubleClick>。</xref:System.Windows.Controls.Control.MouseDoubleClick>などのクラス ハンドラーが生成されたイベントが含まれています       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      > [!IMPORTANT] > 一部のコントロール クラスに固有のクラスのマウス ボタンのイベント処理を必要があります。 イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します</xref:System.Windows.Input.Mouse>。 イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。       前の「重要に記載されているしマウスの左ボタンを押すをこれらのソリューションのいずれかを使用処理するクラスを持つ派生クラスでイベント MouseLeftButtonDown イベントいる問題を解決することができます:-ハンドラーのアタッチ、<xref:System.Windows.UIElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント</xref:System.Windows.UIElement.PreviewMouseDown>。 これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。      ハンドラーを登録コントロールの手続きを呼び出して<xref:System.Windows.UIElement.AddHandler%2A>により、ルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンするハンドラーの署名オプションを選択します</xref:System.Windows.UIElement.AddHandler%2A>。      <a name=&quot;routedEventInfo_MouseLeftButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseLeftButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.MouseLeftButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseLeftButtonDownEvent
  id: MouseLeftButtonDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseLeftButtonDownEvent
  nameWithType: UIElement.MouseLeftButtonDownEvent
  fullName: System.Windows.UIElement.MouseLeftButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseLeftButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseLeftButtonUp
  id: MouseLeftButtonUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseLeftButtonUp
  nameWithType: UIElement.MouseLeftButtonUp
  fullName: System.Windows.UIElement.MouseLeftButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが離されたときに発生します。"
  remarks: "要素ツリーを通じてバブルのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 処理 MouseLeftButtonUp をマークする場合は、マークしている本質的に<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_MouseLeftButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseLeftButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.MouseLeftButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseLeftButtonUpEvent
  id: MouseLeftButtonUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseLeftButtonUpEvent
  nameWithType: UIElement.MouseLeftButtonUpEvent
  fullName: System.Windows.UIElement.MouseLeftButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseLeftButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseMove
  id: MouseMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseMove
  nameWithType: UIElement.MouseMove
  fullName: System.Windows.UIElement.MouseMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上にマウス ポインターが移動したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>MouseMove が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>。 MouseMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName>。      <a name=&quot;routedEventInfo_MouseMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewMouseMove>.</xref:System.Windows.UIElement.PreviewMouseMove> </xref:System.Windows.Input.MouseEventHandler> </xref:System.Windows.UIElement.MouseMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseMove%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler MouseMove;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseMoveEvent
  id: MouseMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseMoveEvent
  nameWithType: UIElement.MouseMoveEvent
  fullName: System.Windows.UIElement.MouseMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseRightButtonDown
  id: MouseRightButtonDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseRightButtonDown
  nameWithType: UIElement.MouseRightButtonDown
  fullName: System.Windows.UIElement.MouseRightButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが押されたときに発生します。"
  remarks: "要素ツリーを通じてバブルのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 処理 MouseRightButtonDown をマークする場合は、マークしている本質的に<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。 これは、可能性のある<xref:System.Windows.Controls.Control.MouseDoubleClick>。</xref:System.Windows.Controls.Control.MouseDoubleClick>などのクラス ハンドラーが生成されたイベントが含まれています       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>       右ボタンをマウス イベントは、アプリケーション シナリオでネイティブの処理を頻繁にあります。 たとえば、マウスの右ボタンを押すは、コンテキスト メニューを表示する可能性があります。 参照してください[ContextMenu 概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_MouseRightButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseRightButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseRightButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.MouseRightButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseRightButtonDownEvent
  id: MouseRightButtonDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseRightButtonDownEvent
  nameWithType: UIElement.MouseRightButtonDownEvent
  fullName: System.Windows.UIElement.MouseRightButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseRightButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseRightButtonUp
  id: MouseRightButtonUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseRightButtonUp
  nameWithType: UIElement.MouseRightButtonUp
  fullName: System.Windows.UIElement.MouseRightButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが離されたときに発生します。"
  remarks: "要素ツリーを通じてバブルのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 処理 MouseRightButtonUp をマークする場合は、マークしている本質的に<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_MouseRightButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseRightButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseRightButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.MouseRightButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseRightButtonUpEvent
  id: MouseRightButtonUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseRightButtonUpEvent
  nameWithType: UIElement.MouseRightButtonUpEvent
  fullName: System.Windows.UIElement.MouseRightButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseRightButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseUp
  id: MouseUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseUp
  nameWithType: UIElement.MouseUp
  fullName: System.Windows.UIElement.MouseUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上で任意のマウス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>MouseUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。 MouseUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。       いずれかと共に MouseUp イベントが発生した多くの場合、<xref:System.Windows.UIElement.MouseLeftButtonUp>または<xref:System.Windows.UIElement.MouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのリリースに対応する</xref:System.Windows.UIElement.MouseRightButtonUp></xref:System.Windows.UIElement.MouseLeftButtonUp>。 <xref:System.Windows.UIElement.MouseLeftButtonUp><xref:System.Windows.UIElement.MouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.UIElement.MouseRightButtonUp>。</xref:System.Windows.UIElement.MouseLeftButtonUp> <xref:System.Windows.UIElement.MouseLeftButtonUp>または<xref:System.Windows.UIElement.MouseRightButtonUp>。</xref:System.Windows.UIElement.MouseRightButtonUp></xref:System.Windows.UIElement.MouseLeftButtonUp>の「解説」を参照してください      <a name=&quot;routedEventInfo_MouseUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewMouseUp>.</xref:System.Windows.UIElement.PreviewMouseUp> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.UIElement.MouseUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseUp%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler MouseUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseUpEvent
  id: MouseUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseUpEvent
  nameWithType: UIElement.MouseUpEvent
  fullName: System.Windows.UIElement.MouseUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseWheel
  id: MouseWheel
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseWheel
  nameWithType: UIElement.MouseWheel
  fullName: System.Windows.UIElement.MouseWheel
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にマウス ポインターが、ユーザーがマウスのホイールを回転させるときに発生します。"
  remarks: "フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。このため、対象を絞ったまたはキャプチャした要素からマウス ホイールのイベントを受信する場合、マウス ポインター実際にあります別の要素上です。       このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>マウス ホイールが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>。 マウス ホイールのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName>。      <a name=&quot;routedEventInfo_MouseWheel&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.MouseWheelEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.MouseWheelEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewMouseWheel>.</xref:System.Windows.UIElement.PreviewMouseWheel> </xref:System.Windows.Input.MouseWheelEventHandler> </xref:System.Windows.UIElement.MouseWheelEvent>      -オーバーライド<xref:System.Windows.UIElement.OnMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnMouseWheel%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseWheelEventHandler MouseWheel;
    return:
      type: System.Windows.Input.MouseWheelEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MouseWheelEvent
  id: MouseWheelEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MouseWheelEvent
  nameWithType: UIElement.MouseWheelEvent
  fullName: System.Windows.UIElement.MouseWheelEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.MouseWheel&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent MouseWheelEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: UIElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.UIElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素から別の要素にフォーカスを移動しようとしています。 ガイダンスの方向になり、この要素のビジュアルの親の組織内で解釈されますが、フォーカスを移動する方向を指定します。"
  remarks: "このメソッドの戻り値を確認してください。 戻り値の`false`コントロールの構成で定義されているタブ ストップの検査を実行し、走査の各要求はラップを要求していないかどうかに返される可能性があります。"
  syntax:
    content: public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "走査の各要求を視覚的に移動する既存のタブ オーダーまたはを方向で走査するモードにはいずれかを示すプロパティが含まれています。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要求された検査が実行された場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  id: OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnAccessKey(AccessKeyEventArgs)
  nameWithType: UIElement.OnAccessKey(AccessKeyEventArgs)
  fullName: System.Windows.UIElement.OnAccessKey(AccessKeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "呼び出されるときはこの要素の意味のあるアクセス キーのクラス処理を提供します。"
  remarks: "実際の AccessKey イベントではありません、<xref:System.Windows.UIElement>クラス、または別の場所を上げたり下げたりするアタッチするハンドラーのデータ型</xref:System.Windows.UIElement> 専用マネージャー クラスを使用して、イベントの代わりに、発生元が<xref:System.Windows.Input.AccessKeyManager>、後に入力モデル全体に適用されるアクセス キーを検索するすべての入力を処理する</xref:System.Windows.Input.AccessKeyManager>。"
  syntax:
    content: protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.AccessKeyEventArgs
      description: "アクセス キー イベントをイベントのデータ。 イベント データ レポートがどのキーが呼び出され、指定するかどうか、 <xref href=&quot;System.Windows.Input.AccessKeyManager&quot;> </xref>これらのイベントの送信を制御するオブジェクトが他の要素にもこのアクセス キーの呼び出しを送信します。"
  overload: System.Windows.UIElement.OnAccessKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  id: OnChildDesiredSizeChanged(System.Windows.UIElement)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnChildDesiredSizeChanged(UIElement)
  nameWithType: UIElement.OnChildDesiredSizeChanged(UIElement)
  fullName: System.Windows.UIElement.OnChildDesiredSizeChanged(UIElement)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "子要素がサイズ変更されると、レイアウトの動作をサポートしています。"
  remarks: "このメソッドは通常、アプリケーション コードで呼び出されません。 公開されるため、独自のレイアウトが無効な可能性のある状態でのクラスで、派生した要素を確認します。 クラスでは、子要素にサイズ変更に基づき、レイアウト パスの処理時間を最小限に抑えるの最適化を試みることもなります。 例の派生した要素クラス OnChildDesiredSizeChanged を実装する、<xref:System.Windows.Controls.Grid>コントロール</xref:System.Windows.Controls.Grid>。"
  syntax:
    content: protected virtual void OnChildDesiredSizeChanged (System.Windows.UIElement child);
    parameters:
    - id: child
      type: System.Windows.UIElement
      description: "サイズが変更される子要素。"
  overload: System.Windows.UIElement.OnChildDesiredSizeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnCreateAutomationPeer
  id: OnCreateAutomationPeer
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnCreateAutomationPeer()
  nameWithType: UIElement.OnCreateAutomationPeer()
  fullName: System.Windows.UIElement.OnCreateAutomationPeer()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "特定のクラスを返します<xref href=&quot;System.Windows.Automation.Peers.AutomationPeer&quot;></xref>の実装、[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]インフラストラクチャです。"
  syntax:
    content: protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();
    parameters: []
    return:
      type: System.Windows.Automation.Peers.AutomationPeer
      description: "型固有<xref href=&quot;System.Windows.Automation.Peers.AutomationPeer&quot;></xref>実装します。"
  overload: System.Windows.UIElement.OnCreateAutomationPeer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  id: OnDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnDragEnter(DragEventArgs)
  nameWithType: UIElement.OnDragEnter(DragEventArgs)
  fullName: System.Windows.UIElement.OnDragEnter(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDragEnter (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnDragEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  id: OnDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnDragLeave(DragEventArgs)
  nameWithType: UIElement.OnDragLeave(DragEventArgs)
  fullName: System.Windows.UIElement.OnDragLeave(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragLeave?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDragLeave (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnDragLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  id: OnDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnDragOver(DragEventArgs)
  nameWithType: UIElement.OnDragOver(DragEventArgs)
  fullName: System.Windows.UIElement.OnDragOver(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragOver?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDragOver (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnDragOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  id: OnDrop(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnDrop(DragEventArgs)
  nameWithType: UIElement.OnDrop(DragEventArgs)
  fullName: System.Windows.UIElement.OnDrop(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnDrop (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnDrop*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  id: OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: UIElement.OnGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.UIElement.OnGiveFeedback(GiveFeedbackEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.GiveFeedback?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);
    parameters:
    - id: e
      type: System.Windows.GiveFeedbackEventArgs
      description: "<xref href=&quot;System.Windows.GiveFeedbackEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnGiveFeedback*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: UIElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.UIElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生させる、 <xref href=&quot;System.Windows.UIElement.GotFocus&quot;> </xref>渡されたイベント データを使用して、ルーティングされたイベント。"
  remarks: "This method, although virtual, does have a default implementation that raises the event.  \n  \n This On* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.UIElement.IsFocused%2A> property value changes. The OnGotFocus implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] On\\* implementations, which only provide a convenient way to add class handling for that event."
  syntax:
    content: protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "A <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納します。 このイベント データの識別子を含める必要があります、 <xref href=&quot;System.Windows.UIElement.GotFocus&quot;> </xref>イベント。"
  overload: System.Windows.UIElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnGotKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  id: OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnGotMouseCapture(MouseEventArgs)
  nameWithType: UIElement.OnGotMouseCapture(MouseEventArgs)
  fullName: System.Windows.UIElement.OnGotMouseCapture(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnGotMouseCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  id: OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnGotStylusCapture(StylusEventArgs)
  nameWithType: UIElement.OnGotStylusCapture(StylusEventArgs)
  fullName: System.Windows.UIElement.OnGotStylusCapture(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnGotStylusCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  id: OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnGotTouchCapture(TouchEventArgs)
  nameWithType: UIElement.OnGotTouchCapture(TouchEventArgs)
  fullName: System.Windows.UIElement.OnGotTouchCapture(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.UIElement.GotTouchCapture&quot;> </xref>タッチがこの要素にキャプチャされるときに発生するイベントをルーティングします。"
  remarks: "OnGotTouchCapture メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnGotTouchCapture、<xref:System.Windows.UIElement.GotTouchCapture>イベント</xref:System.Windows.UIElement.GotTouchCapture>。 必ずメソッドを呼び出して、基底クラスの OnGotTouchCapture 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnGotTouchCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.IsKeyboardFocusedChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsKeyboardFocused%2A>依存関係プロパティの変更</xref:System.Windows.UIElement.IsKeyboardFocused%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.UIElement.IsKeyboardFocusedChanged>。 注意して、<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>イベントは、ルーティングされたイベントではありません</xref:System.Windows.UIElement.IsKeyboardFocusedChanged>。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsKeyboardFocusedChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "直前に呼び出される、 <xref href=&quot;System.Windows.UIElement.IsKeyboardFocusWithinChanged&quot;> </xref>イベントは、この要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>依存関係プロパティの変更</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>。 注意して、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>イベントは、ルーティングされたイベントではありません</xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "A <xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsKeyboardFocusWithinChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.IsMouseCapturedChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsMouseCaptured%2A>依存関係プロパティの値が変更します</xref:System.Windows.UIElement.IsMouseCaptured%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.UIElement.IsMouseCapturedChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.UIElement.IsMouseCapturedChanged>。 <xref:System.Windows.UIElement.IsMouseCapturedChanged>イベントが; ルーティングされたイベントではないことに注意してください。そのため、できませんとしてマークする、クラス ハンドラーで処理します</xref:System.Windows.UIElement.IsMouseCapturedChanged>。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsMouseCapturedChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.IsMouseCaptureWithinChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  syntax:
    content: protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "A <xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsMouseCaptureWithinChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.IsMouseDirectlyOverChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsMouseDirectlyOver%2A>依存関係プロパティの値が変更します</xref:System.Windows.UIElement.IsMouseDirectlyOver%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>。 注意して、<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>イベントは、ルーティングされたイベントではありません</xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsMouseDirectlyOverChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.IsStylusCapturedChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsStylusCaptured%2A>依存関係プロパティの値が変更します</xref:System.Windows.UIElement.IsStylusCaptured%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.UIElement.IsStylusCapturedChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.UIElement.IsStylusCapturedChanged>。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "A <xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsStylusCapturedChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.IsStylusCaptureWithinChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsStylusCaptureWithin%2A>依存関係プロパティの値が変更します</xref:System.Windows.UIElement.IsStylusCaptureWithin%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.UIElement.IsStylusCaptureWithinChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.UIElement.IsStylusCaptureWithinChanged>。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsStylusCaptureWithinChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.IsStylusDirectlyOverChanged&quot;></xref>イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsStylusDirectlyOver%2A>依存関係プロパティの値が変更します</xref:System.Windows.UIElement.IsStylusDirectlyOver%2A>。 仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。 続いて、<xref:System.Windows.UIElement.IsStylusDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します</xref:System.Windows.UIElement.IsStylusDirectlyOverChanged>。 イベントがルーティングされたイベントではないことに注意してください。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。       このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。"
  syntax:
    content: protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "<xref href=&quot;System.Windows.DependencyPropertyChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnIsStylusDirectlyOverChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  id: OnKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnKeyDown(KeyEventArgs)
  nameWithType: UIElement.OnKeyDown(KeyEventArgs)
  fullName: System.Windows.UIElement.OnKeyDown(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Keystrokes are handled by a dedicated input manager. Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke. If these input system features mark the event as handled, then OnKeyDown is not invoked.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnKeyDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  id: OnKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnKeyUp(KeyEventArgs)
  nameWithType: UIElement.OnKeyUp(KeyEventArgs)
  fullName: System.Windows.UIElement.OnKeyUp(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Keystrokes are handled by a dedicated input manager. Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke. If these input system features mark the event as handled, then OnKeyUp is not invoked.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnKeyUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  id: OnLostFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnLostFocus(RoutedEventArgs)
  nameWithType: UIElement.OnLostFocus(RoutedEventArgs)
  fullName: System.Windows.UIElement.OnLostFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "発生させる、 <xref href=&quot;System.Windows.UIElement.LostFocus&quot;> </xref>提供されているイベント データを使用して、ルーティングされたイベント。"
  remarks: "This method, although virtual, does have a default implementation that raises the event.  \n  \n This On* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.UIElement.IsFocused%2A> property value changes. This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] On\\* implementations, which only provide a convenient way to add class handling for that event."
  syntax:
    content: protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "A <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納します。 このイベント データの識別子を含める必要があります、 <xref href=&quot;System.Windows.UIElement.LostFocus&quot;> </xref>イベント。"
  overload: System.Windows.UIElement.OnLostFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnLostKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  id: OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnLostMouseCapture(MouseEventArgs)
  nameWithType: UIElement.OnLostMouseCapture(MouseEventArgs)
  fullName: System.Windows.UIElement.OnLostMouseCapture(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnLostMouseCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  id: OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnLostStylusCapture(StylusEventArgs)
  nameWithType: UIElement.OnLostStylusCapture(StylusEventArgs)
  fullName: System.Windows.UIElement.OnLostStylusCapture(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnLostStylusCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  id: OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnLostTouchCapture(TouchEventArgs)
  nameWithType: UIElement.OnLostTouchCapture(TouchEventArgs)
  fullName: System.Windows.UIElement.OnLostTouchCapture(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.UIElement.LostTouchCapture&quot;> </xref>ルーティング イベントにこの要素は、タッチのキャプチャを失ったときに発生します。"
  remarks: "OnLostTouchCapture メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnLostTouchCapture、<xref:System.Windows.UIElement.LostTouchCapture>イベント</xref:System.Windows.UIElement.LostTouchCapture>。 必ずメソッドを呼び出して、基底クラスの OnLostTouchCapture 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnLostTouchCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  id: OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  nameWithType: UIElement.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  fullName: System.Windows.UIElement.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ときに呼び出されます、 <xref href=&quot;System.Windows.UIElement.ManipulationBoundaryFeedback&quot;> </xref>イベントが発生します。"
  remarks: "OnManipulationBoundaryFeedback メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnManipulationBoundaryFeedback、<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>イベント</xref:System.Windows.UIElement.ManipulationBoundaryFeedback>。 必ずメソッドを呼び出して、OnManipulationBoundaryFeedback 基底クラスの基本クラスは、イベントを受け取るようにしてください。"
  syntax:
    content: protected virtual void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
      description: "イベントのデータ。"
  overload: System.Windows.UIElement.OnManipulationBoundaryFeedback*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  id: OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnManipulationCompleted(ManipulationCompletedEventArgs)
  nameWithType: UIElement.OnManipulationCompleted(ManipulationCompletedEventArgs)
  fullName: System.Windows.UIElement.OnManipulationCompleted(ManipulationCompletedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ときに呼び出されます、 <xref href=&quot;System.Windows.UIElement.ManipulationCompleted&quot;> </xref>イベントが発生します。"
  remarks: "OnManipulationCompleted メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnManipulationCompleted、<xref:System.Windows.UIElement.ManipulationCompleted>イベント</xref:System.Windows.UIElement.ManipulationCompleted>。 必ずメソッドを呼び出して、OnManipulationCompleted 基底クラスの基本クラスは、イベントを受け取るようにしてください。"
  syntax:
    content: protected virtual void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationCompletedEventArgs
      description: "イベントのデータ。"
  overload: System.Windows.UIElement.OnManipulationCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  id: OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnManipulationDelta(ManipulationDeltaEventArgs)
  nameWithType: UIElement.OnManipulationDelta(ManipulationDeltaEventArgs)
  fullName: System.Windows.UIElement.OnManipulationDelta(ManipulationDeltaEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ときに呼び出されます、 <xref href=&quot;System.Windows.UIElement.ManipulationDelta&quot;> </xref>イベントが発生します。"
  remarks: "OnManipulationDelta メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnManipulationDelta、<xref:System.Windows.UIElement.ManipulationDelta>イベント</xref:System.Windows.UIElement.ManipulationDelta>。 必ずメソッドを呼び出して、OnManipulationDelta 基底クラスの基本クラスは、イベントを受け取るようにしてください。"
  syntax:
    content: protected virtual void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationDeltaEventArgs
      description: "イベントのデータ。"
  overload: System.Windows.UIElement.OnManipulationDelta*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  id: OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)
  nameWithType: UIElement.OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)
  fullName: System.Windows.UIElement.OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ときに呼び出されます、 <xref href=&quot;System.Windows.UIElement.ManipulationInertiaStarting&quot;> </xref>イベントが発生します。"
  remarks: "OnManipulationInertiaStarting メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnManipulationInertiaStarting、<xref:System.Windows.UIElement.ManipulationInertiaStarting>イベント</xref:System.Windows.UIElement.ManipulationInertiaStarting>。 必ずメソッドを呼び出して、OnManipulationInertiaStarting 基底クラスの基本クラスは、イベントを受け取るようにしてください。"
  syntax:
    content: protected virtual void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationInertiaStartingEventArgs
      description: "イベントのデータ。"
  overload: System.Windows.UIElement.OnManipulationInertiaStarting*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  id: OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnManipulationStarted(ManipulationStartedEventArgs)
  nameWithType: UIElement.OnManipulationStarted(ManipulationStartedEventArgs)
  fullName: System.Windows.UIElement.OnManipulationStarted(ManipulationStartedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ときに呼び出されます、 <xref href=&quot;System.Windows.UIElement.ManipulationStarted&quot;> </xref>イベントが発生します。"
  remarks: "OnManipulationStarted メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnManipulationStarted、<xref:System.Windows.UIElement.ManipulationStarted>イベント</xref:System.Windows.UIElement.ManipulationStarted>。 必ずメソッドを呼び出して、OnManipulationStarted 基底クラスの基本クラスは、イベントを受け取るようにしてください。"
  syntax:
    content: protected virtual void OnManipulationStarted (System.Windows.Input.ManipulationStartedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationStartedEventArgs
      description: "イベントのデータ。"
  overload: System.Windows.UIElement.OnManipulationStarted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  id: OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnManipulationStarting(ManipulationStartingEventArgs)
  nameWithType: UIElement.OnManipulationStarting(ManipulationStartingEventArgs)
  fullName: System.Windows.UIElement.OnManipulationStarting(ManipulationStartingEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.UIElement.ManipulationStarting&quot;> </xref>操作プロセッサは最初、するときに発生するルーティング イベントを作成します。"
  remarks: "OnManipulationStarting メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnManipulationStarting、<xref:System.Windows.UIElement.ManipulationStarting>イベント</xref:System.Windows.UIElement.ManipulationStarting>。 必ずメソッドを呼び出して、基底クラスの OnManipulationStarting 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationStartingEventArgs
      description: "A <xref href=&quot;System.Windows.Input.ManipulationStartingEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnManipulationStarting*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> event as handled, OnMouseDown is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown>. Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnMouseDown, you are implying that your class handling accounted for all possible mouse button down actions. This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 このイベント データは、押されたマウス ボタンおよび処理済みの状態に関する詳細を報告します。"
  overload: System.Windows.UIElement.OnMouseDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  id: OnMouseEnter(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseEnter(MouseEventArgs)
  nameWithType: UIElement.OnMouseEnter(MouseEventArgs)
  fullName: System.Windows.UIElement.OnMouseEnter(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。 標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnMouseEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  id: OnMouseLeave(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseLeave(MouseEventArgs)
  nameWithType: UIElement.OnMouseLeave(MouseEventArgs)
  fullName: System.Windows.UIElement.OnMouseLeave(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。 標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnMouseLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.MouseLeftButtonDown&quot;></xref>ルーティング イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.MouseLeftButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.UIElement.MouseLeftButtonDown>。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.MouseLeftButtonDown>。</xref:System.Windows.UIElement.MouseLeftButtonDown>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.MouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.MouseLeftButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnMouseLeftButtonDown をオーバーライドすることで</xref:System.Windows.UIElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnMouseLeftButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 派生するなど、<xref:System.Windows.Controls.Button>基本実装を呼び出さずに派生クラスでオーバーライドして OnMouseLeftButtonDown ですただし、これをオーバーライドを無効にし、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</xref:System.Windows.Controls.Primitives.ButtonBase.Click> </xref:System.Windows.Controls.Button> 。"
  syntax:
    content: protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが押されたことを報告します。"
  overload: System.Windows.UIElement.OnMouseLeftButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.MouseLeftButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.MouseLeftButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.UIElement.MouseLeftButtonUp>。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.MouseLeftButtonUp>。</xref:System.Windows.UIElement.MouseLeftButtonUp>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.MouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.MouseLeftButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnMouseLeftButtonUp をオーバーライドすることで</xref:System.Windows.UIElement>。"
  syntax:
    content: protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが離されたことを報告します。"
  overload: System.Windows.UIElement.OnMouseLeftButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  id: OnMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseMove(MouseEventArgs)
  nameWithType: UIElement.OnMouseMove(MouseEventArgs)
  fullName: System.Windows.UIElement.OnMouseMove(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnMouseMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseRightButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.MouseRightButtonDown&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.MouseRightButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.UIElement.MouseRightButtonDown>。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.MouseRightButtonDown>。</xref:System.Windows.UIElement.MouseRightButtonDown>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.MouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.MouseRightButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnMouseRightButtonDown をオーバーライドすることで</xref:System.Windows.UIElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnMouseRightButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 たとえばから派生できます<xref:System.Windows.Controls.Control>呼び出しベースせず派生クラスでオーバーライドして OnMouseRightButtonDown ですただし、このオーバーライドが含まれる、コントロール上のコンテキスト メニュー サービスを無効にし、の、<xref:System.Windows.Controls.Control>既定の動作。</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Control> 。"
  syntax:
    content: protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが押されたことを報告します。"
  overload: System.Windows.UIElement.OnMouseRightButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseRightButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.MouseRightButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.MouseRightButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します</xref:System.Windows.UIElement.MouseRightButtonUp>。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>ルーティングと、バブルを基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.MouseRightButtonUp>。</xref:System.Windows.UIElement.MouseRightButtonUp>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.MouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.MouseRightButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnMouseRightButtonUp をオーバーライドすることで</xref:System.Windows.UIElement>。"
  syntax:
    content: protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが離されたことを報告します。"
  overload: System.Windows.UIElement.OnMouseRightButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName&gt;ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> event as handled, OnMouseUp is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.UIElement.MouseLeftButtonUp> and <xref:System.Windows.UIElement.MouseRightButtonUp>. Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnMouseUp, you are implying that your class handling accounted for all possible mouse button up actions. This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウス ボタンが離されたことを報告します。"
  overload: System.Windows.UIElement.OnMouseUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  id: OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnMouseWheel(MouseWheelEventArgs)
  nameWithType: UIElement.OnMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.UIElement.OnMouseWheel(MouseWheelEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseWheelEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseWheelEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnMouseWheel*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  id: OnPreviewDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewDragEnter(DragEventArgs)
  nameWithType: UIElement.OnPreviewDragEnter(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDragEnter(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewDragEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  id: OnPreviewDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewDragLeave(DragEventArgs)
  nameWithType: UIElement.OnPreviewDragLeave(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDragLeave(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewDragLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  id: OnPreviewDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewDragOver(DragEventArgs)
  nameWithType: UIElement.OnPreviewDragOver(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDragOver(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewDragOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  id: OnPreviewDrop(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewDrop(DragEventArgs)
  nameWithType: UIElement.OnPreviewDrop(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDrop(DragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DragEventArgs
      description: "<xref href=&quot;System.Windows.DragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewDrop*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  id: OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: UIElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.UIElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);
    parameters:
    - id: e
      type: System.Windows.GiveFeedbackEventArgs
      description: "<xref href=&quot;System.Windows.GiveFeedbackEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewGiveFeedback*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewGotKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  id: OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewKeyDown(KeyEventArgs)
  nameWithType: UIElement.OnPreviewKeyDown(KeyEventArgs)
  fullName: System.Windows.UIElement.OnPreviewKeyDown(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewKeyDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  id: OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewKeyUp(KeyEventArgs)
  nameWithType: UIElement.OnPreviewKeyUp(KeyEventArgs)
  fullName: System.Windows.UIElement.OnPreviewKeyUp(KeyEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewKeyUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  id: OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.KeyboardFocusChangedEventArgs
      description: "<xref href=&quot;System.Windows.Input.KeyboardFocusChangedEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewLostKeyboardFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName&gt;添付ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> event as handled, OnPreviewMouseDown is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>. Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnPreviewMouseDown, you are implying that your class handling accounted for all possible mouse button down actions. This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、1 つ以上のマウス ボタンが押されたことを報告します。"
  overload: System.Windows.UIElement.OnPreviewMouseDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.PreviewMouseLeftButtonDown&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>。</xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnPreviewMouseLeftButtonDown をオーバーライドすることで</xref:System.Windows.UIElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnPreviewMouseLeftButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 派生するなど、<xref:System.Windows.Controls.Button>基本実装を呼び出さずに派生クラスでオーバーライドして OnPreviewMouseLeftButtonDown ですただし、これをオーバーライドを無効にし、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</xref:System.Windows.Controls.Primitives.ButtonBase.Click> </xref:System.Windows.Controls.Button> 。"
  syntax:
    content: protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが押されたことを報告します。"
  overload: System.Windows.UIElement.OnPreviewMouseLeftButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.PreviewMouseLeftButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>。</xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnPreviewMouseLeftButtonUp をオーバーライドすることで</xref:System.Windows.UIElement>。"
  syntax:
    content: protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの左ボタンが離されたことを報告します。"
  overload: System.Windows.UIElement.OnPreviewMouseLeftButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  id: OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseMove(MouseEventArgs)
  nameWithType: UIElement.OnPreviewMouseMove(MouseEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseMove(MouseEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewMouseMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.PreviewMouseRightButtonDown&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.UIElement.PreviewMouseRightButtonDown>。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.MouseRightButtonDown>。</xref:System.Windows.UIElement.MouseRightButtonDown>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.PreviewMouseRightButtonDown>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnPreviewMouseRightButtonDown をオーバーライドすることで</xref:System.Windows.UIElement>。       代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。 基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出しに失敗すると、OnPreviewMouseRightButtonDown を起動しようとしても親クラスでは、そのマウス イベントの既定の入力処理が無効にします。 たとえばから派生できます<xref:System.Windows.Controls.Control>呼び出しベースせず派生クラスでオーバーライドして OnPreviewMouseRightButtonDown ですただし、このオーバーライドが含まれる、コントロール上のコンテキスト メニュー サービスを無効にし、の、<xref:System.Windows.Controls.Control>既定の動作。</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Control> 。"
  syntax:
    content: protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが押されたことを報告します。"
  overload: System.Windows.UIElement.OnPreviewMouseRightButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される<xref href=&quot;System.Windows.UIElement.PreviewMouseRightButtonUp&quot;></xref>ルーティング イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します</xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>トンネル ルートである基になるイベントと各<xref:System.Windows.UIElement>イベントに沿ったルートを使用して直接ルーティングされたイベント<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。</xref:System.Windows.UIElement.PreviewMouseRightButtonUp>を生成する処理と同じ</xref:System.Windows.UIElement>には</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません</xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。 イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。       一般的なマウスのイベント処理の既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>適切なローカル イベントに変換します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName></xref:System.Windows.UIElement>。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクターで<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>の代替クラス ハンドラーを登録します マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>OnPreviewMouseRightButtonUp をオーバーライドすることで</xref:System.Windows.UIElement>。"
  syntax:
    content: protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、マウスの右ボタンが離されたことを報告します。"
  overload: System.Windows.UIElement.OnPreviewMouseRightButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  id: OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseUp(MouseButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "Mouse button actions are also handled by a dedicated input manager. Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action. If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> event as handled, OnPreviewMouseUp is not invoked.  \n  \n If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>. Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName> is received.  \n  \n If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data. If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers. Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`. By handling OnPreviewMouseUp, you are implying that your class handling accounted for all possible mouse button up actions. This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.  \n  \n Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.  \n  \n This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseButtonEventArgs&quot;> </xref>イベント データを格納します。 イベント データは、1 つ以上のマウス ボタンが離されたことを報告します。"
  overload: System.Windows.UIElement.OnPreviewMouseUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  id: OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewMouseWheel(MouseWheelEventArgs)
  nameWithType: UIElement.OnPreviewMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseWheel(MouseWheelEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.MouseWheelEventArgs
      description: "<xref href=&quot;System.Windows.Input.MouseWheelEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewMouseWheel*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  id: OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: UIElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.QueryContinueDragEventArgs
      description: "<xref href=&quot;System.Windows.QueryContinueDragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewQueryContinueDrag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  id: OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusButtonDown(StylusButtonEventArgs)
  nameWithType: UIElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  id: OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusButtonUp(StylusButtonEventArgs)
  nameWithType: UIElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  id: OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusDown(StylusDownEventArgs)
  nameWithType: UIElement.OnPreviewStylusDown(StylusDownEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusDown(StylusDownEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusDownEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusDownEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusInAirMove(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusInAirMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusInAirMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusInRange(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusInRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusInRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusInRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusMove(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusOutOfRange(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusOutOfRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusOutOfRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  id: OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: UIElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusSystemGestureEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusSystemGestureEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusSystemGesture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  id: OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewStylusUp(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusUp(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusUp(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewStylusUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  id: OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewTextInput(TextCompositionEventArgs)
  nameWithType: UIElement.OnPreviewTextInput(TextCompositionEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTextInput(TextCompositionEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled. Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked."
  syntax:
    content: protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TextCompositionEventArgs
      description: "<xref href=&quot;System.Windows.Input.TextCompositionEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewTextInput*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  id: OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewTouchDown(TouchEventArgs)
  nameWithType: UIElement.OnPreviewTouchDown(TouchEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTouchDown(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.UIElement.PreviewTouchDown&quot;> </xref>タッチは、この要素を押したときに発生するイベントをルーティングします。"
  remarks: "OnPreviewTouchDown メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnPreviewTouchDown、<xref:System.Windows.UIElement.PreviewTouchDown>イベント</xref:System.Windows.UIElement.PreviewTouchDown>。 必ずメソッドを呼び出して、基底クラスの OnPreviewTouchDown 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewTouchDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  id: OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewTouchMove(TouchEventArgs)
  nameWithType: UIElement.OnPreviewTouchMove(TouchEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTouchMove(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.UIElement.PreviewTouchMove&quot;> </xref>タッチは、この要素の中に内部動かしたときに発生するイベントをルーティングします。"
  remarks: "OnPreviewTouchMove メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnPreviewTouchMove、<xref:System.Windows.UIElement.PreviewTouchMove>イベント</xref:System.Windows.UIElement.PreviewTouchMove>。 必ずメソッドを呼び出して、基底クラスの OnPreviewTouchMove 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewTouchMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  id: OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnPreviewTouchUp(TouchEventArgs)
  nameWithType: UIElement.OnPreviewTouchUp(TouchEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTouchUp(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.UIElement.PreviewTouchUp&quot;> </xref>タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。"
  remarks: "OnPreviewTouchUp メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnPreviewTouchUp、<xref:System.Windows.UIElement.PreviewTouchUp>イベント</xref:System.Windows.UIElement.PreviewTouchUp>。 必ずメソッドを呼び出して、基底クラスの OnPreviewTouchUp 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnPreviewTouchUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  id: OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: UIElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.UIElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);
    parameters:
    - id: e
      type: System.Windows.QueryContinueDragEventArgs
      description: "<xref href=&quot;System.Windows.QueryContinueDragEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnQueryContinueDrag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  id: OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnQueryCursor(QueryCursorEventArgs)
  nameWithType: UIElement.OnQueryCursor(QueryCursorEventArgs)
  fullName: System.Windows.UIElement.OnQueryCursor(QueryCursorEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.QueryCursorEventArgs
      description: "<xref href=&quot;System.Windows.Input.QueryCursorEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnQueryCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  id: OnRender(System.Windows.Media.DrawingContext)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnRender(DrawingContext)
  nameWithType: UIElement.OnRender(DrawingContext)
  fullName: System.Windows.UIElement.OnRender(DrawingContext)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、レイアウト システムによって送られるレンダリング操作に参加します。 この要素のレンダリング指示は、このメソッドが呼び出される場合、直接は使用されませんしレイアウトと描画して非同期後で使用できる代わりに保持されます。"
  remarks: "このメソッドの<xref:System.Windows.UIElement>クラス</xref:System.Windows.UIElement>の既定の実装ではありません。"
  example:
  - "The following code example shows a possible implementation for a panel derived class.  \n  \n [!code-vb[LightWeightCustomPanel#1](~/add/codesnippet/visualbasic/light_custom_panel_vb/offsetpanel.vb#1)]\n [!code-cs[LightWeightCustomPanel#1](~/add/codesnippet/csharp/Light_Custom_Panel_csharp/OffsetPanel.cs#1)]"
  syntax:
    content: protected virtual void OnRender (System.Windows.Media.DrawingContext drawingContext);
    parameters:
    - id: drawingContext
      type: System.Windows.Media.DrawingContext
      description: "特定の要素の描画の命令。 このコンテキストは、レイアウト システムに提供されます。"
  overload: System.Windows.UIElement.OnRender*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  id: OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: UIElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.UIElement.OnRenderSizeChanged(SizeChangedInfo)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、レイアウト システムによって送られるレンダリング操作に参加します。 このメソッドは、レイアウトの更新の後と、レンダリングの前に呼び出される場合、要素の<xref:System.Windows.UIElement.RenderSize*>がレイアウトの更新の結果として変更されました</xref:System.Windows.UIElement.RenderSize*>。"
  remarks: "このメソッドには、既定の実装ではありません。 一般的な WPF フレームワーク レベル要素<xref:System.Windows.FrameworkElement>。</xref:System.Windows.FrameworkElement>オーバーライドの実装を使用します。 <xref:System.Windows.FrameworkElement>実装が無効化、<xref:System.Windows.FrameworkElement.Width%2A>と<xref:System.Windows.FrameworkElement.Height%2A>プロパティとレイアウトを再構築の基本のハンドル</xref:System.Windows.FrameworkElement.Height%2A></xref:System.Windows.FrameworkElement.Width%2A></xref:System.Windows.FrameworkElement>。 OnRenderSizeChanged をオーバーライドする、<xref:System.Windows.UIElement>レベルことを示します、要素の実装は WPF フレームワーク レベルの実装を使用して意図的にないため、要素必要がありますのレイアウト ロジックよりを直接処理、通常置換レイアウト システムを記述しています</xref:System.Windows.UIElement>。"
  syntax:
    content: protected virtual void OnRenderSizeChanged (System.Windows.SizeChangedInfo info);
    parameters:
    - id: info
      type: System.Windows.SizeChangedInfo
      description: "パッケージのパラメーター (<xref href=&quot;System.Windows.SizeChangedInfo&quot;></xref>)、新旧のサイズが含まれているし、どのディメンションが実際に変更します。"
  overload: System.Windows.UIElement.OnRenderSizeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  id: OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusButtonDown(StylusButtonEventArgs)
  nameWithType: UIElement.OnStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnStylusButtonDown(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusButtonDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  id: OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusButtonUp(StylusButtonEventArgs)
  nameWithType: UIElement.OnStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnStylusButtonUp(StylusButtonEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusButtonEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusButtonEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusButtonUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  id: OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusDown(StylusDownEventArgs)
  nameWithType: UIElement.OnStylusDown(StylusDownEventArgs)
  fullName: System.Windows.UIElement.OnStylusDown(StylusDownEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusDownEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusDownEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  id: OnStylusEnter(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusEnter(StylusEventArgs)
  nameWithType: UIElement.OnStylusEnter(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusEnter(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  id: OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusInAirMove(StylusEventArgs)
  nameWithType: UIElement.OnStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusInAirMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusInAirMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  id: OnStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusInRange(StylusEventArgs)
  nameWithType: UIElement.OnStylusInRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusInRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusInRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  id: OnStylusLeave(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusLeave(StylusEventArgs)
  nameWithType: UIElement.OnStylusLeave(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusLeave(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName&gt;添付イベントがこの要素で発生します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "このメソッドには、既定の実装ではありません。 継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。 呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。       このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]でのイベント パターン * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。 ここでは、照合イベントは、ルーティングされたイベントです。 通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。"
  syntax:
    content: protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  id: OnStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusMove(StylusEventArgs)
  nameWithType: UIElement.OnStylusMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusMove(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  id: OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusOutOfRange(StylusEventArgs)
  nameWithType: UIElement.OnStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusOutOfRange(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusOutOfRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  id: OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: UIElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.UIElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusSystemGestureEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusSystemGestureEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusSystemGesture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  id: OnStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnStylusUp(StylusEventArgs)
  nameWithType: UIElement.OnStylusUp(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusUp(StylusEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.StylusEventArgs
      description: "<xref href=&quot;System.Windows.Input.StylusEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnStylusUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  id: OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnTextInput(TextCompositionEventArgs)
  nameWithType: UIElement.OnTextInput(TextCompositionEventArgs)
  fullName: System.Windows.UIElement.OnTextInput(TextCompositionEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "未処理のときに呼び出される&lt;xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName&gt;添付イベントがそのルート上でこのクラスから派生した要素に到達します。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。"
  remarks: "This method has no default implementation. Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.  \n  \n The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers. Therefore, your implementation needs to examine the source properties of the event data. It should not try to reraise the event in most cases.  \n  \n Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.UIElement> can call private class handler methods when the event is received along the event route. One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled."
  syntax:
    content: protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TextCompositionEventArgs
      description: "<xref href=&quot;System.Windows.Input.TextCompositionEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnTextInput*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  id: OnTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnTouchDown(TouchEventArgs)
  nameWithType: UIElement.OnTouchDown(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchDown(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.UIElement.TouchDown&quot;> </xref>タッチがこの要素の内部を押したときに発生するイベントをルーティングします。"
  remarks: "OnTouchDown メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchDown、<xref:System.Windows.UIElement.TouchDown>イベント</xref:System.Windows.UIElement.TouchDown>。 必ずメソッドを呼び出して、基底クラスの OnTouchDown 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnTouchDown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  id: OnTouchEnter(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnTouchEnter(TouchEventArgs)
  nameWithType: UIElement.OnTouchEnter(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchEnter(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.UIElement.TouchEnter&quot;> </xref>タッチから移動するときに発生するルーティング イベントをこの要素の境界内の外部です。"
  remarks: "TheOnTouchEnter メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchEnter、<xref:System.Windows.UIElement.TouchEnter>イベント</xref:System.Windows.UIElement.TouchEnter>。 必ずメソッドを呼び出して、基底クラスの OnTouchEnter 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnTouchEnter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  id: OnTouchLeave(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnTouchLeave(TouchEventArgs)
  nameWithType: UIElement.OnTouchLeave(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchLeave(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.UIElement.TouchLeave&quot;> </xref>タッチから移動するときに発生するルーティング イベントのこの境界の外側を inside <xref href=&quot;System.Windows.UIElement&quot;></xref>です。"
  remarks: "OnTouchLeave メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchLeave、<xref:System.Windows.UIElement.TouchLeave>イベント</xref:System.Windows.UIElement.TouchLeave>。 必ずメソッドを呼び出して、基底クラスの OnTouchLeave 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnTouchLeave*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  id: OnTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnTouchMove(TouchEventArgs)
  nameWithType: UIElement.OnTouchMove(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchMove(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラス処理を提供、 <xref href=&quot;System.Windows.UIElement.TouchMove&quot;> </xref>タッチは、この要素の中に内部動かしたときに発生するイベントをルーティングします。"
  remarks: "OnTouchMove メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchMove、<xref:System.Windows.UIElement.TouchMove>イベント</xref:System.Windows.UIElement.TouchMove>。 必ずメソッドを呼び出して、基底クラスの OnTouchMove 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnTouchMove*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  id: OnTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnTouchUp(TouchEventArgs)
  nameWithType: UIElement.OnTouchUp(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchUp(TouchEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "クラスの処理を提供、 <xref href=&quot;System.Windows.UIElement.TouchUp&quot;> </xref>タッチがこの要素内にリリースされたときに発生するイベントをルーティングします。"
  remarks: "OnTouchUp メソッドには、既定の実装ではありません。 処理する派生クラスでオーバーライドして OnTouchUp、<xref:System.Windows.UIElement.TouchUp>イベント</xref:System.Windows.UIElement.TouchUp>。 必ずメソッドを呼び出して、基底クラスの OnTouchUp 基底クラスは、イベントを受け取るようにします。"
  syntax:
    content: protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.TouchEventArgs
      description: "A <xref href=&quot;System.Windows.Input.TouchEventArgs&quot;> </xref>イベント データを格納します。"
  overload: System.Windows.UIElement.OnTouchUp*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: UIElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.UIElement.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "呼び出されたときにこれの親要素<xref href=&quot;System.Windows.UIElement&quot;></xref>その基になる visual の親に変更を報告します。"
  syntax:
    content: protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "以前の親です。 これは、として指定することがあります<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>場合、 <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>は親要素は既にありませんでした。"
  overload: System.Windows.UIElement.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Opacity
  id: Opacity
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Opacity
  nameWithType: UIElement.Opacity
  fullName: System.Windows.UIElement.Opacity
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または設定全体に適用される不透明度率<xref href=&quot;System.Windows.UIElement&quot;></xref>で表示する際に、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]です。  これは、依存関係プロパティです。"
  remarks: "1.0 の既定値は、<xref:System.Windows.UIElement>クラス</xref:System.Windows.UIElement>の場合は、この依存関係プロパティの初期メタデータによって提供される既定値です。 他の派生クラスは、クラス コンス トラクター内からのメタデータをオーバーライドすることでこの既定値を変更可能性がある可能性があります。       不透明度の値は、要素は表示もしない限り、実際のレイアウトに適用されません (<xref:System.Windows.UIElement.IsVisible%2A>は`true`).</xref:System.Windows.UIElement.IsVisible%2A>       不透明度が、ツリーの下位要素の親要素から、子要素に適用されるが、入れ子になったの不透明度の設定の表示の効果は個々 の子要素のプロパティの値で示されます。 インスタンスの場合は (0.5) の 50% 不透明度は、リストが、そのリスト項目のいずれかが、独自の不透明度が 20% (0.2) に設定する、そのリスト項目の net 表示不透明度として表示するが 10% (0.1) が、不透明度のプロパティのリスト項目のプロパティの値も 0.2 が照会されたときにします。       宣言または評価された不透明度が 0 の場合でも要素はまだ入力イベント、およびコマンドに参加して、フォーカスを設定できる可能性があります。 この側面は便利ですが、マスクの透明な要素を持つ基になるオブジェクトの不透明度&0; オブジェクト (shape) などを使用するのインスタンスにすることはできます。 不透明度&0; のオブジェクトには、すべての入力イベントを基になる領域の処理、処理できます。 ただし、`Background`または`Fill`オブジェクトまたは図形の必要があります設定する値になっている場合でも<xref:System.Windows.Media.Brushes.Transparent%2A>、それ以外の場合のヒット テストが有効でないと、イベントの受信します</xref:System.Windows.Media.Brushes.Transparent%2A>。      <a name=&quot;dependencyPropertyInfo_Opacity&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.OpacityProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.OpacityProperty>"
  syntax:
    content: public double Opacity { get; set; }
    return:
      type: System.Double
      description: "不透明度率。 既定の不透明度は 1.0 です。 必要な値は 0.0 ~ 1.0 の範囲はします。"
  overload: System.Windows.UIElement.Opacity*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OpacityMask
  id: OpacityMask
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OpacityMask
  nameWithType: UIElement.OpacityMask
  fullName: System.Windows.UIElement.OpacityMask
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはとして、不透明マスクを設定、 <xref href=&quot;System.Windows.Media.Brush&quot;> </xref>この要素の描画された内容の任意のアルファ チャネル マスクに適用されるを実装します。  これは、依存関係プロパティです。"
  remarks: "このプロパティは任意のアルファ チャネル値では、指定された<xref:System.Windows.Media.Brush>。</xref:System.Windows.Media.Brush>はのみを使用します。 他のチャネル、 <xref:System.Windows.Media.Brush>(赤、緑、または青) のコンテンツをレンダリングは無視されます</xref:System.Windows.Media.Brush>。       最も一般的な<xref:System.Windows.Media.Brush>この目的は、 <xref:System.Windows.Media.ImageBrush>、さまざまな写真の画像を表示するなどの手法をマスクに使用できる</xref:System.Windows.Media.ImageBrush></xref:System.Windows.Media.Brush>。 いずれかの定義が<xref:System.Windows.Media.Brush>(など<xref:System.Windows.Media.LinearGradientBrush>) 使用することができます</xref:System.Windows.Media.LinearGradientBrush></xref:System.Windows.Media.Brush>。       [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]、このプロパティの値は、<xref:System.Windows.Media.Brush>抽象クラス</xref:System.Windows.Media.Brush>の各実装に固有であるインライン構文を使用できます 詳細については、次を参照してください。[純色、グラデーションの概要でペイント](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;dependencyPropertyInfo_OpacityMask&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.OpacityMaskProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.OpacityMaskProperty>"
  example:
  - "The following markup example shows an <xref:System.Windows.Media.ImageBrush> opacity mask applied to another <xref:System.Windows.Controls.Image>.  \n  \n [!code-xml[OpacityMasksExample#UIElementOpacityMask](~/add/codesnippet/xaml/p-system.windows.uieleme_6_1.xaml)]\n [!code-xml[OpacityMasksExample#UIElementOpacityMask](~/add/codesnippet/xaml/p-system.windows.uieleme_6_1.xaml)]"
  syntax:
    content: public System.Windows.Media.Brush OpacityMask { get; set; }
    return:
      type: System.Windows.Media.Brush
      description: "不透明マスクを使用するブラシ。"
  overload: System.Windows.UIElement.OpacityMask*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OpacityMaskProperty
  id: OpacityMaskProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OpacityMaskProperty
  nameWithType: UIElement.OpacityMaskProperty
  fullName: System.Windows.UIElement.OpacityMaskProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.OpacityMask*>依存関係プロパティ</xref:System.Windows.UIElement.OpacityMask*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OpacityMaskProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.OpacityProperty
  id: OpacityProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: OpacityProperty
  nameWithType: UIElement.OpacityProperty
  fullName: System.Windows.UIElement.OpacityProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.Opacity*>依存関係プロパティ</xref:System.Windows.UIElement.Opacity*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OpacityProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PersistId
  id: PersistId
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PersistId
  nameWithType: UIElement.PersistId
  fullName: System.Windows.UIElement.PersistId
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素を一意に識別する値を取得します。"
  remarks: "PersistId は、各要素を一意に識別します。 要素は同じ PersistId たびに同じ[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)](バイナリ表現を含む) が読み込まれます。 内部の読み込み、解析およびシリアル化の要件については、この識別子が使用されます。 アプリケーション コードで使用することはありません。       このプロパティへのリレーションシップを持たない、 <xref:System.Object.GetHashCode%2A>、特定のインスタンスの結果</xref:System.Object.GetHashCode%2A>。"
  syntax:
    content: public int PersistId { get; }
    return:
      type: System.Int32
      description: "この要素の一意の識別子。"
  overload: System.Windows.UIElement.PersistId*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: UIElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.UIElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "派生クラスでオーバーライドされると、実際にその要素にフォーカスを移動しなくても指定したフォーカスの移動方向をフォーカスを受け取る要素を返します。"
  remarks: "このクラスでこのメソッドの既定の実装が完了していないと、常に返します`null`です。"
  syntax:
    content: public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "要求されたフォーカスの移動の方向です。"
    return:
      type: System.Windows.DependencyObject
      description: "要素がフォーカスを受け取った場合<xref:System.Windows.UIElement.MoveFocus*>が実際に呼び出されます</xref:System.Windows.UIElement.MoveFocus*>。"
  overload: System.Windows.UIElement.PredictFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDragEnter
  id: PreviewDragEnter
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDragEnter
  nameWithType: UIElement.PreviewDragEnter
  fullName: System.Windows.UIElement.PreviewDragEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ先と、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>PreviewDragEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>。 PreviewDragEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDragEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewDragEnterEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.DragEnter>.</xref:System.Windows.UIElement.DragEnter> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.PreviewDragEnterEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewDragEnter%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDragEnter;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDragEnterEvent
  id: PreviewDragEnterEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDragEnterEvent
  nameWithType: UIElement.PreviewDragEnterEvent
  fullName: System.Windows.UIElement.PreviewDragEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewDragEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDragLeave
  id: PreviewDragLeave
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDragLeave
  nameWithType: UIElement.PreviewDragLeave
  fullName: System.Windows.UIElement.PreviewDragLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドラッグ元に、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>PreviewDragLeave が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>。 PreviewDragLeave イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDragLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewDragLeaveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.DragLeave>.</xref:System.Windows.UIElement.DragLeave> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.PreviewDragLeaveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewDragLeave%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDragLeave;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDragLeaveEvent
  id: PreviewDragLeaveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDragLeaveEvent
  nameWithType: UIElement.PreviewDragLeaveEvent
  fullName: System.Windows.UIElement.PreviewDragLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewDragLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDragOver
  id: PreviewDragOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDragOver
  nameWithType: UIElement.PreviewDragOver
  fullName: System.Windows.UIElement.PreviewDragOver
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムが潜在的なドロップ ターゲットとしてこの要素で、基になるドラッグ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>PreviewDragOver が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>。 PreviewDragOver イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDragOver&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewDragOverEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.DragOver>.</xref:System.Windows.UIElement.DragOver> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.PreviewDragOverEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewDragOver%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDragOver;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDragOverEvent
  id: PreviewDragOverEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDragOverEvent
  nameWithType: UIElement.PreviewDragOverEvent
  fullName: System.Windows.UIElement.PreviewDragOverEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewDragOver&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDrop
  id: PreviewDrop
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDrop
  nameWithType: UIElement.PreviewDrop
  fullName: System.Windows.UIElement.PreviewDrop
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>テキストが一部になるよう、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素としては、継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>。 テキストのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewDrop?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewDrop&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewDropEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.DragEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.Drop>.</xref:System.Windows.UIElement.Drop> </xref:System.Windows.DragEventHandler> </xref:System.Windows.UIElement.PreviewDropEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewDrop%2A>。"
  syntax:
    content: public event System.Windows.DragEventHandler PreviewDrop;
    return:
      type: System.Windows.DragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewDropEvent
  id: PreviewDropEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewDropEvent
  nameWithType: UIElement.PreviewDropEvent
  fullName: System.Windows.UIElement.PreviewDropEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewDrop&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewDropEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewGiveFeedback
  id: PreviewGiveFeedback
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewGiveFeedback
  nameWithType: UIElement.PreviewGiveFeedback
  fullName: System.Windows.UIElement.PreviewGiveFeedback
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ドラッグ アンド ドロップ操作が開始されたときに発生します。"
  remarks: "PreviewGiveFeedback イベントは、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソースを使用できます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>PreviewGiveFeedback が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>。 PreviewGiveFeedback イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewGiveFeedback&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewGiveFeedbackEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.GiveFeedbackEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.GiveFeedback>.</xref:System.Windows.UIElement.GiveFeedback> </xref:System.Windows.GiveFeedbackEventHandler> </xref:System.Windows.UIElement.PreviewGiveFeedbackEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A>。"
  syntax:
    content: public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;
    return:
      type: System.Windows.GiveFeedbackEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewGiveFeedbackEvent
  id: PreviewGiveFeedbackEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewGiveFeedbackEvent
  nameWithType: UIElement.PreviewGiveFeedbackEvent
  fullName: System.Windows.UIElement.PreviewGiveFeedbackEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewGiveFeedback&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewGotKeyboardFocus
  id: PreviewGotKeyboardFocus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewGotKeyboardFocus
  nameWithType: UIElement.PreviewGotKeyboardFocus
  fullName: System.Windows.UIElement.PreviewGotKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスがあるときに発生します。"
  remarks: "このイベントは、ルーティング トンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>PreviewGotKeyboardFocus が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>。 PreviewGotKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewGotKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewGotKeyboardFocusEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.GotKeyboardFocus>.</xref:System.Windows.UIElement.GotKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.UIElement.PreviewGotKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  id: PreviewGotKeyboardFocusEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewGotKeyboardFocusEvent
  nameWithType: UIElement.PreviewGotKeyboardFocusEvent
  fullName: System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewGotKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewKeyDown
  id: PreviewKeyDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewKeyDown
  nameWithType: UIElement.PreviewKeyDown
  fullName: System.Windows.UIElement.PreviewKeyDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスがあるときにキーが押されると発生します。"
  remarks: "キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 <xref:System.Windows.UIElement.KeyDown>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります</xref:System.Windows.UIElement.KeyDown>。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>PreviewKeyDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>。 PreviewKeyDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewKeyDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewKeyDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.KeyDown>.</xref:System.Windows.UIElement.KeyDown> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.UIElement.PreviewKeyDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewKeyDown%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler PreviewKeyDown;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewKeyDownEvent
  id: PreviewKeyDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewKeyDownEvent
  nameWithType: UIElement.PreviewKeyDownEvent
  fullName: System.Windows.UIElement.PreviewKeyDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewKeyDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewKeyUp
  id: PreviewKeyUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewKeyUp
  nameWithType: UIElement.PreviewKeyUp
  fullName: System.Windows.UIElement.PreviewKeyUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にフォーカスがあるときにキーが離されると発生します。"
  remarks: "キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。 <xref:System.Windows.UIElement.KeyUp>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります</xref:System.Windows.UIElement.KeyUp>。 これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。 詳細については、個々 のコントロールのマニュアルを確認します。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>PreviewKeyUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>。 PreviewKeyUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewKeyUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewKeyUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.KeyUp>.</xref:System.Windows.UIElement.KeyUp> </xref:System.Windows.Input.KeyEventHandler> </xref:System.Windows.UIElement.PreviewKeyUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewKeyUp%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyEventHandler PreviewKeyUp;
    return:
      type: System.Windows.Input.KeyEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewKeyUpEvent
  id: PreviewKeyUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewKeyUpEvent
  nameWithType: UIElement.PreviewKeyUpEvent
  fullName: System.Windows.UIElement.PreviewKeyUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewKeyUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewLostKeyboardFocus
  id: PreviewLostKeyboardFocus
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewLostKeyboardFocus
  nameWithType: UIElement.PreviewLostKeyboardFocus
  fullName: System.Windows.UIElement.PreviewLostKeyboardFocus
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "キーボードは、この要素にフォーカスが離れたときに発生します。"
  remarks: "このイベントは、ルーティング トンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ</xref:System.Windows.RoutedEventArgs.Source%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>PreviewLostKeyboardFocus が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>。 PreviewLostKeyboardFocus イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewLostKeyboardFocus&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewLostKeyboardFocusEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.LostKeyboardFocus>.</xref:System.Windows.UIElement.LostKeyboardFocus> </xref:System.Windows.Input.KeyboardFocusChangedEventHandler> </xref:System.Windows.UIElement.PreviewLostKeyboardFocusEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A>。"
  syntax:
    content: public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;
    return:
      type: System.Windows.Input.KeyboardFocusChangedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  id: PreviewLostKeyboardFocusEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewLostKeyboardFocusEvent
  nameWithType: UIElement.PreviewLostKeyboardFocusEvent
  fullName: System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewLostKeyboardFocus&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseDown
  id: PreviewMouseDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseDown
  nameWithType: UIElement.PreviewMouseDown
  fullName: System.Windows.UIElement.PreviewMouseDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にポインターが、任意のマウス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>PreviewMouseDown 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素としては、継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 PreviewMouseDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。       PreviewMouseDown 多くの場合、このイベントはいずれかと共に<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応する</xref:System.Windows.UIElement.PreviewMouseRightButtonDown></xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown><xref:System.Windows.UIElement.PreviewMouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName></xref:System.Windows.UIElement.PreviewMouseRightButtonDown>。</xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>。</xref:System.Windows.UIElement.PreviewMouseRightButtonDown></xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>の「解説」を参照してください      <a name=&quot;routedEventInfo_PreviewMouseDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.MouseDown>.</xref:System.Windows.UIElement.MouseDown> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.UIElement.PreviewMouseDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseDown%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseDownEvent
  id: PreviewMouseDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseDownEvent
  nameWithType: UIElement.PreviewMouseDownEvent
  fullName: System.Windows.UIElement.PreviewMouseDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseLeftButtonDown
  id: PreviewMouseLeftButtonDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonDown
  nameWithType: UIElement.PreviewMouseLeftButtonDown
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが押されたときに発生します。"
  remarks: "要素ツリーを通じてトンネリングのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 PreviewMouseLeftButtonDown 処理のマークを付けた場合マークしている本質的に<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 これは、可能性のある<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。</xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>などのクラス ハンドラーが生成されたイベントが含まれています       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseLeftButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  id: PreviewMouseLeftButtonDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonDownEvent
  nameWithType: UIElement.PreviewMouseLeftButtonDownEvent
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseLeftButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseLeftButtonUp
  id: PreviewMouseLeftButtonUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonUp
  nameWithType: UIElement.PreviewMouseLeftButtonUp
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの左ボタンが離されたときに発生します。"
  remarks: "要素ツリーを通じてトンネリングのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 処理 PreviewMouseLeftButtonUp をマークする場合は、マークしている本質的に<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseLeftButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  id: PreviewMouseLeftButtonUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseLeftButtonUpEvent
  nameWithType: UIElement.PreviewMouseLeftButtonUpEvent
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseLeftButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseMove
  id: PreviewMouseMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseMove
  nameWithType: UIElement.PreviewMouseMove
  fullName: System.Windows.UIElement.PreviewMouseMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウス ポインターが移動したときに発生します。"
  remarks: "このイベントは、どちらも要素の境界にマウス ポインターを最初に入力し、マウス ポインターが要素の境界内に残っているときに移動するともします。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>PreviewMouseMove が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>。 PreviewMouseMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewMouseMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.MouseMove>.</xref:System.Windows.UIElement.MouseMove> </xref:System.Windows.Input.MouseEventHandler> </xref:System.Windows.UIElement.PreviewMouseMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseMove%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseEventHandler PreviewMouseMove;
    return:
      type: System.Windows.Input.MouseEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseMoveEvent
  id: PreviewMouseMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseMoveEvent
  nameWithType: UIElement.PreviewMouseMoveEvent
  fullName: System.Windows.UIElement.PreviewMouseMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseRightButtonDown
  id: PreviewMouseRightButtonDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseRightButtonDown
  nameWithType: UIElement.PreviewMouseRightButtonDown
  fullName: System.Windows.UIElement.PreviewMouseRightButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが押されたときに発生します。"
  remarks: "要素ツリーを通じてトンネリングのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 処理 PreviewMouseRightButtonDown をマークする場合は、マークしている本質的に<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=fullName>。 これは、可能性のある<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。</xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>などのクラス ハンドラーが生成されたイベントが含まれています       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseRightButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseRightButtonDownEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.PreviewMouseRightButtonDownEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  id: PreviewMouseRightButtonDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseRightButtonDownEvent
  nameWithType: UIElement.PreviewMouseRightButtonDownEvent
  fullName: System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseRightButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseRightButtonUp
  id: PreviewMouseRightButtonUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseRightButtonUp
  nameWithType: UIElement.PreviewMouseRightButtonUp
  fullName: System.Windows.UIElement.PreviewMouseRightButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "マウス ポインターがこの要素上でマウスの右ボタンが離されたときに発生します。"
  remarks: "要素ツリーを通じてトンネリングのルートに従うようですが、実際には、直接ルーティング イベントが発生し、各<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>要素ツリーに沿って reraised       このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの&1; つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント ルート上の各要素によって処理される添付イベントがイベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       このイベントのイベント データ、イベントのデータを公開、基になる<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。 そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します</xref:System.Windows.UIElement.AddHandler%2A>。 処理 PreviewMouseRightButtonUp をマークする場合は、マークしている本質的に<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>経路、さらにすべてのリスナーの処理され、すべての関連するイベントです</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.UIElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス).</xref:System.Windows.Input.Mouse> </xref:System.Windows.UIElement> イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。 非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse><xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>上のものではなくクラス</xref:System.Windows.Input.Mouse>      <a name=&quot;routedEventInfo_PreviewMouseRightButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseRightButtonUpEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A></xref:System.Windows.Input.MouseButtonEventHandler></xref:System.Windows.UIElement.PreviewMouseRightButtonUpEvent>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  id: PreviewMouseRightButtonUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseRightButtonUpEvent
  nameWithType: UIElement.PreviewMouseRightButtonUpEvent
  fullName: System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseRightButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseUp
  id: PreviewMouseUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseUp
  nameWithType: UIElement.PreviewMouseUp
  fullName: System.Windows.UIElement.PreviewMouseUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にマウス ポインターが、任意のマウス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>PreviewMouseUp 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素としては、継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。 PreviewMouseUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>。       PreviewMouseUp 多くの場合、このイベントはいずれかと共に<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応する</xref:System.Windows.UIElement.PreviewMouseRightButtonUp></xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp><xref:System.Windows.UIElement.PreviewMouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName>イベント イベント ルート上には、この要素に到達します</xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=fullName></xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。</xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。</xref:System.Windows.UIElement.PreviewMouseRightButtonUp></xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>の「解説」を参照してください      <a name=&quot;routedEventInfo_PreviewMouseUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseButtonEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.MouseUp>.</xref:System.Windows.UIElement.MouseUp> </xref:System.Windows.Input.MouseButtonEventHandler> </xref:System.Windows.UIElement.PreviewMouseUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseUp%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;
    return:
      type: System.Windows.Input.MouseButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseUpEvent
  id: PreviewMouseUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseUpEvent
  nameWithType: UIElement.PreviewMouseUpEvent
  fullName: System.Windows.UIElement.PreviewMouseUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseWheel
  id: PreviewMouseWheel
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseWheel
  nameWithType: UIElement.PreviewMouseWheel
  fullName: System.Windows.UIElement.PreviewMouseWheel
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にマウス ポインターが、ユーザーがマウスのホイールを回転させるときに発生します。"
  remarks: "フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。このため、対象を絞ったまたはキャプチャした要素からこのイベントを受信する場合、マウス ポインター実際にあります別の要素上です。       このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName>添付イベントが、このクラスに対してように<xref:System.Windows.UIElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.UIElement.PreviewMouseMove></xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName>。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewMouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=fullName></xref:System.Windows.UIElement.PreviewMouseMove>。      <a name=&quot;routedEventInfo_PreviewMouseWheel&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewMouseWheelEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.MouseWheelEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.MouseWheel>.</xref:System.Windows.UIElement.MouseWheel> </xref:System.Windows.Input.MouseWheelEventHandler> </xref:System.Windows.UIElement.PreviewMouseWheelEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewMouseWheel%2A>。"
  syntax:
    content: public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;
    return:
      type: System.Windows.Input.MouseWheelEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewMouseWheelEvent
  id: PreviewMouseWheelEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewMouseWheelEvent
  nameWithType: UIElement.PreviewMouseWheelEvent
  fullName: System.Windows.UIElement.PreviewMouseWheelEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewMouseWheel&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewQueryContinueDrag
  id: PreviewQueryContinueDrag
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewQueryContinueDrag
  nameWithType: UIElement.PreviewQueryContinueDrag
  fullName: System.Windows.UIElement.PreviewQueryContinueDrag
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ドラッグ アンド ドロップ操作中にキーボードまたはマウス ボタンの状態に変更があるときに発生します。"
  remarks: "PreviewQueryContinueDrag イベントは、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを宣言できます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>PreviewQueryContinueDrag が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>。 PreviewQueryContinueDrag イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewQueryContinueDrag&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewQueryContinueDragEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.QueryContinueDragEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.QueryContinueDrag>.</xref:System.Windows.UIElement.QueryContinueDrag> </xref:System.Windows.QueryContinueDragEventHandler> </xref:System.Windows.UIElement.PreviewQueryContinueDragEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A>。"
  syntax:
    content: public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;
    return:
      type: System.Windows.QueryContinueDragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewQueryContinueDragEvent
  id: PreviewQueryContinueDragEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewQueryContinueDragEvent
  nameWithType: UIElement.PreviewQueryContinueDragEvent
  fullName: System.Windows.UIElement.PreviewQueryContinueDragEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewQueryContinueDrag&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusButtonDown
  id: PreviewStylusButtonDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusButtonDown
  nameWithType: UIElement.PreviewStylusButtonDown
  fullName: System.Windows.UIElement.PreviewStylusButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>PreviewStylusButtonDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>。 PreviewStylusButtonDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Windows Vista でタッチ入力サポート](http://msdn.microsoft.com/en-us/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)と[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusButtonDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusButtonDown>.</xref:System.Windows.UIElement.StylusButtonDown> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.UIElement.PreviewStylusButtonDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusButtonDownEvent
  id: PreviewStylusButtonDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusButtonDownEvent
  nameWithType: UIElement.PreviewStylusButtonDownEvent
  fullName: System.Windows.UIElement.PreviewStylusButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusButtonUp
  id: PreviewStylusButtonUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusButtonUp
  nameWithType: UIElement.PreviewStylusButtonUp
  fullName: System.Windows.UIElement.PreviewStylusButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>PreviewStylusButtonUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>。 PreviewStylusButtonUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusButtonUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusButtonUp>.</xref:System.Windows.UIElement.StylusButtonUp> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.UIElement.PreviewStylusButtonUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusButtonUpEvent
  id: PreviewStylusButtonUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusButtonUpEvent
  nameWithType: UIElement.PreviewStylusButtonUpEvent
  fullName: System.Windows.UIElement.PreviewStylusButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusDown
  id: PreviewStylusDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusDown
  nameWithType: UIElement.PreviewStylusDown
  fullName: System.Windows.UIElement.PreviewStylusDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上でスタイラスがデジタイザーに触れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>PreviewStylusDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>。 PreviewStylusDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusDownEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusDown>.</xref:System.Windows.UIElement.StylusDown> </xref:System.Windows.Input.StylusDownEventHandler> </xref:System.Windows.UIElement.PreviewStylusDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;
    return:
      type: System.Windows.Input.StylusDownEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusDownEvent
  id: PreviewStylusDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusDownEvent
  nameWithType: UIElement.PreviewStylusDownEvent
  fullName: System.Windows.UIElement.PreviewStylusDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusInAirMove
  id: PreviewStylusInAirMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusInAirMove
  nameWithType: UIElement.PreviewStylusInAirMove
  fullName: System.Windows.UIElement.PreviewStylusInAirMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "実際には、デジタイザーに触れることがなく要素上でスタイラスを動かしたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>なく previewstylusinairmove イベントが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>。 なく previewstylusinairmove イベントのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusInAirMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusInAirMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusInAirMove>.</xref:System.Windows.UIElement.StylusInAirMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.PreviewStylusInAirMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusInAirMoveEvent
  id: PreviewStylusInAirMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusInAirMoveEvent
  nameWithType: UIElement.PreviewStylusInAirMoveEvent
  fullName: System.Windows.UIElement.PreviewStylusInAirMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusInAirMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusInRange
  id: PreviewStylusInRange
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusInRange
  nameWithType: UIElement.PreviewStylusInRange
  fullName: System.Windows.UIElement.PreviewStylusInRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上で検出されるまでデジタイザーに近づいたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>PreviewStylusInRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>。 PreviewStylusInRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusInRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusInRangeEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusInRange>.</xref:System.Windows.UIElement.StylusInRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.PreviewStylusInRangeEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusInRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusInRangeEvent
  id: PreviewStylusInRangeEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusInRangeEvent
  nameWithType: UIElement.PreviewStylusInRangeEvent
  fullName: System.Windows.UIElement.PreviewStylusInRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusInRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusMove
  id: PreviewStylusMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusMove
  nameWithType: UIElement.PreviewStylusMove
  fullName: System.Windows.UIElement.PreviewStylusMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "要素上でスタイラスを動かしたときに発生します。 それ以外の場合、このイベントを発生させる、デジタイザーによって検出されている間にスタイラスが移動する必要があります<xref href=&quot;System.Windows.UIElement.PreviewStylusInAirMove&quot;></xref>が代わりに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>PreviewStylusMove が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>。 PreviewStylusMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusMove>.</xref:System.Windows.UIElement.StylusMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.PreviewStylusMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusMoveEvent
  id: PreviewStylusMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusMoveEvent
  nameWithType: UIElement.PreviewStylusMoveEvent
  fullName: System.Windows.UIElement.PreviewStylusMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusOutOfRange
  id: PreviewStylusOutOfRange
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusOutOfRange
  nameWithType: UIElement.PreviewStylusOutOfRange
  fullName: System.Windows.UIElement.PreviewStylusOutOfRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスが検出されたデジタイザーから離れすぎているときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>PreviewStylusOutOfRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>。 PreviewStylusOutOfRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusOutOfRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusOutOfRangeEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusOutOfRange>.</xref:System.Windows.UIElement.StylusOutOfRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.PreviewStylusOutOfRangeEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  id: PreviewStylusOutOfRangeEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusOutOfRangeEvent
  nameWithType: UIElement.PreviewStylusOutOfRangeEvent
  fullName: System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusOutOfRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusSystemGesture
  id: PreviewStylusSystemGesture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusSystemGesture
  nameWithType: UIElement.PreviewStylusSystemGesture
  fullName: System.Windows.UIElement.PreviewStylusSystemGesture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。"
  remarks: "スタイラス ジェスチャの詳細については、 <xref:System.Windows.Input.SystemGesture>。</xref:System.Windows.Input.SystemGesture>を参照してください。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>PreviewStylusSystemGesture が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>。 PreviewStylusSystemGesture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusSystemGesture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusSystemGestureEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusSystemGestureEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusSystemGesture>.</xref:System.Windows.UIElement.StylusSystemGesture> </xref:System.Windows.Input.StylusSystemGestureEventHandler> </xref:System.Windows.UIElement.PreviewStylusSystemGestureEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;
    return:
      type: System.Windows.Input.StylusSystemGestureEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusSystemGestureEvent
  id: PreviewStylusSystemGestureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusSystemGestureEvent
  nameWithType: UIElement.PreviewStylusSystemGestureEvent
  fullName: System.Windows.UIElement.PreviewStylusSystemGestureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusSystemGesture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusUp
  id: PreviewStylusUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusUp
  nameWithType: UIElement.PreviewStylusUp
  fullName: System.Windows.UIElement.PreviewStylusUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にスタイラスが、ユーザーがスタイラスをデジタイザーから離れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName>添付イベントが、このクラスに対してように<xref:System.Windows.UIElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.UIElement.PreviewStylusDown></xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName>。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=fullName></xref:System.Windows.UIElement.PreviewStylusDown>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_PreviewStylusUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewStylusUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.StylusUp>.</xref:System.Windows.UIElement.StylusUp> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.PreviewStylusUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewStylusUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler PreviewStylusUp;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewStylusUpEvent
  id: PreviewStylusUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewStylusUpEvent
  nameWithType: UIElement.PreviewStylusUpEvent
  fullName: System.Windows.UIElement.PreviewStylusUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewStylusUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTextInput
  id: PreviewTextInput
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTextInput
  nameWithType: UIElement.PreviewTextInput
  fullName: System.Windows.UIElement.PreviewTextInput
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素は、デバイスに依存しない方法でテキストを取得したときに発生します。"
  remarks: "PreviewTextInput イベントは、コンポーネントまたはデバイスに依存しない方法でテキスト入力にリッスンするようにアプリケーションを使用します。 キーボードは、PreviewTextInput; の主な手段は、します。音声認識、手書き認識、およびその他の入力デバイスも PreviewTextInput します。       キーの組み合わせのため、既定のキーボードまたは入力方式エディターから — 複数のキー イベントが&1; つだけのテキスト入力イベントを発生させる可能性があります。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>PreviewTextInput が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>。 PreviewTextInput イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=fullName>。      <a name=&quot;routedEventInfo_PreviewTextInput&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewTextInputEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.Windows.Input.TextCompositionEventHandler>|     対応する-バブル イベントは<xref:System.Windows.UIElement.TextInput>.</xref:System.Windows.UIElement.TextInput> </xref:System.Windows.Input.TextCompositionEventHandler> </xref:System.Windows.UIElement.PreviewTextInputEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewTextInput%2A>。"
  syntax:
    content: public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;
    return:
      type: System.Windows.Input.TextCompositionEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTextInputEvent
  id: PreviewTextInputEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTextInputEvent
  nameWithType: UIElement.PreviewTextInputEvent
  fullName: System.Windows.UIElement.PreviewTextInputEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewTextInput&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTouchDown
  id: PreviewTouchDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTouchDown
  nameWithType: UIElement.PreviewTouchDown
  fullName: System.Windows.UIElement.PreviewTouchDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に触れると発生します。"
  remarks: "既定では、PreviewTouchDown と<xref:System.Windows.UIElement.TouchDown>指が画面に触れるし、移動するまでのイベントが発生しません</xref:System.Windows.UIElement.TouchDown>。 移動することがなく保持したりする画面に指を押すと、キーを押して発生して<xref:System.Windows.Input.Stylus>。</xref:System.Windows.Input.Stylus>の動作を保持 プレス アンド ホールド動作は、マウスの右クリックに相当します。       PreviewTouchDown が発生して<xref:System.Windows.UIElement.TouchDown>、画面に触れると発生するイベントを設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName>添付プロパティ`false`この要素の</xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName></xref:System.Windows.UIElement.TouchDown>。      <a name=&quot;routedEventInfo_PreviewTouchDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewTouchDownEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-バブル イベントは<xref:System.Windows.UIElement.TouchDown>.</xref:System.Windows.UIElement.TouchDown> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.UIElement.PreviewTouchDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewTouchDown%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> PreviewTouchDown;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTouchDownEvent
  id: PreviewTouchDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTouchDownEvent
  nameWithType: UIElement.PreviewTouchDownEvent
  fullName: System.Windows.UIElement.PreviewTouchDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewTouchDown&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTouchMove
  id: PreviewTouchMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTouchMove
  nameWithType: UIElement.PreviewTouchMove
  fullName: System.Windows.UIElement.PreviewTouchMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に指を動かしたときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_PreviewTouchMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewTouchMoveEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-バブル イベントは<xref:System.Windows.UIElement.TouchMove>.</xref:System.Windows.UIElement.TouchMove> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.UIElement.PreviewTouchMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewTouchMove%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> PreviewTouchMove;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTouchMoveEvent
  id: PreviewTouchMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTouchMoveEvent
  nameWithType: UIElement.PreviewTouchMoveEvent
  fullName: System.Windows.UIElement.PreviewTouchMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewTouchMove&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTouchUp
  id: PreviewTouchUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTouchUp
  nameWithType: UIElement.PreviewTouchUp
  fullName: System.Windows.UIElement.PreviewTouchUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面から離れる指が発生したときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_PreviewTouchUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.PreviewTouchUpEvent>|  |ルーティング方法 |トンネリング |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-バブル イベントは<xref:System.Windows.UIElement.TouchUp>.</xref:System.Windows.UIElement.TouchUp> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.UIElement.PreviewTouchUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnPreviewTouchUp%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> PreviewTouchUp;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.PreviewTouchUpEvent
  id: PreviewTouchUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: PreviewTouchUpEvent
  nameWithType: UIElement.PreviewTouchUpEvent
  fullName: System.Windows.UIElement.PreviewTouchUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.PreviewTouchUp&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.QueryContinueDrag
  id: QueryContinueDrag
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: QueryContinueDrag
  nameWithType: UIElement.QueryContinueDrag
  fullName: System.Windows.UIElement.QueryContinueDrag
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ドラッグ アンド ドロップ操作中にキーボードまたはマウス ボタンの状態に変更があるときに発生します。"
  remarks: "QueryContinueDrag イベントは、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断できます。       このイベントのエイリアスを作成する、 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>QueryContinueDrag が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>。 QueryContinueDrag イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=fullName>。      <a name=&quot;routedEventInfo_QueryContinueDrag&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.QueryContinueDragEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.QueryContinueDragEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewQueryContinueDrag>.</xref:System.Windows.UIElement.PreviewQueryContinueDrag> </xref:System.Windows.QueryContinueDragEventHandler> </xref:System.Windows.UIElement.QueryContinueDragEvent>      -オーバーライド<xref:System.Windows.UIElement.OnQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnQueryContinueDrag%2A>。"
  syntax:
    content: public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;
    return:
      type: System.Windows.QueryContinueDragEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.QueryContinueDragEvent
  id: QueryContinueDragEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: QueryContinueDragEvent
  nameWithType: UIElement.QueryContinueDragEvent
  fullName: System.Windows.UIElement.QueryContinueDragEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.QueryContinueDrag&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.QueryCursor
  id: QueryCursor
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: QueryCursor
  nameWithType: UIElement.QueryCursor
  fullName: System.Windows.UIElement.QueryCursor
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "表示する、カーソルが要求されると発生します。 マウスのポインターはカーソル オブジェクトを変更する必要がありますが、新しい位置に基づいて、新しい場所に移動するたびに、要素にこのイベントが発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>QueryCursor が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>。 QueryCursor イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=fullName>。       このイベント名によって参照されているカーソルは、必ずしも (カーソルとも呼ばれる) テキストのカーソルではありません。 代わりに、いくつかの可能な入力に関連するデバイスまたはの概念に関連する画面上のグラフィカル表示を宣言するオブジェクトは、このコンテキストでのカーソル[!INCLUDE[TLA2#tla_win](~/add/includes/tla2sharptla-win-md.md)]プログラミングします。 そのオブジェクトがによって表される、<xref:System.Windows.Input.Cursor>クラス[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</xref:System.Windows.Input.Cursor>。 [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]入力システムでは、マウス ポインターの画面上の位置を表す場合は、このカーソルを変更することができます。 定義済みの値を使用することができます、<xref:System.Windows.Input.Cursors>列挙型、または画像ファイルとしてカスタム カーソルを宣言できます</xref:System.Windows.Input.Cursors>。       QueryCursor のイベントのリッスンがカーソル管理の効率的な方法です。 代わりに、各要素が<xref:System.Windows.FrameworkContentElement.Cursor%2A><xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。</xref:System.Windows.FrameworkContentElement.ForceCursor%2A></xref:System.Windows.FrameworkContentElement.Cursor%2A>とそれぞれのカーソル動作を定義する必要があります。 WPF フレームワーク レベルの基本要素を使用していないまたはで特別な状況で要素ごとの単位でのカーソルの動作を定義するがニーズに合わない場合は、のみ QueryCursor に依存する必要があります。 QueryCursor への応答のカーソルの動作を実装する方法については、 <xref:System.Windows.Input.QueryCursorEventHandler>。</xref:System.Windows.Input.QueryCursorEventHandler>を参照してください。      <a name=&quot;routedEventInfo_QueryCursor&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.QueryCursorEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.QueryCursorEventHandler>|     -、定義済みの対応するトンネリング イベントはありません</xref:System.Windows.Input.QueryCursorEventHandler></xref:System.Windows.UIElement.QueryCursorEvent>。      -オーバーライド<xref:System.Windows.UIElement.OnQueryCursor%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnQueryCursor%2A>。"
  syntax:
    content: public event System.Windows.Input.QueryCursorEventHandler QueryCursor;
    return:
      type: System.Windows.Input.QueryCursorEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.QueryCursorEvent
  id: QueryCursorEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: QueryCursorEvent
  nameWithType: UIElement.QueryCursorEvent
  fullName: System.Windows.UIElement.QueryCursorEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.QueryCursor&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent QueryCursorEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  id: RaiseEvent(System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: RaiseEvent(RoutedEventArgs)
  nameWithType: UIElement.RaiseEvent(RoutedEventArgs)
  fullName: System.Windows.UIElement.RaiseEvent(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "特定のルーティング イベントを発生させます。 <xref href=&quot;System.Windows.RoutedEvent&quot;> </xref>内で識別されるときに生成される、 <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>提供されているインスタンス (として、<xref:System.Windows.RoutedEventArgs.RoutedEvent*>そのイベント データのプロパティ).</xref:System.Windows.RoutedEventArgs.RoutedEvent*>"
  remarks: "`e`ルーティング イベントのすべてのデータの共通の基本型として型指定されたパラメーターですただし、ため発生するイベントに使用される最も固有のイベント データの種類として、イベント データを指定してください<xref:System.Windows.RoutedEventArgs>派生クラスが発生すると、特定のイベントは、特定の実際のデータ プロパティが含まれています。</xref:System.Windows.RoutedEventArgs> 。       <xref:System.Windows.RoutedEventArgs>イベントの状態のプロパティだけではありません。ルーティング イベントを発生させるも識別します。</xref:System.Windows.RoutedEventArgs> このイベント発生パターンと、ルーティングされたイベント データの両方が異なる[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]イベントに関連するプロパティを通常だけが含まれるイベントやデータのクラスです。"
  example:
  - "The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.  \n  \n [!code-cs[RoutedEventCustom#RaiseEvent](~/add/codesnippet/csharp/RoutedEventCustom/SDKSampleLibrary/class1.cs#raiseevent)]\n [!code-vb[RoutedEventCustom#RaiseEvent](~/add/codesnippet/visualbasic/SDKSampleLibrary/Class1.vb#raiseevent)]"
  syntax:
    content: public void RaiseEvent (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "A <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>イベント データを格納しても発生させるイベントを識別します。"
  overload: System.Windows.UIElement.RaiseEvent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ReleaseAllTouchCaptures
  id: ReleaseAllTouchCaptures
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ReleaseAllTouchCaptures()
  nameWithType: UIElement.ReleaseAllTouchCaptures()
  fullName: System.Windows.UIElement.ReleaseAllTouchCaptures()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素からすべてのキャプチャされたタッチ デバイスを解放します。"
  syntax:
    content: public void ReleaseAllTouchCaptures ();
    parameters: []
  overload: System.Windows.UIElement.ReleaseAllTouchCaptures*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ReleaseMouseCapture
  id: ReleaseMouseCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ReleaseMouseCapture()
  nameWithType: UIElement.ReleaseMouseCapture()
  fullName: System.Windows.UIElement.ReleaseMouseCapture()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素には、キャプチャが保持されている場合は、マウスのキャプチャを解放します。"
  remarks: "この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。 値を確認してください<xref:System.Windows.UIElement.IsMouseCaptured%2A>このメソッドを呼び出す前にします</xref:System.Windows.UIElement.IsMouseCaptured%2A>。"
  example:
  - "The following example is the parallel to the example given for <xref:System.Windows.UIElement.CaptureMouse%2A>: it handles mouse button up to release mouse capture and re-enable moving the mouse.  \n  \n [!code-cs[CubeAnimation#UIElementMouseCapture](~/add/codesnippet/csharp/CubeAnimation_XBAP/Trackball.cs#uielementmousecapture)]\n [!code-vb[CubeAnimation#UIElementMouseCapture](~/add/codesnippet/visualbasic/cubeanimation_xbap/trackball.vb#uielementmousecapture)]"
  syntax:
    content: public void ReleaseMouseCapture ();
    parameters: []
  overload: System.Windows.UIElement.ReleaseMouseCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ReleaseStylusCapture
  id: ReleaseStylusCapture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ReleaseStylusCapture()
  nameWithType: UIElement.ReleaseStylusCapture()
  fullName: System.Windows.UIElement.ReleaseStylusCapture()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素には、キャプチャが保持されている場合は、スタイラス デバイスのキャプチャを解放します。"
  remarks: "この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。 値を確認してください<xref:System.Windows.UIElement.IsStylusCaptured%2A>このメソッドを呼び出す前にします</xref:System.Windows.UIElement.IsStylusCaptured%2A>。"
  syntax:
    content: public void ReleaseStylusCapture ();
    parameters: []
  overload: System.Windows.UIElement.ReleaseStylusCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  id: ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ReleaseTouchCapture(TouchDevice)
  nameWithType: UIElement.ReleaseTouchCapture(TouchDevice)
  fullName: System.Windows.UIElement.ReleaseTouchCapture(TouchDevice)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素から指定したタッチ デバイスを解放しようとしています。"
  syntax:
    content: public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);
    parameters:
    - id: touchDevice
      type: System.Windows.Input.TouchDevice
      description: "解放するデバイスです。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>タッチ デバイスを放した場合です。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.ReleaseTouchCapture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>touchDevice</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  id: RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: RemoveHandler(RoutedEvent,Delegate)
  nameWithType: UIElement.RemoveHandler(RoutedEvent,Delegate)
  fullName: System.Windows.UIElement.RemoveHandler(RoutedEvent,Delegate)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素から指定したルーティング イベント ハンドラーを削除します。"
  remarks: "これを使用するための最も一般的なシナリオ[!INCLUDE[TLA#tla_api](~/add/includes/tlasharptla-api-md.md)]を実装する場合は、[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]カスタム ルーティング イベントのハンドラーの削除」ロジックを実装するときに特に関連付けられている「ラッパー」イベント、[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]レベル。 これを次の例「解説」セクションでは、このシナリオを示しています。       このメソッドを呼び出しても何も起こりませんメソッドの呼び出しの入力パラメーターに一致する条件で登録されたハンドラーがない場合。       数より多い場合に、イベント ハンドラーのストアの削除に最初のハンドラーのみ、条件に一致する&1; つのハンドラーがアタッチされます。 この動作は整合[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]の動作、`-=`演算子。       どちらも`routedEvent`も`handler`あります`null`です。 いずれかの値として提供しようとしています。`null`で例外が発生します。       このメソッドは無視、`handledEventsToo`場合は、ハンドラーが最初に提供されているパラメーターについては、追加、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>処理済みのイベントの処理を有効に署名します</xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>。 ハンドラーのいずれかの型が削除されます。"
  example:
  - "The following example uses RemoveHandler as part of an event wrapper definition.  \n  \n [!code-cs[RoutedEventCustom#AddRemoveHandler](~/add/codesnippet/csharp/RoutedEventCustom/SDKSampleLibrary/class1.cs#addremovehandler)]\n [!code-vb[RoutedEventCustom#AddRemoveHandler](~/add/codesnippet/visualbasic/SDKSampleLibrary/Class1.vb#addremovehandler)]"
  syntax:
    content: public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);
    parameters:
    - id: routedEvent
      type: System.Windows.RoutedEvent
      description: "ハンドラーがアタッチされているルーティング イベントの識別子。"
    - id: handler
      type: System.Delegate
      description: "この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。"
  overload: System.Windows.UIElement.RemoveHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.RenderSize
  id: RenderSize
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: RenderSize
  nameWithType: UIElement.RenderSize
  fullName: System.Windows.UIElement.RenderSize
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得 (または、セットが、「解説」を参照してください)、最終的なは、この要素サイズを表示します。"
  remarks: "> [!IMPORTANT]> このプロパティは、どちらかに設定しようとはしないで[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]またはコードでは、WPF フレームワーク レベルのレイアウト システムを使用する場合。 ほぼすべての一般的なアプリケーション シナリオでは、このレイアウト システムを使用します。 サイズ セットを RenderSize プロパティでは、レイアウト システムによって直接は反映されません。 RenderSize プロパティが特定の WPF コア レベルの意図的に、<xref:System.Windows.Documents.Adorner>クラス</xref:System.Windows.Documents.Adorner>のサポートなど、一般的なレイアウトのプロトコルを回避するケースをブリッジを有効にする場合にのみ書き込み可能な宣言します。       レイアウト システム内で適用可能な表示サイズをオーバーライド<xref:System.Windows.UIElement.OnRender%2A>または<xref:System.Windows.UIElement.GetLayoutClip%2A>。</xref:System.Windows.UIElement.GetLayoutClip%2A></xref:System.Windows.UIElement.OnRender%2A>などの確認のこのプロパティを使用することができます。       一般的なシナリオの処理、<xref:System.Windows.FrameworkElement.SizeChanged>クラス ハンドラーでイベントをオーバーライドまたは<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>イベント</xref:System.Windows.UIElement.OnRenderSizeChanged%2A></xref:System.Windows.FrameworkElement.SizeChanged>。      <a name=&quot;xamlTextUsage_RenderSize&quot;></a>## XAML テキストの使用方法"
  example:
  - "The following example shows how a custom adorner uses the RenderSize value in order to create and size the rectangle graphic that defines the adorner, as part of its <xref:System.Windows.UIElement.OnRender%2A>implementation.  \n  \n [!code-vb[AdornersMiscCode#UIElementDesiredSize](~/add/codesnippet/visualbasic/adornersmisccode/window1.xaml.vb#uielementdesiredsize)]\n [!code-cs[AdornersMiscCode#UIElementDesiredSize](~/add/codesnippet/csharp/AdornersMiscCode/Window1.xaml.cs#uielementdesiredsize)]"
  syntax:
    content: public System.Windows.Size RenderSize { get; set; }
    return:
      type: System.Windows.Size
      description: "この要素の描画のサイズ。"
  overload: System.Windows.UIElement.RenderSize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.RenderTransform
  id: RenderTransform
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: RenderTransform
  nameWithType: UIElement.RenderTransform
  fullName: System.Windows.UIElement.RenderTransform
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素の描画位置に影響する変換情報を設定します。  これは、依存関係プロパティです。"
  remarks: "描画変換レイアウトのサイズを再生成またはしませんサイズ情報を表示します。 レンダリングの変換は通常アニメーションや要素に一時的な効果を適用するためのものです。 たとえば、要素が拡大表示時マウス上、またはの部分に目を描画する負荷に重点を置いて、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]です。      <a name=&quot;dependencyPropertyInfo_RenderTransform&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.RenderTransformProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.RenderTransformProperty>"
  syntax:
    content: public System.Windows.Media.Transform RenderTransform { get; set; }
    return:
      type: System.Windows.Media.Transform
      description: "必要な描画変換の詳細について説明します。 既定値は&lt;xref:System.Windows.Media.Transform.Identity%2A?displayProperty=fullName&gt;です。"
  overload: System.Windows.UIElement.RenderTransform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.RenderTransformOrigin
  id: RenderTransformOrigin
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: RenderTransformOrigin
  nameWithType: UIElement.RenderTransformOrigin
  fullName: System.Windows.UIElement.RenderTransformOrigin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または設定によって宣言されるすべての使用可能な表示変換の中心点<xref:System.Windows.UIElement.RenderTransform*>、要素の境界に相対パス</xref:System.Windows.UIElement.RenderTransform*>。  これは、依存関係プロパティです。"
  remarks: "RenderTransformOrigin が多少標準を使用して、<xref:System.Windows.Point>構造体の値を<xref:System.Windows.Point>座標システムで絶対位置を表していません</xref:System.Windows.Point></xref:System.Windows.Point>。 代わりに、0 ~ 1 の間の値は、それぞれの x、y 軸の現在の要素の範囲の要素として解釈されます。 たとえば、(0.5,0.5) は、要素上で中央揃えにする描画変換が発生 (1,&1;) または配置描画変換下部にある要素の右上隅です。 <xref:System.Double.NaN>許容される値ではありません。</xref:System.Double.NaN>       0 と 1 以外の値もが受け入れられ、その他の型にはまらない変換効果になります。 たとえば、(5,5) を適用し、RenderTransformOrigin を設定するかどうか、 <xref:System.Windows.Media.RotateTransform>、回転のポイントは、要素自体の境界の外側にもなります</xref:System.Windows.Media.RotateTransform>。 変換には、右下を超える発信される大規模な円で囲んだ中心、要素が回転されます。 原点可能性がありますにどこかにその親要素内してでした可能性のある可能性のあるフレームまたはビューからです。 負の値のポイントの値は似ていますが、これらは左境界を超えます。       レンダリング トランス フォームのレイアウトに影響しない通常を使用して、アニメーションや要素に一時的な効果を適用します。      <a name=&quot;xamlAttributeUsage_RenderTransformOrigin&quot;></a>## XAML 属性の使用```   <object RenderTransformOrigin=&quot;xOrigin, yOrigin&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_RenderTransformOrigin&quot;> </a> ## XAML プロパティ要素の使用```   <object>     <object.RenderTransformOrigin>       <Point X=&quot; xOrigin &quot; Y=&quot; yOrigin &quot;/>     </object.RenderTransformOrigin>   </object>   ``` <a name=&quot;xamlValues_RenderTransformOrigin&quot;> </a> ## XAML 値*xOrigin*水平の中心点の係数。             これは通常、0 ~ 1 の値として指定します。 「解説」を参照してください。       **垂直の中心点の係数。 これは通常、0 ~ 1 の値として指定します。 「解説」を参照してください。      <a name=&quot;dependencyPropertyInfo_RenderTransformOrigin&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.RenderTransformOriginProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.RenderTransformOriginProperty>"
  example:
  - "The following example builds up elements in code, applies a RenderTransformOrigin, and then applies a  <xref:System.Windows.UIElement.RenderTransform%2A>.  \n  \n [!code-cs[transformanimations_snip#UIElementRenderTransformOrigin](~/add/codesnippet/csharp/transformanimations_snip.project/RotateAboutCenterExample.cs#uielementrendertransformorigin)]\n [!code-vb[transformanimations_snip#UIElementRenderTransformOrigin](~/add/codesnippet/visualbasic/project/rotateaboutcenterexample.vb#uielementrendertransformorigin)]"
  syntax:
    content: public System.Windows.Point RenderTransformOrigin { get; set; }
    return:
      type: System.Windows.Point
      description: "描画変換を宣言する値。 既定値は、 <xref href=&quot;System.Windows.Point&quot;> </xref>座標 (0,&0;) を使用しています。"
  overload: System.Windows.UIElement.RenderTransformOrigin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.RenderTransformOriginProperty
  id: RenderTransformOriginProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: RenderTransformOriginProperty
  nameWithType: UIElement.RenderTransformOriginProperty
  fullName: System.Windows.UIElement.RenderTransformOriginProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.RenderTransformOrigin*>依存関係プロパティ</xref:System.Windows.UIElement.RenderTransformOrigin*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty RenderTransformOriginProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.RenderTransformProperty
  id: RenderTransformProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: RenderTransformProperty
  nameWithType: UIElement.RenderTransformProperty
  fullName: System.Windows.UIElement.RenderTransformProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.RenderTransform*>依存関係プロパティ</xref:System.Windows.UIElement.RenderTransform*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty RenderTransformProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ShouldSerializeCommandBindings
  id: ShouldSerializeCommandBindings
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ShouldSerializeCommandBindings()
  nameWithType: UIElement.ShouldSerializeCommandBindings()
  fullName: System.Windows.UIElement.ShouldSerializeCommandBindings()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "シリアル化プロセスが、<xref:System.Windows.UIElement.CommandBindings*>このクラスのインスタンスのプロパティ</xref:System.Windows.UIElement.CommandBindings*>の内容をシリアル化する必要かどうかを返します"
  remarks: "これは、戻り値は`true`場合<xref:System.Windows.UIElement.CommandBindings%2A>ローカルに設定します</xref:System.Windows.UIElement.CommandBindings%2A>。       これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.CommandBindings%2A>プロパティには、単純な既定値にありません</xref:System.Windows.UIElement.CommandBindings%2A>。 このメソッドは、既定値から、プロパティが変更されたかどうかを示します。 デザイナーを開発または<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>を組み込む独自のコントロールを開発する場合に通常、このメソッドが呼び出す       詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public bool ShouldSerializeCommandBindings ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、<xref:System.Windows.UIElement.CommandBindings*>プロパティの値が、それ以外のシリアル化する必要があります<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.UIElement.CommandBindings*> 。"
  overload: System.Windows.UIElement.ShouldSerializeCommandBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.ShouldSerializeInputBindings
  id: ShouldSerializeInputBindings
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: ShouldSerializeInputBindings()
  nameWithType: UIElement.ShouldSerializeInputBindings()
  fullName: System.Windows.UIElement.ShouldSerializeInputBindings()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "シリアル化プロセスが、<xref:System.Windows.UIElement.InputBindings*>このクラスのインスタンスのプロパティ</xref:System.Windows.UIElement.InputBindings*>の内容をシリアル化する必要かどうかを返します"
  remarks: "これは、戻り値は`true`場合<xref:System.Windows.UIElement.InputBindings%2A>ローカルに設定します</xref:System.Windows.UIElement.InputBindings%2A>。       これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.InputBindings%2A>プロパティには、単純な既定値にありません</xref:System.Windows.UIElement.InputBindings%2A>。 このメソッドは、既定値から、プロパティが変更されたかどうかを示します。 デザイナーを開発または<xref:System.Windows.UIElement>。</xref:System.Windows.UIElement>を組み込む独自のコントロールを開発する場合に通常、このメソッドが呼び出す       詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/add/includes/ajax-current-ext-md.md)です。"
  syntax:
    content: public bool ShouldSerializeInputBindings ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、<xref:System.Windows.UIElement.InputBindings*>プロパティの値が、それ以外のシリアル化する必要があります<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Windows.UIElement.InputBindings*> 。"
  overload: System.Windows.UIElement.ShouldSerializeInputBindings*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.SnapsToDevicePixels
  id: SnapsToDevicePixels
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: SnapsToDevicePixels
  nameWithType: UIElement.SnapsToDevicePixels
  fullName: System.Windows.UIElement.SnapsToDevicePixels
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素のレンダリングがレンダリング時にデバイスに固有のピクセルの設定を使用するかどうかを決定する値を設定します。  これは、依存関係プロパティです。"
  remarks: "このプロパティを設定することができます`true`ピクセルを有効にする、ルート要素にスナップ UI 全体にわたって表示します。 デバイスで 96 より大きい[!INCLUDE[TLA#tla_dpi](~/add/includes/ajax-current-ext-md.md)]、ピクセル スナップ レンダリングには、単一の実線の近くのアンチエイリアシング visual 成果物が最小限に抑えることができます。       継承された場合<xref:System.Windows.FrameworkElement>可能性のあるすべての派生クラス、または<xref:System.Windows.FrameworkElement>を設定するには、この依存関係プロパティのメタデータを上書き、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>メタデータ プロパティを`true`</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A></xref:System.Windows.FrameworkElement></xref:System.Windows.FrameworkElement>。 サブツリーの最も外側の要素だけが SnapsToDevicePixels としてを指定する必要があることがこの場合実現`true`とそのサブツリーのすべての子要素として SnapsToDevicePixels、報告`true`SnapsToDevicePixels 視覚効果を必要とします。      <a name=&quot;dependencyPropertyInfo_SnapsToDevicePixels&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.SnapsToDevicePixelsProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.SnapsToDevicePixelsProperty>"
  syntax:
    content: public bool SnapsToDevicePixels { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>デバイスのピクセルに従って要素を描画する場合それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定で宣言されている<xref href=&quot;System.Windows.UIElement&quot;></xref>は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Windows.UIElement.SnapsToDevicePixels*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.SnapsToDevicePixelsProperty
  id: SnapsToDevicePixelsProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: SnapsToDevicePixelsProperty
  nameWithType: UIElement.SnapsToDevicePixelsProperty
  fullName: System.Windows.UIElement.SnapsToDevicePixelsProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.SnapsToDevicePixels*>依存関係プロパティ</xref:System.Windows.UIElement.SnapsToDevicePixels*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusButtonDown
  id: StylusButtonDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusButtonDown
  nameWithType: UIElement.StylusButtonDown
  fullName: System.Windows.UIElement.StylusButtonDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが押されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>StylusButtonDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>。 StylusButtonDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusButtonDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusButtonDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusButtonDown>.</xref:System.Windows.UIElement.PreviewStylusButtonDown> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.UIElement.StylusButtonDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusButtonDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusButtonDownEvent
  id: StylusButtonDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusButtonDownEvent
  nameWithType: UIElement.StylusButtonDownEvent
  fullName: System.Windows.UIElement.StylusButtonDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusButtonDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusButtonUp
  id: StylusButtonUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusButtonUp
  nameWithType: UIElement.StylusButtonUp
  fullName: System.Windows.UIElement.StylusButtonUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ポインターがこの要素上でスタイラス ボタンが離されたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>StylusButtonUp 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素としては、継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>。 StylusButtonUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusButtonUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusButtonUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusButtonEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusButtonUp>.</xref:System.Windows.UIElement.PreviewStylusButtonUp> </xref:System.Windows.Input.StylusButtonEventHandler> </xref:System.Windows.UIElement.StylusButtonUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusButtonUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;
    return:
      type: System.Windows.Input.StylusButtonEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusButtonUpEvent
  id: StylusButtonUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusButtonUpEvent
  nameWithType: UIElement.StylusButtonUpEvent
  fullName: System.Windows.UIElement.StylusButtonUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusButtonUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusDown
  id: StylusDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusDown
  nameWithType: UIElement.StylusDown
  fullName: System.Windows.UIElement.StylusDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上でスタイラスがデジタイザーに触れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>StylusDown が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>。 StylusDown イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusDown?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusDownEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusDown>.</xref:System.Windows.UIElement.PreviewStylusDown> </xref:System.Windows.Input.StylusDownEventHandler> </xref:System.Windows.UIElement.StylusDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusDown%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusDownEventHandler StylusDown;
    return:
      type: System.Windows.Input.StylusDownEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusDownEvent
  id: StylusDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusDownEvent
  nameWithType: UIElement.StylusDownEvent
  fullName: System.Windows.UIElement.StylusDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusDown&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusEnter
  id: StylusEnter
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusEnter
  nameWithType: UIElement.StylusEnter
  fullName: System.Windows.UIElement.StylusEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素の境界に入ったときに発生します。"
  remarks: "StylusEnter は、直接のイベントのルーティング方法を処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       StylusEnter を追跡、スタイラスが要素の境界に入ったときに、このイベントより文字どおりを報告している、<xref:System.Windows.UIElement.IsStylusOver%2A>からプロパティ値が変更された`false`を`true`この要素上です</xref:System.Windows.UIElement.IsStylusOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>StylusEnter が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>。 StylusEnter イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusEnterEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnStylusEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusEnter%2A></xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.UIElement.StylusEnterEvent>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusEnter;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusEnterEvent
  id: StylusEnterEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusEnterEvent
  nameWithType: UIElement.StylusEnterEvent
  fullName: System.Windows.UIElement.StylusEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusEnter&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusInAirMove
  id: StylusInAirMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusInAirMove
  nameWithType: UIElement.StylusInAirMove
  fullName: System.Windows.UIElement.StylusInAirMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "実際には、デジタイザーに触れることがなく要素上でスタイラスを動かしたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>なく stylusinairmove イベントが一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>。 なく stylusinairmove イベントのイベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusInAirMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusInAirMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusInAirMove>.</xref:System.Windows.UIElement.PreviewStylusInAirMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.StylusInAirMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusInAirMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusInAirMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusInAirMoveEvent
  id: StylusInAirMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusInAirMoveEvent
  nameWithType: UIElement.StylusInAirMoveEvent
  fullName: System.Windows.UIElement.StylusInAirMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusInAirMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusInRange
  id: StylusInRange
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusInRange
  nameWithType: UIElement.StylusInRange
  fullName: System.Windows.UIElement.StylusInRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上で検出されるまでデジタイザーに近づいたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>StylusInRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>。 StylusInRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusInRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusInRangeEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusInRange>.</xref:System.Windows.UIElement.PreviewStylusInRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.StylusInRangeEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusInRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusInRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusInRangeEvent
  id: StylusInRangeEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusInRangeEvent
  nameWithType: UIElement.StylusInRangeEvent
  fullName: System.Windows.UIElement.StylusInRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusInRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusInRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusLeave
  id: StylusLeave
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusLeave
  nameWithType: UIElement.StylusLeave
  fullName: System.Windows.UIElement.StylusLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスが要素の境界から出たときに発生します。"
  remarks: "StylusLeave は、直接のイベントのルーティング方法を処理を使用します。 ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。 ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。       StylusLeave を追跡スタイラスが要素の境界から出たときに、このイベントより文字どおりを報告している、<xref:System.Windows.UIElement.IsStylusOver%2A>からプロパティ値が変更された`true`に`false`この要素上です</xref:System.Windows.UIElement.IsStylusOver%2A>。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>StylusLeave が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>。 StylusLeave イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusLeaveEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     -オーバーライド<xref:System.Windows.UIElement.OnStylusLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusLeave%2A></xref:System.Windows.Input.StylusEventHandler></xref:System.Windows.UIElement.StylusLeaveEvent>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusLeave;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusLeaveEvent
  id: StylusLeaveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusLeaveEvent
  nameWithType: UIElement.StylusLeaveEvent
  fullName: System.Windows.UIElement.StylusLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusLeave&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusMove
  id: StylusMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusMove
  nameWithType: UIElement.StylusMove
  fullName: System.Windows.UIElement.StylusMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上でスタイラスを動かしたときに発生します。 スタイラスがデジタイザーにこのイベントを発生時に移動する必要があります。 それ以外の場合、 <xref href=&quot;System.Windows.UIElement.StylusInAirMove&quot;> </xref>が代わりに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>StylusMove 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素としては、継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>。 StylusMove イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusMove?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusMove>.</xref:System.Windows.UIElement.PreviewStylusMove> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.StylusMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusMove%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusMove;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusMoveEvent
  id: StylusMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusMoveEvent
  nameWithType: UIElement.StylusMoveEvent
  fullName: System.Windows.UIElement.StylusMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusMove&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusOutOfRange
  id: StylusOutOfRange
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusOutOfRange
  nameWithType: UIElement.StylusOutOfRange
  fullName: System.Windows.UIElement.StylusOutOfRange
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "スタイラスがこの要素上で、検出されたデジタイザーから離れすぎているときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>StylusOutOfRange が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>。 StylusOutOfRange イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusOutOfRange&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusOutOfRangeEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusOutOfRange>.</xref:System.Windows.UIElement.PreviewStylusOutOfRange> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.StylusOutOfRangeEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusOutOfRange%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusOutOfRange;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusOutOfRangeEvent
  id: StylusOutOfRangeEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusOutOfRangeEvent
  nameWithType: UIElement.StylusOutOfRangeEvent
  fullName: System.Windows.UIElement.StylusOutOfRangeEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusOutOfRange&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusPlugIns
  id: StylusPlugIns
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusPlugIns
  nameWithType: UIElement.StylusPlugIns
  fullName: System.Windows.UIElement.StylusPlugIns
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に関連付けられているすべてのスタイラス プラグイン (カスタマイズ) オブジェクトのコレクションを取得します。"
  remarks: "このコレクションに追加されるコントロールの例としては<xref:System.Windows.Controls.InkCanvas>。</xref:System.Windows.Controls.InkCanvas> <xref:System.Windows.Controls.InkCanvas>追加、<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>これにより、コレクション項目として、<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>スタイラス入力と対話し、スタイラス イベント駆動型への応答で一意のレンダリングを生成します</xref:System.Windows.Input.StylusPlugIns.DynamicRenderer></xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>。</xref:System.Windows.Controls.InkCanvas>       カスタム プラグインを作成する方法については、受信し、スタイラス入力の解釈を参照してください。[スタイラスからの入力をインターセプトし、](~/add/includes/ajax-current-ext-md.md)です。"
  example:
  - "The following example creates a <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> instance and adds it to the StylusPlugIns collection for a custom ink handling control.  \n  \n [!code-vb[StylusPluginSamples#3](~/add/codesnippet/visualbasic/StylusPluginSamples/StylusControl.vb#3)]\n [!code-cs[StylusPluginSamples#3](~/add/codesnippet/csharp/StylusPluginSamples/StylusControl.cs#3)]"
  syntax:
    content: protected System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns { get; }
    return:
      type: System.Windows.Input.StylusPlugIns.StylusPlugInCollection
      description: "スタイラス プラグインの特殊化されたコレクションとしてのコレクション。"
  overload: System.Windows.UIElement.StylusPlugIns*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusSystemGesture
  id: StylusSystemGesture
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusSystemGesture
  nameWithType: UIElement.StylusSystemGesture
  fullName: System.Windows.UIElement.StylusSystemGesture
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。"
  remarks: "スタイラス ジェスチャの詳細については、 <xref:System.Windows.Input.SystemGesture>。</xref:System.Windows.Input.SystemGesture>を参照してください。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>StylusSystemGesture 一部であるように、このクラスのイベントを接続されているクラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素としては、継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>。 StylusSystemGesture イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusSystemGesture&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusSystemGestureEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusSystemGestureEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusSystemGesture>.</xref:System.Windows.UIElement.PreviewStylusSystemGesture> </xref:System.Windows.Input.StylusSystemGestureEventHandler> </xref:System.Windows.UIElement.StylusSystemGestureEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusSystemGesture%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;
    return:
      type: System.Windows.Input.StylusSystemGestureEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusSystemGestureEvent
  id: StylusSystemGestureEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusSystemGestureEvent
  nameWithType: UIElement.StylusSystemGestureEvent
  fullName: System.Windows.UIElement.StylusSystemGestureEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusSystemGesture&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusUp
  id: StylusUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusUp
  nameWithType: UIElement.StylusUp
  fullName: System.Windows.UIElement.StylusUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素上で、ユーザーがスタイラスをデジタイザーから離れたときに発生します。"
  remarks: "このイベントのエイリアスを作成する、 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>StylusUp が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>。 StylusUp イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.Stylus.StylusUp?displayProperty=fullName>。       タッチ、マウス、およびスタイラス入力は、特定のリレーションシップで存在します。 詳細については、次を参照してください。[入力概要](~/add/includes/ajax-current-ext-md.md)です。      <a name=&quot;routedEventInfo_StylusUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.StylusUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.StylusEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewStylusUp>.</xref:System.Windows.UIElement.PreviewStylusUp> </xref:System.Windows.Input.StylusEventHandler> </xref:System.Windows.UIElement.StylusUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnStylusUp%2A>。"
  syntax:
    content: public event System.Windows.Input.StylusEventHandler StylusUp;
    return:
      type: System.Windows.Input.StylusEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.StylusUpEvent
  id: StylusUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: StylusUpEvent
  nameWithType: UIElement.StylusUpEvent
  fullName: System.Windows.UIElement.StylusUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.StylusUp&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent StylusUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TextInput
  id: TextInput
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TextInput
  nameWithType: UIElement.TextInput
  fullName: System.Windows.UIElement.TextInput
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素は、デバイスに依存しない方法でテキストを取得したときに発生します。"
  remarks: "> [!IMPORTANT]> このイベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。 以下の解説を参照してください。       複合コントロールの内部実装によって処理される、TextInput イベントをマーク既に可能性があります。 たとえば、<xref:System.Windows.Controls.TextBox>場所 TextInput イベントは既に設定されて処理済みとして以外の場合は、合成内で複合コントロールは、</xref:System.Windows.Controls.TextBox> 。 コントロールは、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があります。 使用する場合<xref:System.Windows.UIElement.PreviewTextInput>テキスト入力用のハンドラーをアタッチするイベント、としてより良い結果を受け取ることがあります</xref:System.Windows.UIElement.PreviewTextInput>。 この手法は、コントロールの複合ハンドル済みとしては、このイベントをマークが既にあり、ハンドラーがイベント ルート上でイベントを受信できないように、ほとんどの場合を回避できます。       TextInput イベントは、コンポーネントまたはデバイスに依存しない方法でテキスト入力にリッスンするようにアプリケーションを使用します。 キーボードは TextInput が、音声の手書きの主な手段とも、他の入力デバイスは TextInput を生成する可能性ができます。       キーの組み合わせが原因: 既定のキーボードまたは入力方式エディターから — 複数のキー イベントが&1; つのテキスト入力イベントを発生させる可能性があります。       このイベントのエイリアスを作成する、 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>TextInput が一部になるように、このクラスのイベントをアタッチ クラスのメンバー一覧をいつ<xref:System.Windows.UIElement>基本要素として継承します</xref:System.Windows.UIElement></xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>。 TextInput イベントに関連付けられているイベント ハンドラーが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>添付イベントと同じイベント データ インスタンスを受信します</xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=fullName>。      <a name=&quot;routedEventInfo_TextInput&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.TextInputEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.Windows.Input.TextCompositionEventHandler>|     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewTextInput>.</xref:System.Windows.UIElement.PreviewTextInput> </xref:System.Windows.Input.TextCompositionEventHandler> </xref:System.Windows.UIElement.TextInputEvent>      -オーバーライド<xref:System.Windows.UIElement.OnTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnTextInput%2A>。"
  syntax:
    content: public event System.Windows.Input.TextCompositionEventHandler TextInput;
    return:
      type: System.Windows.Input.TextCompositionEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TextInputEvent
  id: TextInputEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TextInputEvent
  nameWithType: UIElement.TextInputEvent
  fullName: System.Windows.UIElement.TextInputEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.TextInput&quot;> </xref>ルーティングされたイベント。"
  remarks: "ルーティング イベントの識別子は、ルーティングされたイベントが登録されているときに作成されます。 これらの識別子には、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用すると、クラス ハンドラーを追加します。       ルーティング イベントの登録の詳細については、 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</xref:System.Windows.EventManager.RegisterClassHandler%2A>を参照してください。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TextInputEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchDown
  id: TouchDown
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchDown
  nameWithType: UIElement.TouchDown
  fullName: System.Windows.UIElement.TouchDown
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に触れると発生します。"
  remarks: "既定では、<xref:System.Windows.UIElement.PreviewTouchDown>し、指が画面に触れるし、移動するまで接地イベントは発生しません</xref:System.Windows.UIElement.PreviewTouchDown>。 移動することがなく保持したりする画面に指を押すと、キーを押して発生して<xref:System.Windows.Input.Stylus>。</xref:System.Windows.Input.Stylus>の動作を保持 プレス アンド ホールド動作は、マウスの右クリックに相当します。       により、<xref:System.Windows.UIElement.PreviewTouchDown>接地イベントは、画面に触れるとすぐにも発生を設定し、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName>添付プロパティ`false`この要素の</xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=fullName></xref:System.Windows.UIElement.PreviewTouchDown>。      <a name=&quot;routedEventInfo_TouchDown&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.TouchDownEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewTouchDown>.</xref:System.Windows.UIElement.PreviewTouchDown> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.UIElement.TouchDownEvent>      -オーバーライド<xref:System.Windows.UIElement.OnTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnTouchDown%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchDown;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchDownEvent
  id: TouchDownEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchDownEvent
  nameWithType: UIElement.TouchDownEvent
  fullName: System.Windows.UIElement.TouchDownEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.TouchDown&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchDownEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchEnter
  id: TouchEnter
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchEnter
  nameWithType: UIElement.TouchEnter
  fullName: System.Windows.UIElement.TouchEnter
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "タッチから移動するときに発生するこの要素の境界内の外部です。"
  remarks: "このイベントはタッチ デバイスがこの要素にキャプチャされるかどうか常に発生します。      <a name=&quot;routedEventInfo_TouchEnter&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.TouchEnterEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.UIElement.OnTouchEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnTouchEnter%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.TouchEnterEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchEnter;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchEnterEvent
  id: TouchEnterEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchEnterEvent
  nameWithType: UIElement.TouchEnterEvent
  fullName: System.Windows.UIElement.TouchEnterEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.TouchEnter&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchEnterEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchesCaptured
  id: TouchesCaptured
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchesCaptured
  nameWithType: UIElement.TouchesCaptured
  fullName: System.Windows.UIElement.TouchesCaptured
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素にキャプチャされているすべてのタッチ デバイスを取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesCaptured { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>をこの要素にキャプチャされているオブジェクト。"
  overload: System.Windows.UIElement.TouchesCaptured*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchesCapturedWithin
  id: TouchesCapturedWithin
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchesCapturedWithin
  nameWithType: UIElement.TouchesCapturedWithin
  fullName: System.Windows.UIElement.TouchesCapturedWithin
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "そのビジュアル ツリー内には、この要素にキャプチャされているすべてのタッチ デバイスまたはすべての子要素を取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesCapturedWithin { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>この要素またはそのビジュアル ツリー内のすべての子要素にキャプチャされているオブジェクト。"
  overload: System.Windows.UIElement.TouchesCapturedWithin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchesDirectlyOver
  id: TouchesDirectlyOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchesDirectlyOver
  nameWithType: UIElement.TouchesDirectlyOver
  fullName: System.Windows.UIElement.TouchesDirectlyOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上にあるすべてのタッチ デバイスを取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesDirectlyOver { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>この要素の上にあるオブジェクト。"
  overload: System.Windows.UIElement.TouchesDirectlyOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchesOver
  id: TouchesOver
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchesOver
  nameWithType: UIElement.TouchesOver
  fullName: System.Windows.UIElement.TouchesOver
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "そのビジュアル ツリーで、この要素上では、すべてのタッチ デバイスまたはすべての子要素を取得します。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice> TouchesOver { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
      description: "列挙体<xref href=&quot;System.Windows.Input.TouchDevice&quot;></xref>この要素またはそのビジュアル ツリー内のすべての子要素の上にあるオブジェクト。"
  overload: System.Windows.UIElement.TouchesOver*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchLeave
  id: TouchLeave
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchLeave
  nameWithType: UIElement.TouchLeave
  fullName: System.Windows.UIElement.TouchLeave
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "タッチから移動するときに発生するこの要素の境界の外側の内部です。"
  remarks: "このイベントはタッチ デバイスがこの要素にキャプチャされるかどうか常に発生します。      <a name=&quot;routedEventInfo_TouchLeave&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.TouchLeaveEvent>|  |ルーティング方法 |直接 |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     -オーバーライド<xref:System.Windows.UIElement.OnTouchLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnTouchLeave%2A></xref:System.Windows.Input.TouchEventArgs></xref:System.EventHandler%601></xref:System.Windows.UIElement.TouchLeaveEvent>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchLeave;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchLeaveEvent
  id: TouchLeaveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchLeaveEvent
  nameWithType: UIElement.TouchLeaveEvent
  fullName: System.Windows.UIElement.TouchLeaveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.TouchLeave&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchLeaveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchMove
  id: TouchMove
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchMove
  nameWithType: UIElement.TouchMove
  fullName: System.Windows.UIElement.TouchMove
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面に指を動かしたときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_TouchMove&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.TouchMoveEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewTouchMove>.</xref:System.Windows.UIElement.PreviewTouchMove> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.UIElement.TouchMoveEvent>      -オーバーライド<xref:System.Windows.UIElement.OnTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnTouchMove%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchMove;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchMoveEvent
  id: TouchMoveEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchMoveEvent
  nameWithType: UIElement.TouchMoveEvent
  fullName: System.Windows.UIElement.TouchMoveEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.TouchMove&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchMoveEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchUp
  id: TouchUp
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchUp
  nameWithType: UIElement.TouchUp
  fullName: System.Windows.UIElement.TouchUp
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素の上に指が画面から離れる指が発生したときに発生します。"
  remarks: "<a name=&quot;routedEventInfo_TouchUp&quot;></a>## イベント情報をルーティング | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.TouchUpEvent>|  |ルーティング方法 |バブル |  |デリゲート |<xref:System.EventHandler%601>型<xref:System.Windows.Input.TouchEventArgs>|。     対応する-トンネリング イベントは<xref:System.Windows.UIElement.PreviewTouchUp>.</xref:System.Windows.UIElement.PreviewTouchUp> </xref:System.Windows.Input.TouchEventArgs> </xref:System.EventHandler%601> </xref:System.Windows.UIElement.TouchUpEvent>      -オーバーライド<xref:System.Windows.UIElement.OnTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装する</xref:System.Windows.UIElement.OnTouchUp%2A>。"
  syntax:
    content: public event EventHandler<System.Windows.Input.TouchEventArgs> TouchUp;
    return:
      type: System.EventHandler{System.Windows.Input.TouchEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TouchUpEvent
  id: TouchUpEvent
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TouchUpEvent
  nameWithType: UIElement.TouchUpEvent
  fullName: System.Windows.UIElement.TouchUpEvent
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、 <xref href=&quot;System.Windows.UIElement.TouchUp&quot;> </xref>ルーティングされたイベント。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent TouchUpEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  id: TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: TranslatePoint(Point,UIElement)
  nameWithType: UIElement.TranslatePoint(Point,UIElement)
  fullName: System.Windows.UIElement.TranslatePoint(Point,UIElement)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素に指定された要素に対する相対座標を相対的に変換します。"
  remarks: "渡す`null`の`relativeTo`を許可したり、この要素が属する論理ツリーのルート要素に対する相対座標がであることを示します。       このメソッドは、変換に使用ヒット テスト ポイント値。 コントロールを作成して、下位レベルの入力を処理する必要がある場合、このメソッドを呼び出すと、主に関連します。 既存のコントロールを使用している場合、通常と見なすことできます完成したコントロールが正しく変換済みのヒット テストの結果を報告することです。"
  syntax:
    content: public System.Windows.Point TranslatePoint (System.Windows.Point point, System.Windows.UIElement relativeTo);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "ポイントは、この要素に対して相対的に値します。"
    - id: relativeTo
      type: System.Windows.UIElement
      description: "指定したポイントに変換する要素。"
    return:
      type: System.Windows.Point
      description: "このソース要素ではなく、ターゲット要素に相対的なポイント値。"
  overload: System.Windows.UIElement.TranslatePoint*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Uid
  id: Uid
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Uid
  nameWithType: UIElement.Uid
  fullName: System.Windows.UIElement.Uid
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得またはこの要素の一意の識別子 (ローカライズ用) を設定します。 これは、依存関係プロパティです。"
  remarks: "取得するデザイナーで使用される、`x:Uid`値 (を参照してください[WPF のグローバリゼーションおよびローカリゼーションの概要](~/add/includes/ajax-current-ext-md.md)詳細については)。      <a name=&quot;dependencyPropertyInfo_WindowWindowStyle&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.UidProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.UidProperty>"
  syntax:
    content: public string Uid { get; set; }
    return:
      type: System.String
      description: "この要素の一意の識別子を指定する文字列。"
  overload: System.Windows.UIElement.Uid*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.UidProperty
  id: UidProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: UidProperty
  nameWithType: UIElement.UidProperty
  fullName: System.Windows.UIElement.UidProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.Uid*>依存関係プロパティ</xref:System.Windows.UIElement.Uid*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty UidProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.UpdateLayout
  id: UpdateLayout
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: UpdateLayout()
  nameWithType: UIElement.UpdateLayout()
  fullName: System.Windows.UIElement.UpdateLayout()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "この要素のすべてのビジュアル子要素がレイアウトに正常に更新されることを確認します。"
  remarks: "<xref:System.Windows.UIElement.IsMeasureValid%2A>を持つ要素は、このメソッドを呼び出すと`false`または<xref:System.Windows.UIElement.IsArrangeValid%2A>`false`特定の要素を呼び出す<xref:System.Windows.UIElement.MeasureCore%2A>と<xref:System.Windows.UIElement.ArrangeCore%2A>メソッドで、強制的にレイアウトを更新して、すべての計算されたサイズが検証されます</xref:System.Windows.UIElement.ArrangeCore%2A></xref:System.Windows.UIElement.MeasureCore%2A></xref:System.Windows.UIElement.IsArrangeValid%2A>。</xref:System.Windows.UIElement.IsMeasureValid%2A>       このメソッドを呼び出しても何も起こりませんレイアウトは変更されない場合、またはレイアウトの配置も測定の状態が無効です。 ただし、レイアウトがいずれかの点では有効でない場合、ページに対して UpdateLayout 呼び出しは、全体のレイアウトをやり直してください。 そのため、要素ツリー内のそれぞれの増分とマイナー変更後のページに対して UpdateLayout を呼び出すことを避ける必要があります。 ルートに対する変更を延期して、すべての子要素が有効になるまで、重み付け手法を使用して、パフォーマンスや通貨のバランスを取るアルゴリズムを使用して、遅延方式で、レイアウト システムは要素のレイアウトを実行します。 どうしても必要な更新のサイズや位置、およびコントロールとする可能性がありますに支障をレイアウト プロパティに対するすべての変更が完了した後にのみ特定する場合にのみ、ページに対して UpdateLayout を呼び出す必要があります。"
  syntax:
    content: public void UpdateLayout ();
    parameters: []
  overload: System.Windows.UIElement.UpdateLayout*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.Visibility
  id: Visibility
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: Visibility
  nameWithType: UIElement.Visibility
  fullName: System.Windows.UIElement.Visibility
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "取得または設定、[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]この要素を表示します。  これは、依存関係プロパティです。"
  remarks: "このプロパティの設定の値に影響を与える<xref:System.Windows.UIElement.IsVisible%2A>が発生する可能性がさらに、<xref:System.Windows.UIElement.IsVisibleChanged>イベント</xref:System.Windows.UIElement.IsVisibleChanged></xref:System.Windows.UIElement.IsVisible%2A>。 ただし、<xref:System.Windows.UIElement.IsVisible%2A>その他の要因をそれが含まれている親の可視性の設定のインスタンスに影響が</xref:System.Windows.UIElement.IsVisible%2A>       要素の表示が行われていない<xref:System.Windows.Visibility>入力のイベント (またはコマンド) に参加していない、レイアウトの測定または整列パスには影響しません、タブ シーケンス、およびヒット テストで報告されません</xref:System.Windows.Visibility>。       <xref:System.Windows.Window>または<xref:System.Windows.Window><xref:System.Windows.Visibility>。</xref:System.Windows.Visibility>にするには、このプロパティの既定値を再定義</xref:System.Windows.Window>その派生クラス</xref:System.Windows.Window>によって継承された場合 これは、レイアウトの測定パスを最初に作成されたで実行されていないの効果<xref:System.Windows.Window>、および<xref:System.Windows.UIElement.RenderSize%2A>(0,&0;) を返します</xref:System.Windows.UIElement.RenderSize%2A></xref:System.Windows.Window>。 詳細については、 <xref:System.Windows.Window>。</xref:System.Windows.Window>を参照してください。 <xref:System.Windows.Controls.Primitives.Popup>また、既定値を再定義<xref:System.Windows.Visibility>の結果と同様の動作と<xref:System.Windows.Controls.Primitives.Popup>とその派生クラス</xref:System.Windows.Controls.Primitives.Popup></xref:System.Windows.Visibility>。</xref:System.Windows.Controls.Primitives.Popup>      <a name=&quot;dependencyPropertyInfo_Visibility&quot;></a>## 依存プロパティ情報 | | |  |-|-|  |識別子フィールド |<xref:System.Windows.UIElement.VisibilityProperty>|  |メタデータ プロパティに設定`true`|None |</xref:System.Windows.UIElement.VisibilityProperty>"
  example:
  - "The following example implements a handler that references two different named buttons that are intended to be a mutually exclusive pair in the user interface. Prior to running the actual program logic associated with the button, the button itself is set to be <xref:System.Windows.Visibility?displayProperty=fullName>, and the other button in the pair is set to <xref:System.Windows.Visibility?displayProperty=fullName>.  \n  \n [!code-cs[MediaElement_snip#UIElementVisibility](~/add/codesnippet/csharp/p-system.windows.uieleme_13_1.cs)]\n [!code-vb[MediaElement_snip#UIElementVisibility](~/add/codesnippet/visualbasic/p-system.windows.uieleme_13_1.vb)]"
  syntax:
    content: public System.Windows.Visibility Visibility { get; set; }
    return:
      type: System.Windows.Visibility
      description: "列挙体の値です。 既定値は<xref href=&quot;System.Windows.Visibility&quot;></xref>です。"
  overload: System.Windows.UIElement.Visibility*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.UIElement.VisibilityProperty
  id: VisibilityProperty
  parent: System.Windows.UIElement
  langs:
  - csharp
  name: VisibilityProperty
  nameWithType: UIElement.VisibilityProperty
  fullName: System.Windows.UIElement.VisibilityProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows
  summary: "識別、<xref:System.Windows.UIElement.Visibility*>依存関係プロパティ</xref:System.Windows.UIElement.Visibility*>。"
  syntax:
    content: public static readonly System.Windows.DependencyProperty VisibilityProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "追加します。"
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Media.Visual
  isExternal: false
  name: System.Windows.Media.Visual
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Windows.UIElement.#ctor
  parent: System.Windows.UIElement
  isExternal: false
  name: UIElement()
  nameWithType: UIElement.UIElement()
  fullName: System.Windows.UIElement.UIElement()
- uid: System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.UIElement
  isExternal: false
  name: AddHandler(RoutedEvent,Delegate)
  nameWithType: UIElement.AddHandler(RoutedEvent,Delegate)
  fullName: System.Windows.UIElement.AddHandler(RoutedEvent,Delegate)
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  parent: System.Windows.UIElement
  isExternal: false
  name: AddHandler(RoutedEvent,Delegate,Boolean)
  nameWithType: UIElement.AddHandler(RoutedEvent,Delegate,Boolean)
  fullName: System.Windows.UIElement.AddHandler(RoutedEvent,Delegate,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: AddToEventRoute(EventRoute,RoutedEventArgs)
  nameWithType: UIElement.AddToEventRoute(EventRoute,RoutedEventArgs)
  fullName: System.Windows.UIElement.AddToEventRoute(EventRoute,RoutedEventArgs)
- uid: System.Windows.EventRoute
  parent: System.Windows
  isExternal: false
  name: EventRoute
  nameWithType: EventRoute
  fullName: System.Windows.EventRoute
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.UIElement.AllowDrop
  parent: System.Windows.UIElement
  isExternal: false
  name: AllowDrop
  nameWithType: UIElement.AllowDrop
  fullName: System.Windows.UIElement.AllowDrop
- uid: System.Windows.UIElement.AllowDropProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: AllowDropProperty
  nameWithType: UIElement.AllowDropProperty
  fullName: System.Windows.UIElement.AllowDropProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.UIElement
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock)
- uid: System.Windows.Media.Animation.AnimationClock
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationClock
  nameWithType: AnimationClock
  fullName: System.Windows.Media.Animation.AnimationClock
- uid: System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.UIElement
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.UIElement.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.UIElement.AreAnyTouchesCaptured
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesCaptured
  nameWithType: UIElement.AreAnyTouchesCaptured
  fullName: System.Windows.UIElement.AreAnyTouchesCaptured
- uid: System.Windows.UIElement.AreAnyTouchesCapturedProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesCapturedProperty
  nameWithType: UIElement.AreAnyTouchesCapturedProperty
  fullName: System.Windows.UIElement.AreAnyTouchesCapturedProperty
- uid: System.Windows.UIElement.AreAnyTouchesCapturedWithin
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesCapturedWithin
  nameWithType: UIElement.AreAnyTouchesCapturedWithin
  fullName: System.Windows.UIElement.AreAnyTouchesCapturedWithin
- uid: System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesCapturedWithinProperty
  nameWithType: UIElement.AreAnyTouchesCapturedWithinProperty
  fullName: System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
- uid: System.Windows.UIElement.AreAnyTouchesDirectlyOver
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesDirectlyOver
  nameWithType: UIElement.AreAnyTouchesDirectlyOver
  fullName: System.Windows.UIElement.AreAnyTouchesDirectlyOver
- uid: System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesDirectlyOverProperty
  nameWithType: UIElement.AreAnyTouchesDirectlyOverProperty
  fullName: System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
- uid: System.Windows.UIElement.AreAnyTouchesOver
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesOver
  nameWithType: UIElement.AreAnyTouchesOver
  fullName: System.Windows.UIElement.AreAnyTouchesOver
- uid: System.Windows.UIElement.AreAnyTouchesOverProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesOverProperty
  nameWithType: UIElement.AreAnyTouchesOverProperty
  fullName: System.Windows.UIElement.AreAnyTouchesOverProperty
- uid: System.Windows.UIElement.Arrange(System.Windows.Rect)
  parent: System.Windows.UIElement
  isExternal: false
  name: Arrange(Rect)
  nameWithType: UIElement.Arrange(Rect)
  fullName: System.Windows.UIElement.Arrange(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.UIElement.ArrangeCore(System.Windows.Rect)
  parent: System.Windows.UIElement
  isExternal: false
  name: ArrangeCore(Rect)
  nameWithType: UIElement.ArrangeCore(Rect)
  fullName: System.Windows.UIElement.ArrangeCore(Rect)
- uid: System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.UIElement
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: UIElement.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.UIElement.BeginAnimation(DependencyProperty,AnimationTimeline)
- uid: System.Windows.Media.Animation.AnimationTimeline
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationTimeline
  nameWithType: AnimationTimeline
  fullName: System.Windows.Media.Animation.AnimationTimeline
- uid: System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.UIElement
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: UIElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.UIElement.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
- uid: System.Windows.UIElement.BitmapEffect
  parent: System.Windows.UIElement
  isExternal: false
  name: BitmapEffect
  nameWithType: UIElement.BitmapEffect
  fullName: System.Windows.UIElement.BitmapEffect
- uid: System.Windows.Media.Effects.BitmapEffect
  parent: System.Windows.Media.Effects
  isExternal: false
  name: BitmapEffect
  nameWithType: BitmapEffect
  fullName: System.Windows.Media.Effects.BitmapEffect
- uid: System.Windows.UIElement.BitmapEffectInput
  parent: System.Windows.UIElement
  isExternal: false
  name: BitmapEffectInput
  nameWithType: UIElement.BitmapEffectInput
  fullName: System.Windows.UIElement.BitmapEffectInput
- uid: System.Windows.Media.Effects.BitmapEffectInput
  parent: System.Windows.Media.Effects
  isExternal: false
  name: BitmapEffectInput
  nameWithType: BitmapEffectInput
  fullName: System.Windows.Media.Effects.BitmapEffectInput
- uid: System.Windows.UIElement.BitmapEffectInputProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: BitmapEffectInputProperty
  nameWithType: UIElement.BitmapEffectInputProperty
  fullName: System.Windows.UIElement.BitmapEffectInputProperty
- uid: System.Windows.UIElement.BitmapEffectProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: BitmapEffectProperty
  nameWithType: UIElement.BitmapEffectProperty
  fullName: System.Windows.UIElement.BitmapEffectProperty
- uid: System.Windows.UIElement.CacheMode
  parent: System.Windows.UIElement
  isExternal: false
  name: CacheMode
  nameWithType: UIElement.CacheMode
  fullName: System.Windows.UIElement.CacheMode
- uid: System.Windows.Media.CacheMode
  parent: System.Windows.Media
  isExternal: false
  name: CacheMode
  nameWithType: CacheMode
  fullName: System.Windows.Media.CacheMode
- uid: System.Windows.UIElement.CacheModeProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: CacheModeProperty
  nameWithType: UIElement.CacheModeProperty
  fullName: System.Windows.UIElement.CacheModeProperty
- uid: System.Windows.UIElement.CaptureMouse
  parent: System.Windows.UIElement
  isExternal: false
  name: CaptureMouse()
  nameWithType: UIElement.CaptureMouse()
  fullName: System.Windows.UIElement.CaptureMouse()
- uid: System.Windows.UIElement.CaptureStylus
  parent: System.Windows.UIElement
  isExternal: false
  name: CaptureStylus()
  nameWithType: UIElement.CaptureStylus()
  fullName: System.Windows.UIElement.CaptureStylus()
- uid: System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  parent: System.Windows.UIElement
  isExternal: false
  name: CaptureTouch(TouchDevice)
  nameWithType: UIElement.CaptureTouch(TouchDevice)
  fullName: System.Windows.UIElement.CaptureTouch(TouchDevice)
- uid: System.Windows.Input.TouchDevice
  parent: System.Windows.Input
  isExternal: false
  name: TouchDevice
  nameWithType: TouchDevice
  fullName: System.Windows.Input.TouchDevice
- uid: System.Windows.UIElement.Clip
  parent: System.Windows.UIElement
  isExternal: false
  name: Clip
  nameWithType: UIElement.Clip
  fullName: System.Windows.UIElement.Clip
- uid: System.Windows.Media.Geometry
  parent: System.Windows.Media
  isExternal: false
  name: Geometry
  nameWithType: Geometry
  fullName: System.Windows.Media.Geometry
- uid: System.Windows.UIElement.ClipProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: ClipProperty
  nameWithType: UIElement.ClipProperty
  fullName: System.Windows.UIElement.ClipProperty
- uid: System.Windows.UIElement.ClipToBounds
  parent: System.Windows.UIElement
  isExternal: false
  name: ClipToBounds
  nameWithType: UIElement.ClipToBounds
  fullName: System.Windows.UIElement.ClipToBounds
- uid: System.Windows.UIElement.ClipToBoundsProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: ClipToBoundsProperty
  nameWithType: UIElement.ClipToBoundsProperty
  fullName: System.Windows.UIElement.ClipToBoundsProperty
- uid: System.Windows.UIElement.CommandBindings
  parent: System.Windows.UIElement
  isExternal: false
  name: CommandBindings
  nameWithType: UIElement.CommandBindings
  fullName: System.Windows.UIElement.CommandBindings
- uid: System.Windows.Input.CommandBindingCollection
  parent: System.Windows.Input
  isExternal: false
  name: CommandBindingCollection
  nameWithType: CommandBindingCollection
  fullName: System.Windows.Input.CommandBindingCollection
- uid: System.Windows.UIElement.DesiredSize
  parent: System.Windows.UIElement
  isExternal: false
  name: DesiredSize
  nameWithType: UIElement.DesiredSize
  fullName: System.Windows.UIElement.DesiredSize
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.UIElement.DragEnter
  parent: System.Windows.UIElement
  isExternal: false
  name: DragEnter
  nameWithType: UIElement.DragEnter
  fullName: System.Windows.UIElement.DragEnter
- uid: System.Windows.DragEventHandler
  parent: System.Windows
  isExternal: false
  name: DragEventHandler
  nameWithType: DragEventHandler
  fullName: System.Windows.DragEventHandler
- uid: System.Windows.UIElement.DragEnterEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: DragEnterEvent
  nameWithType: UIElement.DragEnterEvent
  fullName: System.Windows.UIElement.DragEnterEvent
- uid: System.Windows.UIElement.DragLeave
  parent: System.Windows.UIElement
  isExternal: false
  name: DragLeave
  nameWithType: UIElement.DragLeave
  fullName: System.Windows.UIElement.DragLeave
- uid: System.Windows.UIElement.DragLeaveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: DragLeaveEvent
  nameWithType: UIElement.DragLeaveEvent
  fullName: System.Windows.UIElement.DragLeaveEvent
- uid: System.Windows.UIElement.DragOver
  parent: System.Windows.UIElement
  isExternal: false
  name: DragOver
  nameWithType: UIElement.DragOver
  fullName: System.Windows.UIElement.DragOver
- uid: System.Windows.UIElement.DragOverEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: DragOverEvent
  nameWithType: UIElement.DragOverEvent
  fullName: System.Windows.UIElement.DragOverEvent
- uid: System.Windows.UIElement.Drop
  parent: System.Windows.UIElement
  isExternal: false
  name: Drop
  nameWithType: UIElement.Drop
  fullName: System.Windows.UIElement.Drop
- uid: System.Windows.UIElement.DropEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: DropEvent
  nameWithType: UIElement.DropEvent
  fullName: System.Windows.UIElement.DropEvent
- uid: System.Windows.UIElement.Effect
  parent: System.Windows.UIElement
  isExternal: false
  name: Effect
  nameWithType: UIElement.Effect
  fullName: System.Windows.UIElement.Effect
- uid: System.Windows.Media.Effects.Effect
  parent: System.Windows.Media.Effects
  isExternal: false
  name: Effect
  nameWithType: Effect
  fullName: System.Windows.Media.Effects.Effect
- uid: System.Windows.UIElement.EffectProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: EffectProperty
  nameWithType: UIElement.EffectProperty
  fullName: System.Windows.UIElement.EffectProperty
- uid: System.Windows.UIElement.Focus
  parent: System.Windows.UIElement
  isExternal: false
  name: Focus()
  nameWithType: UIElement.Focus()
  fullName: System.Windows.UIElement.Focus()
- uid: System.Windows.UIElement.Focusable
  parent: System.Windows.UIElement
  isExternal: false
  name: Focusable
  nameWithType: UIElement.Focusable
  fullName: System.Windows.UIElement.Focusable
- uid: System.Windows.UIElement.FocusableChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: FocusableChanged
  nameWithType: UIElement.FocusableChanged
  fullName: System.Windows.UIElement.FocusableChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.UIElement.FocusableProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: FocusableProperty
  nameWithType: UIElement.FocusableProperty
  fullName: System.Windows.UIElement.FocusableProperty
- uid: System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.UIElement
  isExternal: false
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: UIElement.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.UIElement.GetAnimationBaseValue(DependencyProperty)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.UIElement.GetLayoutClip(System.Windows.Size)
  parent: System.Windows.UIElement
  isExternal: false
  name: GetLayoutClip(Size)
  nameWithType: UIElement.GetLayoutClip(Size)
  fullName: System.Windows.UIElement.GetLayoutClip(Size)
- uid: System.Windows.UIElement.GetUIParentCore
  parent: System.Windows.UIElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: UIElement.GetUIParentCore()
  fullName: System.Windows.UIElement.GetUIParentCore()
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.UIElement.GiveFeedback
  parent: System.Windows.UIElement
  isExternal: false
  name: GiveFeedback
  nameWithType: UIElement.GiveFeedback
  fullName: System.Windows.UIElement.GiveFeedback
- uid: System.Windows.GiveFeedbackEventHandler
  parent: System.Windows
  isExternal: false
  name: GiveFeedbackEventHandler
  nameWithType: GiveFeedbackEventHandler
  fullName: System.Windows.GiveFeedbackEventHandler
- uid: System.Windows.UIElement.GiveFeedbackEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: GiveFeedbackEvent
  nameWithType: UIElement.GiveFeedbackEvent
  fullName: System.Windows.UIElement.GiveFeedbackEvent
- uid: System.Windows.UIElement.GotFocus
  parent: System.Windows.UIElement
  isExternal: false
  name: GotFocus
  nameWithType: UIElement.GotFocus
  fullName: System.Windows.UIElement.GotFocus
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.UIElement.GotFocusEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: GotFocusEvent
  nameWithType: UIElement.GotFocusEvent
  fullName: System.Windows.UIElement.GotFocusEvent
- uid: System.Windows.UIElement.GotKeyboardFocus
  parent: System.Windows.UIElement
  isExternal: false
  name: GotKeyboardFocus
  nameWithType: UIElement.GotKeyboardFocus
  fullName: System.Windows.UIElement.GotKeyboardFocus
- uid: System.Windows.Input.KeyboardFocusChangedEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: KeyboardFocusChangedEventHandler
  nameWithType: KeyboardFocusChangedEventHandler
  fullName: System.Windows.Input.KeyboardFocusChangedEventHandler
- uid: System.Windows.UIElement.GotKeyboardFocusEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: GotKeyboardFocusEvent
  nameWithType: UIElement.GotKeyboardFocusEvent
  fullName: System.Windows.UIElement.GotKeyboardFocusEvent
- uid: System.Windows.UIElement.GotMouseCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: GotMouseCapture
  nameWithType: UIElement.GotMouseCapture
  fullName: System.Windows.UIElement.GotMouseCapture
- uid: System.Windows.Input.MouseEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: MouseEventHandler
  nameWithType: MouseEventHandler
  fullName: System.Windows.Input.MouseEventHandler
- uid: System.Windows.UIElement.GotMouseCaptureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: GotMouseCaptureEvent
  nameWithType: UIElement.GotMouseCaptureEvent
  fullName: System.Windows.UIElement.GotMouseCaptureEvent
- uid: System.Windows.UIElement.GotStylusCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: GotStylusCapture
  nameWithType: UIElement.GotStylusCapture
  fullName: System.Windows.UIElement.GotStylusCapture
- uid: System.Windows.Input.StylusEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusEventHandler
  nameWithType: StylusEventHandler
  fullName: System.Windows.Input.StylusEventHandler
- uid: System.Windows.UIElement.GotStylusCaptureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: GotStylusCaptureEvent
  nameWithType: UIElement.GotStylusCaptureEvent
  fullName: System.Windows.UIElement.GotStylusCaptureEvent
- uid: System.Windows.UIElement.GotTouchCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: GotTouchCapture
  nameWithType: UIElement.GotTouchCapture
  fullName: System.Windows.UIElement.GotTouchCapture
- uid: System.EventHandler{System.Windows.Input.TouchEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TouchEventArgs>
  nameWithType: EventHandler<TouchEventArgs>
  fullName: System.EventHandler<System.Windows.Input.TouchEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.TouchEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.TouchEventArgs
    name: TouchEventArgs
    nameWithType: TouchEventArgs
    fullName: TouchEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.GotTouchCaptureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: GotTouchCaptureEvent
  nameWithType: UIElement.GotTouchCaptureEvent
  fullName: System.Windows.UIElement.GotTouchCaptureEvent
- uid: System.Windows.UIElement.HasAnimatedProperties
  parent: System.Windows.UIElement
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: UIElement.HasAnimatedProperties
  fullName: System.Windows.UIElement.HasAnimatedProperties
- uid: System.Windows.UIElement.HasEffectiveKeyboardFocus
  parent: System.Windows.UIElement
  isExternal: false
  name: HasEffectiveKeyboardFocus
  nameWithType: UIElement.HasEffectiveKeyboardFocus
  fullName: System.Windows.UIElement.HasEffectiveKeyboardFocus
- uid: System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  parent: System.Windows.UIElement
  isExternal: false
  name: HitTestCore(GeometryHitTestParameters)
  nameWithType: UIElement.HitTestCore(GeometryHitTestParameters)
  fullName: System.Windows.UIElement.HitTestCore(GeometryHitTestParameters)
- uid: System.Windows.Media.GeometryHitTestResult
  parent: System.Windows.Media
  isExternal: false
  name: GeometryHitTestResult
  nameWithType: GeometryHitTestResult
  fullName: System.Windows.Media.GeometryHitTestResult
- uid: System.Windows.Media.GeometryHitTestParameters
  parent: System.Windows.Media
  isExternal: false
  name: GeometryHitTestParameters
  nameWithType: GeometryHitTestParameters
  fullName: System.Windows.Media.GeometryHitTestParameters
- uid: System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  parent: System.Windows.UIElement
  isExternal: false
  name: HitTestCore(PointHitTestParameters)
  nameWithType: UIElement.HitTestCore(PointHitTestParameters)
  fullName: System.Windows.UIElement.HitTestCore(PointHitTestParameters)
- uid: System.Windows.Media.HitTestResult
  parent: System.Windows.Media
  isExternal: false
  name: HitTestResult
  nameWithType: HitTestResult
  fullName: System.Windows.Media.HitTestResult
- uid: System.Windows.Media.PointHitTestParameters
  parent: System.Windows.Media
  isExternal: false
  name: PointHitTestParameters
  nameWithType: PointHitTestParameters
  fullName: System.Windows.Media.PointHitTestParameters
- uid: System.Windows.UIElement.InputBindings
  parent: System.Windows.UIElement
  isExternal: false
  name: InputBindings
  nameWithType: UIElement.InputBindings
  fullName: System.Windows.UIElement.InputBindings
- uid: System.Windows.Input.InputBindingCollection
  parent: System.Windows.Input
  isExternal: false
  name: InputBindingCollection
  nameWithType: InputBindingCollection
  fullName: System.Windows.Input.InputBindingCollection
- uid: System.Windows.UIElement.InputHitTest(System.Windows.Point)
  parent: System.Windows.UIElement
  isExternal: false
  name: InputHitTest(Point)
  nameWithType: UIElement.InputHitTest(Point)
  fullName: System.Windows.UIElement.InputHitTest(Point)
- uid: System.Windows.IInputElement
  parent: System.Windows
  isExternal: false
  name: IInputElement
  nameWithType: IInputElement
  fullName: System.Windows.IInputElement
- uid: System.Windows.Point
  parent: System.Windows
  isExternal: false
  name: Point
  nameWithType: Point
  fullName: System.Windows.Point
- uid: System.Windows.UIElement.InvalidateArrange
  parent: System.Windows.UIElement
  isExternal: false
  name: InvalidateArrange()
  nameWithType: UIElement.InvalidateArrange()
  fullName: System.Windows.UIElement.InvalidateArrange()
- uid: System.Windows.UIElement.InvalidateMeasure
  parent: System.Windows.UIElement
  isExternal: false
  name: InvalidateMeasure()
  nameWithType: UIElement.InvalidateMeasure()
  fullName: System.Windows.UIElement.InvalidateMeasure()
- uid: System.Windows.UIElement.InvalidateVisual
  parent: System.Windows.UIElement
  isExternal: false
  name: InvalidateVisual()
  nameWithType: UIElement.InvalidateVisual()
  fullName: System.Windows.UIElement.InvalidateVisual()
- uid: System.Windows.UIElement.IsArrangeValid
  parent: System.Windows.UIElement
  isExternal: false
  name: IsArrangeValid
  nameWithType: UIElement.IsArrangeValid
  fullName: System.Windows.UIElement.IsArrangeValid
- uid: System.Windows.UIElement.IsEnabled
  parent: System.Windows.UIElement
  isExternal: false
  name: IsEnabled
  nameWithType: UIElement.IsEnabled
  fullName: System.Windows.UIElement.IsEnabled
- uid: System.Windows.UIElement.IsEnabledChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsEnabledChanged
  nameWithType: UIElement.IsEnabledChanged
  fullName: System.Windows.UIElement.IsEnabledChanged
- uid: System.Windows.UIElement.IsEnabledCore
  parent: System.Windows.UIElement
  isExternal: false
  name: IsEnabledCore
  nameWithType: UIElement.IsEnabledCore
  fullName: System.Windows.UIElement.IsEnabledCore
- uid: System.Windows.UIElement.IsEnabledProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsEnabledProperty
  nameWithType: UIElement.IsEnabledProperty
  fullName: System.Windows.UIElement.IsEnabledProperty
- uid: System.Windows.UIElement.IsFocused
  parent: System.Windows.UIElement
  isExternal: false
  name: IsFocused
  nameWithType: UIElement.IsFocused
  fullName: System.Windows.UIElement.IsFocused
- uid: System.Windows.UIElement.IsFocusedProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsFocusedProperty
  nameWithType: UIElement.IsFocusedProperty
  fullName: System.Windows.UIElement.IsFocusedProperty
- uid: System.Windows.UIElement.IsHitTestVisible
  parent: System.Windows.UIElement
  isExternal: false
  name: IsHitTestVisible
  nameWithType: UIElement.IsHitTestVisible
  fullName: System.Windows.UIElement.IsHitTestVisible
- uid: System.Windows.UIElement.IsHitTestVisibleChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsHitTestVisibleChanged
  nameWithType: UIElement.IsHitTestVisibleChanged
  fullName: System.Windows.UIElement.IsHitTestVisibleChanged
- uid: System.Windows.UIElement.IsHitTestVisibleProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsHitTestVisibleProperty
  nameWithType: UIElement.IsHitTestVisibleProperty
  fullName: System.Windows.UIElement.IsHitTestVisibleProperty
- uid: System.Windows.UIElement.IsInputMethodEnabled
  parent: System.Windows.UIElement
  isExternal: false
  name: IsInputMethodEnabled
  nameWithType: UIElement.IsInputMethodEnabled
  fullName: System.Windows.UIElement.IsInputMethodEnabled
- uid: System.Windows.UIElement.IsKeyboardFocused
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocused
  nameWithType: UIElement.IsKeyboardFocused
  fullName: System.Windows.UIElement.IsKeyboardFocused
- uid: System.Windows.UIElement.IsKeyboardFocusedChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocusedChanged
  nameWithType: UIElement.IsKeyboardFocusedChanged
  fullName: System.Windows.UIElement.IsKeyboardFocusedChanged
- uid: System.Windows.UIElement.IsKeyboardFocusedProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocusedProperty
  nameWithType: UIElement.IsKeyboardFocusedProperty
  fullName: System.Windows.UIElement.IsKeyboardFocusedProperty
- uid: System.Windows.UIElement.IsKeyboardFocusWithin
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocusWithin
  nameWithType: UIElement.IsKeyboardFocusWithin
  fullName: System.Windows.UIElement.IsKeyboardFocusWithin
- uid: System.Windows.UIElement.IsKeyboardFocusWithinChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocusWithinChanged
  nameWithType: UIElement.IsKeyboardFocusWithinChanged
  fullName: System.Windows.UIElement.IsKeyboardFocusWithinChanged
- uid: System.Windows.UIElement.IsKeyboardFocusWithinProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocusWithinProperty
  nameWithType: UIElement.IsKeyboardFocusWithinProperty
  fullName: System.Windows.UIElement.IsKeyboardFocusWithinProperty
- uid: System.Windows.UIElement.IsManipulationEnabled
  parent: System.Windows.UIElement
  isExternal: false
  name: IsManipulationEnabled
  nameWithType: UIElement.IsManipulationEnabled
  fullName: System.Windows.UIElement.IsManipulationEnabled
- uid: System.Windows.UIElement.IsManipulationEnabledProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsManipulationEnabledProperty
  nameWithType: UIElement.IsManipulationEnabledProperty
  fullName: System.Windows.UIElement.IsManipulationEnabledProperty
- uid: System.Windows.UIElement.IsMeasureValid
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMeasureValid
  nameWithType: UIElement.IsMeasureValid
  fullName: System.Windows.UIElement.IsMeasureValid
- uid: System.Windows.UIElement.IsMouseCaptured
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCaptured
  nameWithType: UIElement.IsMouseCaptured
  fullName: System.Windows.UIElement.IsMouseCaptured
- uid: System.Windows.UIElement.IsMouseCapturedChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCapturedChanged
  nameWithType: UIElement.IsMouseCapturedChanged
  fullName: System.Windows.UIElement.IsMouseCapturedChanged
- uid: System.Windows.UIElement.IsMouseCapturedProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCapturedProperty
  nameWithType: UIElement.IsMouseCapturedProperty
  fullName: System.Windows.UIElement.IsMouseCapturedProperty
- uid: System.Windows.UIElement.IsMouseCaptureWithin
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCaptureWithin
  nameWithType: UIElement.IsMouseCaptureWithin
  fullName: System.Windows.UIElement.IsMouseCaptureWithin
- uid: System.Windows.UIElement.IsMouseCaptureWithinChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCaptureWithinChanged
  nameWithType: UIElement.IsMouseCaptureWithinChanged
  fullName: System.Windows.UIElement.IsMouseCaptureWithinChanged
- uid: System.Windows.UIElement.IsMouseCaptureWithinProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCaptureWithinProperty
  nameWithType: UIElement.IsMouseCaptureWithinProperty
  fullName: System.Windows.UIElement.IsMouseCaptureWithinProperty
- uid: System.Windows.UIElement.IsMouseDirectlyOver
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseDirectlyOver
  nameWithType: UIElement.IsMouseDirectlyOver
  fullName: System.Windows.UIElement.IsMouseDirectlyOver
- uid: System.Windows.UIElement.IsMouseDirectlyOverChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseDirectlyOverChanged
  nameWithType: UIElement.IsMouseDirectlyOverChanged
  fullName: System.Windows.UIElement.IsMouseDirectlyOverChanged
- uid: System.Windows.UIElement.IsMouseDirectlyOverProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseDirectlyOverProperty
  nameWithType: UIElement.IsMouseDirectlyOverProperty
  fullName: System.Windows.UIElement.IsMouseDirectlyOverProperty
- uid: System.Windows.UIElement.IsMouseOver
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseOver
  nameWithType: UIElement.IsMouseOver
  fullName: System.Windows.UIElement.IsMouseOver
- uid: System.Windows.UIElement.IsMouseOverProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseOverProperty
  nameWithType: UIElement.IsMouseOverProperty
  fullName: System.Windows.UIElement.IsMouseOverProperty
- uid: System.Windows.UIElement.IsStylusCaptured
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCaptured
  nameWithType: UIElement.IsStylusCaptured
  fullName: System.Windows.UIElement.IsStylusCaptured
- uid: System.Windows.UIElement.IsStylusCapturedChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCapturedChanged
  nameWithType: UIElement.IsStylusCapturedChanged
  fullName: System.Windows.UIElement.IsStylusCapturedChanged
- uid: System.Windows.UIElement.IsStylusCapturedProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCapturedProperty
  nameWithType: UIElement.IsStylusCapturedProperty
  fullName: System.Windows.UIElement.IsStylusCapturedProperty
- uid: System.Windows.UIElement.IsStylusCaptureWithin
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCaptureWithin
  nameWithType: UIElement.IsStylusCaptureWithin
  fullName: System.Windows.UIElement.IsStylusCaptureWithin
- uid: System.Windows.UIElement.IsStylusCaptureWithinChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCaptureWithinChanged
  nameWithType: UIElement.IsStylusCaptureWithinChanged
  fullName: System.Windows.UIElement.IsStylusCaptureWithinChanged
- uid: System.Windows.UIElement.IsStylusCaptureWithinProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCaptureWithinProperty
  nameWithType: UIElement.IsStylusCaptureWithinProperty
  fullName: System.Windows.UIElement.IsStylusCaptureWithinProperty
- uid: System.Windows.UIElement.IsStylusDirectlyOver
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusDirectlyOver
  nameWithType: UIElement.IsStylusDirectlyOver
  fullName: System.Windows.UIElement.IsStylusDirectlyOver
- uid: System.Windows.UIElement.IsStylusDirectlyOverChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusDirectlyOverChanged
  nameWithType: UIElement.IsStylusDirectlyOverChanged
  fullName: System.Windows.UIElement.IsStylusDirectlyOverChanged
- uid: System.Windows.UIElement.IsStylusDirectlyOverProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusDirectlyOverProperty
  nameWithType: UIElement.IsStylusDirectlyOverProperty
  fullName: System.Windows.UIElement.IsStylusDirectlyOverProperty
- uid: System.Windows.UIElement.IsStylusOver
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusOver
  nameWithType: UIElement.IsStylusOver
  fullName: System.Windows.UIElement.IsStylusOver
- uid: System.Windows.UIElement.IsStylusOverProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusOverProperty
  nameWithType: UIElement.IsStylusOverProperty
  fullName: System.Windows.UIElement.IsStylusOverProperty
- uid: System.Windows.UIElement.IsVisible
  parent: System.Windows.UIElement
  isExternal: false
  name: IsVisible
  nameWithType: UIElement.IsVisible
  fullName: System.Windows.UIElement.IsVisible
- uid: System.Windows.UIElement.IsVisibleChanged
  parent: System.Windows.UIElement
  isExternal: false
  name: IsVisibleChanged
  nameWithType: UIElement.IsVisibleChanged
  fullName: System.Windows.UIElement.IsVisibleChanged
- uid: System.Windows.UIElement.IsVisibleProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: IsVisibleProperty
  nameWithType: UIElement.IsVisibleProperty
  fullName: System.Windows.UIElement.IsVisibleProperty
- uid: System.Windows.UIElement.KeyDown
  parent: System.Windows.UIElement
  isExternal: false
  name: KeyDown
  nameWithType: UIElement.KeyDown
  fullName: System.Windows.UIElement.KeyDown
- uid: System.Windows.Input.KeyEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: KeyEventHandler
  nameWithType: KeyEventHandler
  fullName: System.Windows.Input.KeyEventHandler
- uid: System.Windows.UIElement.KeyDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: KeyDownEvent
  nameWithType: UIElement.KeyDownEvent
  fullName: System.Windows.UIElement.KeyDownEvent
- uid: System.Windows.UIElement.KeyUp
  parent: System.Windows.UIElement
  isExternal: false
  name: KeyUp
  nameWithType: UIElement.KeyUp
  fullName: System.Windows.UIElement.KeyUp
- uid: System.Windows.UIElement.KeyUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: KeyUpEvent
  nameWithType: UIElement.KeyUpEvent
  fullName: System.Windows.UIElement.KeyUpEvent
- uid: System.Windows.UIElement.LayoutUpdated
  parent: System.Windows.UIElement
  isExternal: false
  name: LayoutUpdated
  nameWithType: UIElement.LayoutUpdated
  fullName: System.Windows.UIElement.LayoutUpdated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.UIElement.LostFocus
  parent: System.Windows.UIElement
  isExternal: false
  name: LostFocus
  nameWithType: UIElement.LostFocus
  fullName: System.Windows.UIElement.LostFocus
- uid: System.Windows.UIElement.LostFocusEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: LostFocusEvent
  nameWithType: UIElement.LostFocusEvent
  fullName: System.Windows.UIElement.LostFocusEvent
- uid: System.Windows.UIElement.LostKeyboardFocus
  parent: System.Windows.UIElement
  isExternal: false
  name: LostKeyboardFocus
  nameWithType: UIElement.LostKeyboardFocus
  fullName: System.Windows.UIElement.LostKeyboardFocus
- uid: System.Windows.UIElement.LostKeyboardFocusEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: LostKeyboardFocusEvent
  nameWithType: UIElement.LostKeyboardFocusEvent
  fullName: System.Windows.UIElement.LostKeyboardFocusEvent
- uid: System.Windows.UIElement.LostMouseCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: LostMouseCapture
  nameWithType: UIElement.LostMouseCapture
  fullName: System.Windows.UIElement.LostMouseCapture
- uid: System.Windows.UIElement.LostMouseCaptureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: LostMouseCaptureEvent
  nameWithType: UIElement.LostMouseCaptureEvent
  fullName: System.Windows.UIElement.LostMouseCaptureEvent
- uid: System.Windows.UIElement.LostStylusCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: LostStylusCapture
  nameWithType: UIElement.LostStylusCapture
  fullName: System.Windows.UIElement.LostStylusCapture
- uid: System.Windows.UIElement.LostStylusCaptureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: LostStylusCaptureEvent
  nameWithType: UIElement.LostStylusCaptureEvent
  fullName: System.Windows.UIElement.LostStylusCaptureEvent
- uid: System.Windows.UIElement.LostTouchCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: LostTouchCapture
  nameWithType: UIElement.LostTouchCapture
  fullName: System.Windows.UIElement.LostTouchCapture
- uid: System.Windows.UIElement.LostTouchCaptureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: LostTouchCaptureEvent
  nameWithType: UIElement.LostTouchCaptureEvent
  fullName: System.Windows.UIElement.LostTouchCaptureEvent
- uid: System.Windows.UIElement.ManipulationBoundaryFeedback
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationBoundaryFeedback
  nameWithType: UIElement.ManipulationBoundaryFeedback
  fullName: System.Windows.UIElement.ManipulationBoundaryFeedback
- uid: System.EventHandler{System.Windows.Input.ManipulationBoundaryFeedbackEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<ManipulationBoundaryFeedbackEventArgs>
  nameWithType: EventHandler<ManipulationBoundaryFeedbackEventArgs>
  fullName: System.EventHandler<System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
    name: ManipulationBoundaryFeedbackEventArgs
    nameWithType: ManipulationBoundaryFeedbackEventArgs
    fullName: ManipulationBoundaryFeedbackEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationBoundaryFeedbackEvent
  nameWithType: UIElement.ManipulationBoundaryFeedbackEvent
  fullName: System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
- uid: System.Windows.UIElement.ManipulationCompleted
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationCompleted
  nameWithType: UIElement.ManipulationCompleted
  fullName: System.Windows.UIElement.ManipulationCompleted
- uid: System.EventHandler{System.Windows.Input.ManipulationCompletedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<ManipulationCompletedEventArgs>
  nameWithType: EventHandler<ManipulationCompletedEventArgs>
  fullName: System.EventHandler<System.Windows.Input.ManipulationCompletedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.ManipulationCompletedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.ManipulationCompletedEventArgs
    name: ManipulationCompletedEventArgs
    nameWithType: ManipulationCompletedEventArgs
    fullName: ManipulationCompletedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.ManipulationCompletedEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationCompletedEvent
  nameWithType: UIElement.ManipulationCompletedEvent
  fullName: System.Windows.UIElement.ManipulationCompletedEvent
- uid: System.Windows.UIElement.ManipulationDelta
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationDelta
  nameWithType: UIElement.ManipulationDelta
  fullName: System.Windows.UIElement.ManipulationDelta
- uid: System.EventHandler{System.Windows.Input.ManipulationDeltaEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<ManipulationDeltaEventArgs>
  nameWithType: EventHandler<ManipulationDeltaEventArgs>
  fullName: System.EventHandler<System.Windows.Input.ManipulationDeltaEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.ManipulationDeltaEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.ManipulationDeltaEventArgs
    name: ManipulationDeltaEventArgs
    nameWithType: ManipulationDeltaEventArgs
    fullName: ManipulationDeltaEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.ManipulationDeltaEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationDeltaEvent
  nameWithType: UIElement.ManipulationDeltaEvent
  fullName: System.Windows.UIElement.ManipulationDeltaEvent
- uid: System.Windows.UIElement.ManipulationInertiaStarting
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationInertiaStarting
  nameWithType: UIElement.ManipulationInertiaStarting
  fullName: System.Windows.UIElement.ManipulationInertiaStarting
- uid: System.EventHandler{System.Windows.Input.ManipulationInertiaStartingEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<ManipulationInertiaStartingEventArgs>
  nameWithType: EventHandler<ManipulationInertiaStartingEventArgs>
  fullName: System.EventHandler<System.Windows.Input.ManipulationInertiaStartingEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.ManipulationInertiaStartingEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.ManipulationInertiaStartingEventArgs
    name: ManipulationInertiaStartingEventArgs
    nameWithType: ManipulationInertiaStartingEventArgs
    fullName: ManipulationInertiaStartingEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.ManipulationInertiaStartingEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationInertiaStartingEvent
  nameWithType: UIElement.ManipulationInertiaStartingEvent
  fullName: System.Windows.UIElement.ManipulationInertiaStartingEvent
- uid: System.Windows.UIElement.ManipulationStarted
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationStarted
  nameWithType: UIElement.ManipulationStarted
  fullName: System.Windows.UIElement.ManipulationStarted
- uid: System.EventHandler{System.Windows.Input.ManipulationStartedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<ManipulationStartedEventArgs>
  nameWithType: EventHandler<ManipulationStartedEventArgs>
  fullName: System.EventHandler<System.Windows.Input.ManipulationStartedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.ManipulationStartedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.ManipulationStartedEventArgs
    name: ManipulationStartedEventArgs
    nameWithType: ManipulationStartedEventArgs
    fullName: ManipulationStartedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.ManipulationStartedEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationStartedEvent
  nameWithType: UIElement.ManipulationStartedEvent
  fullName: System.Windows.UIElement.ManipulationStartedEvent
- uid: System.Windows.UIElement.ManipulationStarting
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationStarting
  nameWithType: UIElement.ManipulationStarting
  fullName: System.Windows.UIElement.ManipulationStarting
- uid: System.EventHandler{System.Windows.Input.ManipulationStartingEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<ManipulationStartingEventArgs>
  nameWithType: EventHandler<ManipulationStartingEventArgs>
  fullName: System.EventHandler<System.Windows.Input.ManipulationStartingEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Input.ManipulationStartingEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.ManipulationStartingEventArgs
    name: ManipulationStartingEventArgs
    nameWithType: ManipulationStartingEventArgs
    fullName: ManipulationStartingEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.ManipulationStartingEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: ManipulationStartingEvent
  nameWithType: UIElement.ManipulationStartingEvent
  fullName: System.Windows.UIElement.ManipulationStartingEvent
- uid: System.Windows.UIElement.Measure(System.Windows.Size)
  parent: System.Windows.UIElement
  isExternal: false
  name: Measure(Size)
  nameWithType: UIElement.Measure(Size)
  fullName: System.Windows.UIElement.Measure(Size)
- uid: System.Windows.UIElement.MeasureCore(System.Windows.Size)
  parent: System.Windows.UIElement
  isExternal: false
  name: MeasureCore(Size)
  nameWithType: UIElement.MeasureCore(Size)
  fullName: System.Windows.UIElement.MeasureCore(Size)
- uid: System.Windows.UIElement.MouseDown
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseDown
  nameWithType: UIElement.MouseDown
  fullName: System.Windows.UIElement.MouseDown
- uid: System.Windows.Input.MouseButtonEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: MouseButtonEventHandler
  nameWithType: MouseButtonEventHandler
  fullName: System.Windows.Input.MouseButtonEventHandler
- uid: System.Windows.UIElement.MouseDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseDownEvent
  nameWithType: UIElement.MouseDownEvent
  fullName: System.Windows.UIElement.MouseDownEvent
- uid: System.Windows.UIElement.MouseEnter
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseEnter
  nameWithType: UIElement.MouseEnter
  fullName: System.Windows.UIElement.MouseEnter
- uid: System.Windows.UIElement.MouseEnterEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseEnterEvent
  nameWithType: UIElement.MouseEnterEvent
  fullName: System.Windows.UIElement.MouseEnterEvent
- uid: System.Windows.UIElement.MouseLeave
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseLeave
  nameWithType: UIElement.MouseLeave
  fullName: System.Windows.UIElement.MouseLeave
- uid: System.Windows.UIElement.MouseLeaveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseLeaveEvent
  nameWithType: UIElement.MouseLeaveEvent
  fullName: System.Windows.UIElement.MouseLeaveEvent
- uid: System.Windows.UIElement.MouseLeftButtonDown
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseLeftButtonDown
  nameWithType: UIElement.MouseLeftButtonDown
  fullName: System.Windows.UIElement.MouseLeftButtonDown
- uid: System.Windows.UIElement.MouseLeftButtonDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseLeftButtonDownEvent
  nameWithType: UIElement.MouseLeftButtonDownEvent
  fullName: System.Windows.UIElement.MouseLeftButtonDownEvent
- uid: System.Windows.UIElement.MouseLeftButtonUp
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseLeftButtonUp
  nameWithType: UIElement.MouseLeftButtonUp
  fullName: System.Windows.UIElement.MouseLeftButtonUp
- uid: System.Windows.UIElement.MouseLeftButtonUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseLeftButtonUpEvent
  nameWithType: UIElement.MouseLeftButtonUpEvent
  fullName: System.Windows.UIElement.MouseLeftButtonUpEvent
- uid: System.Windows.UIElement.MouseMove
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseMove
  nameWithType: UIElement.MouseMove
  fullName: System.Windows.UIElement.MouseMove
- uid: System.Windows.UIElement.MouseMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseMoveEvent
  nameWithType: UIElement.MouseMoveEvent
  fullName: System.Windows.UIElement.MouseMoveEvent
- uid: System.Windows.UIElement.MouseRightButtonDown
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseRightButtonDown
  nameWithType: UIElement.MouseRightButtonDown
  fullName: System.Windows.UIElement.MouseRightButtonDown
- uid: System.Windows.UIElement.MouseRightButtonDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseRightButtonDownEvent
  nameWithType: UIElement.MouseRightButtonDownEvent
  fullName: System.Windows.UIElement.MouseRightButtonDownEvent
- uid: System.Windows.UIElement.MouseRightButtonUp
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseRightButtonUp
  nameWithType: UIElement.MouseRightButtonUp
  fullName: System.Windows.UIElement.MouseRightButtonUp
- uid: System.Windows.UIElement.MouseRightButtonUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseRightButtonUpEvent
  nameWithType: UIElement.MouseRightButtonUpEvent
  fullName: System.Windows.UIElement.MouseRightButtonUpEvent
- uid: System.Windows.UIElement.MouseUp
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseUp
  nameWithType: UIElement.MouseUp
  fullName: System.Windows.UIElement.MouseUp
- uid: System.Windows.UIElement.MouseUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseUpEvent
  nameWithType: UIElement.MouseUpEvent
  fullName: System.Windows.UIElement.MouseUpEvent
- uid: System.Windows.UIElement.MouseWheel
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseWheel
  nameWithType: UIElement.MouseWheel
  fullName: System.Windows.UIElement.MouseWheel
- uid: System.Windows.Input.MouseWheelEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: MouseWheelEventHandler
  nameWithType: MouseWheelEventHandler
  fullName: System.Windows.Input.MouseWheelEventHandler
- uid: System.Windows.UIElement.MouseWheelEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: MouseWheelEvent
  nameWithType: UIElement.MouseWheelEvent
  fullName: System.Windows.UIElement.MouseWheelEvent
- uid: System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.UIElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: UIElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.UIElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnAccessKey(AccessKeyEventArgs)
  nameWithType: UIElement.OnAccessKey(AccessKeyEventArgs)
  fullName: System.Windows.UIElement.OnAccessKey(AccessKeyEventArgs)
- uid: System.Windows.Input.AccessKeyEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: AccessKeyEventArgs
  nameWithType: AccessKeyEventArgs
  fullName: System.Windows.Input.AccessKeyEventArgs
- uid: System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnChildDesiredSizeChanged(UIElement)
  nameWithType: UIElement.OnChildDesiredSizeChanged(UIElement)
  fullName: System.Windows.UIElement.OnChildDesiredSizeChanged(UIElement)
- uid: System.Windows.UIElement
  parent: System.Windows
  isExternal: false
  name: UIElement
  nameWithType: UIElement
  fullName: System.Windows.UIElement
- uid: System.Windows.UIElement.OnCreateAutomationPeer
  parent: System.Windows.UIElement
  isExternal: false
  name: OnCreateAutomationPeer()
  nameWithType: UIElement.OnCreateAutomationPeer()
  fullName: System.Windows.UIElement.OnCreateAutomationPeer()
- uid: System.Windows.Automation.Peers.AutomationPeer
  parent: System.Windows.Automation.Peers
  isExternal: false
  name: AutomationPeer
  nameWithType: AutomationPeer
  fullName: System.Windows.Automation.Peers.AutomationPeer
- uid: System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDragEnter(DragEventArgs)
  nameWithType: UIElement.OnDragEnter(DragEventArgs)
  fullName: System.Windows.UIElement.OnDragEnter(DragEventArgs)
- uid: System.Windows.DragEventArgs
  parent: System.Windows
  isExternal: false
  name: DragEventArgs
  nameWithType: DragEventArgs
  fullName: System.Windows.DragEventArgs
- uid: System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDragLeave(DragEventArgs)
  nameWithType: UIElement.OnDragLeave(DragEventArgs)
  fullName: System.Windows.UIElement.OnDragLeave(DragEventArgs)
- uid: System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDragOver(DragEventArgs)
  nameWithType: UIElement.OnDragOver(DragEventArgs)
  fullName: System.Windows.UIElement.OnDragOver(DragEventArgs)
- uid: System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDrop(DragEventArgs)
  nameWithType: UIElement.OnDrop(DragEventArgs)
  fullName: System.Windows.UIElement.OnDrop(DragEventArgs)
- uid: System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: UIElement.OnGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.UIElement.OnGiveFeedback(GiveFeedbackEventArgs)
- uid: System.Windows.GiveFeedbackEventArgs
  parent: System.Windows
  isExternal: false
  name: GiveFeedbackEventArgs
  nameWithType: GiveFeedbackEventArgs
  fullName: System.Windows.GiveFeedbackEventArgs
- uid: System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: UIElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.UIElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.Input.KeyboardFocusChangedEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: KeyboardFocusChangedEventArgs
  nameWithType: KeyboardFocusChangedEventArgs
  fullName: System.Windows.Input.KeyboardFocusChangedEventArgs
- uid: System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotMouseCapture(MouseEventArgs)
  nameWithType: UIElement.OnGotMouseCapture(MouseEventArgs)
  fullName: System.Windows.UIElement.OnGotMouseCapture(MouseEventArgs)
- uid: System.Windows.Input.MouseEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: MouseEventArgs
  nameWithType: MouseEventArgs
  fullName: System.Windows.Input.MouseEventArgs
- uid: System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotStylusCapture(StylusEventArgs)
  nameWithType: UIElement.OnGotStylusCapture(StylusEventArgs)
  fullName: System.Windows.UIElement.OnGotStylusCapture(StylusEventArgs)
- uid: System.Windows.Input.StylusEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusEventArgs
  nameWithType: StylusEventArgs
  fullName: System.Windows.Input.StylusEventArgs
- uid: System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotTouchCapture(TouchEventArgs)
  nameWithType: UIElement.OnGotTouchCapture(TouchEventArgs)
  fullName: System.Windows.UIElement.OnGotTouchCapture(TouchEventArgs)
- uid: System.Windows.Input.TouchEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: TouchEventArgs
  nameWithType: TouchEventArgs
  fullName: System.Windows.Input.TouchEventArgs
- uid: System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  nameWithType: UIElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.UIElement.OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnKeyDown(KeyEventArgs)
  nameWithType: UIElement.OnKeyDown(KeyEventArgs)
  fullName: System.Windows.UIElement.OnKeyDown(KeyEventArgs)
- uid: System.Windows.Input.KeyEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: KeyEventArgs
  nameWithType: KeyEventArgs
  fullName: System.Windows.Input.KeyEventArgs
- uid: System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnKeyUp(KeyEventArgs)
  nameWithType: UIElement.OnKeyUp(KeyEventArgs)
  fullName: System.Windows.UIElement.OnKeyUp(KeyEventArgs)
- uid: System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostFocus(RoutedEventArgs)
  nameWithType: UIElement.OnLostFocus(RoutedEventArgs)
  fullName: System.Windows.UIElement.OnLostFocus(RoutedEventArgs)
- uid: System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostMouseCapture(MouseEventArgs)
  nameWithType: UIElement.OnLostMouseCapture(MouseEventArgs)
  fullName: System.Windows.UIElement.OnLostMouseCapture(MouseEventArgs)
- uid: System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostStylusCapture(StylusEventArgs)
  nameWithType: UIElement.OnLostStylusCapture(StylusEventArgs)
  fullName: System.Windows.UIElement.OnLostStylusCapture(StylusEventArgs)
- uid: System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostTouchCapture(TouchEventArgs)
  nameWithType: UIElement.OnLostTouchCapture(TouchEventArgs)
  fullName: System.Windows.UIElement.OnLostTouchCapture(TouchEventArgs)
- uid: System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  nameWithType: UIElement.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  fullName: System.Windows.UIElement.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
- uid: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationBoundaryFeedbackEventArgs
  nameWithType: ManipulationBoundaryFeedbackEventArgs
  fullName: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
- uid: System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationCompleted(ManipulationCompletedEventArgs)
  nameWithType: UIElement.OnManipulationCompleted(ManipulationCompletedEventArgs)
  fullName: System.Windows.UIElement.OnManipulationCompleted(ManipulationCompletedEventArgs)
- uid: System.Windows.Input.ManipulationCompletedEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationCompletedEventArgs
  nameWithType: ManipulationCompletedEventArgs
  fullName: System.Windows.Input.ManipulationCompletedEventArgs
- uid: System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationDelta(ManipulationDeltaEventArgs)
  nameWithType: UIElement.OnManipulationDelta(ManipulationDeltaEventArgs)
  fullName: System.Windows.UIElement.OnManipulationDelta(ManipulationDeltaEventArgs)
- uid: System.Windows.Input.ManipulationDeltaEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationDeltaEventArgs
  nameWithType: ManipulationDeltaEventArgs
  fullName: System.Windows.Input.ManipulationDeltaEventArgs
- uid: System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)
  nameWithType: UIElement.OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)
  fullName: System.Windows.UIElement.OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)
- uid: System.Windows.Input.ManipulationInertiaStartingEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationInertiaStartingEventArgs
  nameWithType: ManipulationInertiaStartingEventArgs
  fullName: System.Windows.Input.ManipulationInertiaStartingEventArgs
- uid: System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationStarted(ManipulationStartedEventArgs)
  nameWithType: UIElement.OnManipulationStarted(ManipulationStartedEventArgs)
  fullName: System.Windows.UIElement.OnManipulationStarted(ManipulationStartedEventArgs)
- uid: System.Windows.Input.ManipulationStartedEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationStartedEventArgs
  nameWithType: ManipulationStartedEventArgs
  fullName: System.Windows.Input.ManipulationStartedEventArgs
- uid: System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationStarting(ManipulationStartingEventArgs)
  nameWithType: UIElement.OnManipulationStarting(ManipulationStartingEventArgs)
  fullName: System.Windows.UIElement.OnManipulationStarting(ManipulationStartingEventArgs)
- uid: System.Windows.Input.ManipulationStartingEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationStartingEventArgs
  nameWithType: ManipulationStartingEventArgs
  fullName: System.Windows.Input.ManipulationStartingEventArgs
- uid: System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseDown(MouseButtonEventArgs)
- uid: System.Windows.Input.MouseButtonEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: MouseButtonEventArgs
  nameWithType: MouseButtonEventArgs
  fullName: System.Windows.Input.MouseButtonEventArgs
- uid: System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseEnter(MouseEventArgs)
  nameWithType: UIElement.OnMouseEnter(MouseEventArgs)
  fullName: System.Windows.UIElement.OnMouseEnter(MouseEventArgs)
- uid: System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseLeave(MouseEventArgs)
  nameWithType: UIElement.OnMouseLeave(MouseEventArgs)
  fullName: System.Windows.UIElement.OnMouseLeave(MouseEventArgs)
- uid: System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseLeftButtonDown(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseLeftButtonUp(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseMove(MouseEventArgs)
  nameWithType: UIElement.OnMouseMove(MouseEventArgs)
  fullName: System.Windows.UIElement.OnMouseMove(MouseEventArgs)
- uid: System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseRightButtonDown(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseRightButtonUp(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnMouseUp(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseWheel(MouseWheelEventArgs)
  nameWithType: UIElement.OnMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.UIElement.OnMouseWheel(MouseWheelEventArgs)
- uid: System.Windows.Input.MouseWheelEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: MouseWheelEventArgs
  nameWithType: MouseWheelEventArgs
  fullName: System.Windows.Input.MouseWheelEventArgs
- uid: System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDragEnter(DragEventArgs)
  nameWithType: UIElement.OnPreviewDragEnter(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDragEnter(DragEventArgs)
- uid: System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDragLeave(DragEventArgs)
  nameWithType: UIElement.OnPreviewDragLeave(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDragLeave(DragEventArgs)
- uid: System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDragOver(DragEventArgs)
  nameWithType: UIElement.OnPreviewDragOver(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDragOver(DragEventArgs)
- uid: System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDrop(DragEventArgs)
  nameWithType: UIElement.OnPreviewDrop(DragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewDrop(DragEventArgs)
- uid: System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  nameWithType: UIElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
  fullName: System.Windows.UIElement.OnPreviewGiveFeedback(GiveFeedbackEventArgs)
- uid: System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewKeyDown(KeyEventArgs)
  nameWithType: UIElement.OnPreviewKeyDown(KeyEventArgs)
  fullName: System.Windows.UIElement.OnPreviewKeyDown(KeyEventArgs)
- uid: System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewKeyUp(KeyEventArgs)
  nameWithType: UIElement.OnPreviewKeyUp(KeyEventArgs)
  fullName: System.Windows.UIElement.OnPreviewKeyUp(KeyEventArgs)
- uid: System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  nameWithType: UIElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
  fullName: System.Windows.UIElement.OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseDown(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseMove(MouseEventArgs)
  nameWithType: UIElement.OnPreviewMouseMove(MouseEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseMove(MouseEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseRightButtonDown(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseRightButtonUp(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseUp(MouseButtonEventArgs)
  nameWithType: UIElement.OnPreviewMouseUp(MouseButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseUp(MouseButtonEventArgs)
- uid: System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseWheel(MouseWheelEventArgs)
  nameWithType: UIElement.OnPreviewMouseWheel(MouseWheelEventArgs)
  fullName: System.Windows.UIElement.OnPreviewMouseWheel(MouseWheelEventArgs)
- uid: System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: UIElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.UIElement.OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)
- uid: System.Windows.QueryContinueDragEventArgs
  parent: System.Windows
  isExternal: false
  name: QueryContinueDragEventArgs
  nameWithType: QueryContinueDragEventArgs
  fullName: System.Windows.QueryContinueDragEventArgs
- uid: System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusButtonDown(StylusButtonEventArgs)
  nameWithType: UIElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusButtonDown(StylusButtonEventArgs)
- uid: System.Windows.Input.StylusButtonEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusButtonEventArgs
  nameWithType: StylusButtonEventArgs
  fullName: System.Windows.Input.StylusButtonEventArgs
- uid: System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusButtonUp(StylusButtonEventArgs)
  nameWithType: UIElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusButtonUp(StylusButtonEventArgs)
- uid: System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusDown(StylusDownEventArgs)
  nameWithType: UIElement.OnPreviewStylusDown(StylusDownEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusDown(StylusDownEventArgs)
- uid: System.Windows.Input.StylusDownEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusDownEventArgs
  nameWithType: StylusDownEventArgs
  fullName: System.Windows.Input.StylusDownEventArgs
- uid: System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusInAirMove(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusInAirMove(StylusEventArgs)
- uid: System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusInRange(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusInRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusInRange(StylusEventArgs)
- uid: System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusMove(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusMove(StylusEventArgs)
- uid: System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusOutOfRange(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusOutOfRange(StylusEventArgs)
- uid: System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: UIElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)
- uid: System.Windows.Input.StylusSystemGestureEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: StylusSystemGestureEventArgs
  nameWithType: StylusSystemGestureEventArgs
  fullName: System.Windows.Input.StylusSystemGestureEventArgs
- uid: System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusUp(StylusEventArgs)
  nameWithType: UIElement.OnPreviewStylusUp(StylusEventArgs)
  fullName: System.Windows.UIElement.OnPreviewStylusUp(StylusEventArgs)
- uid: System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTextInput(TextCompositionEventArgs)
  nameWithType: UIElement.OnPreviewTextInput(TextCompositionEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTextInput(TextCompositionEventArgs)
- uid: System.Windows.Input.TextCompositionEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: TextCompositionEventArgs
  nameWithType: TextCompositionEventArgs
  fullName: System.Windows.Input.TextCompositionEventArgs
- uid: System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTouchDown(TouchEventArgs)
  nameWithType: UIElement.OnPreviewTouchDown(TouchEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTouchDown(TouchEventArgs)
- uid: System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTouchMove(TouchEventArgs)
  nameWithType: UIElement.OnPreviewTouchMove(TouchEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTouchMove(TouchEventArgs)
- uid: System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTouchUp(TouchEventArgs)
  nameWithType: UIElement.OnPreviewTouchUp(TouchEventArgs)
  fullName: System.Windows.UIElement.OnPreviewTouchUp(TouchEventArgs)
- uid: System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnQueryContinueDrag(QueryContinueDragEventArgs)
  nameWithType: UIElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
  fullName: System.Windows.UIElement.OnQueryContinueDrag(QueryContinueDragEventArgs)
- uid: System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnQueryCursor(QueryCursorEventArgs)
  nameWithType: UIElement.OnQueryCursor(QueryCursorEventArgs)
  fullName: System.Windows.UIElement.OnQueryCursor(QueryCursorEventArgs)
- uid: System.Windows.Input.QueryCursorEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: QueryCursorEventArgs
  nameWithType: QueryCursorEventArgs
  fullName: System.Windows.Input.QueryCursorEventArgs
- uid: System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnRender(DrawingContext)
  nameWithType: UIElement.OnRender(DrawingContext)
  fullName: System.Windows.UIElement.OnRender(DrawingContext)
- uid: System.Windows.Media.DrawingContext
  parent: System.Windows.Media
  isExternal: false
  name: DrawingContext
  nameWithType: DrawingContext
  fullName: System.Windows.Media.DrawingContext
- uid: System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: UIElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.UIElement.OnRenderSizeChanged(SizeChangedInfo)
- uid: System.Windows.SizeChangedInfo
  parent: System.Windows
  isExternal: false
  name: SizeChangedInfo
  nameWithType: SizeChangedInfo
  fullName: System.Windows.SizeChangedInfo
- uid: System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusButtonDown(StylusButtonEventArgs)
  nameWithType: UIElement.OnStylusButtonDown(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnStylusButtonDown(StylusButtonEventArgs)
- uid: System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusButtonUp(StylusButtonEventArgs)
  nameWithType: UIElement.OnStylusButtonUp(StylusButtonEventArgs)
  fullName: System.Windows.UIElement.OnStylusButtonUp(StylusButtonEventArgs)
- uid: System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusDown(StylusDownEventArgs)
  nameWithType: UIElement.OnStylusDown(StylusDownEventArgs)
  fullName: System.Windows.UIElement.OnStylusDown(StylusDownEventArgs)
- uid: System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusEnter(StylusEventArgs)
  nameWithType: UIElement.OnStylusEnter(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusEnter(StylusEventArgs)
- uid: System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusInAirMove(StylusEventArgs)
  nameWithType: UIElement.OnStylusInAirMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusInAirMove(StylusEventArgs)
- uid: System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusInRange(StylusEventArgs)
  nameWithType: UIElement.OnStylusInRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusInRange(StylusEventArgs)
- uid: System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusLeave(StylusEventArgs)
  nameWithType: UIElement.OnStylusLeave(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusLeave(StylusEventArgs)
- uid: System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusMove(StylusEventArgs)
  nameWithType: UIElement.OnStylusMove(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusMove(StylusEventArgs)
- uid: System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusOutOfRange(StylusEventArgs)
  nameWithType: UIElement.OnStylusOutOfRange(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusOutOfRange(StylusEventArgs)
- uid: System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusSystemGesture(StylusSystemGestureEventArgs)
  nameWithType: UIElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
  fullName: System.Windows.UIElement.OnStylusSystemGesture(StylusSystemGestureEventArgs)
- uid: System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusUp(StylusEventArgs)
  nameWithType: UIElement.OnStylusUp(StylusEventArgs)
  fullName: System.Windows.UIElement.OnStylusUp(StylusEventArgs)
- uid: System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTextInput(TextCompositionEventArgs)
  nameWithType: UIElement.OnTextInput(TextCompositionEventArgs)
  fullName: System.Windows.UIElement.OnTextInput(TextCompositionEventArgs)
- uid: System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchDown(TouchEventArgs)
  nameWithType: UIElement.OnTouchDown(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchDown(TouchEventArgs)
- uid: System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchEnter(TouchEventArgs)
  nameWithType: UIElement.OnTouchEnter(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchEnter(TouchEventArgs)
- uid: System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchLeave(TouchEventArgs)
  nameWithType: UIElement.OnTouchLeave(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchLeave(TouchEventArgs)
- uid: System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchMove(TouchEventArgs)
  nameWithType: UIElement.OnTouchMove(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchMove(TouchEventArgs)
- uid: System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchUp(TouchEventArgs)
  nameWithType: UIElement.OnTouchUp(TouchEventArgs)
  fullName: System.Windows.UIElement.OnTouchUp(TouchEventArgs)
- uid: System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.UIElement
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: UIElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.UIElement.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.UIElement.Opacity
  parent: System.Windows.UIElement
  isExternal: false
  name: Opacity
  nameWithType: UIElement.Opacity
  fullName: System.Windows.UIElement.Opacity
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.UIElement.OpacityMask
  parent: System.Windows.UIElement
  isExternal: false
  name: OpacityMask
  nameWithType: UIElement.OpacityMask
  fullName: System.Windows.UIElement.OpacityMask
- uid: System.Windows.Media.Brush
  parent: System.Windows.Media
  isExternal: false
  name: Brush
  nameWithType: Brush
  fullName: System.Windows.Media.Brush
- uid: System.Windows.UIElement.OpacityMaskProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: OpacityMaskProperty
  nameWithType: UIElement.OpacityMaskProperty
  fullName: System.Windows.UIElement.OpacityMaskProperty
- uid: System.Windows.UIElement.OpacityProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: OpacityProperty
  nameWithType: UIElement.OpacityProperty
  fullName: System.Windows.UIElement.OpacityProperty
- uid: System.Windows.UIElement.PersistId
  parent: System.Windows.UIElement
  isExternal: false
  name: PersistId
  nameWithType: UIElement.PersistId
  fullName: System.Windows.UIElement.PersistId
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.UIElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: UIElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.UIElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.UIElement.PreviewDragEnter
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDragEnter
  nameWithType: UIElement.PreviewDragEnter
  fullName: System.Windows.UIElement.PreviewDragEnter
- uid: System.Windows.UIElement.PreviewDragEnterEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDragEnterEvent
  nameWithType: UIElement.PreviewDragEnterEvent
  fullName: System.Windows.UIElement.PreviewDragEnterEvent
- uid: System.Windows.UIElement.PreviewDragLeave
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDragLeave
  nameWithType: UIElement.PreviewDragLeave
  fullName: System.Windows.UIElement.PreviewDragLeave
- uid: System.Windows.UIElement.PreviewDragLeaveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDragLeaveEvent
  nameWithType: UIElement.PreviewDragLeaveEvent
  fullName: System.Windows.UIElement.PreviewDragLeaveEvent
- uid: System.Windows.UIElement.PreviewDragOver
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDragOver
  nameWithType: UIElement.PreviewDragOver
  fullName: System.Windows.UIElement.PreviewDragOver
- uid: System.Windows.UIElement.PreviewDragOverEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDragOverEvent
  nameWithType: UIElement.PreviewDragOverEvent
  fullName: System.Windows.UIElement.PreviewDragOverEvent
- uid: System.Windows.UIElement.PreviewDrop
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDrop
  nameWithType: UIElement.PreviewDrop
  fullName: System.Windows.UIElement.PreviewDrop
- uid: System.Windows.UIElement.PreviewDropEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewDropEvent
  nameWithType: UIElement.PreviewDropEvent
  fullName: System.Windows.UIElement.PreviewDropEvent
- uid: System.Windows.UIElement.PreviewGiveFeedback
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewGiveFeedback
  nameWithType: UIElement.PreviewGiveFeedback
  fullName: System.Windows.UIElement.PreviewGiveFeedback
- uid: System.Windows.UIElement.PreviewGiveFeedbackEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewGiveFeedbackEvent
  nameWithType: UIElement.PreviewGiveFeedbackEvent
  fullName: System.Windows.UIElement.PreviewGiveFeedbackEvent
- uid: System.Windows.UIElement.PreviewGotKeyboardFocus
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewGotKeyboardFocus
  nameWithType: UIElement.PreviewGotKeyboardFocus
  fullName: System.Windows.UIElement.PreviewGotKeyboardFocus
- uid: System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewGotKeyboardFocusEvent
  nameWithType: UIElement.PreviewGotKeyboardFocusEvent
  fullName: System.Windows.UIElement.PreviewGotKeyboardFocusEvent
- uid: System.Windows.UIElement.PreviewKeyDown
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewKeyDown
  nameWithType: UIElement.PreviewKeyDown
  fullName: System.Windows.UIElement.PreviewKeyDown
- uid: System.Windows.UIElement.PreviewKeyDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewKeyDownEvent
  nameWithType: UIElement.PreviewKeyDownEvent
  fullName: System.Windows.UIElement.PreviewKeyDownEvent
- uid: System.Windows.UIElement.PreviewKeyUp
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewKeyUp
  nameWithType: UIElement.PreviewKeyUp
  fullName: System.Windows.UIElement.PreviewKeyUp
- uid: System.Windows.UIElement.PreviewKeyUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewKeyUpEvent
  nameWithType: UIElement.PreviewKeyUpEvent
  fullName: System.Windows.UIElement.PreviewKeyUpEvent
- uid: System.Windows.UIElement.PreviewLostKeyboardFocus
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewLostKeyboardFocus
  nameWithType: UIElement.PreviewLostKeyboardFocus
  fullName: System.Windows.UIElement.PreviewLostKeyboardFocus
- uid: System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewLostKeyboardFocusEvent
  nameWithType: UIElement.PreviewLostKeyboardFocusEvent
  fullName: System.Windows.UIElement.PreviewLostKeyboardFocusEvent
- uid: System.Windows.UIElement.PreviewMouseDown
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseDown
  nameWithType: UIElement.PreviewMouseDown
  fullName: System.Windows.UIElement.PreviewMouseDown
- uid: System.Windows.UIElement.PreviewMouseDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseDownEvent
  nameWithType: UIElement.PreviewMouseDownEvent
  fullName: System.Windows.UIElement.PreviewMouseDownEvent
- uid: System.Windows.UIElement.PreviewMouseLeftButtonDown
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseLeftButtonDown
  nameWithType: UIElement.PreviewMouseLeftButtonDown
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonDown
- uid: System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseLeftButtonDownEvent
  nameWithType: UIElement.PreviewMouseLeftButtonDownEvent
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
- uid: System.Windows.UIElement.PreviewMouseLeftButtonUp
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseLeftButtonUp
  nameWithType: UIElement.PreviewMouseLeftButtonUp
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonUp
- uid: System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseLeftButtonUpEvent
  nameWithType: UIElement.PreviewMouseLeftButtonUpEvent
  fullName: System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
- uid: System.Windows.UIElement.PreviewMouseMove
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseMove
  nameWithType: UIElement.PreviewMouseMove
  fullName: System.Windows.UIElement.PreviewMouseMove
- uid: System.Windows.UIElement.PreviewMouseMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseMoveEvent
  nameWithType: UIElement.PreviewMouseMoveEvent
  fullName: System.Windows.UIElement.PreviewMouseMoveEvent
- uid: System.Windows.UIElement.PreviewMouseRightButtonDown
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseRightButtonDown
  nameWithType: UIElement.PreviewMouseRightButtonDown
  fullName: System.Windows.UIElement.PreviewMouseRightButtonDown
- uid: System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseRightButtonDownEvent
  nameWithType: UIElement.PreviewMouseRightButtonDownEvent
  fullName: System.Windows.UIElement.PreviewMouseRightButtonDownEvent
- uid: System.Windows.UIElement.PreviewMouseRightButtonUp
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseRightButtonUp
  nameWithType: UIElement.PreviewMouseRightButtonUp
  fullName: System.Windows.UIElement.PreviewMouseRightButtonUp
- uid: System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseRightButtonUpEvent
  nameWithType: UIElement.PreviewMouseRightButtonUpEvent
  fullName: System.Windows.UIElement.PreviewMouseRightButtonUpEvent
- uid: System.Windows.UIElement.PreviewMouseUp
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseUp
  nameWithType: UIElement.PreviewMouseUp
  fullName: System.Windows.UIElement.PreviewMouseUp
- uid: System.Windows.UIElement.PreviewMouseUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseUpEvent
  nameWithType: UIElement.PreviewMouseUpEvent
  fullName: System.Windows.UIElement.PreviewMouseUpEvent
- uid: System.Windows.UIElement.PreviewMouseWheel
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseWheel
  nameWithType: UIElement.PreviewMouseWheel
  fullName: System.Windows.UIElement.PreviewMouseWheel
- uid: System.Windows.UIElement.PreviewMouseWheelEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewMouseWheelEvent
  nameWithType: UIElement.PreviewMouseWheelEvent
  fullName: System.Windows.UIElement.PreviewMouseWheelEvent
- uid: System.Windows.UIElement.PreviewQueryContinueDrag
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewQueryContinueDrag
  nameWithType: UIElement.PreviewQueryContinueDrag
  fullName: System.Windows.UIElement.PreviewQueryContinueDrag
- uid: System.Windows.QueryContinueDragEventHandler
  parent: System.Windows
  isExternal: false
  name: QueryContinueDragEventHandler
  nameWithType: QueryContinueDragEventHandler
  fullName: System.Windows.QueryContinueDragEventHandler
- uid: System.Windows.UIElement.PreviewQueryContinueDragEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewQueryContinueDragEvent
  nameWithType: UIElement.PreviewQueryContinueDragEvent
  fullName: System.Windows.UIElement.PreviewQueryContinueDragEvent
- uid: System.Windows.UIElement.PreviewStylusButtonDown
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusButtonDown
  nameWithType: UIElement.PreviewStylusButtonDown
  fullName: System.Windows.UIElement.PreviewStylusButtonDown
- uid: System.Windows.Input.StylusButtonEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusButtonEventHandler
  nameWithType: StylusButtonEventHandler
  fullName: System.Windows.Input.StylusButtonEventHandler
- uid: System.Windows.UIElement.PreviewStylusButtonDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusButtonDownEvent
  nameWithType: UIElement.PreviewStylusButtonDownEvent
  fullName: System.Windows.UIElement.PreviewStylusButtonDownEvent
- uid: System.Windows.UIElement.PreviewStylusButtonUp
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusButtonUp
  nameWithType: UIElement.PreviewStylusButtonUp
  fullName: System.Windows.UIElement.PreviewStylusButtonUp
- uid: System.Windows.UIElement.PreviewStylusButtonUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusButtonUpEvent
  nameWithType: UIElement.PreviewStylusButtonUpEvent
  fullName: System.Windows.UIElement.PreviewStylusButtonUpEvent
- uid: System.Windows.UIElement.PreviewStylusDown
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusDown
  nameWithType: UIElement.PreviewStylusDown
  fullName: System.Windows.UIElement.PreviewStylusDown
- uid: System.Windows.Input.StylusDownEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusDownEventHandler
  nameWithType: StylusDownEventHandler
  fullName: System.Windows.Input.StylusDownEventHandler
- uid: System.Windows.UIElement.PreviewStylusDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusDownEvent
  nameWithType: UIElement.PreviewStylusDownEvent
  fullName: System.Windows.UIElement.PreviewStylusDownEvent
- uid: System.Windows.UIElement.PreviewStylusInAirMove
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusInAirMove
  nameWithType: UIElement.PreviewStylusInAirMove
  fullName: System.Windows.UIElement.PreviewStylusInAirMove
- uid: System.Windows.UIElement.PreviewStylusInAirMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusInAirMoveEvent
  nameWithType: UIElement.PreviewStylusInAirMoveEvent
  fullName: System.Windows.UIElement.PreviewStylusInAirMoveEvent
- uid: System.Windows.UIElement.PreviewStylusInRange
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusInRange
  nameWithType: UIElement.PreviewStylusInRange
  fullName: System.Windows.UIElement.PreviewStylusInRange
- uid: System.Windows.UIElement.PreviewStylusInRangeEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusInRangeEvent
  nameWithType: UIElement.PreviewStylusInRangeEvent
  fullName: System.Windows.UIElement.PreviewStylusInRangeEvent
- uid: System.Windows.UIElement.PreviewStylusMove
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusMove
  nameWithType: UIElement.PreviewStylusMove
  fullName: System.Windows.UIElement.PreviewStylusMove
- uid: System.Windows.UIElement.PreviewStylusMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusMoveEvent
  nameWithType: UIElement.PreviewStylusMoveEvent
  fullName: System.Windows.UIElement.PreviewStylusMoveEvent
- uid: System.Windows.UIElement.PreviewStylusOutOfRange
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusOutOfRange
  nameWithType: UIElement.PreviewStylusOutOfRange
  fullName: System.Windows.UIElement.PreviewStylusOutOfRange
- uid: System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusOutOfRangeEvent
  nameWithType: UIElement.PreviewStylusOutOfRangeEvent
  fullName: System.Windows.UIElement.PreviewStylusOutOfRangeEvent
- uid: System.Windows.UIElement.PreviewStylusSystemGesture
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusSystemGesture
  nameWithType: UIElement.PreviewStylusSystemGesture
  fullName: System.Windows.UIElement.PreviewStylusSystemGesture
- uid: System.Windows.Input.StylusSystemGestureEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: StylusSystemGestureEventHandler
  nameWithType: StylusSystemGestureEventHandler
  fullName: System.Windows.Input.StylusSystemGestureEventHandler
- uid: System.Windows.UIElement.PreviewStylusSystemGestureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusSystemGestureEvent
  nameWithType: UIElement.PreviewStylusSystemGestureEvent
  fullName: System.Windows.UIElement.PreviewStylusSystemGestureEvent
- uid: System.Windows.UIElement.PreviewStylusUp
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusUp
  nameWithType: UIElement.PreviewStylusUp
  fullName: System.Windows.UIElement.PreviewStylusUp
- uid: System.Windows.UIElement.PreviewStylusUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewStylusUpEvent
  nameWithType: UIElement.PreviewStylusUpEvent
  fullName: System.Windows.UIElement.PreviewStylusUpEvent
- uid: System.Windows.UIElement.PreviewTextInput
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTextInput
  nameWithType: UIElement.PreviewTextInput
  fullName: System.Windows.UIElement.PreviewTextInput
- uid: System.Windows.Input.TextCompositionEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: TextCompositionEventHandler
  nameWithType: TextCompositionEventHandler
  fullName: System.Windows.Input.TextCompositionEventHandler
- uid: System.Windows.UIElement.PreviewTextInputEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTextInputEvent
  nameWithType: UIElement.PreviewTextInputEvent
  fullName: System.Windows.UIElement.PreviewTextInputEvent
- uid: System.Windows.UIElement.PreviewTouchDown
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTouchDown
  nameWithType: UIElement.PreviewTouchDown
  fullName: System.Windows.UIElement.PreviewTouchDown
- uid: System.Windows.UIElement.PreviewTouchDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTouchDownEvent
  nameWithType: UIElement.PreviewTouchDownEvent
  fullName: System.Windows.UIElement.PreviewTouchDownEvent
- uid: System.Windows.UIElement.PreviewTouchMove
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTouchMove
  nameWithType: UIElement.PreviewTouchMove
  fullName: System.Windows.UIElement.PreviewTouchMove
- uid: System.Windows.UIElement.PreviewTouchMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTouchMoveEvent
  nameWithType: UIElement.PreviewTouchMoveEvent
  fullName: System.Windows.UIElement.PreviewTouchMoveEvent
- uid: System.Windows.UIElement.PreviewTouchUp
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTouchUp
  nameWithType: UIElement.PreviewTouchUp
  fullName: System.Windows.UIElement.PreviewTouchUp
- uid: System.Windows.UIElement.PreviewTouchUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: PreviewTouchUpEvent
  nameWithType: UIElement.PreviewTouchUpEvent
  fullName: System.Windows.UIElement.PreviewTouchUpEvent
- uid: System.Windows.UIElement.QueryContinueDrag
  parent: System.Windows.UIElement
  isExternal: false
  name: QueryContinueDrag
  nameWithType: UIElement.QueryContinueDrag
  fullName: System.Windows.UIElement.QueryContinueDrag
- uid: System.Windows.UIElement.QueryContinueDragEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: QueryContinueDragEvent
  nameWithType: UIElement.QueryContinueDragEvent
  fullName: System.Windows.UIElement.QueryContinueDragEvent
- uid: System.Windows.UIElement.QueryCursor
  parent: System.Windows.UIElement
  isExternal: false
  name: QueryCursor
  nameWithType: UIElement.QueryCursor
  fullName: System.Windows.UIElement.QueryCursor
- uid: System.Windows.Input.QueryCursorEventHandler
  parent: System.Windows.Input
  isExternal: false
  name: QueryCursorEventHandler
  nameWithType: QueryCursorEventHandler
  fullName: System.Windows.Input.QueryCursorEventHandler
- uid: System.Windows.UIElement.QueryCursorEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: QueryCursorEvent
  nameWithType: UIElement.QueryCursorEvent
  fullName: System.Windows.UIElement.QueryCursorEvent
- uid: System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  parent: System.Windows.UIElement
  isExternal: false
  name: RaiseEvent(RoutedEventArgs)
  nameWithType: UIElement.RaiseEvent(RoutedEventArgs)
  fullName: System.Windows.UIElement.RaiseEvent(RoutedEventArgs)
- uid: System.Windows.UIElement.ReleaseAllTouchCaptures
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseAllTouchCaptures()
  nameWithType: UIElement.ReleaseAllTouchCaptures()
  fullName: System.Windows.UIElement.ReleaseAllTouchCaptures()
- uid: System.Windows.UIElement.ReleaseMouseCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseMouseCapture()
  nameWithType: UIElement.ReleaseMouseCapture()
  fullName: System.Windows.UIElement.ReleaseMouseCapture()
- uid: System.Windows.UIElement.ReleaseStylusCapture
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseStylusCapture()
  nameWithType: UIElement.ReleaseStylusCapture()
  fullName: System.Windows.UIElement.ReleaseStylusCapture()
- uid: System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseTouchCapture(TouchDevice)
  nameWithType: UIElement.ReleaseTouchCapture(TouchDevice)
  fullName: System.Windows.UIElement.ReleaseTouchCapture(TouchDevice)
- uid: System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  parent: System.Windows.UIElement
  isExternal: false
  name: RemoveHandler(RoutedEvent,Delegate)
  nameWithType: UIElement.RemoveHandler(RoutedEvent,Delegate)
  fullName: System.Windows.UIElement.RemoveHandler(RoutedEvent,Delegate)
- uid: System.Windows.UIElement.RenderSize
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderSize
  nameWithType: UIElement.RenderSize
  fullName: System.Windows.UIElement.RenderSize
- uid: System.Windows.UIElement.RenderTransform
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderTransform
  nameWithType: UIElement.RenderTransform
  fullName: System.Windows.UIElement.RenderTransform
- uid: System.Windows.Media.Transform
  parent: System.Windows.Media
  isExternal: false
  name: Transform
  nameWithType: Transform
  fullName: System.Windows.Media.Transform
- uid: System.Windows.UIElement.RenderTransformOrigin
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderTransformOrigin
  nameWithType: UIElement.RenderTransformOrigin
  fullName: System.Windows.UIElement.RenderTransformOrigin
- uid: System.Windows.UIElement.RenderTransformOriginProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderTransformOriginProperty
  nameWithType: UIElement.RenderTransformOriginProperty
  fullName: System.Windows.UIElement.RenderTransformOriginProperty
- uid: System.Windows.UIElement.RenderTransformProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderTransformProperty
  nameWithType: UIElement.RenderTransformProperty
  fullName: System.Windows.UIElement.RenderTransformProperty
- uid: System.Windows.UIElement.ShouldSerializeCommandBindings
  parent: System.Windows.UIElement
  isExternal: false
  name: ShouldSerializeCommandBindings()
  nameWithType: UIElement.ShouldSerializeCommandBindings()
  fullName: System.Windows.UIElement.ShouldSerializeCommandBindings()
- uid: System.Windows.UIElement.ShouldSerializeInputBindings
  parent: System.Windows.UIElement
  isExternal: false
  name: ShouldSerializeInputBindings()
  nameWithType: UIElement.ShouldSerializeInputBindings()
  fullName: System.Windows.UIElement.ShouldSerializeInputBindings()
- uid: System.Windows.UIElement.SnapsToDevicePixels
  parent: System.Windows.UIElement
  isExternal: false
  name: SnapsToDevicePixels
  nameWithType: UIElement.SnapsToDevicePixels
  fullName: System.Windows.UIElement.SnapsToDevicePixels
- uid: System.Windows.UIElement.SnapsToDevicePixelsProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: SnapsToDevicePixelsProperty
  nameWithType: UIElement.SnapsToDevicePixelsProperty
  fullName: System.Windows.UIElement.SnapsToDevicePixelsProperty
- uid: System.Windows.UIElement.StylusButtonDown
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusButtonDown
  nameWithType: UIElement.StylusButtonDown
  fullName: System.Windows.UIElement.StylusButtonDown
- uid: System.Windows.UIElement.StylusButtonDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusButtonDownEvent
  nameWithType: UIElement.StylusButtonDownEvent
  fullName: System.Windows.UIElement.StylusButtonDownEvent
- uid: System.Windows.UIElement.StylusButtonUp
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusButtonUp
  nameWithType: UIElement.StylusButtonUp
  fullName: System.Windows.UIElement.StylusButtonUp
- uid: System.Windows.UIElement.StylusButtonUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusButtonUpEvent
  nameWithType: UIElement.StylusButtonUpEvent
  fullName: System.Windows.UIElement.StylusButtonUpEvent
- uid: System.Windows.UIElement.StylusDown
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusDown
  nameWithType: UIElement.StylusDown
  fullName: System.Windows.UIElement.StylusDown
- uid: System.Windows.UIElement.StylusDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusDownEvent
  nameWithType: UIElement.StylusDownEvent
  fullName: System.Windows.UIElement.StylusDownEvent
- uid: System.Windows.UIElement.StylusEnter
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusEnter
  nameWithType: UIElement.StylusEnter
  fullName: System.Windows.UIElement.StylusEnter
- uid: System.Windows.UIElement.StylusEnterEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusEnterEvent
  nameWithType: UIElement.StylusEnterEvent
  fullName: System.Windows.UIElement.StylusEnterEvent
- uid: System.Windows.UIElement.StylusInAirMove
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusInAirMove
  nameWithType: UIElement.StylusInAirMove
  fullName: System.Windows.UIElement.StylusInAirMove
- uid: System.Windows.UIElement.StylusInAirMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusInAirMoveEvent
  nameWithType: UIElement.StylusInAirMoveEvent
  fullName: System.Windows.UIElement.StylusInAirMoveEvent
- uid: System.Windows.UIElement.StylusInRange
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusInRange
  nameWithType: UIElement.StylusInRange
  fullName: System.Windows.UIElement.StylusInRange
- uid: System.Windows.UIElement.StylusInRangeEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusInRangeEvent
  nameWithType: UIElement.StylusInRangeEvent
  fullName: System.Windows.UIElement.StylusInRangeEvent
- uid: System.Windows.UIElement.StylusLeave
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusLeave
  nameWithType: UIElement.StylusLeave
  fullName: System.Windows.UIElement.StylusLeave
- uid: System.Windows.UIElement.StylusLeaveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusLeaveEvent
  nameWithType: UIElement.StylusLeaveEvent
  fullName: System.Windows.UIElement.StylusLeaveEvent
- uid: System.Windows.UIElement.StylusMove
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusMove
  nameWithType: UIElement.StylusMove
  fullName: System.Windows.UIElement.StylusMove
- uid: System.Windows.UIElement.StylusMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusMoveEvent
  nameWithType: UIElement.StylusMoveEvent
  fullName: System.Windows.UIElement.StylusMoveEvent
- uid: System.Windows.UIElement.StylusOutOfRange
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusOutOfRange
  nameWithType: UIElement.StylusOutOfRange
  fullName: System.Windows.UIElement.StylusOutOfRange
- uid: System.Windows.UIElement.StylusOutOfRangeEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusOutOfRangeEvent
  nameWithType: UIElement.StylusOutOfRangeEvent
  fullName: System.Windows.UIElement.StylusOutOfRangeEvent
- uid: System.Windows.UIElement.StylusPlugIns
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusPlugIns
  nameWithType: UIElement.StylusPlugIns
  fullName: System.Windows.UIElement.StylusPlugIns
- uid: System.Windows.Input.StylusPlugIns.StylusPlugInCollection
  parent: System.Windows.Input.StylusPlugIns
  isExternal: false
  name: StylusPlugInCollection
  nameWithType: StylusPlugInCollection
  fullName: System.Windows.Input.StylusPlugIns.StylusPlugInCollection
- uid: System.Windows.UIElement.StylusSystemGesture
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusSystemGesture
  nameWithType: UIElement.StylusSystemGesture
  fullName: System.Windows.UIElement.StylusSystemGesture
- uid: System.Windows.UIElement.StylusSystemGestureEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusSystemGestureEvent
  nameWithType: UIElement.StylusSystemGestureEvent
  fullName: System.Windows.UIElement.StylusSystemGestureEvent
- uid: System.Windows.UIElement.StylusUp
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusUp
  nameWithType: UIElement.StylusUp
  fullName: System.Windows.UIElement.StylusUp
- uid: System.Windows.UIElement.StylusUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusUpEvent
  nameWithType: UIElement.StylusUpEvent
  fullName: System.Windows.UIElement.StylusUpEvent
- uid: System.Windows.UIElement.TextInput
  parent: System.Windows.UIElement
  isExternal: false
  name: TextInput
  nameWithType: UIElement.TextInput
  fullName: System.Windows.UIElement.TextInput
- uid: System.Windows.UIElement.TextInputEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: TextInputEvent
  nameWithType: UIElement.TextInputEvent
  fullName: System.Windows.UIElement.TextInputEvent
- uid: System.Windows.UIElement.TouchDown
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchDown
  nameWithType: UIElement.TouchDown
  fullName: System.Windows.UIElement.TouchDown
- uid: System.Windows.UIElement.TouchDownEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchDownEvent
  nameWithType: UIElement.TouchDownEvent
  fullName: System.Windows.UIElement.TouchDownEvent
- uid: System.Windows.UIElement.TouchEnter
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchEnter
  nameWithType: UIElement.TouchEnter
  fullName: System.Windows.UIElement.TouchEnter
- uid: System.Windows.UIElement.TouchEnterEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchEnterEvent
  nameWithType: UIElement.TouchEnterEvent
  fullName: System.Windows.UIElement.TouchEnterEvent
- uid: System.Windows.UIElement.TouchesCaptured
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesCaptured
  nameWithType: UIElement.TouchesCaptured
  fullName: System.Windows.UIElement.TouchesCaptured
- uid: System.Collections.Generic.IEnumerable{System.Windows.Input.TouchDevice}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<TouchDevice>
  nameWithType: IEnumerable<TouchDevice>
  fullName: System.Collections.Generic.IEnumerable<System.Windows.Input.TouchDevice>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Windows.Input.TouchDevice>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Input.TouchDevice
    name: TouchDevice
    nameWithType: TouchDevice
    fullName: TouchDevice
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.UIElement.TouchesCapturedWithin
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesCapturedWithin
  nameWithType: UIElement.TouchesCapturedWithin
  fullName: System.Windows.UIElement.TouchesCapturedWithin
- uid: System.Windows.UIElement.TouchesDirectlyOver
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesDirectlyOver
  nameWithType: UIElement.TouchesDirectlyOver
  fullName: System.Windows.UIElement.TouchesDirectlyOver
- uid: System.Windows.UIElement.TouchesOver
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesOver
  nameWithType: UIElement.TouchesOver
  fullName: System.Windows.UIElement.TouchesOver
- uid: System.Windows.UIElement.TouchLeave
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchLeave
  nameWithType: UIElement.TouchLeave
  fullName: System.Windows.UIElement.TouchLeave
- uid: System.Windows.UIElement.TouchLeaveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchLeaveEvent
  nameWithType: UIElement.TouchLeaveEvent
  fullName: System.Windows.UIElement.TouchLeaveEvent
- uid: System.Windows.UIElement.TouchMove
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchMove
  nameWithType: UIElement.TouchMove
  fullName: System.Windows.UIElement.TouchMove
- uid: System.Windows.UIElement.TouchMoveEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchMoveEvent
  nameWithType: UIElement.TouchMoveEvent
  fullName: System.Windows.UIElement.TouchMoveEvent
- uid: System.Windows.UIElement.TouchUp
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchUp
  nameWithType: UIElement.TouchUp
  fullName: System.Windows.UIElement.TouchUp
- uid: System.Windows.UIElement.TouchUpEvent
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchUpEvent
  nameWithType: UIElement.TouchUpEvent
  fullName: System.Windows.UIElement.TouchUpEvent
- uid: System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  parent: System.Windows.UIElement
  isExternal: false
  name: TranslatePoint(Point,UIElement)
  nameWithType: UIElement.TranslatePoint(Point,UIElement)
  fullName: System.Windows.UIElement.TranslatePoint(Point,UIElement)
- uid: System.Windows.UIElement.Uid
  parent: System.Windows.UIElement
  isExternal: false
  name: Uid
  nameWithType: UIElement.Uid
  fullName: System.Windows.UIElement.Uid
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.UIElement.UidProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: UidProperty
  nameWithType: UIElement.UidProperty
  fullName: System.Windows.UIElement.UidProperty
- uid: System.Windows.UIElement.UpdateLayout
  parent: System.Windows.UIElement
  isExternal: false
  name: UpdateLayout()
  nameWithType: UIElement.UpdateLayout()
  fullName: System.Windows.UIElement.UpdateLayout()
- uid: System.Windows.UIElement.Visibility
  parent: System.Windows.UIElement
  isExternal: false
  name: Visibility
  nameWithType: UIElement.Visibility
  fullName: System.Windows.UIElement.Visibility
- uid: System.Windows.Visibility
  parent: System.Windows
  isExternal: false
  name: Visibility
  nameWithType: Visibility
  fullName: System.Windows.Visibility
- uid: System.Windows.UIElement.VisibilityProperty
  parent: System.Windows.UIElement
  isExternal: false
  name: VisibilityProperty
  nameWithType: UIElement.VisibilityProperty
  fullName: System.Windows.UIElement.VisibilityProperty
- uid: System.Windows.UIElement.#ctor*
  parent: System.Windows.UIElement
  isExternal: false
  name: UIElement
  nameWithType: UIElement.UIElement
- uid: System.Windows.UIElement.AddHandler*
  parent: System.Windows.UIElement
  isExternal: false
  name: AddHandler
  nameWithType: UIElement.AddHandler
- uid: System.Windows.UIElement.AddToEventRoute*
  parent: System.Windows.UIElement
  isExternal: false
  name: AddToEventRoute
  nameWithType: UIElement.AddToEventRoute
- uid: System.Windows.UIElement.AllowDrop*
  parent: System.Windows.UIElement
  isExternal: false
  name: AllowDrop
  nameWithType: UIElement.AllowDrop
- uid: System.Windows.UIElement.ApplyAnimationClock*
  parent: System.Windows.UIElement
  isExternal: false
  name: ApplyAnimationClock
  nameWithType: UIElement.ApplyAnimationClock
- uid: System.Windows.UIElement.AreAnyTouchesCaptured*
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesCaptured
  nameWithType: UIElement.AreAnyTouchesCaptured
- uid: System.Windows.UIElement.AreAnyTouchesCapturedWithin*
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesCapturedWithin
  nameWithType: UIElement.AreAnyTouchesCapturedWithin
- uid: System.Windows.UIElement.AreAnyTouchesDirectlyOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesDirectlyOver
  nameWithType: UIElement.AreAnyTouchesDirectlyOver
- uid: System.Windows.UIElement.AreAnyTouchesOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: AreAnyTouchesOver
  nameWithType: UIElement.AreAnyTouchesOver
- uid: System.Windows.UIElement.Arrange*
  parent: System.Windows.UIElement
  isExternal: false
  name: Arrange
  nameWithType: UIElement.Arrange
- uid: System.Windows.UIElement.ArrangeCore*
  parent: System.Windows.UIElement
  isExternal: false
  name: ArrangeCore
  nameWithType: UIElement.ArrangeCore
- uid: System.Windows.UIElement.BeginAnimation*
  parent: System.Windows.UIElement
  isExternal: false
  name: BeginAnimation
  nameWithType: UIElement.BeginAnimation
- uid: System.Windows.UIElement.BitmapEffect*
  parent: System.Windows.UIElement
  isExternal: false
  name: BitmapEffect
  nameWithType: UIElement.BitmapEffect
- uid: System.Windows.UIElement.BitmapEffectInput*
  parent: System.Windows.UIElement
  isExternal: false
  name: BitmapEffectInput
  nameWithType: UIElement.BitmapEffectInput
- uid: System.Windows.UIElement.CacheMode*
  parent: System.Windows.UIElement
  isExternal: false
  name: CacheMode
  nameWithType: UIElement.CacheMode
- uid: System.Windows.UIElement.CaptureMouse*
  parent: System.Windows.UIElement
  isExternal: false
  name: CaptureMouse
  nameWithType: UIElement.CaptureMouse
- uid: System.Windows.UIElement.CaptureStylus*
  parent: System.Windows.UIElement
  isExternal: false
  name: CaptureStylus
  nameWithType: UIElement.CaptureStylus
- uid: System.Windows.UIElement.CaptureTouch*
  parent: System.Windows.UIElement
  isExternal: false
  name: CaptureTouch
  nameWithType: UIElement.CaptureTouch
- uid: System.Windows.UIElement.Clip*
  parent: System.Windows.UIElement
  isExternal: false
  name: Clip
  nameWithType: UIElement.Clip
- uid: System.Windows.UIElement.ClipToBounds*
  parent: System.Windows.UIElement
  isExternal: false
  name: ClipToBounds
  nameWithType: UIElement.ClipToBounds
- uid: System.Windows.UIElement.CommandBindings*
  parent: System.Windows.UIElement
  isExternal: false
  name: CommandBindings
  nameWithType: UIElement.CommandBindings
- uid: System.Windows.UIElement.DesiredSize*
  parent: System.Windows.UIElement
  isExternal: false
  name: DesiredSize
  nameWithType: UIElement.DesiredSize
- uid: System.Windows.UIElement.Effect*
  parent: System.Windows.UIElement
  isExternal: false
  name: Effect
  nameWithType: UIElement.Effect
- uid: System.Windows.UIElement.Focus*
  parent: System.Windows.UIElement
  isExternal: false
  name: Focus
  nameWithType: UIElement.Focus
- uid: System.Windows.UIElement.Focusable*
  parent: System.Windows.UIElement
  isExternal: false
  name: Focusable
  nameWithType: UIElement.Focusable
- uid: System.Windows.UIElement.GetAnimationBaseValue*
  parent: System.Windows.UIElement
  isExternal: false
  name: GetAnimationBaseValue
  nameWithType: UIElement.GetAnimationBaseValue
- uid: System.Windows.UIElement.GetLayoutClip*
  parent: System.Windows.UIElement
  isExternal: false
  name: GetLayoutClip
  nameWithType: UIElement.GetLayoutClip
- uid: System.Windows.UIElement.GetUIParentCore*
  parent: System.Windows.UIElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: UIElement.GetUIParentCore
- uid: System.Windows.UIElement.HasAnimatedProperties*
  parent: System.Windows.UIElement
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: UIElement.HasAnimatedProperties
- uid: System.Windows.UIElement.HasEffectiveKeyboardFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: HasEffectiveKeyboardFocus
  nameWithType: UIElement.HasEffectiveKeyboardFocus
- uid: System.Windows.UIElement.HitTestCore*
  parent: System.Windows.UIElement
  isExternal: false
  name: HitTestCore
  nameWithType: UIElement.HitTestCore
- uid: System.Windows.UIElement.InputBindings*
  parent: System.Windows.UIElement
  isExternal: false
  name: InputBindings
  nameWithType: UIElement.InputBindings
- uid: System.Windows.UIElement.InputHitTest*
  parent: System.Windows.UIElement
  isExternal: false
  name: InputHitTest
  nameWithType: UIElement.InputHitTest
- uid: System.Windows.UIElement.InvalidateArrange*
  parent: System.Windows.UIElement
  isExternal: false
  name: InvalidateArrange
  nameWithType: UIElement.InvalidateArrange
- uid: System.Windows.UIElement.InvalidateMeasure*
  parent: System.Windows.UIElement
  isExternal: false
  name: InvalidateMeasure
  nameWithType: UIElement.InvalidateMeasure
- uid: System.Windows.UIElement.InvalidateVisual*
  parent: System.Windows.UIElement
  isExternal: false
  name: InvalidateVisual
  nameWithType: UIElement.InvalidateVisual
- uid: System.Windows.UIElement.IsArrangeValid*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsArrangeValid
  nameWithType: UIElement.IsArrangeValid
- uid: System.Windows.UIElement.IsEnabled*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsEnabled
  nameWithType: UIElement.IsEnabled
- uid: System.Windows.UIElement.IsEnabledCore*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsEnabledCore
  nameWithType: UIElement.IsEnabledCore
- uid: System.Windows.UIElement.IsFocused*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsFocused
  nameWithType: UIElement.IsFocused
- uid: System.Windows.UIElement.IsHitTestVisible*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsHitTestVisible
  nameWithType: UIElement.IsHitTestVisible
- uid: System.Windows.UIElement.IsInputMethodEnabled*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsInputMethodEnabled
  nameWithType: UIElement.IsInputMethodEnabled
- uid: System.Windows.UIElement.IsKeyboardFocused*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocused
  nameWithType: UIElement.IsKeyboardFocused
- uid: System.Windows.UIElement.IsKeyboardFocusWithin*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsKeyboardFocusWithin
  nameWithType: UIElement.IsKeyboardFocusWithin
- uid: System.Windows.UIElement.IsManipulationEnabled*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsManipulationEnabled
  nameWithType: UIElement.IsManipulationEnabled
- uid: System.Windows.UIElement.IsMeasureValid*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMeasureValid
  nameWithType: UIElement.IsMeasureValid
- uid: System.Windows.UIElement.IsMouseCaptured*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCaptured
  nameWithType: UIElement.IsMouseCaptured
- uid: System.Windows.UIElement.IsMouseCaptureWithin*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseCaptureWithin
  nameWithType: UIElement.IsMouseCaptureWithin
- uid: System.Windows.UIElement.IsMouseDirectlyOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseDirectlyOver
  nameWithType: UIElement.IsMouseDirectlyOver
- uid: System.Windows.UIElement.IsMouseOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsMouseOver
  nameWithType: UIElement.IsMouseOver
- uid: System.Windows.UIElement.IsStylusCaptured*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCaptured
  nameWithType: UIElement.IsStylusCaptured
- uid: System.Windows.UIElement.IsStylusCaptureWithin*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusCaptureWithin
  nameWithType: UIElement.IsStylusCaptureWithin
- uid: System.Windows.UIElement.IsStylusDirectlyOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusDirectlyOver
  nameWithType: UIElement.IsStylusDirectlyOver
- uid: System.Windows.UIElement.IsStylusOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsStylusOver
  nameWithType: UIElement.IsStylusOver
- uid: System.Windows.UIElement.IsVisible*
  parent: System.Windows.UIElement
  isExternal: false
  name: IsVisible
  nameWithType: UIElement.IsVisible
- uid: System.Windows.UIElement.Measure*
  parent: System.Windows.UIElement
  isExternal: false
  name: Measure
  nameWithType: UIElement.Measure
- uid: System.Windows.UIElement.MeasureCore*
  parent: System.Windows.UIElement
  isExternal: false
  name: MeasureCore
  nameWithType: UIElement.MeasureCore
- uid: System.Windows.UIElement.MoveFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: MoveFocus
  nameWithType: UIElement.MoveFocus
- uid: System.Windows.UIElement.OnAccessKey*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnAccessKey
  nameWithType: UIElement.OnAccessKey
- uid: System.Windows.UIElement.OnChildDesiredSizeChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnChildDesiredSizeChanged
  nameWithType: UIElement.OnChildDesiredSizeChanged
- uid: System.Windows.UIElement.OnCreateAutomationPeer*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnCreateAutomationPeer
  nameWithType: UIElement.OnCreateAutomationPeer
- uid: System.Windows.UIElement.OnDragEnter*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDragEnter
  nameWithType: UIElement.OnDragEnter
- uid: System.Windows.UIElement.OnDragLeave*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDragLeave
  nameWithType: UIElement.OnDragLeave
- uid: System.Windows.UIElement.OnDragOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDragOver
  nameWithType: UIElement.OnDragOver
- uid: System.Windows.UIElement.OnDrop*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnDrop
  nameWithType: UIElement.OnDrop
- uid: System.Windows.UIElement.OnGiveFeedback*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGiveFeedback
  nameWithType: UIElement.OnGiveFeedback
- uid: System.Windows.UIElement.OnGotFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotFocus
  nameWithType: UIElement.OnGotFocus
- uid: System.Windows.UIElement.OnGotKeyboardFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotKeyboardFocus
  nameWithType: UIElement.OnGotKeyboardFocus
- uid: System.Windows.UIElement.OnGotMouseCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotMouseCapture
  nameWithType: UIElement.OnGotMouseCapture
- uid: System.Windows.UIElement.OnGotStylusCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotStylusCapture
  nameWithType: UIElement.OnGotStylusCapture
- uid: System.Windows.UIElement.OnGotTouchCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnGotTouchCapture
  nameWithType: UIElement.OnGotTouchCapture
- uid: System.Windows.UIElement.OnIsKeyboardFocusedChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsKeyboardFocusedChanged
  nameWithType: UIElement.OnIsKeyboardFocusedChanged
- uid: System.Windows.UIElement.OnIsKeyboardFocusWithinChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsKeyboardFocusWithinChanged
  nameWithType: UIElement.OnIsKeyboardFocusWithinChanged
- uid: System.Windows.UIElement.OnIsMouseCapturedChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsMouseCapturedChanged
  nameWithType: UIElement.OnIsMouseCapturedChanged
- uid: System.Windows.UIElement.OnIsMouseCaptureWithinChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsMouseCaptureWithinChanged
  nameWithType: UIElement.OnIsMouseCaptureWithinChanged
- uid: System.Windows.UIElement.OnIsMouseDirectlyOverChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsMouseDirectlyOverChanged
  nameWithType: UIElement.OnIsMouseDirectlyOverChanged
- uid: System.Windows.UIElement.OnIsStylusCapturedChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsStylusCapturedChanged
  nameWithType: UIElement.OnIsStylusCapturedChanged
- uid: System.Windows.UIElement.OnIsStylusCaptureWithinChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsStylusCaptureWithinChanged
  nameWithType: UIElement.OnIsStylusCaptureWithinChanged
- uid: System.Windows.UIElement.OnIsStylusDirectlyOverChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnIsStylusDirectlyOverChanged
  nameWithType: UIElement.OnIsStylusDirectlyOverChanged
- uid: System.Windows.UIElement.OnKeyDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnKeyDown
  nameWithType: UIElement.OnKeyDown
- uid: System.Windows.UIElement.OnKeyUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnKeyUp
  nameWithType: UIElement.OnKeyUp
- uid: System.Windows.UIElement.OnLostFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostFocus
  nameWithType: UIElement.OnLostFocus
- uid: System.Windows.UIElement.OnLostKeyboardFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostKeyboardFocus
  nameWithType: UIElement.OnLostKeyboardFocus
- uid: System.Windows.UIElement.OnLostMouseCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostMouseCapture
  nameWithType: UIElement.OnLostMouseCapture
- uid: System.Windows.UIElement.OnLostStylusCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostStylusCapture
  nameWithType: UIElement.OnLostStylusCapture
- uid: System.Windows.UIElement.OnLostTouchCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnLostTouchCapture
  nameWithType: UIElement.OnLostTouchCapture
- uid: System.Windows.UIElement.OnManipulationBoundaryFeedback*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationBoundaryFeedback
  nameWithType: UIElement.OnManipulationBoundaryFeedback
- uid: System.Windows.UIElement.OnManipulationCompleted*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationCompleted
  nameWithType: UIElement.OnManipulationCompleted
- uid: System.Windows.UIElement.OnManipulationDelta*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationDelta
  nameWithType: UIElement.OnManipulationDelta
- uid: System.Windows.UIElement.OnManipulationInertiaStarting*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationInertiaStarting
  nameWithType: UIElement.OnManipulationInertiaStarting
- uid: System.Windows.UIElement.OnManipulationStarted*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationStarted
  nameWithType: UIElement.OnManipulationStarted
- uid: System.Windows.UIElement.OnManipulationStarting*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnManipulationStarting
  nameWithType: UIElement.OnManipulationStarting
- uid: System.Windows.UIElement.OnMouseDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseDown
  nameWithType: UIElement.OnMouseDown
- uid: System.Windows.UIElement.OnMouseEnter*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseEnter
  nameWithType: UIElement.OnMouseEnter
- uid: System.Windows.UIElement.OnMouseLeave*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseLeave
  nameWithType: UIElement.OnMouseLeave
- uid: System.Windows.UIElement.OnMouseLeftButtonDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseLeftButtonDown
  nameWithType: UIElement.OnMouseLeftButtonDown
- uid: System.Windows.UIElement.OnMouseLeftButtonUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseLeftButtonUp
  nameWithType: UIElement.OnMouseLeftButtonUp
- uid: System.Windows.UIElement.OnMouseMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseMove
  nameWithType: UIElement.OnMouseMove
- uid: System.Windows.UIElement.OnMouseRightButtonDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseRightButtonDown
  nameWithType: UIElement.OnMouseRightButtonDown
- uid: System.Windows.UIElement.OnMouseRightButtonUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseRightButtonUp
  nameWithType: UIElement.OnMouseRightButtonUp
- uid: System.Windows.UIElement.OnMouseUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseUp
  nameWithType: UIElement.OnMouseUp
- uid: System.Windows.UIElement.OnMouseWheel*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnMouseWheel
  nameWithType: UIElement.OnMouseWheel
- uid: System.Windows.UIElement.OnPreviewDragEnter*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDragEnter
  nameWithType: UIElement.OnPreviewDragEnter
- uid: System.Windows.UIElement.OnPreviewDragLeave*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDragLeave
  nameWithType: UIElement.OnPreviewDragLeave
- uid: System.Windows.UIElement.OnPreviewDragOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDragOver
  nameWithType: UIElement.OnPreviewDragOver
- uid: System.Windows.UIElement.OnPreviewDrop*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewDrop
  nameWithType: UIElement.OnPreviewDrop
- uid: System.Windows.UIElement.OnPreviewGiveFeedback*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewGiveFeedback
  nameWithType: UIElement.OnPreviewGiveFeedback
- uid: System.Windows.UIElement.OnPreviewGotKeyboardFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewGotKeyboardFocus
  nameWithType: UIElement.OnPreviewGotKeyboardFocus
- uid: System.Windows.UIElement.OnPreviewKeyDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewKeyDown
  nameWithType: UIElement.OnPreviewKeyDown
- uid: System.Windows.UIElement.OnPreviewKeyUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewKeyUp
  nameWithType: UIElement.OnPreviewKeyUp
- uid: System.Windows.UIElement.OnPreviewLostKeyboardFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewLostKeyboardFocus
  nameWithType: UIElement.OnPreviewLostKeyboardFocus
- uid: System.Windows.UIElement.OnPreviewMouseDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseDown
  nameWithType: UIElement.OnPreviewMouseDown
- uid: System.Windows.UIElement.OnPreviewMouseLeftButtonDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseLeftButtonDown
  nameWithType: UIElement.OnPreviewMouseLeftButtonDown
- uid: System.Windows.UIElement.OnPreviewMouseLeftButtonUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseLeftButtonUp
  nameWithType: UIElement.OnPreviewMouseLeftButtonUp
- uid: System.Windows.UIElement.OnPreviewMouseMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseMove
  nameWithType: UIElement.OnPreviewMouseMove
- uid: System.Windows.UIElement.OnPreviewMouseRightButtonDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseRightButtonDown
  nameWithType: UIElement.OnPreviewMouseRightButtonDown
- uid: System.Windows.UIElement.OnPreviewMouseRightButtonUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseRightButtonUp
  nameWithType: UIElement.OnPreviewMouseRightButtonUp
- uid: System.Windows.UIElement.OnPreviewMouseUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseUp
  nameWithType: UIElement.OnPreviewMouseUp
- uid: System.Windows.UIElement.OnPreviewMouseWheel*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewMouseWheel
  nameWithType: UIElement.OnPreviewMouseWheel
- uid: System.Windows.UIElement.OnPreviewQueryContinueDrag*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewQueryContinueDrag
  nameWithType: UIElement.OnPreviewQueryContinueDrag
- uid: System.Windows.UIElement.OnPreviewStylusButtonDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusButtonDown
  nameWithType: UIElement.OnPreviewStylusButtonDown
- uid: System.Windows.UIElement.OnPreviewStylusButtonUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusButtonUp
  nameWithType: UIElement.OnPreviewStylusButtonUp
- uid: System.Windows.UIElement.OnPreviewStylusDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusDown
  nameWithType: UIElement.OnPreviewStylusDown
- uid: System.Windows.UIElement.OnPreviewStylusInAirMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusInAirMove
  nameWithType: UIElement.OnPreviewStylusInAirMove
- uid: System.Windows.UIElement.OnPreviewStylusInRange*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusInRange
  nameWithType: UIElement.OnPreviewStylusInRange
- uid: System.Windows.UIElement.OnPreviewStylusMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusMove
  nameWithType: UIElement.OnPreviewStylusMove
- uid: System.Windows.UIElement.OnPreviewStylusOutOfRange*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusOutOfRange
  nameWithType: UIElement.OnPreviewStylusOutOfRange
- uid: System.Windows.UIElement.OnPreviewStylusSystemGesture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusSystemGesture
  nameWithType: UIElement.OnPreviewStylusSystemGesture
- uid: System.Windows.UIElement.OnPreviewStylusUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewStylusUp
  nameWithType: UIElement.OnPreviewStylusUp
- uid: System.Windows.UIElement.OnPreviewTextInput*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTextInput
  nameWithType: UIElement.OnPreviewTextInput
- uid: System.Windows.UIElement.OnPreviewTouchDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTouchDown
  nameWithType: UIElement.OnPreviewTouchDown
- uid: System.Windows.UIElement.OnPreviewTouchMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTouchMove
  nameWithType: UIElement.OnPreviewTouchMove
- uid: System.Windows.UIElement.OnPreviewTouchUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnPreviewTouchUp
  nameWithType: UIElement.OnPreviewTouchUp
- uid: System.Windows.UIElement.OnQueryContinueDrag*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnQueryContinueDrag
  nameWithType: UIElement.OnQueryContinueDrag
- uid: System.Windows.UIElement.OnQueryCursor*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnQueryCursor
  nameWithType: UIElement.OnQueryCursor
- uid: System.Windows.UIElement.OnRender*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnRender
  nameWithType: UIElement.OnRender
- uid: System.Windows.UIElement.OnRenderSizeChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnRenderSizeChanged
  nameWithType: UIElement.OnRenderSizeChanged
- uid: System.Windows.UIElement.OnStylusButtonDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusButtonDown
  nameWithType: UIElement.OnStylusButtonDown
- uid: System.Windows.UIElement.OnStylusButtonUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusButtonUp
  nameWithType: UIElement.OnStylusButtonUp
- uid: System.Windows.UIElement.OnStylusDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusDown
  nameWithType: UIElement.OnStylusDown
- uid: System.Windows.UIElement.OnStylusEnter*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusEnter
  nameWithType: UIElement.OnStylusEnter
- uid: System.Windows.UIElement.OnStylusInAirMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusInAirMove
  nameWithType: UIElement.OnStylusInAirMove
- uid: System.Windows.UIElement.OnStylusInRange*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusInRange
  nameWithType: UIElement.OnStylusInRange
- uid: System.Windows.UIElement.OnStylusLeave*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusLeave
  nameWithType: UIElement.OnStylusLeave
- uid: System.Windows.UIElement.OnStylusMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusMove
  nameWithType: UIElement.OnStylusMove
- uid: System.Windows.UIElement.OnStylusOutOfRange*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusOutOfRange
  nameWithType: UIElement.OnStylusOutOfRange
- uid: System.Windows.UIElement.OnStylusSystemGesture*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusSystemGesture
  nameWithType: UIElement.OnStylusSystemGesture
- uid: System.Windows.UIElement.OnStylusUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnStylusUp
  nameWithType: UIElement.OnStylusUp
- uid: System.Windows.UIElement.OnTextInput*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTextInput
  nameWithType: UIElement.OnTextInput
- uid: System.Windows.UIElement.OnTouchDown*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchDown
  nameWithType: UIElement.OnTouchDown
- uid: System.Windows.UIElement.OnTouchEnter*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchEnter
  nameWithType: UIElement.OnTouchEnter
- uid: System.Windows.UIElement.OnTouchLeave*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchLeave
  nameWithType: UIElement.OnTouchLeave
- uid: System.Windows.UIElement.OnTouchMove*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchMove
  nameWithType: UIElement.OnTouchMove
- uid: System.Windows.UIElement.OnTouchUp*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnTouchUp
  nameWithType: UIElement.OnTouchUp
- uid: System.Windows.UIElement.OnVisualParentChanged*
  parent: System.Windows.UIElement
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: UIElement.OnVisualParentChanged
- uid: System.Windows.UIElement.Opacity*
  parent: System.Windows.UIElement
  isExternal: false
  name: Opacity
  nameWithType: UIElement.Opacity
- uid: System.Windows.UIElement.OpacityMask*
  parent: System.Windows.UIElement
  isExternal: false
  name: OpacityMask
  nameWithType: UIElement.OpacityMask
- uid: System.Windows.UIElement.PersistId*
  parent: System.Windows.UIElement
  isExternal: false
  name: PersistId
  nameWithType: UIElement.PersistId
- uid: System.Windows.UIElement.PredictFocus*
  parent: System.Windows.UIElement
  isExternal: false
  name: PredictFocus
  nameWithType: UIElement.PredictFocus
- uid: System.Windows.UIElement.RaiseEvent*
  parent: System.Windows.UIElement
  isExternal: false
  name: RaiseEvent
  nameWithType: UIElement.RaiseEvent
- uid: System.Windows.UIElement.ReleaseAllTouchCaptures*
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseAllTouchCaptures
  nameWithType: UIElement.ReleaseAllTouchCaptures
- uid: System.Windows.UIElement.ReleaseMouseCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseMouseCapture
  nameWithType: UIElement.ReleaseMouseCapture
- uid: System.Windows.UIElement.ReleaseStylusCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseStylusCapture
  nameWithType: UIElement.ReleaseStylusCapture
- uid: System.Windows.UIElement.ReleaseTouchCapture*
  parent: System.Windows.UIElement
  isExternal: false
  name: ReleaseTouchCapture
  nameWithType: UIElement.ReleaseTouchCapture
- uid: System.Windows.UIElement.RemoveHandler*
  parent: System.Windows.UIElement
  isExternal: false
  name: RemoveHandler
  nameWithType: UIElement.RemoveHandler
- uid: System.Windows.UIElement.RenderSize*
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderSize
  nameWithType: UIElement.RenderSize
- uid: System.Windows.UIElement.RenderTransform*
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderTransform
  nameWithType: UIElement.RenderTransform
- uid: System.Windows.UIElement.RenderTransformOrigin*
  parent: System.Windows.UIElement
  isExternal: false
  name: RenderTransformOrigin
  nameWithType: UIElement.RenderTransformOrigin
- uid: System.Windows.UIElement.ShouldSerializeCommandBindings*
  parent: System.Windows.UIElement
  isExternal: false
  name: ShouldSerializeCommandBindings
  nameWithType: UIElement.ShouldSerializeCommandBindings
- uid: System.Windows.UIElement.ShouldSerializeInputBindings*
  parent: System.Windows.UIElement
  isExternal: false
  name: ShouldSerializeInputBindings
  nameWithType: UIElement.ShouldSerializeInputBindings
- uid: System.Windows.UIElement.SnapsToDevicePixels*
  parent: System.Windows.UIElement
  isExternal: false
  name: SnapsToDevicePixels
  nameWithType: UIElement.SnapsToDevicePixels
- uid: System.Windows.UIElement.StylusPlugIns*
  parent: System.Windows.UIElement
  isExternal: false
  name: StylusPlugIns
  nameWithType: UIElement.StylusPlugIns
- uid: System.Windows.UIElement.TouchesCaptured*
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesCaptured
  nameWithType: UIElement.TouchesCaptured
- uid: System.Windows.UIElement.TouchesCapturedWithin*
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesCapturedWithin
  nameWithType: UIElement.TouchesCapturedWithin
- uid: System.Windows.UIElement.TouchesDirectlyOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesDirectlyOver
  nameWithType: UIElement.TouchesDirectlyOver
- uid: System.Windows.UIElement.TouchesOver*
  parent: System.Windows.UIElement
  isExternal: false
  name: TouchesOver
  nameWithType: UIElement.TouchesOver
- uid: System.Windows.UIElement.TranslatePoint*
  parent: System.Windows.UIElement
  isExternal: false
  name: TranslatePoint
  nameWithType: UIElement.TranslatePoint
- uid: System.Windows.UIElement.Uid*
  parent: System.Windows.UIElement
  isExternal: false
  name: Uid
  nameWithType: UIElement.Uid
- uid: System.Windows.UIElement.UpdateLayout*
  parent: System.Windows.UIElement
  isExternal: false
  name: UpdateLayout
  nameWithType: UIElement.UpdateLayout
- uid: System.Windows.UIElement.Visibility*
  parent: System.Windows.UIElement
  isExternal: false
  name: Visibility
  nameWithType: UIElement.Visibility
