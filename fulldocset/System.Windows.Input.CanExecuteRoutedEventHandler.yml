### YamlMime:ManagedReference
items:
- uid: System.Windows.Input.CanExecuteRoutedEventHandler
  id: CanExecuteRoutedEventHandler
  langs:
  - csharp
  name: CanExecuteRoutedEventHandler
  nameWithType: CanExecuteRoutedEventHandler
  fullName: System.Windows.Input.CanExecuteRoutedEventHandler
  type: Delegate
  summary: "処理するメソッドを表す、 <xref href=&quot;System.Windows.Input.CommandBinding.CanExecute&quot;> </xref>イベント。"
  remarks: "CanExecuteRoutedEventHandler では、イベント ソースに関連付けられたコマンドがコマンド ターゲットで実行することを決定します。 コマンドにコマンド ソース、ターゲットを指定したかどうかに、使用するターゲットの情報を取得できます`sender`です。 場合、<xref:System.Windows.Input.ICommandSource.CommandTarget%2A>がキーボード フォーカスを持つ要素が、ターゲットであるし、を取得することもできます、設定されていない`sender`</xref:System.Windows.Input.ICommandSource.CommandTarget%2A>。  コマンドが、ターゲットで実行できることが特定された場合、<xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=fullName>プロパティに設定する必要があります`true`、それ以外に設定`false`</xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=fullName>。       コマンド、ソースとターゲットを特定のイベント データに依存する必要はありません。 これは、コマンドの構造は、イベント ルートの連続する潜在的な目標に同じコマンドを実行するコマンド ルーティングに広範囲に依存している場合に実行するより困難ですが、既知コマンド呼び出しのハンドラーの使用量を制限できます。"
  example:
  - "The following example shows a CanExecuteRoutedEventHandler that sets <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> to `true`.  \n  \n [!code-cs[commandwithhandler#CommandHandlerCanExecuteHandler](~/add/codesnippet/csharp/commandWithHandler/Window1.xaml.cs#commandhandlercanexecutehandler)]\n [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/add/codesnippet/visualbasic/commandWithHandler/Window1.xaml.vb#commandhandlercanexecutehandler)]"
  syntax:
    content: public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);
  inheritance:
  - System.Delegate
  platform:
  - net462
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
