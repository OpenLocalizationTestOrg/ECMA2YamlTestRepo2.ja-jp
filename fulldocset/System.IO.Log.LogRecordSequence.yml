### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "格納されているレコードのシーケンスを表す、 <xref href=&quot;System.IO.Log.LogStore&quot;></xref>です。"
  remarks: "LogRecordSequence クラスは、Common Log File System (CLFS) ログ上でレコード シーケンス インターフェイスの実装を提供します。 標準機能に加えて、レコード指向は、ログがいっぱいの条件を回避し、同じ物理ファイル上のクライアントを多重化のポリシー モデルを提供します。 連携して、<xref:System.IO.Log.LogStore>クラスを直接操作および管理する CLFS ログ ファイル用のインターフェイスを提供します</xref:System.IO.Log.LogStore>。 間のリレーションシップ、<xref:System.IO.Log.LogStore>クラスおよび LogRecordSequence クラスは、ディスク ファイルの間のリレーションシップに似ています、<xref:System.IO.FileStream>オブジェクト</xref:System.IO.FileStream></xref:System.IO.Log.LogStore>。 ディスク ファイルは、具体的な記憶域を提供し、長さや最終アクセス日時; などの属性を持つ<xref:System.IO.FileStream>オブジェクトは、読み取りし、書き込みを突き止めに使用できるファイルのビューを提供</xref:System.IO.FileStream>中には 同様に、<xref:System.IO.Log.LogStore>クラスには、ポリシーやディスク エクステントのコレクションなどの属性および LogRecordSequence クラスには、データ読み取りおよび書き込みのレコード指向の機構が用意されています</xref:System.IO.Log.LogStore>。"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>指定されたログ ストアを持つクラス。"
  remarks: "バッファー サイズでは、追加または読み取り可能なレコードの最大サイズを決定します。 このコンス トラクターでは、64 の既定値が設定されます。 目的のバッファー数は 10 に設定されます。"
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>このレコード シーケンスが使用する必要があります。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>正しくありません。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>ログ ストアとアクセス モードに指定されたパスを持つクラス。"
  remarks: "このコンス トラクターを新しい初期化<xref:System.IO.Log.LogRecordSequence>上の新しい<xref:System.IO.Log.LogStore>オブジェクトを指定したパスおよびモードで開きます</xref:System.IO.Log.LogStore></xref:System.IO.Log.LogRecordSequence>。 ストアに読み取り/書き込みアクセスが指定され、読み取りアクセスを共有ストアが開きます。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "開くログ ストアの基本ファイルの相対パスまたは絶対パス。"
    - id: mode
      type: System.IO.FileMode
      description: "1 つ、 <xref href=&quot;System.IO.FileMode&quot;> </xref>開くか、ストアを作成する方法を決定する値。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;) です。       - または -<code>path</code>空白のみが含まれています。       - または - <code>path</code>&1; つまたは複数の無効な文字が含まれています。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>無効な値が含まれています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ファイルが見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ログ ストアを開くときに、I/O エラーが発生します。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "この操作がサポートされていません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>必要な Common Log File System (CLFS) コンポーネントがインストールされていないために使用できません。 プラットフォームを使用する場合は、CLFS コンポーネントをインストールまたは使用して、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>クラスです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>クラス、指定されたログ ストア、各レコードのバッファー サイズと数をバッファーします。"
  remarks: "値を指定する場合は、このコンス トラクターを使用して`bufferSize`と`bufferCount`64 用の既定値を使用したくないと`bufferSize`と 10 を`bufferCount`です。"
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>このレコード シーケンスが使用する必要があります。"
    - id: bufferSize
      type: System.Int32
      description: "バイト単位のバッファー サイズ。 バッファー サイズでは、追加または読み取り可能なレコードの最大サイズを決定します。"
    - id: bufferCount
      type: System.Int32
      description: "必要なバッファー数。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>負の値またはゼロです。       - または -<code>bufferCount</code>が負の値またはゼロです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>ログ ストアとアクセスおよび共有モードに指定されたパスを持つクラス。"
  remarks: "このコンス トラクターを新しい初期化<xref:System.IO.Log.LogRecordSequence>上の新しい<xref:System.IO.Log.LogStore>し、指定したパス、モード、およびアクセスと共に開きますオブジェクト</xref:System.IO.Log.LogStore></xref:System.IO.Log.LogRecordSequence>。 このストアが開き読み取りアクセスを共有します。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "開くログ ストアの基本ファイルの相対パスまたは絶対パス。"
    - id: mode
      type: System.IO.FileMode
      description: "1 つ、 <xref href=&quot;System.IO.FileMode&quot;> </xref>開くか、ストアを作成する方法を決定する値。"
    - id: access
      type: System.IO.FileAccess
      description: "1 つ、 <xref href=&quot;System.IO.FileAccess&quot;> </xref>によって、ファイルにアクセスできる方法を決定する値、 <xref href=&quot;System.IO.Log.LogStore&quot;></xref>です。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;) です。       - または -<code>path</code>空白のみが含まれています。       - または - <code>path</code>&1; つまたは複数の無効な文字が含まれています。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>無効な値が含まれています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ファイルが見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ログ ストアを開くときに、I/O エラーが発生します。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "この操作がサポートされていません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>必要な Common Log File System (CLFS) コンポーネントがインストールされていないために使用できません。 プラットフォームを使用する場合は、CLFS コンポーネントをインストールまたは使用して、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>クラスです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>ログ ストアとアクセス モードに指定されたパスを持つクラス。"
  remarks: "このコンス トラクターを新しい初期化<xref:System.IO.Log.LogRecordSequence>上の新しい<xref:System.IO.Log.LogStore>し、指定したパス、モード、およびアクセスと共に開きますオブジェクト</xref:System.IO.Log.LogStore></xref:System.IO.Log.LogRecordSequence>。 このストアが開き、指定したアクセスを共有します。"
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "開くログ ストアの基本ファイルの相対パスまたは絶対パス。"
    - id: mode
      type: System.IO.FileMode
      description: "1 つ、 <xref href=&quot;System.IO.FileMode&quot;> </xref>開くか、ストアを作成する方法を決定する値。"
    - id: access
      type: System.IO.FileAccess
      description: "1 つ、 <xref href=&quot;System.IO.FileAccess&quot;> </xref>によって、ファイルにアクセスできる方法を決定する値、 <xref href=&quot;System.IO.Log.LogStore&quot;></xref>です。"
    - id: share
      type: System.IO.FileShare
      description: "1 つ、 <xref href=&quot;System.IO.FileShare&quot;> </xref>プロセス間でログ ストアを共有する方法を決定する値。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;) です。       - または -<code>path</code>空白のみが含まれています。       - または - <code>path</code>&1; つまたは複数の無効な文字が含まれています。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>無効な値が含まれています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ファイルが見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ログ ストアを開くときに、I/O エラーが発生します。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "この操作がサポートされていません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>必要な Common Log File System (CLFS) コンポーネントがインストールされていないために使用できません。 プラットフォームを使用する場合は、CLFS コンポーネントをインストールまたは使用して、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>クラスです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>ログ ストア、ファイルのアクセス許可、アクセスおよび共有モード、およびバッファー サイズ、およびレコードの数を指定されたパスを持つクラス。"
  remarks: "このコンス トラクターを新しい初期化<xref:System.IO.Log.LogRecordSequence>上の新しい<xref:System.IO.Log.LogStore>し、指定したパス、モード、およびアクセスと共に開きますオブジェクト</xref:System.IO.Log.LogStore></xref:System.IO.Log.LogRecordSequence>。 このストアが開き、指定したアクセスを共有します。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "開くログ ストアの基本ファイルの相対パスまたは絶対パス。"
    - id: mode
      type: System.IO.FileMode
      description: "1 つ、 <xref href=&quot;System.IO.FileMode&quot;> </xref>開くか、ストアを作成する方法を決定する値。"
    - id: access
      type: System.IO.FileAccess
      description: "1 つ、 <xref href=&quot;System.IO.FileAccess&quot;> </xref>によって、ファイルにアクセスできる方法を決定する値、 <xref href=&quot;System.IO.Log.LogStore&quot;></xref>です。"
    - id: share
      type: System.IO.FileShare
      description: "1 つ、 <xref href=&quot;System.IO.FileShare&quot;> </xref>プロセス間でログ ストアを共有する方法を決定する値。"
    - id: bufferSize
      type: System.Int32
      description: "バイト単位のバッファー サイズ。 バッファー サイズでは、追加または読み取り可能なレコードの最大サイズを決定します。"
    - id: bufferCount
      type: System.Int32
      description: "必要なバッファー数。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>空の文字列 (&quot;&quot;) です。       - または -<code>path</code>空白のみが含まれています。       - または - <code>path</code>&1; つまたは複数の無効な文字が含まれています。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>無効な値が含まれています。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "ファイルが見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ログ ストアを開くときに、I/O エラーが発生します。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "この操作がサポートされていません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>必要な Common Log File System (CLFS) コンポーネントがインストールされていないために使用できません。 プラットフォームを使用する場合は、CLFS コンポーネントをインストールまたは使用して、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>クラスです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>クラスです。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "開くログ ストアの基本ファイルの相対パスまたは絶対パス。"
    - id: mode
      type: System.IO.FileMode
      description: "有効な<xref href=&quot;System.IO.FileMode&quot;></xref>開くか、ストアを作成する方法を決定する値。"
    - id: access
      type: System.IO.FileAccess
      description: "有効な<xref href=&quot;System.IO.FileAccess&quot;></xref>ログ ストアへのアクセス方法を決定する値。"
    - id: share
      type: System.IO.FileShare
      description: "有効な<xref href=&quot;System.IO.FileShare&quot;></xref>プロセス間でログ ストアを共有する方法を決定する値。"
    - id: bufferSize
      type: System.Int32
      description: "バイト単位のバッファー サイズ。 バッファー サイズでは、追加または読み取り可能なレコードの最大サイズを決定します。"
    - id: bufferCount
      type: System.Int32
      description: "必要なバッファー数。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "有効な<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>ストアを作成する必要がある場合、新しく作成されたストアに設定するセキュリティを指定する値。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "によって指定されたファイル<code> path </code>が無効です。       または、指定されたログ ストア ファイル名が無効です。       - または - <code> mode </code>の値を持つ<xref href=&quot;System.IO.FileMode&quot;> </xref>、書き込みアクセスがなければ使用できません。       - または - <code> mode </code>の値を持つ<xref href=&quot;System.IO.FileMode&quot;> </xref>、書き込みアクセスがなければ使用できません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "1 つ以上の引数が範囲外です。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "によって指定されたファイル<code> path </code>が見つかりません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - で指定されたファイル<code> path </code>別のプロセスによって使用されているために、アクセスできません。       - または - で指定されたファイル<code> path </code>ファイルまたはディレクトリが既に存在するので作成できません。       - または - ログ ハンドルをスレッド プールにバインドできませんでした。       または、指定されたログ ファイル形式またはバージョンが無効です。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "この操作がサポートされていません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>必要な Common Log File System (CLFS) コンポーネントがインストールされていないために使用できません。 プラットフォームを使用する場合は、CLFS コンポーネントをインストールまたは使用して、 <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>クラスです。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログの基本シーケンス番号を前方移動します。 このメソッドは継承できません。"
  remarks: "このメソッドを使用して多くの場合、<xref:System.IO.Log.LogRecordSequence.TailPinned>レコード内の領域を解放するイベントです</xref:System.IO.Log.LogRecordSequence.TailPinned>。 <xref:System.IO.Log.LogRecordSequence.TailPinned>イベントは、シーケンス (つまり、基本シーケンス番号) の末尾を前方の空き領域に移動する必要があることを示します</xref:System.IO.Log.LogRecordSequence.TailPinned>。 領域の解放を行うを書き込むかを使用して領域を再起動して、<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>メソッドか、ログの切り捨てによって指定された&1; つに、ログの基本シーケンス番号を進める AdvanceBaseSequenceNumber メソッドを使用して、`newBaseSequenceNumber`パラメーター</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 。 使用例」のサンプル コードでは、2 番目の方法を示します。       このメソッドの呼び出しが同じである新しい基本シーケンス番号を使用して、設定した場合とに注意してください、<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>メソッドをログに再開レコードが書き込まれませんする点を除いて</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい基本型を指定<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>ログ。 現在の基本シーケンス番号と、ログの最後のシーケンス番号の範囲で包括的にこのなければなりません。"
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>このシーケンスに対して無効です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。       - または - <code> newBaseSequenceNumber </code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定されたログにエクステントがありません。 レコード シーケンスが使用される前に、1 つ以上のエクステントを作成する必要があります。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを書き込みます、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを追加、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを追加、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>、以前のシーケンスに予約された領域を使用します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログ レコードを追加、 <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>、以前のシーケンスに予約された領域を使用します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.IRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.IRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "現在の最初の有効なレコードのシーケンス番号を取得<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。"
  remarks: "有効なシーケンス番号より大きいまたは basesequencenumber と同じ値に等しいと<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>。</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>よりも小さい       このプロパティの値を呼び出すことにより変更することができます、<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>メソッドまたは<xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>メソッド</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A></xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>。"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "有効なレコードに対応する下限のシーケンス番号、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。"
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後、プロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期開始操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期開始操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期開始操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期開始操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       追加されたレコードは以前に予約されたで指定された予約を使用して領域の消費量、`reservations`パラメーター。 追加に成功した場合、最小予約領域が消費データを保存して、その予約領域をコレクションから削除されます。       通常、このメソッドは、レコードが書き込まれる前に完了します。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>このレコードを使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す非同期の追加は、保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "以前のシーケンスに予約された領域を使用して、非同期のフラッシュ操作を開始します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>を現在のメソッドによって返される、 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>、フラッシュが完了し、リソースが適切に解放されるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndFlush%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期のフラッシュ中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndFlush%2A>。       このメソッドを呼び出すことにより、すべてのレコードを追加されていること、<xref:System.IO.Log.LogRecordSequence>は永続的に書き込まれます</xref:System.IO.Log.LogRecordSequence>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など非同期フラッシュ要求、中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>。"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "書き込む必要のある最新レコードのシーケンス番号。 この場合<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>が正しくない、すべてのレコードを書き込む必要があります。"
    - id: callback
      type: System.AsyncCallback
      description: "フラッシュが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期フラッシュ要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期のフラッシュ操作をまだ</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>このシーケンスに対して無効です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定されたログにエクステントがありません。 レコード シーケンスを使用する前に、1 つ以上のエクステントを作成する必要があります。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の予約を開始し、操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す、この非同期操作を保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の予約を開始し、操作を追加します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>追加操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期追加中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    - id: callback
      type: System.AsyncCallback
      description: "追加の完全なときに呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期を区別するユーザー指定のオブジェクトは、他の要求からの要求を追加します。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>を表す、この非同期操作を保留になっている可能性があります</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、十分な空き領域を新しいレコードを格納する、または予約を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "以前のシーケンスに予約された領域を使用して、非同期の再開領域書き込み操作を開始します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>再開領域の書き込み操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期の再開領域の書き込み操作中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       操作が正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       場合、<xref:System.IO.Log.ReservationCollection>を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します</xref:System.IO.Log.ReservationCollection>。 メソッドが成功すると、消費され、最も小さな予約データを格納できること、および予約がコレクションから削除されます。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>。"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメント。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "再開領域の書き込みが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期の再開領域の書き込み要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期の再開領域の書き込み操作、まだでした</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>このシーケンスに対して無効です。       または、指定されたログ列挙開始シーケンス番号が正しくありません。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservation</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "1 つまたは複数のパラメーターが<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。       - または - <code> newBaseSeqNum </code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "以前のシーケンスに予約された領域を使用して、非同期の再開領域書き込み操作を開始します。 このメソッドは継承できません。"
  remarks: "渡す必要があります、<xref:System.IAsyncResult>にこのメソッドによって返される、<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>再開領域の書き込み操作が完了し、リソースを適切に解放できるようにするメソッド</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A></xref:System.IAsyncResult>。 まで例外はスローされません非同期の再開領域の書き込み操作中にエラーが発生した場合、<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出された、<xref:System.IAsyncResult>このメソッドによって返される</xref:System.IAsyncResult></xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>。       含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       操作が正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       場合、<xref:System.IO.Log.ReservationCollection>を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します</xref:System.IO.Log.ReservationCollection>。 メソッドが成功すると、消費され、最も小さな予約データを格納できること、および予約がコレクションから削除されます。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>。"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    - id: callback
      type: System.AsyncCallback
      description: "再開領域の書き込みが完了すると呼び出されるオプションの非同期コールバック。"
    - id: state
      type: System.Object
      description: "この特定の非同期の再開領域の書き込み要求を他の要求と区別するユーザー指定のオブジェクト。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>保留になっていることを表す非同期の再開領域の書き込み操作、まだでした</xref:System.IAsyncResult>。"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>このシーケンスに対して無効です。       または、指定されたログ列挙開始シーケンス番号が正しくありません。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservationCollection</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "1 つまたは複数のパラメーターが<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。       - または - <code> newBaseSeqNum </code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "新たに作成<xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>です。 このメソッドは継承できません。"
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新しく作成された<xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>です。"
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "コンポーネントによって使用されているリソースを解放します。"
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加操作を非同期の終了。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndAppend が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>メソッド</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期のフラッシュ操作を終了します。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndFlush が呼び出されたときに、I/O 要求時にディスク障害など非同期フラッシュ要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "予約および追加操作を非同期の終了。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndReserveAndAppend が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>メソッド</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "非同期の再開領域の書き込み操作を終了します。 このメソッドは継承できません。"
  remarks: "このメソッドは、I/O 操作が完了するまでブロックします。 EndWriteRestartArea が呼び出されたときに、I/O 要求時にディスク障害など、非同期書き込み要求中に発生したエラーが表示されます。       このメソッドは&1; 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>によって返される、<xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>メソッド</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A></xref:System.IAsyncResult>。"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未処理の非同期 I/O リクエストへの参照。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "書き込まれたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>正しくありません。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>この非同期操作に対して既に呼び出されています。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "追加したすべてのレコードが書き込まれていることを確認します。 このメソッドは継承できません。"
  remarks: "このメソッドを呼び出すことにより、すべてのレコードを追加されていること、<xref:System.IO.Log.LogRecordSequence>永続的に書き込まれます</xref:System.IO.Log.LogRecordSequence>。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "データのフラッシュ中に I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "この操作がサポートされていません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定されたログにエクステントがありません。 レコード シーケンスを使用する前に、1 つ以上のエクステントを作成する必要があります。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "指定されたシーケンス番号を持つレコードを含むすべての追加されたレコードが永続的に書き込まれていることを確認します。 このメソッドは継承できません。"
  remarks: "このメソッドにより、すべてのレコード シーケンス番号を呼び出すと、指定されたシーケンス番号は、永続的に書き込まれています。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "書き込む必要のある最新レコードのシーケンス番号。 この場合<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>が正しくない、すべてのレコードを書き込む必要があります。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後に書き込まれたレコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>このシーケンスに対して無効です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定されたログにエクステントがありません。 レコード シーケンスを使用する前に、1 つ以上のエクステントを作成する必要があります。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "シーケンス番号を取得するが追加された最後のレコードより大きい"
  remarks: "このプロパティには、大きくすることが保証されるシーケンス番号が含まれています。 最後のシーケンス番号よりも、レコードを追加します。 有効なシーケンス番号がより大きいか等しい<xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>LastSequenceNumber よりも小さいです</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>。 その他のすべてのシーケンス番号が無効です。"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加された最後のレコードより大きい番号シーケンス番号します。"
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後、プロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得、 <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>このレコード シーケンスのデータを格納しています。 このメソッドは継承できません。"
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>このレコード シーケンスのデータを格納しています。"
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "このレコード シーケンスに追加できるレコードの最大サイズを取得します。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "このレコード シーケンスに追加できるレコードの最大サイズ。"
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "シーケンス内のレコードの列挙可能なコレクションを返します。 このメソッドは継承できません。"
  remarks: "このメソッドは、シーケンス内のレコードの列挙可能なコレクションを返します。 列挙されたレコードの順序の値によって異なります、`logRecordEnum`パラメーター。"
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "読み込みを開始する最初のレコードのシーケンス番号。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "有効な<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>内からレコードを読み取る方法 (つまり、前方または後方) を指定する値、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "シーケンス内のレコードの列挙可能なコレクション。"
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>このシーケンスに対して無効です。       - または -<code>logRecordEnum</code>が無効です。       または、指定した要素がコレクション内に見つかりません。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。       - またはログ レコードが読み取りに使用されるバッファーのサイズを超える書き込みに使用されるバッファー サイズ。       または、レコード シーケンスが破損しています。       または、指定されたログ ファイル形式またはバージョンが無効です。       または、レコードは、レコード シーケンスの互換性のないバージョンで書き込まれました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "列挙体が開始されていないために、操作が無効です。 呼び出し<xref:System.Collections.IEnumerator.MoveNext*>行う必要があります</xref:System.Collections.IEnumerator.MoveNext*>。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "シーケンス内の再開領域の列挙可能なコレクションを返します。 このメソッドは継承できません。"
  remarks: "再開領域が下限のシーケンス番号のシーケンス番号の最大値からは、反転シーケンス番号の順に列挙されます。 最後のシーケンス番号間のシーケンス番号を持つ再開領域のみと、基本シーケンス番号が列挙されます。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "シーケンス内の再開領域の列挙可能なコレクション。"
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。       - またはログ レコードが読み取りに使用されるバッファーのサイズを超える書き込みに使用されるバッファー サイズ。       または、レコード シーケンスが破損しています。       または、指定されたログ ファイル形式またはバージョンが無効です。       または、レコードは、レコード シーケンスの互換性のないバージョンで書き込まれました。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "列挙体が開始されていないために、操作が無効です。 呼び出し<xref:System.Collections.IEnumerator.MoveNext*>行う必要があります</xref:System.Collections.IEnumerator.MoveNext*>。       -列挙体が終了したか。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動的に単一の予約を行い、シーケンスにレコードを追加します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>で予約を作成するコレクションを格納します。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>または<code>previousRecord</code>このシーケンスに対して無効です。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservations</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動的に単一の予約を行い、シーケンスにレコードを追加します。 このメソッドは継承できません。"
  remarks: "含まれるデータ、`data`パラメーターは、レコードとして追加するための単一のバイト配列に連結されます。 ただし、データを分割して配列セグメントに戻す、レコードが読み取られると準備は実施されません。       指定の予約情報が追加されたレコードと分割不可能な操作でコレクションを提供された予約するには、追加の操作です。 追加が失敗した場合、領域は予約されていません。       通常、このメソッドは、レコードが書き込まれた前に完了場合があります。 指定するか、レコードが書き込まれたことを確認してくださいに、<xref:System.IO.Log.RecordAppendOptions>フラグを使用して、`recordAppendOptions`パラメーター、または呼び出し、<xref:System.IO.Log.LogRecordSequence.Flush%2A>メソッド</xref:System.IO.Log.LogRecordSequence.Flush%2A></xref:System.IO.Log.RecordAppendOptions>。"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "ユーザー指定の順序で次のレコードのシーケンス番号。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "以前の順序で次のレコードのシーケンス番号。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有効な値<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>データの書き込み方法を指定します。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "予約を作成する予約コレクション。"
    - id: reservations
      type: System.Int64[]
      description: "(バイト単位) を作成する予約します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "追加されたログ レコードのシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "レコードの追加中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、十分な空き領域を新しいレコードを格納する、または予約を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>または<code>previousRecord</code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "レコード シーケンスが読み取り専用アクセスで開かれたために、操作を実行できません。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "合わせて十分なサイズの予約<code> data </code>は含まれて<code> reservations</code>です。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "予約されているバイトの合計数を取得します。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "このレコード シーケンスで行われたすべての予約の合計サイズ。"
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後、プロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "ログの末尾に最も近い再開領域のシーケンス番号を取得します。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して、<xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>削除することができます、メソッド、直前に書き込まれた再開領域</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "ログの末尾に最も近い再開領域のシーケンス番号。"
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後、プロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得または設定を示す値かどうかを追加、ログがいっぱいの場合は、自動的に再試行します。"
  remarks: "このプロパティの値が場合`true`、および<xref:System.IO.Log.LogRecordSequence.Append%2A>、シーケンス内に十分な領域がないために、呼び出しが失敗し、レコード シーケンスが領域を解放して、追加の再試行を試みた</xref:System.IO.Log.LogRecordSequence.Append%2A>。"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合追加は自動的に再試行を行う場合、ログがいっぱいです。それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後、プロパティがアクセスされました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "の最後のレコードの設定、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。"
  remarks: "指定されたシーケンス番号は、基本シーケンス番号より大きくなければなりません。       このメソッドが完了すると、指定されたシーケンス番号より大きいシーケンス番号で以前に追加されたすべてのレコードにアクセスできません。"
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新しい最後のシーケンス番号、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。       これは、現在のログの現在の有効なレコードを参照してください。"
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>このシーケンスに対して無効です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。       - または - <code> sequenceNumber </code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       または、ログの末尾に達しています。       または、指定されたログ ファイル形式またはバージョンが無効です。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "シーケンスの末尾を移動する必要を通知します。"
  remarks: "レコード シーケンスが領域を使い果たしたときに、このイベントを発生させることができます。 このイベントが発生したときに、シーケンス (つまり、基本シーケンス番号) の末尾は領域を解放する前方に移動します。       レコード シーケンスことに何らかの理由で、領域を解放する必要がありますを決定するときにいつでもイベントを発生できます。 たとえば、CLFS ポリシー エンジンはありますかを決定する、同じログ ファイルを共有する&2; つのログ クライアントの末尾が離れすぎているイベントを発生させます。 領域の解放を実行するか再開領域を書き込むか、ログの切り捨てを使用して、<xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>領域をクリアするメソッド</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>。 使用例」のサンプル コードでは、2 番目の方法を示します。       呼び出すことも、<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>領域を解放する TailPinned イベントの外部でのメソッド</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>。 再開領域は、その他のログ処理システムにおけるチェックポイントと似ています。 このメソッドを呼び出すことを示し、アプリケーションと完全に完了したら、再開領域の前にすべての以前のレコードを考慮する今後のレコードで使用できるように追加します。 他のレコードと同様に、このメソッドによるレコード書き込みには、関数にログに実際の空き領域が必要です。"
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>。       バイト配列セグメント内のデータは、レコードとして追加するための単一のバイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加される配列セグメント。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>です。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>。       バイト配列セグメント内のデータは、レコードとして追加するための単一のバイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "引数の&1; つ以上が<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>基本シーケンス番号を更新します。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>基本シーケンス番号を更新します。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>予約を使用して、基本シーケンス番号を更新します。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       予約を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します。 メソッドが成功すると、消費され、最も小さな予約データを持つことができること、および予約がコレクションから削除されます。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "1 つ以上の引数が無効です。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "再開領域の書き込み中に I/O エラーが発生しました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスは、新しい再開領域を格納するための十分な空き領域を作成できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "再開領域を書き込み、 <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>予約を使用して、基本シーケンス番号を更新します。 このメソッドは継承できません。"
  remarks: "再開領域は、クライアントの最後のチェックポイント操作が含まれるデータを一時的に保存するために使用します。 Common Log File System (CLFS) は、2 つの再開には、少なくとも&1; つの有効な領域が常に利用可能なを保証するために領域を保持します。 回復処理が必要なときに、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブル、ダーティ ページ テーブル、およびファイルを開くテーブルを初期化します。       使用して再開領域を読み取ることができます、<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>メソッド</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>。       再開領域が書き込まれるときに、バイト配列セグメント内のデータは、レコードとして追加するために単一バイト配列に連結されます。 データを分割して配列セグメントに戻す、再開領域を読み取るときに、準備は実施されません。       予約を指定すると、書き込まれた再開領域は以前に予約された、コレクションに含まれている予約を使用して領域を消費します。 メソッドが成功すると、消費され、最も小さな予約データを持つことができること、および予約がコレクションから削除されます。       このメソッドが正常に完了すると、基本シーケンス番号が更新されました。 すべてのログ レコードのシーケンス番号を持つ未満の新しい基本シーケンス番号はアクセスできません。       レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、例外がスローされますすぐにこの操作内で。 I/O 要求時にディスク障害など、非同期追加要求中に発生したエラーが発生するときに例外スロー、<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>メソッドが呼び出されます</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "連結して、レコードとして追加されるバイト配列セグメントの一覧。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新しい基本シーケンス番号。 指定されたシーケンス番号は、現在の基本シーケンス番号以上でなければなりません。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>この再開領域で使用する予約情報を格納します。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "シーケンス数、書き込まれた再開領域です。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>このシーケンスに対して無効です。       または、指定されたログ列挙開始シーケンス番号が正しくありません。       - または -<code>data</code>最大レコード サイズよりも大きいために追加されることはできません。       - または -<code>reservationCollection</code>このレコード シーケンスによって作成されていません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "1 つまたは複数のパラメーターが<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新規または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。       - または - <code> newBaseSeqNum </code>このシーケンスの基本と最後のシーケンス番号の間ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "予期しない I/O 例外のため、要求を実行できませんでした。       - または - I/O デバイス エラーのため、要求を実行できませんでした。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "シーケンスが破棄された後に、メソッドが呼び出されました。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "プログラムの実行を継続する十分なメモリがありません。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "指定したログ シーケンスへのアクセスは、オペレーティング システムによって拒否されました。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "レコード シーケンスがいっぱいです。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
