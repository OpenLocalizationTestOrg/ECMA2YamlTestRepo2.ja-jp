### YamlMime:ManagedReference
items:
- uid: System.Collections.Stack
  id: Stack
  children:
  - System.Collections.Stack.#ctor
  - System.Collections.Stack.#ctor(System.Collections.ICollection)
  - System.Collections.Stack.#ctor(System.Int32)
  - System.Collections.Stack.Clear
  - System.Collections.Stack.Clone
  - System.Collections.Stack.Contains(System.Object)
  - System.Collections.Stack.CopyTo(System.Array,System.Int32)
  - System.Collections.Stack.Count
  - System.Collections.Stack.GetEnumerator
  - System.Collections.Stack.IsSynchronized
  - System.Collections.Stack.Peek
  - System.Collections.Stack.Pop
  - System.Collections.Stack.Push(System.Object)
  - System.Collections.Stack.Synchronized(System.Collections.Stack)
  - System.Collections.Stack.SyncRoot
  - System.Collections.Stack.ToArray
  langs:
  - csharp
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
  type: Class
  summary: "オブジェクトの単純な最後先出し (LIFO) の非ジェネリック コレクションを表します。"
  remarks: "このコレクションの汎用バージョン、 <xref:System.Collections.Generic.Stack%601?displayProperty=fullName>。</xref:System.Collections.Generic.Stack%601?displayProperty=fullName>を参照してください。       スタックの容量とは、スタックに格納できる要素の数です。 要素がスタックに追加されるため、容量を増やすは自動的に再割り当て、必要に応じて。       場合<xref:System.Collections.Stack.Count%2A>がスタックの容量よりも小さい<xref:System.Collections.Stack.Push%2A>は、o (1) 操作になります</xref:System.Collections.Stack.Push%2A></xref:System.Collections.Stack.Count%2A>。 容量が、新しい要素を格納するためにする必要がある場合<xref:System.Collections.Stack.Push%2A>O になります (`n`) 操作、場所`n`は<xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A> </xref:System.Collections.Stack.Push%2A> <xref:System.Collections.Stack.Pop%2A>o (1) 操作です。</xref:System.Collections.Stack.Pop%2A>       スタックを受け入れる`null`有効な値としてでき、重複する要素。"
  example:
  - "The following example shows how to create and add values to a Stack and how to display its values.  \n  \n [!code-cs[Classic Stack Example#1](~/add/codesnippet/csharp/t-system.collections.stack_1.cs)]\n [!code-vb[Classic Stack Example#1](~/add/codesnippet/visualbasic/t-system.collections.stack_1.vb)]\n [!code-cpp[Classic Stack Example#1](~/add/codesnippet/cpp/t-system.collections.stack_1.cpp)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Stack : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor
  id: '#ctor'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Collections.Stack&quot;> </xref>が空で、既定の初期量を備えたクラスです。"
  remarks: "容量、<xref:System.Collections.Stack>は要素の数を<xref:System.Collections.Stack>を保持できます</xref:System.Collections.Stack></xref:System.Collections.Stack>。 要素が追加されるにつれて、 <xref:System.Collections.Stack>、容量を増やすは自動的に内部の配列を再割り当てによる要求どおり</xref:System.Collections.Stack>。       コレクションのサイズを推定できる場合の<xref:System.Collections.Stack>。</xref:System.Collections.Stack>へ要素を追加中にサイズ変更操作を実行する必要があるの初期量を指定します。       このコンス トラクターは、o (1) 操作です。"
  syntax:
    content: public Stack ();
    parameters: []
  overload: System.Collections.Stack.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Collections.Stack&quot;> </xref>指定したコレクションからコピーされた要素を格納し、コピーされた要素の数と同じ初期量を備えたクラスです。"
  remarks: "容量、<xref:System.Collections.Stack>は要素の数を<xref:System.Collections.Stack>を保持できます</xref:System.Collections.Stack></xref:System.Collections.Stack>。 要素が追加されるにつれて、 <xref:System.Collections.Stack>、容量を増やすは自動的に内部の配列を再割り当てによる要求どおり</xref:System.Collections.Stack>。       コレクションのサイズを推定できる場合の<xref:System.Collections.Stack>。</xref:System.Collections.Stack>へ要素を追加中にサイズ変更操作を実行する必要があるの初期量を指定します。       、<xref:System.Collections.Stack>同じ順序<xref:System.Collections.IEnumerator><xref:System.Collections.ICollection>。</xref:System.Collections.ICollection></xref:System.Collections.IEnumerator>によって読み取られる順序で</xref:System.Collections.Stack>要素のコピーします。       このコンス トラクターは、O (`n`) 操作では、ここで`n`内の要素の数は、`col`です。"
  syntax:
    content: public Stack (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>から要素をコピーする</xref:System.Collections.ICollection>。"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Collections.Stack&quot;> </xref>はクラスを空にして、指定した初期量または既定の初期量、大きい方です。"
  remarks: "容量、<xref:System.Collections.Stack>は要素の数を<xref:System.Collections.Stack>を保持できます</xref:System.Collections.Stack></xref:System.Collections.Stack>。 要素が追加されるにつれて、 <xref:System.Collections.Stack>、容量を増やすは自動的に内部の配列を再割り当てによる要求どおり</xref:System.Collections.Stack>。       コレクションのサイズを推定できる場合の<xref:System.Collections.Stack>。</xref:System.Collections.Stack>へ要素を追加中にサイズ変更操作を実行する必要があるの初期量を指定します。       このコンス トラクターは、O (`n`) 操作では、ここで`n`は`initialCapacity`します。"
  syntax:
    content: public Stack (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "最初の要素数を<xref href=&quot;System.Collections.Stack&quot;></xref>含めることができます。"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>0 未満です。"
  platform:
  - net462
- uid: System.Collections.Stack.Clear
  id: Clear
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "すべてのオブジェクトを削除、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "<xref:System.Collections.Stack.Count%2A>0 に設定し、コレクションの要素から他のオブジェクトへの参照も解放します。</xref:System.Collections.Stack.Count%2A>       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>は、"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Stack>.  \n  \n [!code-cpp[Classic Stack.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sta_5_1.cpp)]\n [!code-vb[Classic Stack.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_5_1.vb)]\n [!code-cs[Classic Stack.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sta_5_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Stack.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Clone
  id: Clone
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "簡易コピーを作成、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "コレクションの簡易コピーは、参照型または値の型が参照先のオブジェクトはコピーしないかどうか、コレクションの要素のみをコピーします。 新しいコレクション内の参照は、元のコレクション内の参照をポイントする同じオブジェクトをポイントします。       これに対し、コレクションのディープ コピーされた要素をコピーして、要素が直接または間接的に参照するすべてです。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>は、"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "簡易コピー、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  overload: System.Collections.Stack.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "要素がであるかどうかを判断、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "このメソッドを呼び出すことで等しいかどうかを判断、<xref:System.Object.Equals%2A?displayProperty=fullName>メソッド</xref:System.Object.Equals%2A?displayProperty=fullName>。       このメソッドは、一方向の検索を実行します。そのため、このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>は、       以降、.NET Framework 2.0 では、このメソッドはテスト等しいかどうかを渡すことによって、`obj`への引数、<xref:System.Object.Equals%2A>コレクション内の個々 のオブジェクトのメソッド</xref:System.Object.Equals%2A>。 以前のバージョンの .NET Framework では、この決定が行われたために、コレクション内の個々 の項目を渡すことを使用して、<xref:System.Object.Equals%2A>のメソッド、`obj`引数</xref:System.Object.Equals%2A>。"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "内で検索するオブジェクト、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。 値を指定できます<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, if <code>obj</code> is found in the <xref href=&quot;System.Collections.Stack&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Stack.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "コピー、 <xref href=&quot;System.Collections.Stack&quot;> </xref>既存の&1; 次元に<xref:System.Array>、指定した配列インデックスから始まります</xref:System.Array>。"
  remarks: "要素の最後で先出し (LIFO) の順序、 <xref:System.Collections.Stack.Pop%2A>。</xref:System.Collections.Stack.Pop%2A>への呼び出しの連続してによって返される要素の順序と似ての配列にコピーします。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>は、"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_6_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_6_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_6_1.cs)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "1 次元<xref:System.Array>からコピーした要素のコピー先は<xref href=&quot;System.Collections.Stack&quot;> </xref></xref:System.Array> 。 <xref:System.Array>0 から始まるインデックス番号が必要です</xref:System.Array>。"
    - id: index
      type: System.Int32
      description: "内の&0; から始まるインデックス`array`コピーの開始位置。"
  overload: System.Collections.Stack.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>0 未満です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>多次元です。       - または - ソース内の要素の数<xref href=&quot;System.Collections.Stack&quot;></xref>から使用可能な領域より大きくなって<code>index</code>変換先の末尾に<code>array</code>です。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "ソースの種類<xref href=&quot;System.Collections.Stack&quot;></xref>変換先の型に自動的にキャストすることはできません<code> array</code>です。"
  platform:
  - net462
- uid: System.Collections.Stack.Count
  id: Count
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "含まれる要素の数を取得、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "容量は、要素の数を<xref:System.Collections.Stack>格納できます</xref:System.Collections.Stack>。 数は実際に<xref:System.Collections.Stack>。</xref:System.Collections.Stack>内にある要素の数       容量は、常に Count 以上です。 数を超えた場合、容量の要素を追加するときに、前の要素をコピーし、新しい要素を追加する前に、内部配列の再割り当てによって、容量は自動的に増加します。       このプロパティの値を取得するは、o (1) 操作です。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "含まれる要素の数、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  overload: System.Collections.Stack.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Stack
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "返します、<xref:System.Collections.IEnumerator>の<xref href=&quot;System.Collections.Stack&quot;> </xref></xref:System.Collections.IEnumerator> 。"
  remarks: "[Visual Basic、C# の場合]      `foreach` C# 言語のステートメント (`for each` Visual Basic で)、列挙子の複雑さが隠されています。  したがってを使用して`foreach`列挙子を直接操作せずにお勧めします。       列挙子を使用して、コレクション内のデータを読み取ることができますが、基になるコレクションを変更するのには使用できません。       最初に、列挙子はコレクション内の最初の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A>列挙子をこの位置に戻さ点もあります。</xref:System.Collections.IEnumerator.Reset%2A>  この位置にある<xref:System.Collections.IEnumerator.Current%2A>が定義されていません</xref:System.Collections.IEnumerator.Current%2A>。 したがって、 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>。</xref:System.Collections.IEnumerator.Current%2A>の値を読み取る前に、コレクションの最初の要素に列挙子を進めるに</xref:System.Collections.IEnumerator.MoveNext%2A>呼び出す必要があります。       <xref:System.Collections.IEnumerator.Current%2A>いずれかのまで同じオブジェクトを返します<xref:System.Collections.IEnumerator.MoveNext%2A>または<xref:System.Collections.IEnumerator.Reset%2A>と呼びます</xref:System.Collections.IEnumerator.Reset%2A></xref:System.Collections.IEnumerator.MoveNext%2A>。</xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>設定<xref:System.Collections.IEnumerator.Current%2A>次の要素にします</xref:System.Collections.IEnumerator.Current%2A>。</xref:System.Collections.IEnumerator.MoveNext%2A>       場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子をコレクションの末尾が、コレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`</xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.MoveNext%2A>。 列挙子がこの位置では、後続の呼び出しの場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`</xref:System.Collections.IEnumerator.MoveNext%2A>。 最後の呼び出し場合<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、<xref:System.Collections.IEnumerator.Current%2A>が定義されていません</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>。 <xref:System.Collections.IEnumerator.Current%2A>再度、コレクションの最初の要素に<xref:System.Collections.IEnumerator.Reset%2A><xref:System.Collections.IEnumerator.MoveNext%2A>。</xref:System.Collections.IEnumerator.MoveNext%2A>続けて</xref:System.Collections.IEnumerator.Reset%2A>を呼び出すことができます</xref:System.Collections.IEnumerator.Current%2A>を設定するには       コレクションが変更されない限り、列挙子は有効です。 コレクションの変更が加えられた場合など、追加、変更、または要素を削除すると、列挙子は回復不可能とその動作は未定義です。       列挙子はコレクションへの排他アクセスがありません。そのため、コレクションの列挙は、本質的には、スレッド セーフなプロシージャではします。  列挙中にスレッドの安全性を保証するためには、列挙中にコレクションをロックできます。  読み取りと書き込みの複数のスレッドがアクセスするコレクションを許可するのには、独自に同期を実装する必要があります。       このメソッドは、o (1) 操作です。"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Stack&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Stack.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Stack
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "アクセスをするかどうかを示す値を取得、 <xref href=&quot;System.Collections.Stack&quot;> </xref>が同期されている (スレッド セーフである)。"
  remarks: "スレッド セーフを確保する、 <xref:System.Collections.Stack>、によって返されるラッパーを介してすべての操作を行う必要があります、<xref:System.Collections.Stack.Synchronized%2A>メソッド</xref:System.Collections.Stack.Synchronized%2A></xref:System.Collections.Stack>。       コレクションの列挙は本質的にスレッド セーフなプロシージャ コレクションが同期されている場合でも、他のスレッドがコレクションを変更、これにより、列挙子は例外をスローします。 列挙処理中には、スレッド セーフを確保するには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更に起因する例外をキャッチします。       次のコード例を使用してコレクションをロックする方法を示しています、<xref:System.Collections.Stack.SyncRoot%2A>列挙中に</xref:System.Collections.Stack.SyncRoot%2A>。       [!code-cpp[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)][!code-cs[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)][!code-vb[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb) ] o (1) 操作には、このプロパティの値を取得します。    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sta_0_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sta_0_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sta_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>、場合へのアクセス、 <xref href=&quot;System.Collections.Stack&quot;> </xref>が同期 (スレッド セーフな) です。 それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Collections.Stack.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Peek
  id: Peek
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "上部にあるオブジェクトを返します、 <xref href=&quot;System.Collections.Stack&quot;> </xref>削除することがなくです。"
  remarks: "このメソッドは<xref:System.Collections.Stack.Pop%2A>、メソッドがピーク<xref:System.Collections.Stack>。</xref:System.Collections.Stack>は変更されません。</xref:System.Collections.Stack.Pop%2A>       `null`プッシュされることができます、<xref:System.Collections.Stack>必要な場合は、プレース ホルダーとして</xref:System.Collections.Stack>。 区別する、null 値、スタックの末尾、確認、<xref:System.Collections.Stack.Count%2A>プロパティまたは catch、 <xref:System.InvalidOperationException>、ときにスローする、<xref:System.Collections.Stack>が空です</xref:System.Collections.Stack></xref:System.InvalidOperationException></xref:System.Collections.Stack.Count%2A>。       このメソッドは、o (1) 操作です。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_4_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_4_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_4_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "<xref:System.Object>の上部にある、 <xref href=&quot;System.Collections.Stack&quot;> </xref></xref:System.Object> 。"
  overload: System.Collections.Stack.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>が空です。"
  platform:
  - net462
- uid: System.Collections.Stack.Pop
  id: Pop
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "削除し、上部にあるオブジェクトを返します、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "このメソッド、<xref:System.Collections.Stack.Peek%2A>メソッドは<xref:System.Collections.Stack.Peek%2A><xref:System.Collections.Stack>。</xref:System.Collections.Stack>を変更しません</xref:System.Collections.Stack.Peek%2A></xref:System.Collections.Stack.Peek%2A>       `null`プッシュされることができます、<xref:System.Collections.Stack>必要な場合は、プレース ホルダーとして</xref:System.Collections.Stack>。 区別する、null 値、スタックの末尾、確認、<xref:System.Collections.Stack.Count%2A>プロパティまたは catch、 <xref:System.InvalidOperationException>、ときにスローする、<xref:System.Collections.Stack>が空です</xref:System.Collections.Stack></xref:System.InvalidOperationException></xref:System.Collections.Stack.Count%2A>。       このメソッドは、o (1) 操作です。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_2_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_2_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_2_1.cpp)]"
  syntax:
    content: public virtual object Pop ();
    parameters: []
    return:
      type: System.Object
      description: "<xref:System.Object>の最上部から削除された、 <xref href=&quot;System.Collections.Stack&quot;> </xref></xref:System.Object> 。"
  overload: System.Collections.Stack.Pop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>が空です。"
  platform:
  - net462
- uid: System.Collections.Stack.Push(System.Object)
  id: Push(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "上部にあるオブジェクトを挿入、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "場合<xref:System.Collections.Stack.Count%2A>容量の容量と既に同じ、<xref:System.Collections.Stack>内部の配列を自動的に再割り当てが増加し、新しい要素が追加される前に、既存の要素が新しい配列にコピーされます</xref:System.Collections.Stack></xref:System.Collections.Stack.Count%2A>。       `null`プッシュされることができます、<xref:System.Collections.Stack>必要な場合は、プレース ホルダーとして</xref:System.Collections.Stack>。 スタック内のスロットを占有し、任意のオブジェクトと同様に扱われます。       場合<xref:System.Collections.Stack.Count%2A>が小さいスタックの容量よりもプッシュは、o (1) 操作になります</xref:System.Collections.Stack.Count%2A>。 容量は、新しい要素を格納するためにする必要があります、プッシュが O (`n`) 操作では、ここで`n` <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>は、"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_1_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_1_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_1_1.cpp)]"
  syntax:
    content: public virtual void Push (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>にプッシュする、 <xref href=&quot;System.Collections.Stack&quot;> </xref></xref:System.Object> 。 値を指定できます<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  overload: System.Collections.Stack.Push*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  id: Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "同期されたを返します (スレッド セーフな) ラッパーを<xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "スレッド セーフを確保する、 <xref:System.Collections.Stack>、このラッパーを通じて、すべての操作を行う必要があります</xref:System.Collections.Stack>。       コレクションの列挙は本質的にスレッド セーフなプロシージャ コレクションが同期されている場合でも、他のスレッドがコレクションを変更、これにより、列挙子は例外をスローします。 列挙処理中には、スレッド セーフを確保するには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更に起因する例外をキャッチします。       次のコード例を使用してコレクションをロックする方法を示しています、<xref:System.Collections.Stack.SyncRoot%2A>列挙中に</xref:System.Collections.Stack.SyncRoot%2A>。       [!code-cpp[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)][!code-cs[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)][!code-vb[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb) ]このメソッドは、o (1) 操作になります。    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_3_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sta_3_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sta_3_2.cs)]"
  syntax:
    content: public static System.Collections.Stack Synchronized (System.Collections.Stack stack);
    parameters:
    - id: stack
      type: System.Collections.Stack
      description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>同期するためにします。"
    return:
      type: System.Collections.Stack
      description: "同期されたラッパー、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  overload: System.Collections.Stack.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.SyncRoot
  id: SyncRoot
  parent: System.Collections.Stack
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "アクセスを同期するために使用できるオブジェクトを取得、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  remarks: "同期されたバージョンを作成する、<xref:System.Collections.Stack>を使用して、<xref:System.Collections.Stack.Synchronized%2A>メソッド</xref:System.Collections.Stack.Synchronized%2A></xref:System.Collections.Stack>。 ただし、派生クラスは、独自の同期されたバージョンを指定、 <xref:System.Collections.Stack>SyncRoot プロパティを使用します</xref:System.Collections.Stack>。 同期されたコードでの操作を実行する必要があります、 <xref:System.Collections.Stack>、 <xref:System.Collections.Stack>.</xref:System.Collections.Stack>で直接</xref:System.Collections.Stack> これにより、他のオブジェクトから派生したコレクションを適切に操作します。 具体的には、同時に変更する可能性がある別スレッドとの適切な同期を維持、<xref:System.Collections.Stack>オブジェクト</xref:System.Collections.Stack>。       コレクションの列挙は本質的にスレッド セーフなプロシージャ コレクションが同期されている場合でも、他のスレッドがコレクションを変更、これにより、列挙子は例外をスローします。 列挙処理中には、スレッド セーフを確保するには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更に起因する例外をキャッチします。       次のコード例では、列挙中に、SyncRoot を使用して、コレクションをロックする方法を示します。       [!code-cpp[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)][!code-cs[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)][!code-vb[クラシック Stack.IsSynchronized 例&2;](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb) ] o (1) 操作には、このプロパティの値を取得します。    "
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "<xref:System.Object>へのアクセスを同期するために使用できる、 <xref href=&quot;System.Collections.Stack&quot;> </xref></xref:System.Object> 。"
  overload: System.Collections.Stack.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.ToArray
  id: ToArray
  parent: System.Collections.Stack
  langs:
  - csharp
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "コピー、 <xref href=&quot;System.Collections.Stack&quot;> </xref>を新しい配列にします。"
  remarks: "要素の最後で先出し (LIFO) の順序、 <xref:System.Collections.Stack.Pop%2A>。</xref:System.Collections.Stack.Pop%2A>への呼び出しの連続してによって返される要素の順序と似ての配列にコピーします。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>は、"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_0_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_0_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_0_1.cs)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "新しい配列の要素のコピーを格納、 <xref href=&quot;System.Collections.Stack&quot;></xref>です。"
  overload: System.Collections.Stack.ToArray*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.Stack.#ctor
  parent: System.Collections.Stack
  isExternal: false
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Stack.#ctor(System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Stack.Clear
  parent: System.Collections.Stack
  isExternal: false
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
- uid: System.Collections.Stack.Clone
  parent: System.Collections.Stack
  isExternal: false
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
- uid: System.Collections.Stack.Contains(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Stack.Count
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
- uid: System.Collections.Stack.GetEnumerator
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Stack.IsSynchronized
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
- uid: System.Collections.Stack.Peek
  parent: System.Collections.Stack
  isExternal: false
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
- uid: System.Collections.Stack.Pop
  parent: System.Collections.Stack
  isExternal: false
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
- uid: System.Collections.Stack.Push(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
- uid: System.Collections.Stack
  parent: System.Collections
  isExternal: false
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
- uid: System.Collections.Stack.SyncRoot
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
- uid: System.Collections.Stack.ToArray
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Stack.#ctor*
  parent: System.Collections.Stack
  isExternal: false
  name: Stack
  nameWithType: Stack.Stack
- uid: System.Collections.Stack.Clear*
  parent: System.Collections.Stack
  isExternal: false
  name: Clear
  nameWithType: Stack.Clear
- uid: System.Collections.Stack.Clone*
  parent: System.Collections.Stack
  isExternal: false
  name: Clone
  nameWithType: Stack.Clone
- uid: System.Collections.Stack.Contains*
  parent: System.Collections.Stack
  isExternal: false
  name: Contains
  nameWithType: Stack.Contains
- uid: System.Collections.Stack.CopyTo*
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo
  nameWithType: Stack.CopyTo
- uid: System.Collections.Stack.Count*
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
- uid: System.Collections.Stack.GetEnumerator*
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator
  nameWithType: Stack.GetEnumerator
- uid: System.Collections.Stack.IsSynchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
- uid: System.Collections.Stack.Peek*
  parent: System.Collections.Stack
  isExternal: false
  name: Peek
  nameWithType: Stack.Peek
- uid: System.Collections.Stack.Pop*
  parent: System.Collections.Stack
  isExternal: false
  name: Pop
  nameWithType: Stack.Pop
- uid: System.Collections.Stack.Push*
  parent: System.Collections.Stack
  isExternal: false
  name: Push
  nameWithType: Stack.Push
- uid: System.Collections.Stack.Synchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized
  nameWithType: Stack.Synchronized
- uid: System.Collections.Stack.SyncRoot*
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
- uid: System.Collections.Stack.ToArray*
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray
  nameWithType: Stack.ToArray
