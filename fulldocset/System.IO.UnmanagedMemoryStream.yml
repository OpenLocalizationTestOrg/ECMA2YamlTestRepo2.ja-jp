### YamlMime:ManagedReference
items:
- uid: System.IO.UnmanagedMemoryStream
  id: UnmanagedMemoryStream
  children:
  - System.IO.UnmanagedMemoryStream.#ctor
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.CanRead
  - System.IO.UnmanagedMemoryStream.CanSeek
  - System.IO.UnmanagedMemoryStream.CanWrite
  - System.IO.UnmanagedMemoryStream.Capacity
  - System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  - System.IO.UnmanagedMemoryStream.Flush
  - System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Length
  - System.IO.UnmanagedMemoryStream.Position
  - System.IO.UnmanagedMemoryStream.PositionPointer
  - System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.ReadByte
  - System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  - System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream
  fullName: System.IO.UnmanagedMemoryStream
  type: Class
  summary: "メモリのアンマネージ ブロックにマネージ コードからのアクセスを提供します。"
  remarks: "このクラスは、既存のストリームに基づくモデルを使用してアンマネージ メモリへのアクセスをサポートし、ヒープをアンマネージ メモリの内容をコピーすることは必要ありません。      > [!IMPORTANT] > この型は、<xref:System.IDisposable>インターフェイス</xref:System.IDisposable>。 型を使用してが完了したらを直接的または間接的にその破棄する必要があります。 型の直接 dispose を呼び出す、<xref:System.IDisposable.Dispose%2A>メソッドで、 `try` / `catch`ブロック</xref:System.IDisposable.Dispose%2A>。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(C# の場合) または`Using`(Visual Basic で)。 詳細についてを参照してください&quot;を使用して、オブジェクトを実装する IDisposable&quot;、<xref:System.IDisposable>インターフェイスに関するトピック</xref:System.IDisposable>。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the UnmanagedMemoryStream class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/t-system.io.unmanagedmem_1.cs)]"
  syntax:
    content: 'public class UnmanagedMemoryStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor
  id: '#ctor'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>クラスです。"
  syntax:
    content: protected UnmanagedMemoryStream ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "ユーザーには、必要なアクセス許可がありません。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  id: '#ctor(System.Byte*,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>クラスの指定した位置とメモリ長を使用します。"
  remarks: "このコンス トラクターの新しいインスタンスを作成する、<xref:System.IO.UnmanagedMemoryStream>クラス、および既定では設定、<xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>プロパティを`false`と<xref:System.IO.UnmanagedMemoryStream.CanRead%2A>プロパティを`true`</xref:System.IO.UnmanagedMemoryStream.CanRead%2A></xref:System.IO.UnmanagedMemoryStream.CanWrite%2A></xref:System.IO.UnmanagedMemoryStream>。 <xref:System.IO.UnmanagedMemoryStream.Length%2A>の値に設定されて、`length`パラメーターは変更できません</xref:System.IO.UnmanagedMemoryStream.Length%2A>。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_4_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "アンマネージ メモリ位置へのポインター。"
    - id: length
      type: System.Int64
      description: "使用するメモリの長さ。"
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "ユーザーには、必要なアクセス許可がありません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>指定されたオフセットと長さを使用して、セーフ バッファー内のクラスです。"
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "アンマネージ メモリ ストリームを格納するバッファー。"
    - id: offset
      type: System.Int64
      description: "アンマネージ メモリ ストリームを開始する位置を示すバッファー内のバイト位置。"
    - id: length
      type: System.Int64
      description: "アンマネージ メモリ ストリームの長さ。"
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>クラスの指定した場所、メモリ長、メモリの総量を使用して、ファイルの値にアクセスします。"
  remarks: "`length`パラメーターは、使用中メモリの現在の量を定義します。 読み取り、ストリームにデータを追加する場合、`length`値から読み込まれるストリームに有効なデータの量と等しくする必要がありますまたは保持されます。 ストリームに書き込み、この値は&0; にする必要があります。       `capacity`パラメーターが使用できる合計メモリの量を示します。 この値は、指定された長さよりも長い地域を説明またはに追加できる領域を示すことができます。 この値を超える書き込みするあらゆる試みは失敗します。       `access`パラメーター セット、 <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>、および<xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>プロパティ</xref:System.IO.UnmanagedMemoryStream.CanWrite%2A></xref:System.IO.UnmanagedMemoryStream.CanRead%2A>。 指定する<xref:System.IO.FileAccess>ストリームを書き込み可能になることは保証されません</xref:System.IO.FileAccess>。 アクセスのパラメーターは、その実装が公開されている実際のストリームを照合できるオブジェクトを作成する実行者を使用します。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/62930bcb-5dff-4d38-8341-_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "アンマネージ メモリ位置へのポインター。"
    - id: length
      type: System.Int64
      description: "使用するメモリの長さ。"
    - id: capacity
      type: System.Int64
      description: "ストリームに割り当てられたメモリの総量。"
    - id: access
      type: System.IO.FileAccess
      description: "1 つ、 <xref href=&quot;System.IO.FileAccess&quot;> </xref>値。"
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "ユーザーには、必要なアクセス許可がありません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is greater than the <code>capacity</code> value."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>クラスを指定したオフセット、長さ、使用して、セーフ バッファー内で、ファイルへのアクセス。"
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "アンマネージ メモリ ストリームを格納するバッファー。"
    - id: offset
      type: System.Int64
      description: "アンマネージ メモリ ストリームを開始する位置を示すバッファー内のバイト位置。"
    - id: length
      type: System.Int64
      description: "アンマネージ メモリ ストリームの長さ。"
    - id: access
      type: System.IO.FileAccess
      description: "アンマネージ メモリ ストリームにアクセスするファイルのモードです。"
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanRead
  id: CanRead
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリームが読み取りをサポートするかどうかを示す値を取得します。"
  remarks: "このプロパティは、現在のストリーム オブジェクトが読み取りをサポートするかどうかを示します。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanRead property before attempting to display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>持つコンス トラクターによってオブジェクトが作成された場合、 <code> access </code>パラメーター ストリームの読み取りが含まれていませんが、ストリームが閉じている、それ以外の場合と<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.UnmanagedMemoryStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  id: CanSeek
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリームがシークをサポートするかどうかを示す値を取得します。"
  remarks: "このプロパティは、現在のストリーム オブジェクトがシークをサポートするかどうかを示します。"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>場合は、ストリームは閉じられます。それ以外の場合、 <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.UnmanagedMemoryStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  id: CanWrite
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリームが書き込みをサポートするかどうかを示す値を取得します。"
  remarks: "このプロパティは、現在のストリームが書き込みをサポートするかどうかを示します。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanWrite property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>持つコンス トラクターによってオブジェクトが作成された場合、 <code> access </code>書き込みをサポートしていますが、パラメーターを持たないコンス トラクターによって作成されたパラメーター値のストリームが閉じている、それ以外の場合、または<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.IO.UnmanagedMemoryStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Capacity
  id: Capacity
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリームの長さ (サイズ) またはストリーム (容量) に割り当てられたメモリの総量を取得します。"
  remarks: "このプロパティを返します、`capacity`コンス トラクターに指定された値。 ない場合は`capacity`ストリームが初期化されたときに、値は指定された、このプロパティは、ストリームの長さを返します。"
  syntax:
    content: public long Capacity { get; }
    return:
      type: System.Int64
      description: "サイズまたはストリームの容量。"
  overload: System.IO.UnmanagedMemoryStream.Capacity*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "によって使用されるアンマネージ リソースを解放、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>し、必要に応じてマネージ リソースを解放します。"
  remarks: "このメソッドは、パブリック<xref:System.ComponentModel.Component.Dispose%2A>メソッドおよび<xref:System.Object.Finalize%2A>メソッド</xref:System.Object.Finalize%2A></xref:System.ComponentModel.Component.Dispose%2A>。 <xref:System.ComponentModel.Component.Dispose%2A>保護された Dispose メソッドを呼び出し、`disposing`パラメーターに設定`true`です。</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>Dispose を呼び出す`disposing`&quot;éý&quot;`false`です。</xref:System.Object.Finalize%2A>       ときに、`disposing`パラメーターは`true`、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放しますこの<xref:System.IO.UnmanagedMemoryStream>参照。</xref:System.IO.UnmanagedMemoryStream> 。 このメソッドを呼び出して、<xref:System.ComponentModel.Component.Dispose%2A>参照される各オブジェクトのメソッド</xref:System.ComponentModel.Component.Dispose%2A>。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マネージ コードとアンマネージ リソースを解放するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>アンマネージ リソースだけを解放します。"
  overload: System.IO.UnmanagedMemoryStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Flush
  id: Flush
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "上書き、<xref:System.IO.Stream.Flush*>メソッド操作が実行されないようにします</xref:System.IO.Stream.Flush*>。"
  remarks: "このメソッドは、このクラスの操作は実行されませんが、<xref:System.IO.Stream>基底クラス</xref:System.IO.Stream>の一部として含まれて すべてのデータが書き込まれるため RAM をこのメソッドは冗長です。"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "上書き、 &lt;xref:System.IO.Stream.FlushAsync%2A?displayProperty=fullName&gt;メソッド、指定した場合、操作がキャンセルされるが他のアクションが実行されないようにします。       以降で利用可能[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "操作はキャンセルされていない場合、<xref:System.IO.UnmanagedMemoryStream>呼び出し、<xref:System.IO.UnmanagedMemoryStream.Flush%2A>メソッドで、アクションが実行されないことを意味します</xref:System.IO.UnmanagedMemoryStream.Flush%2A></xref:System.IO.UnmanagedMemoryStream>。"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "キャンセル要求を監視するトークンです。 既定値は<xref:System.Threading.CancellationToken.None*>。</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "非同期のフラッシュ操作を表すタスク。"
  overload: System.IO.UnmanagedMemoryStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>アンマネージ メモリ位置へのポインターを使用して、クラスです。"
  remarks: "このメソッドは、<xref:System.IO.UnmanagedMemoryStream.%23ctor%2A>コンス トラクター</xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> 。 ストリームの変数を設定する前に、ポインターを初期化する必要があるあり、そのため、パラメーター化されたコンス トラクターを呼び出すことはできませんの方法がサポートしています。 このようなメソッドは、既定のコンス トラクターを使用する必要があります<xref:System.IO.UnmanagedMemoryStream.%23ctor>、ポインターを初期化および初期化メソッドを呼び出します</xref:System.IO.UnmanagedMemoryStream.%23ctor>。"
  syntax:
    content: protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "アンマネージ メモリ位置へのポインター。"
    - id: length
      type: System.Int64
      description: "使用するメモリの長さ。"
    - id: capacity
      type: System.Int64
      description: "ストリームに割り当てられたメモリの総量。"
    - id: access
      type: System.IO.FileAccess
      description: "1 つ、 <xref href=&quot;System.IO.FileAccess&quot;> </xref>値。"
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "ユーザーには、必要なアクセス許可がありません。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref>クラスを指定したオフセット、長さ、使用して、セーフ バッファー内で、ファイルへのアクセス。"
  syntax:
    content: protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "アンマネージ メモリ ストリームを格納するバッファー。"
    - id: offset
      type: System.Int64
      description: "アンマネージ メモリ ストリームを開始する位置を示すバッファー内のバイト位置。"
    - id: length
      type: System.Int64
      description: "アンマネージ メモリ ストリームの長さ。"
    - id: access
      type: System.IO.FileAccess
      description: "アンマネージ メモリ ストリームにアクセスするファイルのモードです。"
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Length
  id: Length
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリーム内のデータの長さを取得します。"
  remarks: "変更せずにストリームが初期化されたので、このプロパティは、コンス トラクターに渡された長さの値を返します。 ストリームへの変更が発生した場合、このプロパティは、データの長さへの変更を表します。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "ストリーム内のデータの長さ。"
  overload: System.IO.UnmanagedMemoryStream.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Position
  id: Position
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得またはストリーム内の現在位置を設定します。"
  remarks: "ストリームが初期化されると、このプロパティは&0; に設定します。       その領域を使用してアクセスできませんするストリームのキャパシティを超えるストリームの位置を設定できますが、<xref:System.IO.UnmanagedMemoryStream.Read%2A>と<xref:System.IO.UnmanagedMemoryStream.Write%2A>メソッド</xref:System.IO.UnmanagedMemoryStream.Write%2A></xref:System.IO.UnmanagedMemoryStream.Read%2A>。 <xref:System.IO.UnmanagedMemoryStream.Read%2A>0 と<xref:System.IO.UnmanagedMemoryStream.Write%2A><xref:System.NotSupportedException>。</xref:System.NotSupportedException>がスローされます</xref:System.IO.UnmanagedMemoryStream.Write%2A>を返します</xref:System.IO.UnmanagedMemoryStream.Read%2A> これは、主に、設計やコードとの互換性の基本的なストリーム操作です。"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "ストリームの現在の位置。"
  overload: System.IO.UnmanagedMemoryStream.Position*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "位置がよりも大きな位置が、0 より小さい値に設定されているか<xref:System.Int32.MaxValue>か結果の現在のポインターに追加されるとオーバーフロー</xref:System.Int32.MaxValue> 。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  id: PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得またはストリームの現在の位置に基づいてストリームにバイトのポインターを設定します。"
  remarks: "全体のストリームへのポインターを返しますするには設定、<xref:System.IO.UnmanagedMemoryStream.Position%2A>プロパティを&0;、し、このプロパティを呼び出します</xref:System.IO.UnmanagedMemoryStream.Position%2A>。"
  syntax:
    content: public byte* PositionPointer { get; set; }
    return:
      type: System.Byte*
      description: "バイトのポインター。"
  overload: System.IO.UnmanagedMemoryStream.PositionPointer*
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "現在の位置は、ストリームの容量を超えています。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "されている位置セットは、現在のストリーム内の正しい位置ではありません。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ポインターは、ストリームの開始位置より小さい値に設定されているされます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.Runtime.InteropServices.SafeBuffer>。</xref:System.Runtime.InteropServices.SafeBuffer>で使用するためのストリームが初期化されました PositionPointer プロパティに初期化されるストリームに対してのみ有効では、<xref:System.Byte>ポインター</xref:System.Byte> 。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "指定した配列に指定したバイト数を読み取ります。"
  remarks: "`offset`パラメーターはバイトのオフセット、`array`読み取りを開始する位置を示すパラメーター (バッファーのインデックス)、および`count`パラメーターは、このストリームから読み取られるバイトの最大数を示します。 ストリームの末尾に達した場合は、実際の数バイトを読み取り、または&0; を返されるです。 読み取り操作が成功した場合、ストリームの現在の位置は読み取られたバイト数で進められます。 例外が発生する場合は、ストリームの現在の位置は変更されません。       Read メソッドでは、ストリームの末尾に到達した場合にのみゼロを返します。 それ以外の場合、読み取り常に少なくとも&1; バイトのストリームから読み取りを返す前にします。 読み取りを呼び出すとストリームから使用可能なデータがない場合、メソッドは、少なくとも&1; バイトのデータを返すことができるまでにブロックされます。 実装は、ストリームの末尾に達していない場合でも、要求されたより少ないバイト数を返すことです。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "このメソッドが戻るときまでの値が指定したバイト配列が含まれています。`offset`と (`offset`  +  `count` - 1) 現在のソースから読み取られたバイトに置き換えられます。 このパラメーターは初期化せずに渡されます。"
    - id: offset
      type: System.Int32
      description: "内の&0; から始まるバイト オフセット`buffer`開始位置を示す現在のストリームから読み取ったデータの格納します。"
    - id: count
      type: System.Int32
      description: "現在のストリームから読み取るバイトの最大数。"
    return:
      type: System.Int32
      description: "バッファーに読み取られた合計バイト数。 バイト数は要求より小さくバイト数が、現在ご利用いただけませんまたはゼロ (0) の場合、ストリームの末尾に達していることができます。"
  overload: System.IO.UnmanagedMemoryStream.Read*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The <xref:System.IO.UnmanagedMemoryStream.CanRead*> property is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is set to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>offset</code> parameter is less than zero.  \n  \n \\- or -  \n  \n The <code>count</code> parameter is less than zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "バッファー配列の長さ、 <code> offset </code>パラメーターより小さい<code> count </code>パラメーター。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "指定された配列に指定したバイト数を非同期に読み取ります。       以降で利用可能[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "として設定する読み取り操作中に例外が発生した場合、 <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>、返されるタスクのプロパティの</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>。"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "データを書き込むバッファー。"
    - id: offset
      type: System.Int32
      description: "内のバイト オフセット`buffer`ストリームからデータを書き込む開始位置を示すです。"
    - id: count
      type: System.Int32
      description: "読み取るバイトの最大数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "キャンセル要求を監視するトークンです。 既定値は<xref:System.Threading.CancellationToken.None*>。</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "読み取り操作を表す、非同期タスク。 値、 <code> TResult </code>パラメーターには、バッファーに読み取られたバイトの合計数が含まれています。 結果の値は、現在使用できるバイト数が要求した数より小さいか、ストリームの末尾に達している場合 0 (ゼロ) であることを要求したバイト数より小さくできます。"
  overload: System.IO.UnmanagedMemoryStream.ReadAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  id: ReadByte
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ストリームからバイトを読み取りますを&1; バイト、ストリーム内の位置を進めますやストリームの末尾にある場合は-1 を返します。"
  remarks: "このメソッドを使用して、ストリームから整数値を返します。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "キャストされた符号なしバイト、<xref:System.Int32>オブジェクト、または、ストリームの末尾にある場合は-1</xref:System.Int32> 。"
  overload: System.IO.UnmanagedMemoryStream.ReadByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The current position is at the end of the stream."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "指定した値を現在のストリームの現在の位置を設定します。"
  remarks: "詳細については、シーク、 <xref:System.IO.FileStream.Seek%2A>。</xref:System.IO.FileStream.Seek%2A>を参照してください。"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin loc);
    parameters:
    - id: offset
      type: System.Int64
      description: "に対する相対ポイント`origin`シークの開始。"
    - id: loc
      type: System.IO.SeekOrigin
      description: "参照ポイントとして先頭、末尾、または現在位置を示す`origin`、 <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>型の値を使用します。"
    return:
      type: System.Int64
      description: "ストリームの新しい位置。"
  overload: System.IO.UnmanagedMemoryStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "ストリームの先頭より前に、をシークしようとしました。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>値は、ストリームの最大サイズを超えています。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>loc</code>正しくありません。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "指定した値に、ストリームの長さを設定します。"
  remarks: "指定した値が、ストリームの現在の長さより小さい場合は、ストリームは切り捨てられます。 指定した値が、ストリームの現在の長さより大きい場合は、ストリームが拡張されます。 ストリームが展開されている場合、古いクライアント シークレットと新しい長さの間のストリームの内容は未定義です。       ストリームには、書き込みとシーク操作 SetLength の両方をサポートする必要があります。"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "ストリームの長さ。"
  overload: System.IO.UnmanagedMemoryStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O エラーが発生しました。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The specified <code>value</code> exceeds the capacity of the stream.  \n  \n \\- or -  \n  \n The specified <code>value</code> is negative."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "バッファーからデータを使用して現在のストリームにバイトのブロックを書き込みます。"
  remarks: "ストリームの現在位置にある書き込みが発生します。"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_3_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "現在のストリームにバイトをコピーするバイト配列。"
    - id: offset
      type: System.Int32
      description: "現在のストリームにバイトのコピーを開始する位置を示すバッファー内のオフセット。"
    - id: count
      type: System.Int32
      description: "現在のストリームに書き込むバイト数。"
  overload: System.IO.UnmanagedMemoryStream.Write*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The <code>count</code> value is greater than the capacity of the stream.  \n  \n \\- or -  \n  \n The position is at the end of the stream capacity."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/O エラーが発生します。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定したパラメーターのいずれかが&0; 未満です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> offset </code>パラメーターの長さマイナス、 <code> buffer </code>パラメーターより小さい<code> count </code>パラメーター。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "非同期的に現在のストリームにバイトのシーケンスを書き込み、書き込んだバイト数だけストリーム内の現在位置を進めます、キャンセル要求を監視します。       以降で利用可能[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "として設定する書き込み操作中に例外が発生した場合、 <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>、返されるタスクのプロパティの</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>。"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "データを書き込むバッファー。"
    - id: offset
      type: System.Int32
      description: "内の&0; から始まるバイト オフセット`buffer`ストリームにバイトのコピー開始位置を示すです。"
    - id: count
      type: System.Int32
      description: "書き込むバイトの最大数。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "キャンセル要求を監視するトークンです。 既定値は<xref:System.Threading.CancellationToken.None*>。</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "非同期の書き込み操作を表すタスク。"
  overload: System.IO.UnmanagedMemoryStream.WriteAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "ファイル ストリームの現在の位置にバイトを書き込みます。"
  remarks: ''
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "ストリームに書き込むバイト値。"
  overload: System.IO.UnmanagedMemoryStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "ストリームは閉じられます。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The current position is at the end of the capacity of the stream."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定された<code> value </code>ストリームと、処理能力の上限を超えます。"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IndexOutOfRangeException
  isExternal: true
  name: System.IndexOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.UnmanagedMemoryStream.#ctor
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
- uid: System.Runtime.InteropServices.SafeBuffer
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeBuffer
  nameWithType: SafeBuffer
  fullName: System.Runtime.InteropServices.SafeBuffer
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.CanRead
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
- uid: System.IO.UnmanagedMemoryStream.Flush
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Length
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.UnmanagedMemoryStream.#ctor*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream
- uid: System.IO.UnmanagedMemoryStream.CanRead*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
- uid: System.IO.UnmanagedMemoryStream.CanSeek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose
  nameWithType: UnmanagedMemoryStream.Dispose
- uid: System.IO.UnmanagedMemoryStream.Flush*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush
  nameWithType: UnmanagedMemoryStream.Flush
- uid: System.IO.UnmanagedMemoryStream.FlushAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync
  nameWithType: UnmanagedMemoryStream.FlushAsync
- uid: System.IO.UnmanagedMemoryStream.Initialize*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize
  nameWithType: UnmanagedMemoryStream.Initialize
- uid: System.IO.UnmanagedMemoryStream.Length*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read
  nameWithType: UnmanagedMemoryStream.Read
- uid: System.IO.UnmanagedMemoryStream.ReadAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync
  nameWithType: UnmanagedMemoryStream.ReadAsync
- uid: System.IO.UnmanagedMemoryStream.ReadByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte
  nameWithType: UnmanagedMemoryStream.ReadByte
- uid: System.IO.UnmanagedMemoryStream.Seek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek
  nameWithType: UnmanagedMemoryStream.Seek
- uid: System.IO.UnmanagedMemoryStream.SetLength*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength
  nameWithType: UnmanagedMemoryStream.SetLength
- uid: System.IO.UnmanagedMemoryStream.Write*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write
  nameWithType: UnmanagedMemoryStream.Write
- uid: System.IO.UnmanagedMemoryStream.WriteAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync
  nameWithType: UnmanagedMemoryStream.WriteAsync
- uid: System.IO.UnmanagedMemoryStream.WriteByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte
  nameWithType: UnmanagedMemoryStream.WriteByte
