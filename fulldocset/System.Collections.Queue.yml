### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "オブジェクトの先入れ先出しコレクションを表します。"
  remarks: "このクラスは、循環を配列として、キューを実装します。 キューに格納されているオブジェクトは、一方の端に、挿入や削除、他のです。       キューおよびスタックは場合に役立ちますについて; 一時的な保存する必要があります。つまり、可能性がある場合の値を取得後に要素を破棄します。 これが、コレクションに格納される順序と同じ順序での情報にアクセスする必要がある場合は、キューを使用します。 使用して<xref:System.Collections.Stack>かどうかは、逆の順序で、情報にアクセスする必要があります</xref:System.Collections.Stack>。 使用して<xref:System.Collections.Concurrent.ConcurrentQueue%601>または<xref:System.Collections.Concurrent.ConcurrentStack%601>かどうかは、同時に複数のスレッドからコレクションにアクセスする必要があります</xref:System.Collections.Concurrent.ConcurrentStack%601></xref:System.Collections.Concurrent.ConcurrentQueue%601>。       キューとその要素は次の&3; つの主要な操作を実行できます:-<xref:System.Collections.Queue.Enqueue%2A>キューの末尾に要素を追加します</xref:System.Collections.Queue.Enqueue%2A>。      -<xref:System.Collections.Queue.Dequeue%2A>キューの先頭から最も古い要素を削除します</xref:System.Collections.Queue.Dequeue%2A>。      -<xref:System.Collections.Queue.Peek%2A>キューの先頭には、キューからは削除されません古い要素を返します</xref:System.Collections.Queue.Peek%2A>。       キューの容量とは、キューに格納できる要素の数です。 要素は、キューに追加されるため、容量を増やすは自動的に再割り当て、必要に応じて。  <xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出すことによって、容量を削減することができます。       増加率より大きな空き領域が必要な場合に、現在の容量を乗算する数です。  増加率は、キューを作成するときに決定されます。 既定の増加率は 2.0 です。 キューの容量が少なくとも最低&4; で、増加率に関係なく、常に増加します。 たとえば、1.0 の増加率を持つキューが常に高まります容量 4 でより大きな空き領域が必要な場合。       キューが受け入れる`null`有効な値としてでき、重複する要素。       このコレクションの汎用のバージョンについては、次を参照してください。<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Collections.Queue&quot;> </xref>が空で、クラスの既定の初期量を備え既定の増加率を使用します。"
  remarks: "容量、<xref:System.Collections.Queue>要素の数が、<xref:System.Collections.Queue>を保持できます</xref:System.Collections.Queue></xref:System.Collections.Queue>。  要素が追加されるにつれて、 <xref:System.Collections.Queue>、容量を増やすは自動的に再割り当て、必要に応じて</xref:System.Collections.Queue>。  <xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出すことによって、容量を削減することができます。       増加率より大きな空き領域が必要な場合に、現在の容量を乗算する数です。  増加率が決まるときに、<xref:System.Collections.Queue>を構築します</xref:System.Collections.Queue>。       このコンス トラクターは、o (1) 操作です。"
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Collections.Queue&quot;> </xref>クラスを指定したコレクションからコピーされた要素を含む、コピーした要素の数と同じ初期量があり、既定の増加率を使用します。"
  remarks: "容量、<xref:System.Collections.Queue>要素の数が、<xref:System.Collections.Queue>を保持できます</xref:System.Collections.Queue></xref:System.Collections.Queue>。  要素が追加されるにつれて、 <xref:System.Collections.Queue>、容量を増やすは自動的に再割り当て、必要に応じて</xref:System.Collections.Queue>。  <xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出すことによって、容量を削減することができます。       増加率より大きな空き領域が必要な場合に、現在の容量を乗算する数です。  増加率が決まるときに、<xref:System.Collections.Queue>を構築します</xref:System.Collections.Queue>。       、<xref:System.Collections.Queue>同じ順序<xref:System.Collections.IEnumerator><xref:System.Collections.ICollection>。</xref:System.Collections.ICollection></xref:System.Collections.IEnumerator>によって読み取られる順序で</xref:System.Collections.Queue>要素のコピーします。       このコンス トラクターは、O (`n`) 操作では、ここで`n`内の要素の数は、`col`です。"
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>から要素をコピーする</xref:System.Collections.ICollection>。"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Collections.Queue&quot;> </xref>が空で、クラス、指定した初期量、および既定の増加率を使用します。"
  remarks: "容量、<xref:System.Collections.Queue>要素の数が、<xref:System.Collections.Queue>を保持できます</xref:System.Collections.Queue></xref:System.Collections.Queue>。  要素が追加されるにつれて、 <xref:System.Collections.Queue>、容量を増やすは自動的に再割り当て、必要に応じて</xref:System.Collections.Queue>。  <xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出すことによって、容量を削減することができます。       増加率より大きな空き領域が必要な場合に、現在の容量を乗算する数です。  増加率が決まるときに、<xref:System.Collections.Queue>を構築します</xref:System.Collections.Queue>。       コレクションのサイズを推定できる場合の<xref:System.Collections.Queue>。</xref:System.Collections.Queue>へ要素を追加中にサイズ変更操作を実行する必要があるの初期量を指定します。       このコンス トラクターは、O (`n`) 操作では、ここで`n`は`capacity`します。"
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "最初の要素数を<xref href=&quot;System.Collections.Queue&quot;></xref>含めることができます。"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>0 未満です。"
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Collections.Queue&quot;> </xref>クラスは、空を指定した初期量を備え、指定した増加率を使用します。"
  remarks: "容量、<xref:System.Collections.Queue>要素の数が、<xref:System.Collections.Queue>を保持できます</xref:System.Collections.Queue></xref:System.Collections.Queue>。  要素が追加されるにつれて、 <xref:System.Collections.Queue>、容量を増やすは自動的に再割り当て、必要に応じて</xref:System.Collections.Queue>。  <xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出すことによって、容量を削減することができます。       増加率より大きな空き領域が必要な場合に、現在の容量を乗算する数です。  増加率が決まるときに、<xref:System.Collections.Queue>を構築します</xref:System.Collections.Queue>。 容量、<xref:System.Collections.Queue>増加率に関係なくの最小値は常にだけ増加させる; 1.0 の増加率が防ぐことはできません、<xref:System.Collections.Queue>のサイズを大きくします</xref:System.Collections.Queue></xref:System.Collections.Queue>。       コレクションのサイズを推定できる場合の<xref:System.Collections.Queue>。</xref:System.Collections.Queue>へ要素を追加中にサイズ変更操作を実行する必要があるの初期量を指定します。       このコンス トラクターは、O (`n`) 操作では、ここで`n`は`capacity`します。"
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "最初の要素数を<xref href=&quot;System.Collections.Queue&quot;></xref>含めることができます。"
    - id: growFactor
      type: System.Single
      description: "係数の容量、 <xref href=&quot;System.Collections.Queue&quot;> </xref>が展開されています。"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>0 未満です。       - または - <code>growFactor</code> 1.0 より小さいか、10.0 を超える。"
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "すべてのオブジェクトを削除、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "<xref:System.Collections.Queue.Count%2A>0 に設定し、コレクションの要素から他のオブジェクトへの参照も解放します。</xref:System.Collections.Queue.Count%2A>       容量はそのまま残ります。 この<xref:System.Collections.Queue><xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出す</xref:System.Collections.Queue>の容量をリセットするには 空のトリミング<xref:System.Collections.Queue>のキャパシティを設定、<xref:System.Collections.Queue>を既定の容量</xref:System.Collections.Queue></xref:System.Collections.Queue>。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>は、"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "簡易コピーを作成、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "コレクションの簡易コピーは、参照型または値の型が参照先のオブジェクトはコピーしないかどうか、コレクションの要素のみをコピーします。 新しいコレクション内の参照は、元のコレクション内の参照をポイントする同じオブジェクトをポイントします。       これに対し、コレクションのディープ コピーされた要素をコピーして、要素が直接または間接的に参照するすべてです。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>は、"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "簡易コピー、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "要素がであるかどうかを判断、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "このメソッドは、 <xref:System.Object.Equals%2A?displayProperty=fullName>。</xref:System.Object.Equals%2A?displayProperty=fullName>を呼び出すことで等しいかどうかを決定します。       このメソッドは、一方向の検索を実行します。そのため、このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>は、       以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>メソッド`obj`を決定するかどうか`item`が存在します</xref:System.IComparable.CompareTo%2A></xref:System.Object.Equals%2A>。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、`obj`コレクション内のオブジェクトのパラメーターです</xref:System.IComparable.CompareTo%2A></xref:System.Object.Equals%2A>。"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>内で検索する、 <xref href=&quot;System.Collections.Queue&quot;> </xref></xref:System.Object> 。 値を指定できます<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "コピー、 <xref href=&quot;System.Collections.Queue&quot;> </xref>要素を既存の&1; 次元<xref:System.Array>、指定した配列インデックスから始まります</xref:System.Array>。"
  remarks: "<xref:System.Array>列挙<xref:System.Collections.Queue>。</xref:System.Collections.Queue>同じ順序で</xref:System.Array>要素のコピーします。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>は、"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "1 次元<xref:System.Array>からコピーした要素のコピー先は<xref href=&quot;System.Collections.Queue&quot;> </xref></xref:System.Array> 。 <xref:System.Array>0 から始まるインデックス番号が必要です</xref:System.Array>。"
    - id: index
      type: System.Int32
      description: "内の&0; から始まるインデックス`array`コピーの開始位置。"
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>0 未満です。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>多次元です。       - または - ソース内の要素の数<xref href=&quot;System.Collections.Queue&quot;></xref>から使用可能な領域より大きくなって<code>index</code>変換先の末尾に<code>array</code>です。"
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "ソースの種類<xref href=&quot;System.Collections.Queue&quot;></xref>変換先の型に自動的にキャストすることはできません<code> array</code>です。"
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "含まれる要素の数を取得、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "容量、<xref:System.Collections.Queue>は要素の数を<xref:System.Collections.Queue>格納できます</xref:System.Collections.Queue></xref:System.Collections.Queue>。 数は実際に<xref:System.Collections.Queue>。</xref:System.Collections.Queue>内にある要素の数       容量、<xref:System.Collections.Queue>数以上では常にします</xref:System.Collections.Queue>。 数を超えた場合、容量の要素を追加するときに、前の要素をコピーし、新しい要素を追加する前に、内部配列の再割り当てによって、容量は自動的に増加します。 これは増加率を現在の容量を乗算することによって新しい容量を決定ときに決定されます、<xref:System.Collections.Queue>を構築します</xref:System.Collections.Queue>。 容量、<xref:System.Collections.Queue>増加率に関係なくの最小値は常にだけ増加させる; 1.0 の増加率が防ぐことはできません、<xref:System.Collections.Queue>のサイズを大きくします</xref:System.Collections.Queue></xref:System.Collections.Queue>。       <xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出すことによって、容量を削減することができます。       このプロパティの値を取得するは、o (1) 操作です。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "含まれる要素の数、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "削除しの先頭にあるオブジェクトを返します、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "このメソッド、<xref:System.Collections.Queue.Peek%2A>メソッドは<xref:System.Collections.Queue.Peek%2A><xref:System.Collections.Queue>。</xref:System.Collections.Queue>を変更しません</xref:System.Collections.Queue.Peek%2A></xref:System.Collections.Queue.Peek%2A>       `null`追加することができます、<xref:System.Collections.Queue>値として</xref:System.Collections.Queue>。 Null 値との末尾を識別する、 <xref:System.Collections.Queue>、確認、<xref:System.Collections.Queue.Count%2A>プロパティまたは catch、 <xref:System.InvalidOperationException>、ときにスローする、<xref:System.Collections.Queue>が空です</xref:System.Collections.Queue></xref:System.InvalidOperationException></xref:System.Collections.Queue.Count%2A></xref:System.Collections.Queue>。       このメソッドは、o (1) 操作です。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "先頭から削除されるオブジェクト、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>が空です。"
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "末尾にオブジェクトを追加、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "容量、<xref:System.Collections.Queue>要素の数が、<xref:System.Collections.Queue>を保持できます</xref:System.Collections.Queue></xref:System.Collections.Queue>。  要素が追加されるにつれて、 <xref:System.Collections.Queue>、容量を増やすは自動的に再割り当て、必要に応じて</xref:System.Collections.Queue>。  <xref:System.Collections.Queue.TrimToSize%2A>。</xref:System.Collections.Queue.TrimToSize%2A>を呼び出すことによって、容量を削減することができます。       増加率より大きな空き領域が必要な場合に、現在の容量を乗算する数です。  増加率が決まるときに、<xref:System.Collections.Queue>を構築します</xref:System.Collections.Queue>。 容量、<xref:System.Collections.Queue>増加率に関係なくの最小値は常にだけ増加させる; 1.0 の増加率が防ぐことはできません、<xref:System.Collections.Queue>のサイズを大きくします</xref:System.Collections.Queue></xref:System.Collections.Queue>。       場合<xref:System.Collections.Queue.Count%2A>が小さい内部配列の容量よりも、このメソッドは、o (1) 操作になります</xref:System.Collections.Queue.Count%2A>。 内部の配列は、新しい要素のために再割り当てする必要がある、このメソッドが O (`n`) 操作では、ここで`n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>は、"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "追加するオブジェクト、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。 値を指定できます<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "反復処理する列挙子を返します、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "`foreach` C# 言語のステートメント (`for each` Visual Basic で)、列挙子の複雑さが隠されています。  したがってを使用して`foreach`列挙子を直接操作せずにお勧めします。       列挙子を使用して、コレクション内のデータを読み取ることができますが、基になるコレクションを変更するのには使用できません。       最初に、列挙子はコレクション内の最初の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A>列挙子をこの位置に戻さ点もあります。</xref:System.Collections.IEnumerator.Reset%2A>  この位置にある<xref:System.Collections.IEnumerator.Current%2A>が定義されていません</xref:System.Collections.IEnumerator.Current%2A>。 したがって、 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>。</xref:System.Collections.IEnumerator.Current%2A>の値を読み取る前に、コレクションの最初の要素に列挙子を進めるに</xref:System.Collections.IEnumerator.MoveNext%2A>呼び出す必要があります。       <xref:System.Collections.IEnumerator.Current%2A>いずれかのまで同じオブジェクトを返します<xref:System.Collections.IEnumerator.MoveNext%2A>または<xref:System.Collections.IEnumerator.Reset%2A>と呼びます</xref:System.Collections.IEnumerator.Reset%2A></xref:System.Collections.IEnumerator.MoveNext%2A>。</xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>設定<xref:System.Collections.IEnumerator.Current%2A>次の要素にします</xref:System.Collections.IEnumerator.Current%2A>。</xref:System.Collections.IEnumerator.MoveNext%2A>       場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子をコレクションの末尾が、コレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`</xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.MoveNext%2A>。 列挙子がこの位置では、後続の呼び出しの場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`</xref:System.Collections.IEnumerator.MoveNext%2A>。 最後の呼び出し場合<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、<xref:System.Collections.IEnumerator.Current%2A>が定義されていません</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>。 <xref:System.Collections.IEnumerator.Current%2A>再度、コレクションの最初の要素に<xref:System.Collections.IEnumerator.Reset%2A><xref:System.Collections.IEnumerator.MoveNext%2A>。</xref:System.Collections.IEnumerator.MoveNext%2A>続けて</xref:System.Collections.IEnumerator.Reset%2A>を呼び出すことができます</xref:System.Collections.IEnumerator.Current%2A>を設定するには       コレクションが変更されない限り、列挙子は有効です。 コレクションの変更が加えられた場合など、追加、変更、または要素を削除すると、列挙子は回復不可能とその動作は未定義です。       列挙子はコレクションへの排他アクセスがありません。そのため、コレクションの列挙は、本質的には、スレッド セーフなプロシージャではします。  列挙中にスレッドの安全性を保証するためには、列挙中にコレクションをロックできます。  読み取りと書き込みの複数のスレッドがアクセスするコレクションを許可するのには、独自に同期を実装する必要があります。       このメソッドは、o (1) 操作です。"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "アクセスをするかどうかを示す値を取得、 <xref href=&quot;System.Collections.Queue&quot;> </xref>が同期されている (スレッド セーフである)。"
  remarks: "スレッド セーフを確保する、 <xref:System.Collections.Queue>、によって返されるラッパーを介してすべての操作を行う必要があります、<xref:System.Collections.Queue.Synchronized%2A>メソッド</xref:System.Collections.Queue.Synchronized%2A></xref:System.Collections.Queue>。       コレクションの列挙は本質的にスレッド セーフなプロシージャ コレクションが同期されている場合でも、他のスレッドがコレクションを変更、これにより、列挙子は例外をスローします。 列挙処理中には、スレッド セーフを確保するには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更に起因する例外をキャッチします。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合へのアクセス、 <xref href=&quot;System.Collections.Queue&quot;> </xref>が同期 (スレッド セーフな) です。 それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "先頭にオブジェクトを返します、 <xref href=&quot;System.Collections.Queue&quot;> </xref>削除することがなくです。"
  remarks: "このメソッドは<xref:System.Collections.Queue.Dequeue%2A>、メソッドがピーク<xref:System.Collections.Queue>。</xref:System.Collections.Queue>は変更されません。</xref:System.Collections.Queue.Dequeue%2A>       `null`追加することができます、<xref:System.Collections.Queue>値として</xref:System.Collections.Queue>。 Null 値との末尾を識別する、 <xref:System.Collections.Queue>、確認、<xref:System.Collections.Queue.Count%2A>プロパティまたは catch、 <xref:System.InvalidOperationException>、ときにスローする、<xref:System.Collections.Queue>が空です</xref:System.Collections.Queue></xref:System.InvalidOperationException></xref:System.Collections.Queue.Count%2A></xref:System.Collections.Queue>。       このメソッドは、o (1) 操作です。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "先頭にあるオブジェクト、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>が空です。"
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "新しいを返します<xref href=&quot;System.Collections.Queue&quot;></xref>を元のキューをラップし、スレッド セーフであります。"
  remarks: "このメソッドによって返されるラッパーは、スレッド セーフな方法で実行されるように操作が実行される前に、キューをロックします。       スレッド セーフを確保する、 <xref:System.Collections.Queue>、このラッパーのみを通じてすべての操作を行う必要があります</xref:System.Collections.Queue>。       コレクションの列挙は本質的にスレッド セーフなプロシージャ コレクションが同期されている場合でも、他のスレッドがコレクションを変更、これにより、列挙子は例外をスローします。 列挙処理中には、スレッド セーフを確保するには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更に起因する例外をキャッチします。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>同期するためにします。"
    return:
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref>同期されている (スレッド セーフである)。"
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "アクセスを同期するために使用できるオブジェクトを取得、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "同期されたバージョンを作成する、<xref:System.Collections.Queue>を使用して、<xref:System.Collections.Queue.Synchronized%2A>メソッド</xref:System.Collections.Queue.Synchronized%2A></xref:System.Collections.Queue>。 ただし、派生クラスは、独自の同期されたバージョンを指定、 <xref:System.Collections.Queue>SyncRoot プロパティを使用します</xref:System.Collections.Queue>。 同期されたコードでの操作を実行する必要があります、 <xref:System.Collections.Queue>、 <xref:System.Collections.Queue>.</xref:System.Collections.Queue>で直接</xref:System.Collections.Queue> これにより、他のオブジェクトから派生したコレクションを適切に操作します。 具体的には、同時に変更する可能性がある別スレッドとの適切な同期を維持、<xref:System.Collections.Queue>オブジェクト</xref:System.Collections.Queue>。       コレクションの列挙は本質的にスレッド セーフなプロシージャ コレクションが同期されている場合でも、他のスレッドがコレクションを変更、これにより、列挙子は例外をスローします。 列挙処理中には、スレッド セーフを確保するには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更に起因する例外をキャッチします。"
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "アクセスを同期するために使用できるオブジェクト、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "コピー、 <xref href=&quot;System.Collections.Queue&quot;> </xref>要素を新しい配列にします。"
  remarks: "<xref:System.Collections.Queue>は変更されません</xref:System.Collections.Queue>。 先頭から要素の順序と同じ新しい配列の要素の順序は、<xref:System.Collections.Queue>終了まで</xref:System.Collections.Queue>。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>は、"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "コピーした要素を格納する新しい配列、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "実際の要素数を容量を設定、 <xref href=&quot;System.Collections.Queue&quot;></xref>です。"
  remarks: "このメソッドは、キューのメモリ オーバーヘッドを最小のキューに新しい要素が追加されない場合に使用できます。       リセットする、<xref:System.Collections.Queue>を初期状態に呼び出し、 <xref:System.Collections.Queue.Clear%2A>TrimToSize を呼び出す前にメソッド</xref:System.Collections.Queue.Clear%2A></xref:System.Collections.Queue>。 空のトリミング<xref:System.Collections.Queue>のキャパシティを設定、<xref:System.Collections.Queue>を既定の容量</xref:System.Collections.Queue></xref:System.Collections.Queue>。       このメソッドは、O (`n`) 操作では、ここで`n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>は、"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>は読み取り専用です。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
