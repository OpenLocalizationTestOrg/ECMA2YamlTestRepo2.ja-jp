### YamlMime:ManagedReference
items:
- uid: System.Timers.Timer
  id: Timer
  children:
  - System.Timers.Timer.#ctor
  - System.Timers.Timer.#ctor(System.Double)
  - System.Timers.Timer.AutoReset
  - System.Timers.Timer.BeginInit
  - System.Timers.Timer.Close
  - System.Timers.Timer.Dispose(System.Boolean)
  - System.Timers.Timer.Elapsed
  - System.Timers.Timer.Enabled
  - System.Timers.Timer.EndInit
  - System.Timers.Timer.Interval
  - System.Timers.Timer.Site
  - System.Timers.Timer.Start
  - System.Timers.Timer.Stop
  - System.Timers.Timer.SynchronizingObject
  langs:
  - csharp
  name: Timer
  nameWithType: Timer
  fullName: System.Timers.Timer
  type: Class
  summary: "一定の間隔で定期的なイベントを生成するオプションの後にイベントを生成します。       この型の .NET Framework ソース コードを参照するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)です。"
  remarks: "> [!NOTE]> この型の .NET Framework ソース コードを表示するにはを参照してください、[参照ソース](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。       Timer コンポーネントは、サーバー ベースのタイマーを発生させる、<xref:System.Timers.Timer.Elapsed>のミリ秒数の後に、アプリケーション内のイベント、<xref:System.Timers.Timer.Interval%2A>プロパティが経過した</xref:System.Timers.Timer.Interval%2A></xref:System.Timers.Timer.Elapsed>。 使用して&1; 回だけまたは繰り返しイベントを発生させるタイマー オブジェクトを構成することができます、<xref:System.Timers.Timer.AutoReset%2A>プロパティ</xref:System.Timers.Timer.AutoReset%2A>。 通常、タイマー オブジェクトでは、必要な限り、スコープ内に保持できるようにクラス レベルで宣言されます。 処理することができますし、その<xref:System.Timers.Timer.Elapsed>通常の処理を提供するイベントです</xref:System.Timers.Timer.Elapsed>。 たとえば、する必要がある重要なサーバーがある場合 24 時間、日、週 7 日間を実行します。 オブジェクトを使用して、タイマーを定期的にサーバーを確認し、システムが稼働していることを確認してください。 サービスを作成します。 システムが応答していない場合、サービスでしたしようと、サーバーを再起動するか、管理者に通知します。      > [!IMPORTANT] > のタイマー クラスは、.NET Framework のみで使用できます。 .NET 標準ライブラリに含まれていないと、その他のプラットフォームでは、.NET Core など、ユニバーサル Windows プラットフォームでは使用できません。 これらのプラットフォームおよびすべての .NET プラットフォーム間で移植性のためを使用してください、<xref:System.Threading.Timer?displayProperty=fullName>クラスの代わりにします</xref:System.Threading.Timer?displayProperty=fullName>。       この型は、<xref:System.IDisposable>インターフェイス</xref:System.IDisposable>。 型を使用してが完了したらを直接的または間接的にその破棄する必要があります。 型の直接 dispose を呼び出す、<xref:System.IDisposable.Dispose%2A>メソッドで、 `try` / `catch`ブロック</xref:System.IDisposable.Dispose%2A>。 など、使用言語構成要素に直接ことのない dispose `using` (C# の場合) または`Using`(Visual Basic で)。 詳細についてを参照してください&quot;を使用して、オブジェクトを実装する IDisposable&quot;、<xref:System.IDisposable>インターフェイスに関するトピック</xref:System.IDisposable>。       サーバー ベースのタイマー クラスは、マルチ スレッド環境でのワーカー スレッドで使用するために設計されています。 サーバーのタイマーは、発生したを処理するスレッド間で移動できます<xref:System.Timers.Timer.Elapsed>時間でイベントの発生時にウィンドウ タイマーは結果として得られるイベント</xref:System.Timers.Timer.Elapsed>。       Timer コンポーネントを生成、 <xref:System.Timers.Timer.Elapsed>(ミリ秒) の値に基づく、イベント、<xref:System.Timers.Timer.Interval%2A>プロパティ</xref:System.Timers.Timer.Interval%2A></xref:System.Timers.Timer.Elapsed>。 必要がある処理を実行するには、このイベントを処理することができます。 たとえば、継続的にデータベースへの販売注文を投稿するオンライン販売アプリケーションがあるとします。 出荷の指示をコンパイルするサービスは、各注文を個別に処理するのではなく、注文のバッチで動作します。 バッチ 30 分ごとの処理を開始するのにタイマーを使用する可能性があります。      > [!IMPORTANT] >、System.Timers.Timer クラスには、システム クロックと同じ解像度。 つまり、<xref:System.Timers.Timer.Elapsed>場合、システム クロックの解像度によって定義された間隔でイベントは起動、<xref:System.Timers.Timer.Interval%2A>プロパティは、システム時計の解像度より小さい</xref:System.Timers.Timer.Interval%2A></xref:System.Timers.Timer.Elapsed>。 詳細については、次を参照してください、<xref:System.Timers.Timer.Interval%2A>プロパティ。</xref:System.Timers.Timer.Interval%2A> 。       ときに<xref:System.Timers.Timer.AutoReset%2A>に設定されている`false`、タイマー オブジェクトを生成、<xref:System.Timers.Timer.Elapsed>イベントは&1; 回のみ、最初より後<xref:System.Timers.Timer.Interval%2A>が経過した</xref:System.Timers.Timer.Interval%2A></xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer.AutoReset%2A>。 させると保持する、<xref:System.Timers.Timer.Elapsed>によって定義された間隔で定期的にイベント、<xref:System.Timers.Timer.Interval%2A>設定、<xref:System.Timers.Timer.AutoReset%2A>に`true`、これは、既定値です</xref:System.Timers.Timer.AutoReset%2A></xref:System.Timers.Timer.Interval%2A></xref:System.Timers.Timer.Elapsed>。       Timer コンポーネントをキャッチし、において、イベント ハンドラーによってスローされる例外すべてを非表示、<xref:System.Timers.Timer.Elapsed>イベント</xref:System.Timers.Timer.Elapsed>。 この動作は、.NET Framework の将来のリリースで変更されます。 ただし、非同期的に実行してが含まれているイベント ハンドラーの場合は true ではないこと、`await`演算子 (c#) または`Await`演算子 (Visual Basic で)。 これらのイベント ハンドラーでスローされた例外は、次の例に示すように、呼び出し元のスレッドに反映されます。 非同期メソッドでスローされた例外の詳細については、次を参照してください。[例外処理](~/add/includes/ajax-current-ext-md.md)です。       [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/t-system.timers.timer_1.cs)][!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/t-system.timers.timer_1.vb) ]場合、<xref:System.Timers.Timer.SynchronizingObject%2A>プロパティは`null`、<xref:System.Timers.Timer.Elapsed>にイベントが発生、<xref:System.Threading.ThreadPool>スレッド</xref:System.Threading.ThreadPool></xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer.SynchronizingObject%2A>。   処理の場合、<xref:System.Timers.Timer.Elapsed>よりも長いイベント存続<xref:System.Timers.Timer.Interval%2A>、別のイベントを再度発生させる可能性があります<xref:System.Threading.ThreadPool>スレッド</xref:System.Threading.ThreadPool></xref:System.Timers.Timer.Interval%2A></xref:System.Timers.Timer.Elapsed>。 このような状況で、イベント ハンドラーは再入可能にする必要があります。      > [!NOTE] > イベント処理メソッドが&1; つのスレッド別のスレッドが同時に実行される、<xref:System.Timers.Timer.Stop%2A>メソッドまたはセット、<xref:System.Timers.Timer.Enabled%2A>プロパティを`false`</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Stop%2A>。 これは、場合、<xref:System.Timers.Timer.Elapsed>タイマーを停止した後に発生するイベントです</xref:System.Timers.Timer.Elapsed>。 コードの使用例、<xref:System.Timers.Timer.Stop%2A>メソッドは、この競合状態を回避する方法を示しています</xref:System.Timers.Timer.Stop%2A>。       場合でも<xref:System.Timers.Timer.SynchronizingObject%2A>は`null`、<xref:System.Timers.Timer.Elapsed>後にイベントが発生する可能性が、<xref:System.Timers.Timer.Dispose%2A>または<xref:System.Timers.Timer.Stop%2A>メソッドが呼び出されたか、後、<xref:System.Timers.Timer.Enabled%2A>プロパティに設定されて`false`ため、シグナルを発生させる、<xref:System.Timers.Timer.Elapsed>スレッド プールのスレッド上で実行するイベントが常にキューに置かれた</xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Stop%2A></xref:System.Timers.Timer.Dispose%2A></xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer.SynchronizingObject%2A>。 イベント ハンドラーを示すフラグを設定するは、この競合状態を解決するのには&1; つの方法、<xref:System.Timers.Timer.Elapsed>を後続のイベントを無視するイベントです</xref:System.Timers.Timer.Elapsed>。       Timer クラス、フォームやコントロールなどのユーザー インターフェイス要素に使用する場合をかけることがなく、そのユーザー インターフェイス要素でタイマーを割り当てるフォームやコントロールにタイマーが含まれていますが、<xref:System.Timers.Timer.SynchronizingObject%2A>プロパティ、イベントは、ユーザー インターフェイス スレッドにマーシャ リングできるようにします</xref:System.Timers.Timer.SynchronizingObject%2A>。       タイマーのインスタンスの既定のプロパティ値の一覧は、次を参照してください、<xref:System.Timers.Timer.%23ctor%2A>コンス トラクター。</xref:System.Timers.Timer.%23ctor%2A> 。      > [!TIP] > という&4; つのクラスが、.NET Framework クラス ライブラリが含まれることに注意してください`Timer`、それぞれ異なる機能を提供するの: >>-タイマー (このトピック): 一定の間隔でイベントを発生させます。 クラスは、サーバー ベースとして使用するか、マルチ スレッド環境でのサービス コンポーネントユーザー インターフェイスを持たないし、実行時に表示されていません。   >- <xref:System.Threading.Timer?displayProperty=fullName>: 一定の間隔でスレッド プールのスレッドで単一のコールバック メソッドを実行します</xref:System.Threading.Timer?displayProperty=fullName>。 コールバック メソッドは、タイマーがインスタンス化され、変更できないときに定義されます。 Timer クラスと同様にこのクラスは、サーバー ベースとして使用するか、マルチ スレッド環境でのサービス コンポーネントユーザー インターフェイスを持たないし、実行時に表示されていません。   >- <xref:System.Windows.Forms.Timer?displayProperty=fullName>: 一定の間隔でイベントを起動する Windows フォームのコンポーネント</xref:System.Windows.Forms.Timer?displayProperty=fullName>。 コンポーネントは、ユーザー インターフェイスを持たないされ、シングル スレッド環境での使用に適しています。   >- <xref:System.Web.UI.Timer?displayProperty=fullName>: 定期的な間隔で非同期または同期の web ページのポストバックを実行するための ASP.NET コンポーネント</xref:System.Web.UI.Timer?displayProperty=fullName>。"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/t-system.timers.timer_2.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/t-system.timers.timer_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Elapsed")]

      [System.ComponentModel.DefaultProperty("Interval")]

      public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Timers.Timer.#ctor
  id: '#ctor'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Timers.Timer&quot;> </xref>クラス、およびすべてのプロパティを初期値に設定します。"
  remarks: "次の表は、 <xref:System.Timers.Timer>。</xref:System.Timers.Timer>のインスタンスの初期プロパティ値を示しています。      |プロパティ |初期値 |  |--------------|-------------------|  |<xref:System.Timers.Timer.AutoReset%2A>|`true`|  |<xref:System.Timers.Timer.Enabled%2A>|`false`|  |<xref:System.Timers.Timer.Interval%2A>|&100; ミリ秒 |  |<xref:System.Timers.Timer.SynchronizingObject%2A>|Null 参照 (`Nothing` Visual Basic で). |</xref:System.Timers.Timer.SynchronizingObject%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.AutoReset%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/m-system.timers.timer.sh_1_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/m-system.timers.timer.sh_1_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_1_1.vb)]"
  syntax:
    content: public Timer ();
    parameters: []
  overload: System.Timers.Timer.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.#ctor(System.Double)
  id: '#ctor(System.Double)'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "新しいインスタンスを初期化、 <xref href=&quot;System.Timers.Timer&quot;> </xref>クラス、およびセット、<xref:System.Timers.Timer.Interval*>プロパティを指定したミリ秒数</xref:System.Timers.Timer.Interval*>。"
  remarks: "このコンス トラクターを設定、 <xref:System.Timers.Timer.Interval%2A>、タイマーの新しいインスタンスのプロパティが、タイマーを有効にしません</xref:System.Timers.Timer.Interval%2A>。"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/m-system.timers.timer.sh_0_1.cs)]\n [!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_0_1.vb)]"
  syntax:
    content: public Timer (double interval);
    parameters:
    - id: interval
      type: System.Double
      description: "(ミリ秒単位) のイベントの間の時間。 値は&0; より大きくする必要があります以上&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;です。"
  overload: System.Timers.Timer.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "値、 <code> interval </code>パラメーターより小さいか等しいには、0 以上&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;です。"
  platform:
  - net462
- uid: System.Timers.Timer.AutoReset
  id: AutoReset
  parent: System.Timers.Timer
  langs:
  - csharp
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得または設定を示すブール値かどうか、 <xref href=&quot;System.Timers.Timer&quot;> </xref>を発生させる、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>&1; 回だけイベント (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>) か、または繰り返し (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>)。"
  remarks: "場合、<xref:System.Timers.Timer>は既に有効になっている場合、<xref:System.Timers.Timer.Start%2A>メソッドが呼び出されると、間隔をリセットします</xref:System.Timers.Timer.Start%2A></xref:System.Timers.Timer>。 持つ自動リセットが場合`false`、<xref:System.Timers.Timer.Start%2A>カウントをもう一度開始するためにメソッドを呼び出す必要があります</xref:System.Timers.Timer.Start%2A>。       間隔のリセットに影響を与える場合に、<xref:System.Timers.Timer.Elapsed>イベントが発生します</xref:System.Timers.Timer.Elapsed>。 たとえば、5 秒間に間隔を設定し、設定すると、<xref:System.Timers.Timer.Enabled%2A>プロパティを`true`、カウントの開始時に<xref:System.Timers.Timer.Enabled%2A>設定されている</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Enabled%2A>。 カウントが 3 秒の場合、10 秒間隔をリセットする場合、 <xref:System.Timers.Timer.Elapsed>13 秒後に初めてイベントは、<xref:System.Timers.Timer.Enabled%2A>プロパティに設定されました`true`</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Elapsed>。"
  example:
  - "The following example creates a <xref:System.Timers.Timer> whose <xref:System.Timers.Timer.Elapsed> event fires after 1.5 seconds. Its event handler then displays \"Hello World!\" on the console.  \n  \n [!code-vb[Classic Timer.Timer1 Example#1](~/add/codesnippet/visualbasic/p-system.timers.timer.au_1.vb)]\n [!code-cs[Classic Timer.Timer1 Example#1](~/add/codesnippet/csharp/p-system.timers.timer.au_1.cs)]\n [!code-cpp[Classic Timer.Timer1 Example#1](~/add/codesnippet/cpp/p-system.timers.timer.au_1.cpp)]"
  syntax:
    content: public bool AutoReset { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、 <xref href=&quot;System.Timers.Timer&quot;> </xref>を発生させる、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>イベントたびに、間隔が経過します。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>発生させる場合、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>間隔が経過する最初の時刻より後に&1; 回だけです。 既定値は<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>です。"
  overload: System.Timers.Timer.AutoReset*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.BeginInit
  id: BeginInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "実行時の初期化を開始、 <xref href=&quot;System.Timers.Timer&quot;> </xref>フォームまたは別のコンポーネントによって使用されます。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントに使用されるコンポーネントの初期化を開始します。 <xref:System.Timers.Timer.EndInit%2A>メソッドが初期化を終了します</xref:System.Timers.Timer.EndInit%2A>。 BeginInit を使用して<xref:System.Timers.Timer.EndInit%2A>メソッド使用されないように、コントロールが完全に初期化される前にします</xref:System.Timers.Timer.EndInit%2A>。"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Timers.Timer.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Close
  id: Close
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "によって使用されるリソースを解放、 <xref href=&quot;System.Timers.Timer&quot;></xref>です。"
  remarks: "Close メソッドを呼び出して、`Dispose`メソッドです。"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Timers.Timer.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "現在の使用されているすべてのリソースを解放<xref href=&quot;System.Timers.Timer&quot;></xref>です。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>マネージ コードとアンマネージ リソースを解放するには<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>アンマネージ リソースだけを解放します。"
  overload: System.Timers.Timer.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Elapsed
  id: Elapsed
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
  type: Event
  assemblies:
  - System
  namespace: System.Timers
  summary: "間隔が経過すると発生します。"
  remarks: "Elapsed イベントが発生する場合、<xref:System.Timers.Timer.Enabled%2A>プロパティは`true`と、時間間隔 (ミリ秒単位) によって定義された、<xref:System.Timers.Timer.Interval%2A>プロパティが経過するとします</xref:System.Timers.Timer.Interval%2A></xref:System.Timers.Timer.Enabled%2A>。 場合、<xref:System.Timers.Timer.AutoReset%2A>プロパティは`true`、によって定義された間隔でイベントが繰り返し発生する、<xref:System.Timers.Timer.Interval%2A>プロパティですそれ以外の場合、このイベントは最初に&1; 回だけ、<xref:System.Timers.Timer.Interval%2A>が経過するまでの値。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.AutoReset%2A> 。       場合<xref:System.Timers.Timer.Interval%2A>後に設定されている、<xref:System.Timers.Timer>が開始されると、カウントがリセットされます</xref:System.Timers.Timer></xref:System.Timers.Timer.Interval%2A>。 たとえば、5 秒間に間隔を設定し、設定すると<xref:System.Timers.Timer.Enabled%2A>に`true`、カウントの開始時に<xref:System.Timers.Timer.Enabled%2A>設定されている</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Enabled%2A>。 カウントが 3 秒の場合、10 秒間隔をリセットすると、Elapsed イベントが 13 秒後に初めて発生<xref:System.Timers.Timer.Enabled%2A>に設定された`true`</xref:System.Timers.Timer.Enabled%2A>。       場合、<xref:System.Timers.Timer.SynchronizingObject%2A>プロパティは`null`の Elapsed イベントが発生した、<xref:System.Threading.ThreadPool>スレッド</xref:System.Threading.ThreadPool></xref:System.Timers.Timer.SynchronizingObject%2A>。 Elapsed イベントの処理が長く持続する場合よりも<xref:System.Timers.Timer.Interval%2A>、別のイベントを再度発生させる可能性があります<xref:System.Threading.ThreadPool>スレッド</xref:System.Threading.ThreadPool></xref:System.Timers.Timer.Interval%2A>。 このような状況で、イベント ハンドラーは再入可能にする必要があります。      > [!NOTE] > イベント処理メソッドが&1; つのスレッド別のスレッドが同時に実行される、<xref:System.Timers.Timer.Stop%2A>メソッドまたはセット、<xref:System.Timers.Timer.Enabled%2A>プロパティを`false`</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Stop%2A>。 これにより、Elapsed イベント、タイマーを停止した後に発生する可能性があります。 コードの使用例、<xref:System.Timers.Timer.Stop%2A>メソッドは、この競合状態を回避する方法を示しています</xref:System.Timers.Timer.Stop%2A>。       場合でも<xref:System.Timers.Timer.SynchronizingObject%2A>は`null`、Elapsed イベントが後に発生することが、<xref:System.Timers.Timer.Dispose%2A>または<xref:System.Timers.Timer.Stop%2A>メソッドが呼び出されたか、後、<xref:System.Timers.Timer.Enabled%2A>プロパティに設定された`false`Elapsed イベントを発生させる信号は常にスレッド プールのスレッドで実行をキューに置かれたため、</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.SynchronizingObject%2A> 。 この競合状態を解決するのには&1; つの方法では、後続のイベントを無視する Elapsed イベントのイベント ハンドラーを示すフラグを設定します。       <xref:System.Timers.Timer>コンポーネントをキャッチし、Elapsed イベントのイベント ハンドラーによってスローされる例外すべてを表示しません</xref:System.Timers.Timer>。 この動作は、.NET Framework の将来のリリースで変更されます。"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its Elapsed event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/e-system.timers.timer.el_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/e-system.timers.timer.el_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/e-system.timers.timer.el_1.vb)]"
  syntax:
    content: public event System.Timers.ElapsedEventHandler Elapsed;
    return:
      type: System.Timers.ElapsedEventHandler
      description: "追加します。"
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Enabled
  id: Enabled
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得または設定を示す値かどうか、 <xref href=&quot;System.Timers.Timer&quot;> </xref>を発生させる、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>イベント。"
  remarks: "有効`true`は呼び出すことと同じ<xref:System.Timers.Timer.Start%2A>する設定が有効化中に、 `false` <xref:System.Timers.Timer.Stop%2A>.</xref:System.Timers.Timer.Stop%2A>を呼び出すことと同じです</xref:System.Timers.Timer.Start%2A>      > [!NOTE] >、シグナルを発生させる、<xref:System.Timers.Timer.Elapsed>イベントは、常に実行するためキューに置かれた、<xref:System.Threading.ThreadPool>スレッド</xref:System.Threading.ThreadPool></xref:System.Timers.Timer.Elapsed>。 これは、場合、 <xref:System.Timers.Timer.Elapsed>Enabled プロパティに設定した後に発生するイベント`false`</xref:System.Timers.Timer.Elapsed>。 コード例、<xref:System.Timers.Timer.Stop%2A>メソッドは、この競合状態を回避する方法を示しています</xref:System.Timers.Timer.Stop%2A>。       有効になっている場合`true`と<xref:System.Timers.Timer.AutoReset%2A>に設定されている`false`、<xref:System.Timers.Timer>を発生させます、<xref:System.Timers.Timer.Elapsed>最初の時間間隔に&1; 回だけが経過した</xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer></xref:System.Timers.Timer.AutoReset%2A>。       後に、間隔が設定されている場合、<xref:System.Timers.Timer>が開始されると、カウントがリセットされます</xref:System.Timers.Timer>。 たとえば、5 秒間に間隔を設定し Enabled プロパティを設定すると`true`カウントが有効に設定されている時刻に開始します。 カウントが 3 秒の場合、10 秒間隔をリセットする場合、<xref:System.Timers.Timer.Elapsed>初めて 13 秒を有効に設定された後のイベントは`true`</xref:System.Timers.Timer.Elapsed>。      > [!NOTE] > など、Microsoft Visual Studio でのいくつかのビジュアル デザイナーでは、Enabled プロパティを設定`true`新しい<xref:System.Timers.Timer>.</xref:System.Timers.Timer>を挿入するときに"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.en_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.en_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.en_1.vb)]"
  syntax:
    content: public bool Enabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>場合、 <xref href=&quot;System.Timers.Timer&quot;> </xref>を発生させる、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>イベントです。 それ以外の場合、 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。 既定値は<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>です。"
  overload: System.Timers.Timer.Enabled*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "タイマーが破棄されているために、このプロパティを設定することはできません。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Timers.Timer.Interval*>プロパティがより大きい値に設定されました&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;タイマーが有効にする前にします</xref:System.Timers.Timer.Interval*>。"
  platform:
  - net462
- uid: System.Timers.Timer.EndInit
  id: EndInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "実行時の初期化を終了、 <xref href=&quot;System.Timers.Timer&quot;> </xref>フォームまたは別のコンポーネントによって使用されます。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントに使用されるコンポーネントの初期化を終了します。 <xref:System.Timers.Timer.BeginInit%2A>メソッドは、初期化を開始します</xref:System.Timers.Timer.BeginInit%2A>。 使用して、 <xref:System.Timers.Timer.BeginInit%2A>EndInit メソッド使用されないように、コントロールが完全に初期化される前に、</xref:System.Timers.Timer.BeginInit%2A> 。"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Timers.Timer.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Interval
  id: Interval
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得または設定の間隔 (ミリ秒単位) が発生する位置を示す、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>イベント。"
  remarks: "間隔プロパティを使用する頻度を決定して、<xref:System.Timers.Timer.Elapsed>イベントが発生します</xref:System.Timers.Timer.Elapsed>。 <xref:System.Timers.Timer>クラスは、システム クロックに依存して、システム時計と同じ解像度がある</xref:System.Timers.Timer>。 つまり、<xref:System.Timers.Timer.Elapsed>イベントは、間隔のプロパティは、システム時計の解像度よりも小さい場合、システム クロックの解像度によって定義された間隔で発生します</xref:System.Timers.Timer.Elapsed>。 次の例では、5 ミリ秒間隔のプロパティを設定します。 実行すると、 [!INCLUDE[win7](~/add/includes/win7-md.md)] 5 ミリ秒間隔ではなく、約 15 ミリ秒ごとのシステム クロックが、イベントの起動、約 15 ミリ秒単位の解像度を持つシステムです。       [!code-cs[System.Timers.Timer.Interval#1](~/add/codesnippet/csharp/p-system.timers.timer.in_1.cs)][!code-vb[System.Timers.Timer.Interval#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_1.vb) ]次のコードを使用するを現在のシステムのシステム時計の解像度を判断: [!code-cs [System.Timers.Timer.Interval#2](~/add/codesnippet/csharp/p-system.timers.timer.in_2.cs)][!code-vb[System.Timers.Timer.Interval#2](~/add/codesnippet/visualbasic/p-system.timers.timer.in_2.vb) ]によって提供されるものより高い解像度が、アプリに必要なかどうか、<xref:System.Timers.Timer>クラスまたは参照; 高解像度のマルチ メディア タイマーを使用して、システム クロック[する方法: 高分解能タイマーを使用して](http://msdn.microsoft.com/library/aa964692.aspx)</xref:System.Timers.Timer>。           後に、間隔が設定されている場合、<xref:System.Timers.Timer>が開始されると、カウントがリセットされます</xref:System.Timers.Timer>。 たとえば、5 秒間に間隔を設定し、設定すると、<xref:System.Timers.Timer.Enabled%2A>プロパティを`true`、カウントの開始時に<xref:System.Timers.Timer.Enabled%2A>設定されている</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Enabled%2A>。 カウントが 3 秒の場合、10 秒間隔をリセットする場合、<xref:System.Timers.Timer.Elapsed>を初めて 13 秒後にイベントを発生<xref:System.Timers.Timer.Enabled%2A>に設定された`true`</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Elapsed>。       場合<xref:System.Timers.Timer.Enabled%2A>に設定されている`true`と<xref:System.Timers.Timer.AutoReset%2A>に設定されている`false`、<xref:System.Timers.Timer>を発生させます、<xref:System.Timers.Timer.Elapsed>最初の時間間隔に&1; 回だけが経過した</xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer></xref:System.Timers.Timer.AutoReset%2A></xref:System.Timers.Timer.Enabled%2A>。 <xref:System.Timers.Timer.Enabled%2A>設定されているし、`false`です。</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > 場合<xref:System.Timers.Timer.Enabled%2A>と<xref:System.Timers.Timer.AutoReset%2A>に設定されて`false`、およびタイマーが以前有効になって、間隔プロパティの原因を設定、<xref:System.Timers.Timer.Elapsed>イベントが&1; 回発生するよう、<xref:System.Timers.Timer.Enabled%2A>に設定されたプロパティ`true`</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer.AutoReset%2A></xref:System.Timers.Timer.Enabled%2A>。 間隔を設定する、イベントを発生させることがなく、一時的に設定できます、<xref:System.Timers.Timer.Enabled%2A>プロパティを`true`を希望する時間間隔に間隔のプロパティを設定、すぐに設定して、<xref:System.Timers.Timer.Enabled%2A>プロパティ`false`</xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Enabled%2A>。"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.in_3.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.in_3.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_3.vb)]"
  syntax:
    content: public double Interval { get; set; }
    return:
      type: System.Double
      description: "時間 (ミリ秒単位) の間で<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>イベント。 値は&0; より大きくする必要があります以上&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;です。 既定値は、100 ミリ秒です。"
  overload: System.Timers.Timer.Interval*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "間隔は、0 に等しいまたはそれよりも小さいです。       - または - 間隔よりも大きい&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;タイマーが現在有効になっているとします。 (タイマーが現在有効でない場合は、例外はスローされませんが有効にするまでです。)"
  platform:
  - net462
- uid: System.Timers.Timer.Site
  id: Site
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得またはバインドするサイトの設定、 <xref href=&quot;System.Timers.Timer&quot;> </xref>デザイン モードでは、そのコンテナーにします。"
  remarks: "サイトのバインド、<xref:System.ComponentModel.Component>を<xref:System.ComponentModel.Container>とそれらの間で通信を有効にするだけでなく、コンテナーがコンポーネントを管理するための方法を提供します</xref:System.ComponentModel.Container></xref:System.ComponentModel.Component>。"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "<xref href=&quot;System.ComponentModel.ISite&quot;> </xref>サイト バインドを表すインターフェイス、 <xref href=&quot;System.Timers.Timer&quot;> </xref>オブジェクト コンテナーにします。"
  overload: System.Timers.Timer.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Start
  id: Start
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "発生を開始、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>を設定してイベント<xref:System.Timers.Timer.Enabled*>に<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref></xref:System.Timers.Timer.Enabled*> 。"
  remarks: "Start を呼び出す場合と<xref:System.Timers.Timer.AutoReset%2A>に設定されている`false`、<xref:System.Timers.Timer>を発生させます、<xref:System.Timers.Timer.Elapsed>最初の時間間隔に&1; 回だけが経過した</xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer></xref:System.Timers.Timer.AutoReset%2A>。 Start を呼び出す場合と<xref:System.Timers.Timer.AutoReset%2A>は`true`、<xref:System.Timers.Timer>を発生させます、<xref:System.Timers.Timer.Elapsed>イベント最初の時間間隔が経過して、指定した間隔でイベントが発生し続けます</xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer></xref:System.Timers.Timer.AutoReset%2A>。       設定して、タイミングを開始することもできます<xref:System.Timers.Timer.Enabled%2A>に`true`。</xref:System.Timers.Timer.Enabled%2A> 。      > [!NOTE] > 場合<xref:System.Timers.Timer.AutoReset%2A>は`false`カウントをもう一度開始するために Start メソッドを呼び出す必要があります</xref:System.Timers.Timer.AutoReset%2A>。       タイマーが有効にすると、開始メソッドの呼び出しには影響はありません。"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Timers.Timer.Start*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<xref href=&quot;System.Timers.Timer&quot;> </xref>以上になるとは、間隔で作成&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; + 1、または 0 未満の間隔に設定します。"
  platform:
  - net462
- uid: System.Timers.Timer.Stop
  id: Stop
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "停止させると、 <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref>を設定してイベント<xref:System.Timers.Timer.Enabled*>に<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref></xref:System.Timers.Timer.Enabled*> 。"
  remarks: "設定して、タイミングを停止することもできます<xref:System.Timers.Timer.Enabled%2A>に`false`。</xref:System.Timers.Timer.Enabled%2A> 。      > [!NOTE] >、シグナルを発生させる、<xref:System.Timers.Timer.Elapsed>イベントは、常に実行するためキューに置かれた、<xref:System.Threading.ThreadPool>スレッドが、イベント処理メソッドが&1; つのスレッド停止メソッドへの呼び出しが別のスレッドで実行されている、同時に実行されるようにします</xref:System.Threading.ThreadPool></xref:System.Timers.Timer.Elapsed>。 これは、場合、<xref:System.Timers.Timer.Elapsed>停止メソッドが呼び出された後に発生するイベントです</xref:System.Timers.Timer.Elapsed>。 次のセクションのコード例では、この競合状態を回避する&1; つの方法を示します。"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised. When the user presses the Enter key, the application calls the  Stop method before terminating the application.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/m-system.timers.timer.stop_1.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_1.vb)]  \n  \n The following code example shows one way to prevent the thread that calls the Stop method from continuing until a currently executing <xref:System.Timers.Timer.Elapsed> event ends, and also to prevent two <xref:System.Timers.Timer.Elapsed> events from executing the event handler at the same time (often referred to as reentrancy).  \n  \n The example executes 100 test runs. Each time the test is run, the timer is started with an interval of 150 milliseconds. The event handler uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to simulate a task that randomly varies in length from 50 to 200 milliseconds. The test method also starts a control thread that waits for a second and then stops the timer. If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.  \n  \n The <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends. The event handler uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set a control variable to 1, but only if the value is currently zero. This is an atomic operation. If the return value is zero, the control variable has been set to 1 and the event handler proceeds. If the return value is non-zero, the event is simply discarded to avoid reentrancy. (If it were necessary to execute every event, the <xref:System.Threading.Monitor> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero. The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the Stop method was called.  \n  \n The control thread uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set the control variable to -1 (minus one), but only if the value is currently zero. If the atomic operation returns non-zero, an event is currently executing. The control thread waits and tries again. The example records the number of times the control thread had to wait for an event to finish.  \n  \n [!code-cs[Timer.Stop#1](~/add/codesnippet/csharp/m-system.timers.timer.stop_2.cs)]\n [!code-vb[Timer.Stop#1](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_2.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Timers.Timer.Stop*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.SynchronizingObject
  id: SynchronizingObject
  parent: System.Timers.Timer
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得または間隔が経過したときに発行されるイベント ハンドラー呼び出しをマーシャ リングに使用するオブジェクトを設定します。"
  remarks: "SynchronizingObject がある場合`null`、処理するメソッド、<xref:System.Timers.Timer.Elapsed>イベントは、システムのスレッド プールのスレッドで呼び出されます</xref:System.Timers.Timer.Elapsed>。 システム スレッド プールの詳細については、 <xref:System.Threading.ThreadPool>。</xref:System.Threading.ThreadPool>を参照してください。       ときに、<xref:System.Timers.Timer.Elapsed>可能性がありますか、例外の結果が動作しないシステム スレッド プールを介したコンポーネントにアクセスする、ボタンなどの visual Windows フォームのコンポーネントでイベントが処理されます</xref:System.Timers.Timer.Elapsed>。 SynchronizingObject を処理するメソッドを、Windows フォームのコンポーネントに設定してこの特殊効果を避けるため、<xref:System.Timers.Timer.Elapsed>コンポーネントが作成された同じスレッドで呼び出されるイベント</xref:System.Timers.Timer.Elapsed>。      > [!NOTE] > SynchronizingObject プロパティがない場合でも`null`、<xref:System.Timers.Timer.Elapsed>後にイベントが発生する、<xref:System.Timers.Timer.Dispose%2A>または<xref:System.Timers.Timer.Stop%2A>メソッドが呼び出されたか、後、<xref:System.Timers.Timer.Enabled%2A>プロパティに設定されて`false`ため、シグナルを発生させる、<xref:System.Timers.Timer.Elapsed>スレッド プールのスレッド上で実行するイベントが常にキューに置かれた</xref:System.Timers.Timer.Elapsed></xref:System.Timers.Timer.Enabled%2A></xref:System.Timers.Timer.Stop%2A></xref:System.Timers.Timer.Dispose%2A></xref:System.Timers.Timer.Elapsed>。 イベント ハンドラーを示すフラグを設定するは、この競合状態を解決するのには&1; つの方法、<xref:System.Timers.Timer.Elapsed>を後続のイベントを無視するイベントです</xref:System.Timers.Timer.Elapsed>。       場合、<xref:System.Timers.Timer>は、Windows フォーム デザイナーで Visual Studio で使用される、SynchronizingObject が自動的に設定を含む<xref:System.Timers.Timer>.</xref:System.Timers.Timer>コントロール</xref:System.Timers.Timer> 配置する場合など、<xref:System.Timers.Timer>をデザイナーで`Form1`(から継承される<xref:System.Windows.Forms.Form>) の SynchronizingObject プロパティ<xref:System.Timers.Timer>のインスタンスに設定されている`Form1`</xref:System.Timers.Timer></xref:System.Windows.Forms.Form></xref:System.Timers.Timer>。"
  example:
  - "The following example is a Windows Forms app that serves as a very simple text file editor. When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.  To do this, the <xref:System.Timers.Timer.Interval%2A> property is set to one minute (60,000 milliseconds), and the SynchronizingObject property is set to the <xref:System.Windows.Forms.Form> object.  \n  \n [!code-cs[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/csharp/SynchronizingObjectCS1/Form1.cs#1)]\n [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/visualbasic/SynchronizingObjectVB1/Form1.vb#1)]  \n  \n The example requires that you add the following controls to the form:  \n  \n-   A <xref:System.Windows.Forms.TextBox> control named `TextBox1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.Button> control named `Button1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.SaveFileDialog> control named `SaveSaveFileDialog1` (its default name) ."
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>間隔が経過したときに発行されるイベント ハンドラー呼び出しをマーシャ リングするために使用するオブジェクトを表すです。 既定値は<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>です。"
  overload: System.Timers.Timer.SynchronizingObject*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Timers.Timer.#ctor
  parent: System.Timers.Timer
  isExternal: false
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
- uid: System.Timers.Timer.#ctor(System.Double)
  parent: System.Timers.Timer
  isExternal: false
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Timers.Timer.AutoReset
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Timers.Timer.BeginInit
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
- uid: System.Timers.Timer.Close
  parent: System.Timers.Timer
  isExternal: false
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
- uid: System.Timers.Timer.Dispose(System.Boolean)
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
- uid: System.Timers.Timer.Elapsed
  parent: System.Timers.Timer
  isExternal: false
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
- uid: System.Timers.ElapsedEventHandler
  parent: System.Timers
  isExternal: false
  name: ElapsedEventHandler
  nameWithType: ElapsedEventHandler
  fullName: System.Timers.ElapsedEventHandler
- uid: System.Timers.Timer.Enabled
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
- uid: System.Timers.Timer.EndInit
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
- uid: System.Timers.Timer.Interval
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
- uid: System.Timers.Timer.Site
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Timers.Timer.Start
  parent: System.Timers.Timer
  isExternal: false
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
- uid: System.Timers.Timer.Stop
  parent: System.Timers.Timer
  isExternal: false
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
- uid: System.Timers.Timer.SynchronizingObject
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Timers.Timer.#ctor*
  parent: System.Timers.Timer
  isExternal: false
  name: Timer
  nameWithType: Timer.Timer
- uid: System.Timers.Timer.AutoReset*
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
- uid: System.Timers.Timer.BeginInit*
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit
  nameWithType: Timer.BeginInit
- uid: System.Timers.Timer.Close*
  parent: System.Timers.Timer
  isExternal: false
  name: Close
  nameWithType: Timer.Close
- uid: System.Timers.Timer.Dispose*
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose
  nameWithType: Timer.Dispose
- uid: System.Timers.Timer.Enabled*
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
- uid: System.Timers.Timer.EndInit*
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit
  nameWithType: Timer.EndInit
- uid: System.Timers.Timer.Interval*
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
- uid: System.Timers.Timer.Site*
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
- uid: System.Timers.Timer.Start*
  parent: System.Timers.Timer
  isExternal: false
  name: Start
  nameWithType: Timer.Start
- uid: System.Timers.Timer.Stop*
  parent: System.Timers.Timer
  isExternal: false
  name: Stop
  nameWithType: Timer.Stop
- uid: System.Timers.Timer.SynchronizingObject*
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
